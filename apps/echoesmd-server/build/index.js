import {createRequire} from "node:module";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = createRequire(import.meta.url);

// ../../node_modules/async-lock/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var AsyncLock = function(opts) {
    opts = opts || {};
    this.Promise = opts.Promise || Promise;
    this.queues = Object.create(null);
    this.domainReentrant = opts.domainReentrant || false;
    if (this.domainReentrant) {
      if (typeof process === "undefined" || typeof process.domain === "undefined") {
        throw new Error("Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, " + "use a NodeJS version that still implements Domain, or install a browser polyfill.");
      }
      this.domains = Object.create(null);
    }
    this.timeout = opts.timeout || AsyncLock.DEFAULT_TIMEOUT;
    this.maxOccupationTime = opts.maxOccupationTime || AsyncLock.DEFAULT_MAX_OCCUPATION_TIME;
    this.maxExecutionTime = opts.maxExecutionTime || AsyncLock.DEFAULT_MAX_EXECUTION_TIME;
    if (opts.maxPending === Infinity || Number.isInteger(opts.maxPending) && opts.maxPending >= 0) {
      this.maxPending = opts.maxPending;
    } else {
      this.maxPending = AsyncLock.DEFAULT_MAX_PENDING;
    }
  };
  AsyncLock.DEFAULT_TIMEOUT = 0;
  AsyncLock.DEFAULT_MAX_OCCUPATION_TIME = 0;
  AsyncLock.DEFAULT_MAX_EXECUTION_TIME = 0;
  AsyncLock.DEFAULT_MAX_PENDING = 1000;
  AsyncLock.prototype.acquire = function(key, fn, cb, opts) {
    if (Array.isArray(key)) {
      return this._acquireBatch(key, fn, cb, opts);
    }
    if (typeof fn !== "function") {
      throw new Error("You must pass a function to execute");
    }
    var deferredResolve = null;
    var deferredReject = null;
    var deferred = null;
    if (typeof cb !== "function") {
      opts = cb;
      cb = null;
      deferred = new this.Promise(function(resolve, reject) {
        deferredResolve = resolve;
        deferredReject = reject;
      });
    }
    opts = opts || {};
    var resolved = false;
    var timer = null;
    var occupationTimer = null;
    var executionTimer = null;
    var self2 = this;
    var done = function(locked, err, ret) {
      if (occupationTimer) {
        clearTimeout(occupationTimer);
        occupationTimer = null;
      }
      if (executionTimer) {
        clearTimeout(executionTimer);
        executionTimer = null;
      }
      if (locked) {
        if (!!self2.queues[key] && self2.queues[key].length === 0) {
          delete self2.queues[key];
        }
        if (self2.domainReentrant) {
          delete self2.domains[key];
        }
      }
      if (!resolved) {
        if (!deferred) {
          if (typeof cb === "function") {
            cb(err, ret);
          }
        } else {
          if (err) {
            deferredReject(err);
          } else {
            deferredResolve(ret);
          }
        }
        resolved = true;
      }
      if (locked) {
        if (!!self2.queues[key] && self2.queues[key].length > 0) {
          self2.queues[key].shift()();
        }
      }
    };
    var exec = function(locked) {
      if (resolved) {
        return done(locked);
      }
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      if (self2.domainReentrant && locked) {
        self2.domains[key] = process.domain;
      }
      var maxExecutionTime = opts.maxExecutionTime || self2.maxExecutionTime;
      if (maxExecutionTime) {
        executionTimer = setTimeout(function() {
          if (!!self2.queues[key]) {
            done(locked, new Error("Maximum execution time is exceeded " + key));
          }
        }, maxExecutionTime);
      }
      if (fn.length === 1) {
        var called = false;
        try {
          fn(function(err, ret) {
            if (!called) {
              called = true;
              done(locked, err, ret);
            }
          });
        } catch (err) {
          if (!called) {
            called = true;
            done(locked, err);
          }
        }
      } else {
        self2._promiseTry(function() {
          return fn();
        }).then(function(ret) {
          done(locked, undefined, ret);
        }, function(error) {
          done(locked, error);
        });
      }
    };
    if (self2.domainReentrant && !!process.domain) {
      exec = process.domain.bind(exec);
    }
    var maxPending = opts.maxPending || self2.maxPending;
    if (!self2.queues[key]) {
      self2.queues[key] = [];
      exec(true);
    } else if (self2.domainReentrant && !!process.domain && process.domain === self2.domains[key]) {
      exec(false);
    } else if (self2.queues[key].length >= maxPending) {
      done(false, new Error("Too many pending tasks in queue " + key));
    } else {
      var taskFn = function() {
        exec(true);
      };
      if (opts.skipQueue) {
        self2.queues[key].unshift(taskFn);
      } else {
        self2.queues[key].push(taskFn);
      }
      var timeout = opts.timeout || self2.timeout;
      if (timeout) {
        timer = setTimeout(function() {
          timer = null;
          done(false, new Error("async-lock timed out in queue " + key));
        }, timeout);
      }
    }
    var maxOccupationTime = opts.maxOccupationTime || self2.maxOccupationTime;
    if (maxOccupationTime) {
      occupationTimer = setTimeout(function() {
        if (!!self2.queues[key]) {
          done(false, new Error("Maximum occupation time is exceeded in queue " + key));
        }
      }, maxOccupationTime);
    }
    if (deferred) {
      return deferred;
    }
  };
  AsyncLock.prototype._acquireBatch = function(keys, fn, cb, opts) {
    if (typeof cb !== "function") {
      opts = cb;
      cb = null;
    }
    var self2 = this;
    var getFn = function(key, fn2) {
      return function(cb2) {
        self2.acquire(key, fn2, cb2, opts);
      };
    };
    var fnx = keys.reduceRight(function(prev, key) {
      return getFn(key, prev);
    }, fn);
    if (typeof cb === "function") {
      fnx(cb);
    } else {
      return new this.Promise(function(resolve, reject) {
        if (fnx.length === 1) {
          fnx(function(err, ret) {
            if (err) {
              reject(err);
            } else {
              resolve(ret);
            }
          });
        } else {
          resolve(fnx());
        }
      });
    }
  };
  AsyncLock.prototype.isBusy = function(key) {
    if (!key) {
      return Object.keys(this.queues).length > 0;
    } else {
      return !!this.queues[key];
    }
  };
  AsyncLock.prototype._promiseTry = function(fn) {
    try {
      return this.Promise.resolve(fn());
    } catch (e) {
      return this.Promise.reject(e);
    }
  };
  module.exports = AsyncLock;
});

// ../../node_modules/uuid/dist/max.js
var require_max = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = exports.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
});

// ../../node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = exports.default = "00000000-0000-0000-0000-000000000000";
});

// ../../node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
});

// ../../node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var validate = function(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  var _default = exports.default = validate;
});

// ../../node_modules/uuid/dist/parse.js
var require_parse = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var parse = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = exports.default = parse;
});

// ../../node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var unsafeStringify = function(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  };
  var stringify = function(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  var _default = exports.default = stringify;
});

// ../../node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var rng = function() {
    if (poolPtr > rnds8Pool.length - 16) {
      _nodeCrypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _nodeCrypto = _interopRequireDefault(__require("node:crypto"));
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
});

// ../../node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var v1 = function(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node;
    let clockseq = options.clockseq;
    if (!options._v6) {
      if (!node) {
        node = _nodeId;
      }
      if (clockseq == null) {
        clockseq = _clockseq;
      }
    }
    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node == null) {
        node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        if (!_nodeId && !options._v6) {
          node[0] |= 1;
          _nodeId = node;
        }
      }
      if (clockseq == null) {
        clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        if (_clockseq === undefined && !options._v6) {
          _clockseq = clockseq;
        }
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || (0, _stringify.unsafeStringify)(b);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  var _default = exports.default = v1;
});

// ../../node_modules/uuid/dist/v1ToV6.js
var require_v1ToV6 = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var v1ToV6 = function(uuid) {
    const v1Bytes = typeof uuid === "string" ? (0, _parse.default)(uuid) : uuid;
    const v6Bytes = _v1ToV6(v1Bytes);
    return typeof uuid === "string" ? (0, _stringify.unsafeStringify)(v6Bytes) : v6Bytes;
  };
  var _v1ToV6 = function(v1Bytes, randomize = false) {
    return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v1ToV6;
  var _parse = _interopRequireDefault(require_parse());
  var _stringify = require_stringify();
});

// ../../node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var stringToBytes = function(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0;i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  };
  var v35 = function(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      var _namespace;
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify();
  var _parse = _interopRequireDefault(require_parse());
  var DNS = exports.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  var URL = exports.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
});

// ../../node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var md5 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _nodeCrypto.default.createHash("md5").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(__require("node:crypto"));
  var _default = exports.default = md5;
});

// ../../node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = exports.default = v3;
});

// ../../node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(__require("node:crypto"));
  var _default = exports.default = {
    randomUUID: _nodeCrypto.default.randomUUID
  };
});

// ../../node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var v4 = function(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  var _default = exports.default = v4;
});

// ../../node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var sha1 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _nodeCrypto.default.createHash("sha1").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(__require("node:crypto"));
  var _default = exports.default = sha1;
});

// ../../node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = exports.default = v5;
});

// ../../node_modules/uuid/dist/v6.js
var require_v6 = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var v6 = function(options = {}, buf, offset = 0) {
    let bytes = (0, _v.default)({
      ...options,
      _v6: true
    }, new Uint8Array(16));
    bytes = (0, _v1ToV.default)(bytes);
    if (buf) {
      for (let i = 0;i < 16; i++) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(bytes);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v6;
  var _stringify = require_stringify();
  var _v = _interopRequireDefault(require_v1());
  var _v1ToV = _interopRequireDefault(require_v1ToV6());
});

// ../../node_modules/uuid/dist/v6ToV1.js
var require_v6ToV1 = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var v6ToV1 = function(uuid) {
    const v6Bytes = typeof uuid === "string" ? (0, _parse.default)(uuid) : uuid;
    const v1Bytes = _v6ToV1(v6Bytes);
    return typeof uuid === "string" ? (0, _stringify.unsafeStringify)(v1Bytes) : v1Bytes;
  };
  var _v6ToV1 = function(v6Bytes) {
    return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v6ToV1;
  var _parse = _interopRequireDefault(require_parse());
  var _stringify = require_stringify();
});

// ../../node_modules/uuid/dist/v7.js
var require_v7 = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var v7 = function(options, buf, offset) {
    options = options || {};
    let i = buf && offset || 0;
    const b = buf || new Uint8Array(16);
    const rnds = options.random || (options.rng || _rng.default)();
    const msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let seq = options.seq !== undefined ? options.seq : null;
    let seqHigh = _seqHigh;
    let seqLow = _seqLow;
    if (msecs > _msecs && options.msecs === undefined) {
      _msecs = msecs;
      if (seq !== null) {
        seqHigh = null;
        seqLow = null;
      }
    }
    if (seq !== null) {
      if (seq > 2147483647) {
        seq = 2147483647;
      }
      seqHigh = seq >>> 19 & 4095;
      seqLow = seq & 524287;
    }
    if (seqHigh === null || seqLow === null) {
      seqHigh = rnds[6] & 127;
      seqHigh = seqHigh << 8 | rnds[7];
      seqLow = rnds[8] & 63;
      seqLow = seqLow << 8 | rnds[9];
      seqLow = seqLow << 5 | rnds[10] >>> 3;
    }
    if (msecs + 1e4 > _msecs && seq === null) {
      if (++seqLow > 524287) {
        seqLow = 0;
        if (++seqHigh > 4095) {
          seqHigh = 0;
          _msecs++;
        }
      }
    } else {
      _msecs = msecs;
    }
    _seqHigh = seqHigh;
    _seqLow = seqLow;
    b[i++] = _msecs / 1099511627776 & 255;
    b[i++] = _msecs / 4294967296 & 255;
    b[i++] = _msecs / 16777216 & 255;
    b[i++] = _msecs / 65536 & 255;
    b[i++] = _msecs / 256 & 255;
    b[i++] = _msecs & 255;
    b[i++] = seqHigh >>> 4 & 15 | 112;
    b[i++] = seqHigh & 255;
    b[i++] = seqLow >>> 13 & 63 | 128;
    b[i++] = seqLow >>> 5 & 255;
    b[i++] = seqLow << 3 & 255 | rnds[10] & 7;
    b[i++] = rnds[11];
    b[i++] = rnds[12];
    b[i++] = rnds[13];
    b[i++] = rnds[14];
    b[i++] = rnds[15];
    return buf || (0, _stringify.unsafeStringify)(b);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  var _seqLow = null;
  var _seqHigh = null;
  var _msecs = 0;
  var _default = exports.default = v7;
});

// ../../node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var version = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = exports.default = version;
});

// ../../node_modules/uuid/dist/index.js
var require_dist = __commonJS((exports) => {
  var _interopRequireDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "MAX", {
    enumerable: true,
    get: function() {
      return _max.default;
    }
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v1ToV6", {
    enumerable: true,
    get: function() {
      return _v1ToV.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "v6", {
    enumerable: true,
    get: function() {
      return _v5.default;
    }
  });
  Object.defineProperty(exports, "v6ToV1", {
    enumerable: true,
    get: function() {
      return _v6ToV.default;
    }
  });
  Object.defineProperty(exports, "v7", {
    enumerable: true,
    get: function() {
      return _v6.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _max = _interopRequireDefault(require_max());
  var _nil = _interopRequireDefault(require_nil());
  var _parse = _interopRequireDefault(require_parse());
  var _stringify = _interopRequireDefault(require_stringify());
  var _v = _interopRequireDefault(require_v1());
  var _v1ToV = _interopRequireDefault(require_v1ToV6());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _v5 = _interopRequireDefault(require_v6());
  var _v6ToV = _interopRequireDefault(require_v6ToV1());
  var _v6 = _interopRequireDefault(require_v7());
  var _validate = _interopRequireDefault(require_validate());
  var _version = _interopRequireDefault(require_version());
});

// ../../node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var emitClose = function(stream) {
    stream.emit("close");
  };
  var duplexOnEnd = function() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  };
  var duplexOnError = function(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  };
  var createWebSocketStream = function(ws, options) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  };
  var { Duplex } = __require("stream");
  module.exports = createWebSocketStream;
});

// ../../node_modules/ws/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  module.exports = {
    BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {
    }
  };
});

// ../../node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var concat = function(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  };
  var _mask = function(source, mask, output, offset, length2) {
    for (let i = 0;i < length2; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  };
  var _unmask = function(buffer, mask) {
    for (let i = 0;i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  };
  var toArrayBuffer = function(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  };
  var toBuffer = function(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  };
  var { EMPTY_BUFFER } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = (()=>{throw new Error(`Cannot require module "bufferutil"`);})();
      module.exports.mask = function(source, mask, output, offset, length2) {
        if (length2 < 48)
          _mask(source, mask, output, offset, length2);
        else
          bufferUtil.mask(source, mask, output, offset, length2);
      };
      module.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bufferUtil.unmask(buffer, mask);
      };
    } catch (e) {
    }
  }
});

// ../../node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// ../../node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var deflateOnData = function(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  };
  var inflateOnData = function(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  };
  var inflateOnError = function(err) {
    this[kPerMessageDeflate]._inflate = null;
    err[kStatusCode] = 1007;
    this[kCallback](err);
  };
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params2 = {};
      if (this._options.serverNoContextTakeover) {
        params2.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params2.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params2.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params2.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params2.client_max_window_bits = true;
      }
      return params2;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params2) => {
        if (opts.serverNoContextTakeover === false && params2.server_no_context_takeover || params2.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params2.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params2.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params2 = response[0];
      if (this._options.clientNoContextTakeover === false && params2.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params2.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params2.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params2.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params2;
    }
    normalizeParams(configurations) {
      configurations.forEach((params2) => {
        Object.keys(params2).forEach((key) => {
          let value = params2[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params2[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin) {
          data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
});

// ../../node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var isValidStatusCode = function(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  };
  var _isValidUTF8 = function(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  };
  var { isUtf8 } = __require("buffer");
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  module.exports = {
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = (()=>{throw new Error(`Cannot require module "utf-8-validate"`);})();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {
    }
  }
});

// ../../node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants();
  var { concat, toArrayBuffer, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var FastBuffer = Buffer[Symbol.species];
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var DEFER_EVENT = 6;

  class Receiver extends Writable {
    constructor(options = {}) {
      super();
      this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;
      this._binaryType = options.binaryType || BINARY_TYPES[0];
      this._extensions = options.extensions || {};
      this._isServer = !!options.isServer;
      this._maxPayload = options.maxPayload | 0;
      this._skipUTF8Validation = !!options.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._errored = false;
      this._loop = false;
      this._state = GET_INFO;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        return new FastBuffer(buf.buffer, buf.byteOffset, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            this.getInfo(cb);
            break;
          case GET_PAYLOAD_LENGTH_16:
            this.getPayloadLength16(cb);
            break;
          case GET_PAYLOAD_LENGTH_64:
            this.getPayloadLength64(cb);
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            this.getData(cb);
            break;
          case INFLATING:
          case DEFER_EVENT:
            this._loop = false;
            return;
        }
      } while (this._loop);
      if (!this._errored)
        cb();
    }
    getInfo(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        const error = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        cb(error);
        return;
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        cb(error);
        return;
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (!this._fragmented) {
          const error = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          const error = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          cb(error);
          return;
        }
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          cb(error);
          return;
        }
      } else {
        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        cb(error);
        return;
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          const error = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          cb(error);
          return;
        }
      } else if (this._masked) {
        const error = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        cb(error);
        return;
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        this.haveLength(cb);
    }
    getPayloadLength16(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      this.haveLength(cb);
    }
    getPayloadLength64(cb) {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        const error = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        cb(error);
        return;
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      this.haveLength(cb);
    }
    haveLength(cb) {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          cb(error);
          return;
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7) {
        this.controlMessage(data, cb);
        return;
      }
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      this.dataMessage(cb);
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
            cb(error);
            return;
          }
          this._fragments.push(buf);
        }
        this.dataMessage(cb);
        if (this._state === GET_INFO)
          this.startLoop(cb);
      });
    }
    dataMessage(cb) {
      if (!this._fin) {
        this._state = GET_INFO;
        return;
      }
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data;
        if (this._binaryType === "nodebuffer") {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }
        if (this._allowSynchronousEvents) {
          this.emit("message", data, true);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", data, true);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      } else {
        const buf = concat(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          cb(error);
          return;
        }
        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit("message", buf, false);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", buf, false);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
    }
    controlMessage(data, cb) {
      if (this._opcode === 8) {
        if (data.length === 0) {
          this._loop = false;
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            cb(error);
            return;
          }
          const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            cb(error);
            return;
          }
          this._loop = false;
          this.emit("conclude", code, buf);
          this.end();
        }
        this._state = GET_INFO;
        return;
      }
      if (this._allowSynchronousEvents) {
        this.emit(this._opcode === 9 ? "ping" : "pong", data);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
    createError(ErrorCtor, message, prefix, statusCode, errorCode) {
      this._loop = false;
      this._errored = true;
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, this.createError);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
  module.exports = Receiver;
});

// ../../node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var { Duplex } = __require("stream");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER } = require_constants();
  var { isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);
  var RANDOM_POOL_SIZE = 8 * 1024;
  var randomPool;
  var randomPoolPointer = RANDOM_POOL_SIZE;

  class Sender {
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._deflating = false;
      this._queue = [];
    }
    static frame(data, options) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options.mask) {
        mask = options.maskBuffer || maskBuffer;
        if (options.generateMask) {
          options.generateMask(mask);
        } else {
          if (randomPoolPointer === RANDOM_POOL_SIZE) {
            if (randomPool === undefined) {
              randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
            }
            randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
            randomPoolPointer = 0;
          }
          mask[0] = randomPool[randomPoolPointer++];
          mask[1] = randomPool[randomPoolPointer++];
          mask[2] = randomPool[randomPoolPointer++];
          mask[3] = randomPool[randomPoolPointer++];
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
          dataLength = options[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge = options.mask && options.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options.fin ? options.opcode | 128 : options.opcode;
      if (options.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options.mask)
        return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data];
      if (merge) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    close(code, data, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length2 = Buffer.byteLength(data);
        if (length2 > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length2);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, buf, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    send(data, options, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options.binary ? 2 : 1;
      let rsv1 = options.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options.fin)
        this._firstFragment = true;
      if (perMessageDeflate) {
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      } else {
        this.sendFrame(Sender.frame(data, {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }), cb);
      }
    }
    dispatch(data, compress, options, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options[kByteLength];
      this._deflating = true;
      perMessageDeflate.compress(data, options.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          if (typeof cb === "function")
            cb(err);
          for (let i = 0;i < this._queue.length; i++) {
            const params2 = this._queue[i];
            const callback = params2[params2.length - 1];
            if (typeof callback === "function")
              callback(err);
          }
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        this._deflating = false;
        options.readOnly = false;
        this.sendFrame(Sender.frame(buf, options), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (!this._deflating && this._queue.length) {
        const params2 = this._queue.shift();
        this._bufferedBytes -= params2[3][kByteLength];
        Reflect.apply(params2[0], this, params2.slice(1));
      }
    }
    enqueue(params2) {
      this._bufferedBytes += params2[3][kByteLength];
      this._queue.push(params2);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
});

// ../../node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var callListener = function(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  };
  var { kForOnEventAttribute, kListener } = require_constants();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event.prototype, "target", { enumerable: true });
  Object.defineProperty(Event.prototype, "type", { enumerable: true });

  class CloseEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kCode] = options.code === undefined ? 0 : options.code;
      this[kReason] = options.reason === undefined ? "" : options.reason;
      this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kError] = options.error === undefined ? null : options.error;
      this[kMessage] = options.message === undefined ? "" : options.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kData] = options.data === undefined ? null : options.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget = {
    addEventListener(type, handler, options = {}) {
      for (const listener of this.listeners(type)) {
        if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event,
    EventTarget,
    MessageEvent
  };
});

// ../../node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var push = function(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  };
  var parse2 = function(header) {
    const offers = Object.create(null);
    let params2 = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params2);
            params2 = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params2, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params2);
            params2 = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params2, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params2);
            params2 = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params2);
    } else {
      if (paramName === undefined) {
        push(params2, token, true);
      } else if (mustUnescape) {
        push(params2, paramName, token.replace(/\\/g, ""));
      } else {
        push(params2, paramName, token);
      }
      push(offers, extensionName, params2);
    }
    return offers;
  };
  var format = function(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params2) => {
        return [extension].concat(Object.keys(params2).map((k) => {
          let values = params2[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  };
  var { tokenChars } = require_validation();
  module.exports = { format, parse: parse2 };
});

// ../../node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var initAsClient = function(websocket, address, protocols, options) {
    const opts = {
      allowSynchronousEvents: true,
      autoPong: true,
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    websocket._autoPong = opts.autoPong;
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL) {
      parsedUrl = address;
    } else {
      try {
        parsedUrl = new URL(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
    }
    if (parsedUrl.protocol === "http:") {
      parsedUrl.protocol = "ws:";
    } else if (parsedUrl.protocol === "https:") {
      parsedUrl.protocol = "wss:";
    }
    websocket._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", ' + '"http:", "https", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options && options.headers;
        options = { ...options, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options.headers.authorization) {
        options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location2 = res.headers.location;
      const statusCode = res.statusCode;
      if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL(location2, address);
        } catch (e) {
          const err = new SyntaxError(`Invalid URL: ${location2}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket.CONNECTING)
        return;
      req = websocket._req = null;
      const upgrade = res.headers.upgrade;
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension " + "was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse2(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        allowSynchronousEvents: opts.allowSynchronousEvents,
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket);
    } else {
      req.end();
    }
  };
  var emitErrorAndClose = function(websocket, err) {
    websocket._readyState = WebSocket.CLOSING;
    websocket.emit("error", err);
    websocket.emitClose();
  };
  var netConnect = function(options) {
    options.path = options.socketPath;
    return net.connect(options);
  };
  var tlsConnect = function(options) {
    options.path = undefined;
    if (!options.servername && options.servername !== "") {
      options.servername = net.isIP(options.host) ? "" : options.host;
    }
    return tls.connect(options);
  };
  var abortHandshake = function(websocket, stream, message) {
    websocket._readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
      stream[kAborted] = true;
      stream.abort();
      if (stream.socket && !stream.socket.destroyed) {
        stream.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream.destroy(err);
      stream.once("error", websocket.emit.bind(websocket, "error"));
      stream.once("close", websocket.emitClose.bind(websocket));
    }
  };
  var sendAfterClose = function(websocket, data, cb) {
    if (data) {
      const length2 = toBuffer(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length2;
      else
        websocket._bufferedAmount += length2;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      process.nextTick(cb, err);
    }
  };
  var receiverOnConclude = function(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  };
  var receiverOnDrain = function() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  };
  var receiverOnError = function(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    websocket.emit("error", err);
  };
  var receiverOnFinish = function() {
    this[kWebSocket].emitClose();
  };
  var receiverOnMessage = function(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  };
  var receiverOnPing = function(data) {
    const websocket = this[kWebSocket];
    if (websocket._autoPong)
      websocket.pong(data, !this._isServer, NOOP);
    websocket.emit("ping", data);
  };
  var receiverOnPong = function(data) {
    this[kWebSocket].emit("pong", data);
  };
  var resume = function(stream) {
    stream.resume();
  };
  var socketOnClose = function() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket.CLOSING;
    let chunk;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  };
  var socketOnData = function(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  };
  var socketOnEnd = function() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket.CLOSING;
    websocket._receiver.end();
    this.end();
  };
  var socketOnError = function() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket.CLOSING;
      this.destroy();
    }
  };
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash } = __require("crypto");
  var { Duplex, Readable } = __require("stream");
  var { URL } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants();
  var {
    EventTarget: { addEventListener: addEventListener2, removeEventListener: removeEventListener2 }
  } = require_event_target();
  var { format, parse: parse2 } = require_extension();
  var { toBuffer } = require_buffer_util();
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket extends EventEmitter {
    constructor(address, protocols, options) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options);
      } else {
        this._autoPong = options.autoPong;
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options) {
      const receiver = new Receiver({
        allowSynchronousEvents: options.allowSynchronousEvents,
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options.maxPayload,
        skipUTF8Validation: options.skipUTF8Validation
      });
      this._sender = new Sender(socket, this._extensions, options.generateMask);
      this._receiver = receiver;
      this._socket = socket;
      receiver[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      if (socket.setTimeout)
        socket.setTimeout(0);
      if (socket.setNoDelay)
        socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
    }
    pause() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket.prototype.addEventListener = addEventListener2;
  WebSocket.prototype.removeEventListener = removeEventListener2;
  module.exports = WebSocket;
});

// ../../node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var parse2 = function(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const protocol2 = header.slice(start, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  };
  var { tokenChars } = require_validation();
  module.exports = { parse: parse2 };
});

// ../../node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var addListeners = function(server, map) {
    for (const event of Object.keys(map))
      server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  };
  var emitClose = function(server) {
    server._state = CLOSED;
    server.emit("close");
  };
  var socketOnError = function() {
    this.destroy();
  };
  var abortHandshake = function(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
  };
  var abortHandshakeOrEmitwsClientError = function(server, req, socket, code, message) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message);
    }
  };
  var EventEmitter = __require("events");
  var http = __require("http");
  var { Duplex } = __require("stream");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket = require_websocket();
  var { GUID, kWebSocket } = require_constants();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options, callback) {
      super();
      options = {
        allowSynchronousEvents: true,
        autoPong: true,
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket,
        ...options
      };
      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + "must be specified");
      }
      if (options.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        this._server = options.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options.perMessageDeflate === true)
        options.perMessageDeflate = {};
      if (options.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const upgrade = req.headers.upgrade;
      const version2 = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (key === undefined || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version2 !== 8 && version2 !== 13) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version2 === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same " + "socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null, undefined, this.options);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params2 = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params2]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat("\r\n").join("\r\n"));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        allowSynchronousEvents: this.options.allowSynchronousEvents,
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
});

// ../../node_modules/pm2/node_modules/commander/index.js
var require_commander = __commonJS((exports2, module2) => {
  var Option = function(flags, description2) {
    this.flags = flags;
    this.required = ~flags.indexOf("<");
    this.optional = ~flags.indexOf("[");
    this.bool = !~flags.indexOf("-no-");
    flags = flags.split(/[ ,|]+/);
    if (flags.length > 1 && !/^[[<]/.test(flags[1]))
      this.short = flags.shift();
    this.long = flags.shift();
    this.description = description2 || "";
  };
  var Command = function(name2) {
    this.commands = [];
    this.options = [];
    this._execs = {};
    this._allowUnknownOption = false;
    this._args = [];
    this._name = name2 || "";
  };
  var camelcase = function(flag) {
    return flag.split("-").reduce(function(str, word) {
      return str + word[0].toUpperCase() + word.slice(1);
    });
  };
  var pad = function(str, width) {
    var len = Math.max(0, width - str.length);
    return str + Array(len + 1).join(" ");
  };
  var outputHelpIfNecessary = function(cmd, options2) {
    options2 = options2 || [];
    for (var i = 0;i < options2.length; i++) {
      if (options2[i] === "--help" || options2[i] === "-h") {
        cmd.outputHelp();
        process.exit(0);
      }
    }
  };
  var humanReadableArgName = function(arg) {
    var nameOutput = arg.name + (arg.variadic === true ? "..." : "");
    return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
  };
  var exists = function(file) {
    try {
      if (fs.statSync(file).isFile()) {
        return true;
      }
    } catch (e) {
      return false;
    }
  };
  var EventEmitter = __require("events").EventEmitter;
  var spawn = __require("child_process").spawn;
  var path2 = __require("path");
  var dirname = path2.dirname;
  var basename = path2.basename;
  var fs = __require("fs");
  __require("util").inherits(Command, EventEmitter);
  exports2 = module2.exports = new Command;
  exports2.Command = Command;
  exports2.Option = Option;
  Option.prototype.name = function() {
    return this.long.replace("--", "").replace("no-", "");
  };
  Option.prototype.attributeName = function() {
    return camelcase(this.name());
  };
  Option.prototype.is = function(arg) {
    return this.short === arg || this.long === arg;
  };
  Command.prototype.command = function(name2, desc, opts) {
    if (typeof desc === "object" && desc !== null) {
      opts = desc;
      desc = null;
    }
    opts = opts || {};
    var args2 = name2.split(/ +/);
    var cmd = new Command(args2.shift());
    if (desc) {
      cmd.description(desc);
      this.executables = true;
      this._execs[cmd._name] = true;
      if (opts.isDefault)
        this.defaultExecutable = cmd._name;
    }
    cmd._noHelp = !!opts.noHelp;
    this.commands.push(cmd);
    cmd.parseExpectedArgs(args2);
    cmd.parent = this;
    if (desc)
      return this;
    return cmd;
  };
  Command.prototype.arguments = function(desc) {
    return this.parseExpectedArgs(desc.split(/ +/));
  };
  Command.prototype.addImplicitHelpCommand = function() {
    this.command("help [cmd]", "display help for [cmd]");
  };
  Command.prototype.parseExpectedArgs = function(args2) {
    if (!args2.length)
      return;
    var self2 = this;
    args2.forEach(function(arg) {
      var argDetails = {
        required: false,
        name: "",
        variadic: false
      };
      switch (arg[0]) {
        case "<":
          argDetails.required = true;
          argDetails.name = arg.slice(1, -1);
          break;
        case "[":
          argDetails.name = arg.slice(1, -1);
          break;
      }
      if (argDetails.name.length > 3 && argDetails.name.slice(-3) === "...") {
        argDetails.variadic = true;
        argDetails.name = argDetails.name.slice(0, -3);
      }
      if (argDetails.name) {
        self2._args.push(argDetails);
      }
    });
    return this;
  };
  Command.prototype.action = function(fn) {
    var self2 = this;
    var listener = function(args2, unknown) {
      args2 = args2 || [];
      unknown = unknown || [];
      var parsed = self2.parseOptions(unknown);
      outputHelpIfNecessary(self2, parsed.unknown);
      if (parsed.unknown.length > 0) {
        self2.unknownOption(parsed.unknown[0]);
      }
      if (parsed.args.length)
        args2 = parsed.args.concat(args2);
      self2._args.forEach(function(arg, i) {
        if (arg.required && args2[i] == null) {
          self2.missingArgument(arg.name);
        } else if (arg.variadic) {
          if (i !== self2._args.length - 1) {
            self2.variadicArgNotLast(arg.name);
          }
          args2[i] = args2.splice(i);
        }
      });
      if (self2._args.length) {
        args2[self2._args.length] = self2;
      } else {
        args2.push(self2);
      }
      fn.apply(self2, args2);
    };
    var parent = this.parent || this;
    var name2 = parent === this ? "*" : this._name;
    parent.on("command:" + name2, listener);
    if (this._alias)
      parent.on("command:" + this._alias, listener);
    return this;
  };
  Command.prototype.option = function(flags, description2, fn, defaultValue) {
    var self2 = this, option = new Option(flags, description2), oname = option.name(), name2 = option.attributeName();
    if (typeof fn !== "function") {
      if (fn instanceof RegExp) {
        var regex = fn;
        fn = function(val, def) {
          var m = regex.exec(val);
          return m ? m[0] : def;
        };
      } else {
        defaultValue = fn;
        fn = null;
      }
    }
    if (!option.bool || option.optional || option.required) {
      if (!option.bool)
        defaultValue = true;
      if (defaultValue !== undefined) {
        self2[name2] = defaultValue;
        option.defaultValue = defaultValue;
      }
    }
    this.options.push(option);
    this.on("option:" + oname, function(val) {
      if (val !== null && fn) {
        val = fn(val, self2[name2] === undefined ? defaultValue : self2[name2]);
      }
      if (typeof self2[name2] === "boolean" || typeof self2[name2] === "undefined") {
        if (val == null) {
          self2[name2] = option.bool ? defaultValue || true : false;
        } else {
          self2[name2] = val;
        }
      } else if (val !== null) {
        self2[name2] = val;
      }
    });
    return this;
  };
  Command.prototype.allowUnknownOption = function(arg) {
    this._allowUnknownOption = arguments.length === 0 || arg;
    return this;
  };
  Command.prototype.parse = function(argv) {
    if (this.executables)
      this.addImplicitHelpCommand();
    this.rawArgs = argv;
    this._name = this._name || basename(argv[1], ".js");
    if (this.executables && argv.length < 3 && !this.defaultExecutable) {
      argv.push("--help");
    }
    var parsed = this.parseOptions(this.normalize(argv.slice(2)));
    var args2 = this.args = parsed.args;
    var result = this.parseArgs(this.args, parsed.unknown);
    var name2 = result.args[0];
    var aliasCommand = null;
    if (name2) {
      aliasCommand = this.commands.filter(function(command) {
        return command.alias() === name2;
      })[0];
    }
    if (this._execs[name2] && typeof this._execs[name2] !== "function") {
      return this.executeSubCommand(argv, args2, parsed.unknown);
    } else if (aliasCommand) {
      args2[0] = aliasCommand._name;
      return this.executeSubCommand(argv, args2, parsed.unknown);
    } else if (this.defaultExecutable) {
      args2.unshift(this.defaultExecutable);
      return this.executeSubCommand(argv, args2, parsed.unknown);
    }
    return result;
  };
  Command.prototype.executeSubCommand = function(argv, args2, unknown) {
    args2 = args2.concat(unknown);
    if (!args2.length)
      this.help();
    if (args2[0] === "help" && args2.length === 1)
      this.help();
    if (args2[0] === "help") {
      args2[0] = args2[1];
      args2[1] = "--help";
    }
    var f = argv[1];
    var bin = basename(f, ".js") + "-" + args2[0];
    var baseDir, link = fs.lstatSync(f).isSymbolicLink() ? fs.readlinkSync(f) : f;
    if (link !== f && link.charAt(0) !== "/") {
      link = path2.join(dirname(f), link);
    }
    baseDir = dirname(link);
    var localBin = path2.join(baseDir, bin);
    var isExplicitJS = false;
    if (exists(localBin + ".js")) {
      bin = localBin + ".js";
      isExplicitJS = true;
    } else if (exists(localBin)) {
      bin = localBin;
    }
    args2 = args2.slice(1);
    var proc;
    if (process.platform !== "win32") {
      if (isExplicitJS) {
        args2.unshift(bin);
        args2 = (process.execArgv || []).concat(args2);
        proc = spawn(process.argv[0], args2, { stdio: "inherit", customFds: [0, 1, 2] });
      } else {
        proc = spawn(bin, args2, { stdio: "inherit", customFds: [0, 1, 2] });
      }
    } else {
      args2.unshift(bin);
      proc = spawn(process.execPath, args2, { stdio: "inherit" });
    }
    var signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
    signals.forEach(function(signal) {
      process.on(signal, function() {
        if (proc.killed === false && proc.exitCode === null) {
          proc.kill(signal);
        }
      });
    });
    proc.on("close", process.exit.bind(process));
    proc.on("error", function(err) {
      if (err.code === "ENOENT") {
        console.error("\n  %s(1) does not exist, try --help\n", bin);
      } else if (err.code === "EACCES") {
        console.error("\n  %s(1) not executable. try chmod or run with root\n", bin);
      }
      process.exit(1);
    });
    this.runningCommand = proc;
  };
  Command.prototype.normalize = function(args2) {
    var ret = [], arg, lastOpt, index;
    for (var i = 0, len = args2.length;i < len; ++i) {
      arg = args2[i];
      if (i > 0) {
        lastOpt = this.optionFor(args2[i - 1]);
      }
      if (arg === "--") {
        ret = ret.concat(args2.slice(i));
        break;
      } else if (lastOpt && lastOpt.required) {
        ret.push(arg);
      } else if (arg.length > 1 && arg[0] === "-" && arg[1] !== "-") {
        arg.slice(1).split("").forEach(function(c) {
          ret.push("-" + c);
        });
      } else if (/^--/.test(arg) && ~(index = arg.indexOf("="))) {
        ret.push(arg.slice(0, index), arg.slice(index + 1));
      } else {
        ret.push(arg);
      }
    }
    return ret;
  };
  Command.prototype.parseArgs = function(args2, unknown) {
    var name2;
    if (args2.length) {
      name2 = args2[0];
      if (this.listeners("command:" + name2).length) {
        this.emit("command:" + args2.shift(), args2, unknown);
      } else {
        this.emit("command:*", args2);
      }
    } else {
      outputHelpIfNecessary(this, unknown);
      if (unknown.length > 0) {
        this.unknownOption(unknown[0]);
      }
    }
    return this;
  };
  Command.prototype.optionFor = function(arg) {
    for (var i = 0, len = this.options.length;i < len; ++i) {
      if (this.options[i].is(arg)) {
        return this.options[i];
      }
    }
  };
  Command.prototype.parseOptions = function(argv) {
    var args2 = [], len = argv.length, literal, option, arg;
    var unknownOptions = [];
    for (var i = 0;i < len; ++i) {
      arg = argv[i];
      if (literal) {
        args2.push(arg);
        continue;
      }
      if (arg === "--") {
        literal = true;
        continue;
      }
      option = this.optionFor(arg);
      if (option) {
        if (option.required) {
          arg = argv[++i];
          if (arg == null)
            return this.optionMissingArgument(option);
          this.emit("option:" + option.name(), arg);
        } else if (option.optional) {
          arg = argv[i + 1];
          if (arg == null || arg[0] === "-" && arg !== "-") {
            arg = null;
          } else {
            ++i;
          }
          this.emit("option:" + option.name(), arg);
        } else {
          this.emit("option:" + option.name());
        }
        continue;
      }
      if (arg.length > 1 && arg[0] === "-") {
        unknownOptions.push(arg);
        if (i + 1 < argv.length && argv[i + 1][0] !== "-") {
          unknownOptions.push(argv[++i]);
        }
        continue;
      }
      args2.push(arg);
    }
    return { args: args2, unknown: unknownOptions };
  };
  Command.prototype.opts = function() {
    var result = {}, len = this.options.length;
    for (var i = 0;i < len; i++) {
      var key = this.options[i].attributeName();
      result[key] = key === this._versionOptionName ? this._version : this[key];
    }
    return result;
  };
  Command.prototype.missingArgument = function(name2) {
    console.error();
    console.error("  error: missing required argument `%s'", name2);
    console.error();
    process.exit(1);
  };
  Command.prototype.optionMissingArgument = function(option, flag) {
    console.error();
    if (flag) {
      console.error("  error: option `%s' argument missing, got `%s'", option.flags, flag);
    } else {
      console.error("  error: option `%s' argument missing", option.flags);
    }
    console.error();
    process.exit(1);
  };
  Command.prototype.unknownOption = function(flag) {
    if (this._allowUnknownOption)
      return;
    console.error();
    console.error("  error: unknown option `%s'", flag);
    console.error();
    process.exit(1);
  };
  Command.prototype.variadicArgNotLast = function(name2) {
    console.error();
    console.error("  error: variadic arguments must be last `%s'", name2);
    console.error();
    process.exit(1);
  };
  Command.prototype.version = function(str, flags) {
    if (arguments.length === 0)
      return this._version;
    this._version = str;
    flags = flags || "-V, --version";
    var versionOption = new Option(flags, "output the version number");
    this._versionOptionName = versionOption.long.substr(2) || "version";
    this.options.push(versionOption);
    this.on("option:" + this._versionOptionName, function() {
      process.stdout.write(str + "\n");
      process.exit(0);
    });
    return this;
  };
  Command.prototype.description = function(str, argsDescription) {
    if (arguments.length === 0)
      return this._description;
    this._description = str;
    this._argsDescription = argsDescription;
    return this;
  };
  Command.prototype.alias = function(alias) {
    var command = this;
    if (this.commands.length !== 0) {
      command = this.commands[this.commands.length - 1];
    }
    if (arguments.length === 0)
      return command._alias;
    if (alias === command._name)
      throw new Error("Command alias can\'t be the same as its name");
    command._alias = alias;
    return this;
  };
  Command.prototype.usage = function(str) {
    var args2 = this._args.map(function(arg) {
      return humanReadableArgName(arg);
    });
    var usage = "[options]" + (this.commands.length ? " [command]" : "") + (this._args.length ? " " + args2.join(" ") : "");
    if (arguments.length === 0)
      return this._usage || usage;
    this._usage = str;
    return this;
  };
  Command.prototype.name = function(str) {
    if (arguments.length === 0)
      return this._name;
    this._name = str;
    return this;
  };
  Command.prototype.prepareCommands = function() {
    return this.commands.filter(function(cmd) {
      return !cmd._noHelp;
    }).map(function(cmd) {
      var args2 = cmd._args.map(function(arg) {
        return humanReadableArgName(arg);
      }).join(" ");
      return [
        cmd._name + (cmd._alias ? "|" + cmd._alias : "") + (cmd.options.length ? " [options]" : "") + (args2 ? " " + args2 : ""),
        cmd._description
      ];
    });
  };
  Command.prototype.largestCommandLength = function() {
    var commands = this.prepareCommands();
    return commands.reduce(function(max4, command) {
      return Math.max(max4, command[0].length);
    }, 0);
  };
  Command.prototype.largestOptionLength = function() {
    var options2 = [].slice.call(this.options);
    options2.push({
      flags: "-h, --help"
    });
    return options2.reduce(function(max4, option) {
      return Math.max(max4, option.flags.length);
    }, 0);
  };
  Command.prototype.largestArgLength = function() {
    return this._args.reduce(function(max4, arg) {
      return Math.max(max4, arg.name.length);
    }, 0);
  };
  Command.prototype.padWidth = function() {
    var width = this.largestOptionLength();
    if (this._argsDescription && this._args.length) {
      if (this.largestArgLength() > width) {
        width = this.largestArgLength();
      }
    }
    if (this.commands && this.commands.length) {
      if (this.largestCommandLength() > width) {
        width = this.largestCommandLength();
      }
    }
    return width;
  };
  Command.prototype.optionHelp = function() {
    var width = this.padWidth();
    return this.options.map(function(option) {
      return pad(option.flags, width) + "  " + option.description + (option.bool && option.defaultValue !== undefined ? " (default: " + option.defaultValue + ")" : "");
    }).concat([pad("-h, --help", width) + "  " + "output usage information"]).join("\n");
  };
  Command.prototype.commandHelp = function() {
    if (!this.commands.length)
      return "";
    var commands = this.prepareCommands();
    var width = this.padWidth();
    return [
      "  Commands:",
      "",
      commands.map(function(cmd) {
        var desc = cmd[1] ? "  " + cmd[1] : "";
        return (desc ? pad(cmd[0], width) : cmd[0]) + desc;
      }).join("\n").replace(/^/gm, "    "),
      ""
    ].join("\n");
  };
  Command.prototype.helpInformation = function() {
    var desc = [];
    if (this._description) {
      desc = [
        "  " + this._description,
        ""
      ];
      var argsDescription = this._argsDescription;
      if (argsDescription && this._args.length) {
        var width = this.padWidth();
        desc.push("  Arguments:");
        desc.push("");
        this._args.forEach(function(arg) {
          desc.push("    " + pad(arg.name, width) + "  " + argsDescription[arg.name]);
        });
        desc.push("");
      }
    }
    var cmdName = this._name;
    if (this._alias) {
      cmdName = cmdName + "|" + this._alias;
    }
    var usage = [
      "",
      "  Usage: " + cmdName + " " + this.usage(),
      ""
    ];
    var cmds = [];
    var commandHelp = this.commandHelp();
    if (commandHelp)
      cmds = [commandHelp];
    var options2 = [
      "  Options:",
      "",
      "" + this.optionHelp().replace(/^/gm, "    "),
      ""
    ];
    return usage.concat(desc).concat(options2).concat(cmds).join("\n");
  };
  Command.prototype.outputHelp = function(cb) {
    if (!cb) {
      cb = function(passthru) {
        return passthru;
      };
    }
    process.stdout.write(cb(this.helpInformation()));
    this.emit("--help");
  };
  Command.prototype.help = function(cb) {
    this.outputHelp(cb);
    process.exit();
  };
});

// ../../node_modules/async/internal/once.js
var require_once = __commonJS((exports2, module2) => {
  var once = function(fn) {
    function wrapper(...args2) {
      if (fn === null)
        return;
      var callFn = fn;
      fn = null;
      callFn.apply(this, args2);
    }
    Object.assign(wrapper, fn);
    return wrapper;
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = once;
  module2.exports = exports2.default;
});

// ../../node_modules/async/internal/isArrayLike.js
var require_isArrayLike = __commonJS((exports2, module2) => {
  var isArrayLike = function(value) {
    return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isArrayLike;
  module2.exports = exports2.default;
});

// ../../node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = function(coll) {
    return coll[Symbol.iterator] && coll[Symbol.iterator]();
  };
  module2.exports = exports2.default;
});

// ../../node_modules/async/internal/iterator.js
var require_iterator = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var createArrayIterator = function(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
      return ++i < len ? { value: coll[i], key: i } : null;
    };
  };
  var createES2015Iterator = function(iterator) {
    var i = -1;
    return function next() {
      var item = iterator.next();
      if (item.done)
        return null;
      i++;
      return { value: item.value, key: i };
    };
  };
  var createObjectIterator = function(obj) {
    var okeys = obj ? Object.keys(obj) : [];
    var i = -1;
    var len = okeys.length;
    return function next() {
      var key = okeys[++i];
      if (key === "__proto__") {
        return next();
      }
      return i < len ? { value: obj[key], key } : null;
    };
  };
  var createIterator2 = function(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
      return createArrayIterator(coll);
    }
    var iterator = (0, _getIterator2.default)(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = createIterator2;
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _getIterator = require_getIterator();
  var _getIterator2 = _interopRequireDefault(_getIterator);
  module2.exports = exports2.default;
});

// ../../node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS((exports2, module2) => {
  var onlyOnce = function(fn) {
    return function(...args2) {
      if (fn === null)
        throw new Error("Callback was already called.");
      var callFn = fn;
      fn = null;
      callFn.apply(this, args2);
    };
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = onlyOnce;
  module2.exports = exports2.default;
});

// ../../node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = function(fn) {
    return function(...args2) {
      var callback = args2.pop();
      return fn.call(this, args2, callback);
    };
  };
  module2.exports = exports2.default;
});

// ../../node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS((exports2) => {
  var fallback = function(fn) {
    setTimeout(fn, 0);
  };
  var wrap = function(defer) {
    return (fn, ...args2) => defer(() => fn(...args2));
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.fallback = fallback;
  exports2.wrap = wrap;
  var hasQueueMicrotask = exports2.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
  var hasSetImmediate = exports2.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
  var hasNextTick = exports2.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
  var _defer;
  if (hasQueueMicrotask) {
    _defer = queueMicrotask;
  } else if (hasSetImmediate) {
    _defer = setImmediate;
  } else if (hasNextTick) {
    _defer = process.nextTick;
  } else {
    _defer = fallback;
  }
  exports2.default = wrap(_defer);
});

// ../../node_modules/async/asyncify.js
var require_asyncify = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var asyncify = function(func) {
    if ((0, _wrapAsync.isAsync)(func)) {
      return function(...args2) {
        const callback = args2.pop();
        const promise = func.apply(this, args2);
        return handlePromise(promise, callback);
      };
    }
    return (0, _initialParams2.default)(function(args2, callback) {
      var result;
      try {
        result = func.apply(this, args2);
      } catch (e) {
        return callback(e);
      }
      if (result && typeof result.then === "function") {
        return handlePromise(result, callback);
      } else {
        callback(null, result);
      }
    });
  };
  var handlePromise = function(promise, callback) {
    return promise.then((value) => {
      invokeCallback(callback, null, value);
    }, (err) => {
      invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
    });
  };
  var invokeCallback = function(callback, error, value) {
    try {
      callback(error, value);
    } catch (err) {
      (0, _setImmediate2.default)((e) => {
        throw e;
      }, err);
    }
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = asyncify;
  var _initialParams = require_initialParams();
  var _initialParams2 = _interopRequireDefault(_initialParams);
  var _setImmediate = require_setImmediate();
  var _setImmediate2 = _interopRequireDefault(_setImmediate);
  var _wrapAsync = require_wrapAsync();
  module2.exports = exports2.default;
});

// ../../node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS((exports2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isAsync = function(fn) {
    return fn[Symbol.toStringTag] === "AsyncFunction";
  };
  var isAsyncGenerator = function(fn) {
    return fn[Symbol.toStringTag] === "AsyncGenerator";
  };
  var isAsyncIterable = function(obj) {
    return typeof obj[Symbol.asyncIterator] === "function";
  };
  var wrapAsync = function(asyncFn) {
    if (typeof asyncFn !== "function")
      throw new Error("expected a function");
    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.isAsyncIterable = exports2.isAsyncGenerator = exports2.isAsync = undefined;
  var _asyncify = require_asyncify();
  var _asyncify2 = _interopRequireDefault(_asyncify);
  exports2.default = wrapAsync;
  exports2.isAsync = isAsync;
  exports2.isAsyncGenerator = isAsyncGenerator;
  exports2.isAsyncIterable = isAsyncIterable;
});

// ../../node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var breakLoop = {};
  exports2.default = breakLoop;
  module2.exports = exports2.default;
});

// ../../node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var asyncEachOfLimit = function(generator, limit, iteratee, callback) {
    let done = false;
    let canceled = false;
    let awaiting = false;
    let running = 0;
    let idx = 0;
    function replenish() {
      if (running >= limit || awaiting || done)
        return;
      awaiting = true;
      generator.next().then(({ value, done: iterDone }) => {
        if (canceled || done)
          return;
        awaiting = false;
        if (iterDone) {
          done = true;
          if (running <= 0) {
            callback(null);
          }
          return;
        }
        running++;
        iteratee(value, idx, iterateeCallback);
        idx++;
        replenish();
      }).catch(handleError);
    }
    function iterateeCallback(err, result) {
      running -= 1;
      if (canceled)
        return;
      if (err)
        return handleError(err);
      if (err === false) {
        done = true;
        canceled = true;
        return;
      }
      if (result === _breakLoop2.default || done && running <= 0) {
        done = true;
        return callback(null);
      }
      replenish();
    }
    function handleError(err) {
      if (canceled)
        return;
      awaiting = false;
      done = true;
      callback(err);
    }
    replenish();
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = asyncEachOfLimit;
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  module2.exports = exports2.default;
});

// ../../node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _once = require_once();
  var _once2 = _interopRequireDefault(_once);
  var _iterator = require_iterator();
  var _iterator2 = _interopRequireDefault(_iterator);
  var _onlyOnce = require_onlyOnce();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _wrapAsync = require_wrapAsync();
  var _asyncEachOfLimit = require_asyncEachOfLimit();
  var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  exports2.default = (limit) => {
    return (obj, iteratee, callback) => {
      callback = (0, _once2.default)(callback);
      if (limit <= 0) {
        throw new RangeError("concurrency limit cannot be less than 1");
      }
      if (!obj) {
        return callback(null);
      }
      if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
        return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
      }
      if ((0, _wrapAsync.isAsyncIterable)(obj)) {
        return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
      }
      var nextElem = (0, _iterator2.default)(obj);
      var done = false;
      var canceled = false;
      var running = 0;
      var looping = false;
      function iterateeCallback(err, value) {
        if (canceled)
          return;
        running -= 1;
        if (err) {
          done = true;
          callback(err);
        } else if (err === false) {
          done = true;
          canceled = true;
        } else if (value === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        } else if (!looping) {
          replenish();
        }
      }
      function replenish() {
        looping = true;
        while (running < limit && !done) {
          var elem = nextElem();
          if (elem === null) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running += 1;
          iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
        }
        looping = false;
      }
      replenish();
    };
  };
  module2.exports = exports2.default;
});

// ../../node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS((exports2, module2) => {
  var _withoutIndex = function(iteratee) {
    return (value, index, callback) => iteratee(value, callback);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = _withoutIndex;
  module2.exports = exports2.default;
});

// ../../node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS((exports2, module2) => {
  var awaitify = function(asyncFn, arity) {
    if (!arity)
      arity = asyncFn.length;
    if (!arity)
      throw new Error("arity is undefined");
    function awaitable(...args2) {
      if (typeof args2[arity - 1] === "function") {
        return asyncFn.apply(this, args2);
      }
      return new Promise((resolve, reject) => {
        args2[arity - 1] = (err, ...cbArgs) => {
          if (err)
            return reject(err);
          resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
        };
        asyncFn.apply(this, args2);
      });
    }
    return awaitable;
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = awaitify;
  module2.exports = exports2.default;
});

// ../../node_modules/async/eachLimit.js
var require_eachLimit = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachLimit = function(coll, limit, iteratee, callback) {
    return (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _eachOfLimit = require_eachOfLimit();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _withoutIndex = require_withoutIndex();
  var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports2.default = (0, _awaitify2.default)(eachLimit, 4);
  module2.exports = exports2.default;
});

// ../../node_modules/async/internal/parallel.js
var require_parallel = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports2.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
    eachfn(tasks, (task, key, taskCb) => {
      (0, _wrapAsync2.default)(task)((err, ...result) => {
        if (result.length < 2) {
          [result] = result;
        }
        results[key] = result;
        taskCb(err);
      });
    }, (err) => callback(err, results));
  }, 3);
  module2.exports = exports2.default;
});

// ../../node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachOfLimit = function(coll, limit, iteratee, callback) {
    return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _eachOfLimit2 = require_eachOfLimit();
  var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports2.default = (0, _awaitify2.default)(eachOfLimit, 4);
  module2.exports = exports2.default;
});

// ../../node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachOfSeries = function(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _eachOfLimit = require_eachOfLimit2();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports2.default = (0, _awaitify2.default)(eachOfSeries, 3);
  module2.exports = exports2.default;
});

// ../../node_modules/async/series.js
var require_series = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var series = function(tasks, callback) {
    return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = series;
  var _parallel2 = require_parallel();
  var _parallel3 = _interopRequireDefault(_parallel2);
  var _eachOfSeries = require_eachOfSeries();
  var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
  module2.exports = exports2.default;
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var parse2 = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n, name2) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
  };
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options2) {
    options2 = options2 || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// ../../node_modules/debug/src/common.js
var require_common = __commonJS((exports2, module2) => {
  var setup = function(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args2) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args2[0] = createDebug.coerce(args2[0]);
        if (typeof args2[0] !== "string") {
          args2.unshift("%O");
        }
        let index = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args2[index];
            match = formatter.call(self2, val);
            args2.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args2);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args2);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0;i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name2) {
      if (name2[name2.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name2)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  };
  module2.exports = setup;
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS((exports2, module2) => {
  var useColors = function() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  };
  var formatArgs = function(args2) {
    args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + exports2.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args2.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args2[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args2.splice(lastC, 0, c);
  };
  var save = function(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  };
  var load = function() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  };
  var localstorage = function() {
    try {
      return localStorage;
    } catch (error) {
    }
  };
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  exports2.log = console.debug || console.log || (() => {
  });
  module2.exports = require_common()(exports2);
  var { formatters } = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports2, module2) => {
  module2.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports2, module2) => {
  var translateLevel = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor2 = function(haveStream, streamIsTTY) {
    if (forceColor2 === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor2 === undefined) {
      return 0;
    }
    const min4 = forceColor2 || 0;
    if (env.TERM === "dumb") {
      return min4;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min4;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version3 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version3 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min4;
  };
  var getSupportLevel = function(stream2) {
    const level = supportsColor2(stream2, stream2 && stream2.isTTY);
    return translateLevel(level);
  };
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var forceColor2;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor2 = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor2 = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor2 = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor2 = 0;
    } else {
      forceColor2 = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor2(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor2(true, tty.isatty(2)))
  };
});

// ../../node_modules/debug/src/node.js
var require_node = __commonJS((exports2, module2) => {
  var useColors = function() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  };
  var formatArgs = function(args2) {
    const { namespace: name2, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
      args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
      args2.push(colorCode + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
    } else {
      args2[0] = getDate() + name2 + " " + args2[0];
    }
  };
  var getDate = function() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  };
  var log = function(...args2) {
    return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args2) + "\n");
  };
  var save = function(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  };
  var load = function() {
    return process.env.DEBUG;
  };
  var init2 = function(debug) {
    debug.inspectOpts = {};
    const keys3 = Object.keys(exports2.inspectOpts);
    for (let i = 0;i < keys3.length; i++) {
      debug.inspectOpts[keys3[i]] = exports2.inspectOpts[keys3[i]];
    }
  };
  var tty = __require("tty");
  var util = __require("util");
  exports2.init = init2;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor2 = require_supports_color();
    if (supportsColor2 && (supportsColor2.stderr || supportsColor2).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  module2.exports = require_common()(exports2);
  var { formatters } = module2.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// ../../node_modules/debug/src/index.js
var require_src = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module2.exports = require_browser();
  } else {
    module2.exports = require_node();
  }
});

// ../../node_modules/color-name/index.js
var require_color_name = __commonJS((exports2, module2) => {
  module2.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../../node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports2, module2) => {
  var comparativeDistance = function(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  };
  var cssKeywords = require_color_name();
  var reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  var convert = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  module2.exports = convert;
  for (const model of Object.keys(convert)) {
    if (!("channels" in convert[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", { value: channels });
    Object.defineProperty(convert[model], "labels", { value: labels });
  }
  convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min4 = Math.min(r, g, b);
    const max4 = Math.max(r, g, b);
    const delta = max4 - min4;
    let h;
    let s;
    if (max4 === min4) {
      h = 0;
    } else if (r === max4) {
      h = (g - b) / delta;
    } else if (g === max4) {
      h = 2 + (b - r) / delta;
    } else if (b === max4) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min4 + max4) / 2;
    if (max4 === min4) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max4 + min4);
    } else {
      s = delta / (2 - max4 - min4);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0;i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args2, saturation = null) {
    const [r, g, b] = args2;
    let value = saturation === null ? convert.rgb.hsv(args2)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args2) {
    return convert.rgb.ansi16(convert.hsv.rgb(args2), args2[2]);
  };
  convert.rgb.ansi256 = function(args2) {
    const r = args2[0];
    const g = args2[1];
    const b = args2[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args2) {
    let color = args2 % 10;
    if (color === 0 || color === 7) {
      if (args2 > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args2 > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args2) {
    if (args2 >= 232) {
      const c = (args2 - 232) * 10 + 8;
      return [c, c, c];
    }
    args2 -= 16;
    let rem;
    const r = Math.floor(args2 / 36) / 5 * 255;
    const g = Math.floor((rem = args2 % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args2) {
    const integer = ((Math.round(args2[0]) & 255) << 16) + ((Math.round(args2[1]) & 255) << 8) + (Math.round(args2[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args2) {
    const match = args2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max4 = Math.max(Math.max(r, g), b);
    const min4 = Math.min(Math.min(r, g), b);
    const chroma = max4 - min4;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min4 / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max4 === r) {
      hue = (g - b) / chroma % 6;
    } else if (max4 === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args2) {
    return [args2[0] / 100 * 255, args2[0] / 100 * 255, args2[0] / 100 * 255];
  };
  convert.gray.hsl = function(args2) {
    return [0, 0, args2[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// ../../node_modules/color-convert/route.js
var require_route = __commonJS((exports2, module2) => {
  var buildGraph = function() {
    const graph = {};
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0;i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  };
  var deriveBFS = function(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0;i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  };
  var link = function(from3, to) {
    return function(args2) {
      return to(from3(args2));
    };
  };
  var wrapConversion = function(toModel, graph) {
    const path2 = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path2.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path2;
    return fn;
  };
  var conversions = require_conversions();
  module2.exports = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0;i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// ../../node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports2, module2) => {
  var wrapRaw = function(fn) {
    const wrappedFn = function(...args2) {
      const arg0 = args2[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args2 = arg0;
      }
      return fn(args2);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  };
  var wrapRounded = function(fn) {
    const wrappedFn = function(...args2) {
      const arg0 = args2[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args2 = arg0;
      }
      const result = fn(args2);
      if (typeof result === "object") {
        for (let len = result.length, i = 0;i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  };
  var conversions = require_conversions();
  var route = require_route();
  var convert = {};
  var models = Object.keys(conversions);
  models.forEach((fromModel) => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
    Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module2.exports = convert;
});

// ../../node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS((exports2, module2) => {
  var assembleStyles = function() {
    const codes = new Map;
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, "codes", {
      value: codes,
      enumerable: false
    });
    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles;
  };
  var wrapAnsi16 = (fn, offset) => (...args2) => {
    const code = fn(...args2);
    return `\x1B[${code + offset}m`;
  };
  var wrapAnsi256 = (fn, offset) => (...args2) => {
    const code = fn(...args2);
    return `\x1B[${38 + offset};5;${code}m`;
  };
  var wrapAnsi16m = (fn, offset) => (...args2) => {
    const rgb = fn(...args2);
    return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  var ansi2ansi = (n) => n;
  var rgb2rgb = (r, g, b) => [r, g, b];
  var setLazyProperty = (object, property, get) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  var colorConvert;
  var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
    if (colorConvert === undefined) {
      colorConvert = require_color_convert();
    }
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
      const name2 = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles[name2] = wrap(identity, offset);
      } else if (typeof suite === "object") {
        styles[name2] = wrap(suite[targetSpace], offset);
      }
    }
    return styles;
  };
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// ../../node_modules/pm2/node_modules/chalk/source/util.js
var require_util = __commonJS((exports2, module2) => {
  var stringReplaceAll = (string, substring, replacer) => {
    let index = string.indexOf(substring);
    if (index === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
      endIndex = index + substringLength;
      index = string.indexOf(substring, endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index - 1] === "\r";
      returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index + 1;
      index = string.indexOf("\n", endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  module2.exports = {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  };
});

// ../../node_modules/pm2/node_modules/chalk/source/templates.js
var require_templates = __commonJS((exports2, module2) => {
  var unescape2 = function(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES.get(c) || c;
  };
  var parseArguments = function(name2, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number)) {
        results.push(number);
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, character) => escape2 ? unescape2(escape2) : character));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
      }
    }
    return results;
  };
  var parseStyle = function(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name2 = matches[1];
      if (matches[2]) {
        const args2 = parseArguments(name2, matches[2]);
        results.push([name2].concat(args2));
      } else {
        results.push([name2]);
      }
    }
    return results;
  };
  var buildStyle = function(chalk, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk;
    for (const [styleName, styles2] of Object.entries(enabled)) {
      if (!Array.isArray(styles2)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
    }
    return current;
  };
  var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "\t"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  module2.exports = (chalk, temporary) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter) {
        chunk.push(unescape2(escapeCharacter));
      } else if (style) {
        const string = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
        styles.push({ inverse, styles: parseStyle(style) });
      } else if (close) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMsg);
    }
    return chunks.join("");
  };
});

// ../../node_modules/pm2/node_modules/chalk/source/index.js
var require_source = __commonJS((exports2, module2) => {
  var Chalk = function(options2) {
    return chalkFactory(options2);
  };
  var ansiStyles = require_ansi_styles();
  var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
  var {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  } = require_util();
  var levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  var styles = Object.create(null);
  var applyOptions = (object, options2 = {}) => {
    if (options2.level > 3 || options2.level < 0) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options2.level === undefined ? colorLevel : options2.level;
  };

  class ChalkClass {
    constructor(options2) {
      return chalkFactory(options2);
    }
  }
  var chalkFactory = (options2) => {
    const chalk2 = {};
    applyOptions(chalk2, options2);
    chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
    Object.setPrototypeOf(chalk2, Chalk.prototype);
    Object.setPrototypeOf(chalk2.template, chalk2);
    chalk2.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    };
    chalk2.template.Instance = ChalkClass;
    return chalk2.template;
  };
  for (const [styleName, style] of Object.entries(ansiStyles)) {
    styles[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
        Object.defineProperty(this, styleName, { value: builder });
        return builder;
      }
    };
  }
  styles.visible = {
    get() {
      const builder = createBuilder(this, this._styler, true);
      Object.defineProperty(this, "visible", { value: builder });
      return builder;
    }
  };
  var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const model of usedModels) {
    styles[model] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  for (const model of usedModels) {
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, {
    ...styles,
    level: {
      enumerable: true,
      get() {
        return this._generator.level;
      },
      set(level) {
        this._generator.level = level;
      }
    }
  });
  var createStyler = (open, close, parent) => {
    let openAll;
    let closeAll;
    if (parent === undefined) {
      openAll = open;
      closeAll = close;
    } else {
      openAll = parent.openAll + open;
      closeAll = close + parent.closeAll;
    }
    return {
      open,
      close,
      openAll,
      closeAll,
      parent
    };
  };
  var createBuilder = (self2, _styler, _isEmpty) => {
    const builder = (...arguments_) => {
      return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    };
    builder.__proto__ = proto;
    builder._generator = self2;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
  };
  var applyStyle = (self2, string) => {
    if (self2.level <= 0 || !string) {
      return self2._isEmpty ? "" : string;
    }
    let styler = self2._styler;
    if (styler === undefined) {
      return string;
    }
    const { openAll, closeAll } = styler;
    if (string.indexOf("\x1B") !== -1) {
      while (styler !== undefined) {
        string = stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  };
  var template;
  var chalkTag = (chalk2, ...strings) => {
    const [firstString] = strings;
    if (!Array.isArray(firstString)) {
      return strings.join(" ");
    }
    const arguments_ = strings.slice(1);
    const parts = [firstString.raw[0]];
    for (let i = 1;i < firstString.length; i++) {
      parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
    }
    if (template === undefined) {
      template = require_templates();
    }
    return template(chalk2, parts.join(""));
  };
  Object.defineProperties(Chalk.prototype, styles);
  var chalk = Chalk();
  chalk.supportsColor = stdoutColor;
  chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
  chalk.stderr.supportsColor = stderrColor;
  chalk.Level = {
    None: 0,
    Basic: 1,
    Ansi256: 2,
    TrueColor: 3,
    0: "None",
    1: "Basic",
    2: "Ansi256",
    3: "TrueColor"
  };
  module2.exports = chalk;
});

// ../../node_modules/fclone/dist/fclone.js
var require_fclone = __commonJS((exports2, module2) => {
  (function(root, factory) {
    if (typeof define === "function" && define.amd) {
      define("fclone", [], factory);
    } else if (typeof module2 === "object" && exports2) {
      module2.exports = factory();
    } else {
      root.fclone = factory();
    }
  })(exports2, function() {
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function isArrayLike(item) {
      if (Array.isArray(item))
        return true;
      var len = item && item.length;
      return typeof len === "number" && (len === 0 || (len - 1 in item)) && typeof item.indexOf === "function";
    }
    function fclone(obj, refs) {
      if (!obj || (typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== "object")
        return obj;
      if (obj instanceof Date) {
        return new Date(obj);
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer(obj)) {
        return new Buffer(obj);
      }
      if (typeof obj.subarray === "function" && /[A-Z][A-Za-z\d]+Array/.test(Object.prototype.toString.call(obj))) {
        return obj.subarray(0);
      }
      if (!refs) {
        refs = [];
      }
      if (isArrayLike(obj)) {
        refs[refs.length] = obj;
        var _l = obj.length;
        var i = -1;
        var _copy = [];
        while (_l > ++i) {
          _copy[i] = ~refs.indexOf(obj[i]) ? "[Circular]" : fclone(obj[i], refs);
        }
        refs.length && refs.length--;
        return _copy;
      }
      refs[refs.length] = obj;
      var copy2 = {};
      if (obj instanceof Error) {
        copy2.name = obj.name;
        copy2.message = obj.message;
        copy2.stack = obj.stack;
      }
      var keys3 = Object.keys(obj);
      var l = keys3.length;
      while (l--) {
        var k = keys3[l];
        copy2[k] = ~refs.indexOf(obj[k]) ? "[Circular]" : fclone(obj[k], refs);
      }
      refs.length && refs.length--;
      return copy2;
    }
    fclone.default = fclone;
    return fclone;
  });
});

// ../../node_modules/pm2/lib/API/ExtraMgmt/Docker.js
var require_Docker = __commonJS((exports2, module2) => {
  var execDocker = function(cmd, cb) {
    var i = spawn("docker", cmd, {
      stdio: "inherit",
      env: process.env,
      shell: true
    });
    i.on("close", cb);
  };
  var util = __require("util");
  var spawn = __require("child_process").spawn;
  var DockerMgmt = {};
  module2.exports = DockerMgmt;
  DockerMgmt.processCommand = function(PM2, start_id, select_id, action, cb) {
    PM2.Client.executeRemote("getSystemData", {}, (err, sys_infos) => {
      if (sys_infos.containers && sys_infos.containers.length == 0)
        return cb(new Error(`Process ${select_id} not found`));
      var container = sys_infos.containers[select_id - start_id - 1];
      if (action == "stopProcessId")
        execDocker(["stop", container.id], cb);
      if (action == "deleteProcessId")
        execDocker(["rm", container.id], cb);
      if (action == "restartProcessId")
        execDocker(["restart", container.id], cb);
    });
  };
});

// ../../node_modules/pm2/paths.js
var require_paths = __commonJS((exports2, module2) => {
  var getDefaultPM2Home = function() {
    var PM2_ROOT_PATH;
    if (process.env.PM2_HOME)
      PM2_ROOT_PATH = process.env.PM2_HOME;
    else if (process.env.HOME && !process.env.HOMEPATH)
      PM2_ROOT_PATH = p.resolve(process.env.HOME, ".pm2");
    else if (process.env.HOME || process.env.HOMEPATH)
      PM2_ROOT_PATH = p.resolve(process.env.HOMEDRIVE, process.env.HOME || process.env.HOMEPATH, ".pm2");
    else {
      console.error("[PM2][Initialization] Environment variable HOME (Linux) or HOMEPATH (Windows) are not set!");
      console.error("[PM2][Initialization] Defaulting to /etc/.pm2");
      PM2_ROOT_PATH = p.resolve("/etc", ".pm2");
    }
    debug("pm2 home resolved to %s", PM2_ROOT_PATH, process.env.HOME);
    return PM2_ROOT_PATH;
  };
  var __dirname = "C:\\Users\\balle\\Documents\\GitHub\\echoesmd\\node_modules\\pm2";
  var debug = require_src()("pm2:paths");
  var p = __require("path");
  var fs = __require("fs");
  module2.exports = function(PM2_HOME) {
    var has_node_embedded = false;
    if (fs.existsSync(p.resolve(__dirname, "./node")) === true) {
      has_node_embedded = true;
    }
    if (!PM2_HOME) {
      PM2_HOME = getDefaultPM2Home();
    }
    var pm2_file_stucture = {
      PM2_HOME,
      PM2_ROOT_PATH: PM2_HOME,
      PM2_CONF_FILE: p.resolve(PM2_HOME, "conf.js"),
      PM2_MODULE_CONF_FILE: p.resolve(PM2_HOME, "module_conf.json"),
      PM2_LOG_FILE_PATH: p.resolve(PM2_HOME, "pm2.log"),
      PM2_PID_FILE_PATH: p.resolve(PM2_HOME, "pm2.pid"),
      PM2_RELOAD_LOCKFILE: p.resolve(PM2_HOME, "reload.lock"),
      DEFAULT_PID_PATH: p.resolve(PM2_HOME, "pids"),
      DEFAULT_LOG_PATH: p.resolve(PM2_HOME, "logs"),
      DEFAULT_MODULE_PATH: p.resolve(PM2_HOME, "modules"),
      PM2_IO_ACCESS_TOKEN: p.resolve(PM2_HOME, "pm2-io-token"),
      DUMP_FILE_PATH: p.resolve(PM2_HOME, "dump.pm2"),
      DUMP_BACKUP_FILE_PATH: p.resolve(PM2_HOME, "dump.pm2.bak"),
      DAEMON_RPC_PORT: p.resolve(PM2_HOME, "rpc.sock"),
      DAEMON_PUB_PORT: p.resolve(PM2_HOME, "pub.sock"),
      INTERACTOR_RPC_PORT: p.resolve(PM2_HOME, "interactor.sock"),
      INTERACTOR_LOG_FILE_PATH: p.resolve(PM2_HOME, "agent.log"),
      INTERACTOR_PID_PATH: p.resolve(PM2_HOME, "agent.pid"),
      INTERACTION_CONF: p.resolve(PM2_HOME, "agent.json5"),
      HAS_NODE_EMBEDDED: has_node_embedded,
      BUILTIN_NODE_PATH: has_node_embedded === true ? p.resolve(__dirname, "./node/bin/node") : null,
      BUILTIN_NPM_PATH: has_node_embedded === true ? p.resolve(__dirname, "./node/bin/npm") : null
    };
    var paths = Object.keys(pm2_file_stucture);
    paths.forEach(function(key) {
      var envKey = key.indexOf("PM2_") > -1 ? key : "PM2_" + key;
      if (process.env[envKey] && key !== "PM2_HOME" && key !== "PM2_ROOT_PATH") {
        pm2_file_stucture[key] = process.env[envKey];
      }
    });
    if (process.platform === "win32" || process.platform === "win64") {
      pm2_file_stucture.DAEMON_RPC_PORT = "\\\\.\\pipe\\rpc.sock";
      pm2_file_stucture.DAEMON_PUB_PORT = "\\\\.\\pipe\\pub.sock";
      pm2_file_stucture.INTERACTOR_RPC_PORT = "\\\\.\\pipe\\interactor.sock";
    }
    return pm2_file_stucture;
  };
});

// ../../node_modules/pm2/constants.js
var require_constants2 = __commonJS((exports2, module2) => {
  var __dirname = "C:\\Users\\balle\\Documents\\GitHub\\echoesmd\\node_modules\\pm2";
  var debug = require_src()("pm2:conf");
  var p = __require("path");
  var util = __require("util");
  var chalk = require_source();
  var path_structure = require_paths()(process.env.OVER_HOME);
  var csts = {
    PREFIX_MSG: chalk.green("[PM2] "),
    PREFIX_MSG_INFO: chalk.cyan("[PM2][INFO] "),
    PREFIX_MSG_ERR: chalk.red("[PM2][ERROR] "),
    PREFIX_MSG_MOD: chalk.bold.green("[PM2][Module] "),
    PREFIX_MSG_MOD_ERR: chalk.red("[PM2][Module][ERROR] "),
    PREFIX_MSG_WARNING: chalk.yellow("[PM2][WARN] "),
    PREFIX_MSG_SUCCESS: chalk.cyan("[PM2] "),
    PM2_IO_MSG: chalk.cyan("[PM2 I/O]"),
    PM2_IO_MSG_ERR: chalk.red("[PM2 I/O]"),
    TEMPLATE_FOLDER: p.join(__dirname, "lib/templates"),
    APP_CONF_DEFAULT_FILE: "ecosystem.config.js",
    APP_CONF_TPL: "ecosystem.tpl",
    APP_CONF_TPL_SIMPLE: "ecosystem-simple.tpl",
    SAMPLE_CONF_FILE: "sample-conf.js",
    LOGROTATE_SCRIPT: "logrotate.d/pm2",
    DOCKERFILE_NODEJS: "Dockerfiles/Dockerfile-nodejs.tpl",
    DOCKERFILE_JAVA: "Dockerfiles/Dockerfile-java.tpl",
    DOCKERFILE_RUBY: "Dockerfiles/Dockerfile-ruby.tpl",
    SUCCESS_EXIT: 0,
    ERROR_EXIT: 1,
    CODE_UNCAUGHTEXCEPTION: 1,
    IS_WINDOWS: process.platform === "win32" || process.platform === "win64" || /^(msys|cygwin)$/.test(process.env.OSTYPE),
    ONLINE_STATUS: "online",
    STOPPED_STATUS: "stopped",
    STOPPING_STATUS: "stopping",
    WAITING_RESTART: "waiting restart",
    LAUNCHING_STATUS: "launching",
    ERRORED_STATUS: "errored",
    ONE_LAUNCH_STATUS: "one-launch-status",
    CLUSTER_MODE_ID: "cluster_mode",
    FORK_MODE_ID: "fork_mode",
    LOW_MEMORY_ENVIRONMENT: process.env.PM2_OPTIMIZE_MEMORY || false,
    MACHINE_NAME: process.env.INSTANCE_NAME || process.env.MACHINE_NAME || process.env.PM2_MACHINE_NAME,
    SECRET_KEY: process.env.KEYMETRICS_SECRET || process.env.PM2_SECRET_KEY || process.env.SECRET_KEY,
    PUBLIC_KEY: process.env.KEYMETRICS_PUBLIC || process.env.PM2_PUBLIC_KEY || process.env.PUBLIC_KEY,
    KEYMETRICS_ROOT_URL: process.env.KEYMETRICS_NODE || process.env.PM2_APM_ADDRESS || process.env.ROOT_URL || process.env.INFO_NODE || "root.keymetrics.io",
    PM2_BANNER: "../lib/motd",
    PM2_UPDATE: "../lib/API/pm2-plus/pres/motd.update",
    DEFAULT_MODULE_JSON: "package.json",
    MODULE_BASEFOLDER: "module",
    MODULE_CONF_PREFIX: "module-db-v2",
    MODULE_CONF_PREFIX_TAR: "tar-modules",
    EXP_BACKOFF_RESET_TIMER: parseInt(process.env.EXP_BACKOFF_RESET_TIMER) || 30000,
    REMOTE_PORT_TCP: isNaN(parseInt(process.env.KEYMETRICS_PUSH_PORT)) ? 80 : parseInt(process.env.KEYMETRICS_PUSH_PORT),
    REMOTE_PORT: 41624,
    REMOTE_HOST: "s1.keymetrics.io",
    SEND_INTERVAL: 1000,
    RELOAD_LOCK_TIMEOUT: parseInt(process.env.PM2_RELOAD_LOCK_TIMEOUT) || 30000,
    GRACEFUL_TIMEOUT: parseInt(process.env.PM2_GRACEFUL_TIMEOUT) || 8000,
    GRACEFUL_LISTEN_TIMEOUT: parseInt(process.env.PM2_GRACEFUL_LISTEN_TIMEOUT) || 3000,
    LOGS_BUFFER_SIZE: 8,
    CONTEXT_ON_ERROR: 2,
    AGGREGATION_DURATION: process.env.PM2_DEBUG || false ? 3000 : 5 * 60000,
    TRACE_FLUSH_INTERVAL: process.env.PM2_DEBUG ? 1000 : 60000,
    CONCURRENT_ACTIONS: function() {
      var concurrent_actions = parseInt(process.env.PM2_CONCURRENT_ACTIONS) || 2;
      debug("Using %d parallelism (CONCURRENT_ACTIONS)", concurrent_actions);
      return concurrent_actions;
    }(),
    DEBUG: process.env.PM2_DEBUG || false,
    WEB_IPADDR: process.env.PM2_API_IPADDR || "0.0.0.0",
    WEB_PORT: parseInt(process.env.PM2_API_PORT) || 9615,
    WEB_STRIP_ENV_VARS: process.env.PM2_WEB_STRIP_ENV_VARS || false,
    MODIFY_REQUIRE: process.env.PM2_MODIFY_REQUIRE || false,
    WORKER_INTERVAL: process.env.PM2_WORKER_INTERVAL || 30000,
    KILL_TIMEOUT: process.env.PM2_KILL_TIMEOUT || 1600,
    KILL_SIGNAL: process.env.PM2_KILL_SIGNAL || "SIGINT",
    KILL_USE_MESSAGE: process.env.PM2_KILL_USE_MESSAGE || false,
    PM2_PROGRAMMATIC: typeof process.env.pm_id !== "undefined" || process.env.PM2_PROGRAMMATIC,
    PM2_LOG_DATE_FORMAT: process.env.PM2_LOG_DATE_FORMAT !== undefined ? process.env.PM2_LOG_DATE_FORMAT : "YYYY-MM-DDTHH:mm:ss"
  };
  module2.exports = Object.assign(csts, path_structure);
});

// ../../node_modules/semver/internal/constants.js
var require_constants3 = __commonJS((exports2, module2) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER4 = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module2.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER4,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// ../../node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports2, module2) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args2) => console.error("SEMVER", ...args2) : () => {
  };
  module2.exports = debug;
});

// ../../node_modules/semver/internal/re.js
var require_re = __commonJS((exports2, module2) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants3();
  var debug = require_debug();
  exports2 = module2.exports = {};
  var re = exports2.re = [];
  var safeRe = exports2.safeRe = [];
  var src = exports2.src = [];
  var t = exports2.t = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value) => {
    for (const [token, max4] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max4}}`).split(`${token}+`).join(`${token}{1,${max4}}`);
    }
    return value;
  };
  var createToken = (name2, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug(name2, index, value);
    t[name2] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}\$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}\$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}\$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken("COERCE", `${src[t.COERCEPLAIN]}(?:\$|[^\\d])`);
  createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:\$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("COERCERTLFULL", src[t.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}\$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}\$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})\$|^\$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})\$|^\$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*\$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*\$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// ../../node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports2, module2) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options2) => {
    if (!options2) {
      return emptyOpts;
    }
    if (typeof options2 !== "object") {
      return looseOption;
    }
    return options2;
  };
  module2.exports = parseOptions;
});

// ../../node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports2, module2) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module2.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// ../../node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports2, module2) => {
  var debug = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER4 } = require_constants3();
  var { safeRe: re, t } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version3, options2) {
      options2 = parseOptions(options2);
      if (version3 instanceof SemVer) {
        if (version3.loose === !!options2.loose && version3.includePrerelease === !!options2.includePrerelease) {
          return version3;
        } else {
          version3 = version3.version;
        }
      } else if (typeof version3 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version3}".`);
      }
      if (version3.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version3, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      const m = version3.trim().match(options2.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version3}`);
      }
      this.raw = version3;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER4 || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER4 || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER4 || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id2) => {
          if (/^[0-9]+$/.test(id2)) {
            const num = +id2;
            if (num >= 0 && num < MAX_SAFE_INTEGER4) {
              return num;
            }
          }
          return id2;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("build compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    inc(release, identifier, identifierBase) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module2.exports = SemVer;
});

// ../../node_modules/semver/functions/parse.js
var require_parse2 = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var parse2 = (version3, options2, throwErrors = false) => {
    if (version3 instanceof SemVer) {
      return version3;
    }
    try {
      return new SemVer(version3, options2);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module2.exports = parse2;
});

// ../../node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports2, module2) => {
  var parse2 = require_parse2();
  var valid = (version3, options2) => {
    const v = parse2(version3, options2);
    return v ? v.version : null;
  };
  module2.exports = valid;
});

// ../../node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports2, module2) => {
  var parse2 = require_parse2();
  var clean = (version3, options2) => {
    const s = parse2(version3.trim().replace(/^[=v]+/, ""), options2);
    return s ? s.version : null;
  };
  module2.exports = clean;
});

// ../../node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var inc = (version3, release, options2, identifier, identifierBase) => {
    if (typeof options2 === "string") {
      identifierBase = identifier;
      identifier = options2;
      options2 = undefined;
    }
    try {
      return new SemVer(version3 instanceof SemVer ? version3.version : version3, options2).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module2.exports = inc;
});

// ../../node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports2, module2) => {
  var parse2 = require_parse2();
  var diff = (version1, version22) => {
    const v12 = parse2(version1, null, true);
    const v2 = parse2(version22, null, true);
    const comparison = v12.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v12 : v2;
    const lowVersion = v1Higher ? v2 : v12;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (highVersion.patch) {
        return "patch";
      }
      if (highVersion.minor) {
        return "minor";
      }
      return "major";
    }
    const prefix = highHasPre ? "pre" : "";
    if (v12.major !== v2.major) {
      return prefix + "major";
    }
    if (v12.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v12.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module2.exports = diff;
});

// ../../node_modules/semver/functions/major.js
var require_major = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var major = (a, loose) => new SemVer(a, loose).major;
  module2.exports = major;
});

// ../../node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var minor = (a, loose) => new SemVer(a, loose).minor;
  module2.exports = minor;
});

// ../../node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var patch = (a, loose) => new SemVer(a, loose).patch;
  module2.exports = patch;
});

// ../../node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports2, module2) => {
  var parse2 = require_parse2();
  var prerelease = (version3, options2) => {
    const parsed = parse2(version3, options2);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module2.exports = prerelease;
});

// ../../node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module2.exports = compare;
});

// ../../node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var rcompare = (a, b, loose) => compare(b, a, loose);
  module2.exports = rcompare;
});

// ../../node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var compareLoose = (a, b) => compare(a, b, true);
  module2.exports = compareLoose;
});

// ../../node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module2.exports = compareBuild;
});

// ../../node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports2, module2) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  module2.exports = sort;
});

// ../../node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports2, module2) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  module2.exports = rsort;
});

// ../../node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var gt = (a, b, loose) => compare(a, b, loose) > 0;
  module2.exports = gt;
});

// ../../node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var lt = (a, b, loose) => compare(a, b, loose) < 0;
  module2.exports = lt;
});

// ../../node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var eq = (a, b, loose) => compare(a, b, loose) === 0;
  module2.exports = eq;
});

// ../../node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module2.exports = neq;
});

// ../../node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var gte = (a, b, loose) => compare(a, b, loose) >= 0;
  module2.exports = gte;
});

// ../../node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var lte = (a, b, loose) => compare(a, b, loose) <= 0;
  module2.exports = lte;
});

// ../../node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports2, module2) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module2.exports = cmp;
});

// ../../node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var parse2 = require_parse2();
  var { safeRe: re, t } = require_re();
  var coerce = (version3, options2) => {
    if (version3 instanceof SemVer) {
      return version3;
    }
    if (typeof version3 === "number") {
      version3 = String(version3);
    }
    if (typeof version3 !== "string") {
      return null;
    }
    options2 = options2 || {};
    let match = null;
    if (!options2.rtl) {
      match = version3.match(options2.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    } else {
      const coerceRtlRegex = options2.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options2.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options2.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options2);
  };
  module2.exports = coerce;
});

// ../../node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS((exports2, module2) => {
  class LRUCache {
    constructor() {
      this.max = 1000;
      this.map = new Map;
    }
    get(key) {
      const value = this.map.get(key);
      if (value === undefined) {
        return;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== undefined) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  module2.exports = LRUCache;
});

// ../../node_modules/semver/classes/range.js
var require_range = __commonJS((exports2, module2) => {
  class Range {
    constructor(range, options2) {
      options2 = parseOptions(options2);
      if (range instanceof Range) {
        if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options2);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options2) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options2) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options2);
            });
          });
        });
      });
    }
    test(version3) {
      if (!version3) {
        return false;
      }
      if (typeof version3 === "string") {
        try {
          version3 = new SemVer(version3, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version3, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module2.exports = Range;
  var LRU = require_lrucache();
  var cache = new LRU;
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver();
  var {
    safeRe: re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants3();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options2) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options2);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options2) => {
    debug("comp", comp, options2);
    comp = replaceCarets(comp, options2);
    debug("caret", comp);
    comp = replaceTildes(comp, options2);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options2);
    debug("xrange", comp);
    comp = replaceStars(comp, options2);
    debug("stars", comp);
    return comp;
  };
  var isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  var replaceTildes = (comp, options2) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options2)).join(" ");
  };
  var replaceTilde = (comp, options2) => {
    const r = options2.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options2) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options2)).join(" ");
  };
  var replaceCaret = (comp, options2) => {
    debug("caret", comp, options2);
    const r = options2.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options2.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options2) => {
    debug("replaceXRanges", comp, options2);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options2)).join(" ");
  };
  var replaceXRange = (comp, options2) => {
    comp = comp.trim();
    const r = options2.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options2.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options2) => {
    debug("replaceStars", comp, options2);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options2) => {
    debug("replaceGTE0", comp, options2);
    return comp.trim().replace(re[options2.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from3, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from3 = "";
    } else if (isX(fm)) {
      from3 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from3 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from3 = `>=${from3}`;
    } else {
      from3 = `>=${from3}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from3} ${to}`.trim();
  };
  var testSet = (set, version3, options2) => {
    for (let i = 0;i < set.length; i++) {
      if (!set[i].test(version3)) {
        return false;
      }
    }
    if (version3.prerelease.length && !options2.includePrerelease) {
      for (let i = 0;i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// ../../node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports2, module2) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options2) {
      options2 = parseOptions(options2);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options2.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== undefined ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version3) {
      debug("Comparator.test", version3, this.options.loose);
      if (this.semver === ANY || version3 === ANY) {
        return true;
      }
      if (typeof version3 === "string") {
        try {
          version3 = new SemVer(version3, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version3, this.operator, this.semver, this.options);
    }
    intersects(comp, options2) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options2).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options2).test(comp.semver);
      }
      options2 = parseOptions(options2);
      if (options2.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options2.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options2) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options2) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module2.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re, t } = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver();
  var Range = require_range();
});

// ../../node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports2, module2) => {
  var Range = require_range();
  var satisfies = (version3, range, options2) => {
    try {
      range = new Range(range, options2);
    } catch (er) {
      return false;
    }
    return range.test(version3);
  };
  module2.exports = satisfies;
});

// ../../node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports2, module2) => {
  var Range = require_range();
  var toComparators = (range, options2) => new Range(range, options2).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module2.exports = toComparators;
});

// ../../node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range, options2) => {
    let max4 = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options2);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max4 || maxSV.compare(v) === -1) {
          max4 = v;
          maxSV = new SemVer(max4, options2);
        }
      }
    });
    return max4;
  };
  module2.exports = maxSatisfying;
});

// ../../node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range, options2) => {
    let min4 = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options2);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min4 || minSV.compare(v) === 1) {
          min4 = v;
          minSV = new SemVer(min4, options2);
        }
      }
    });
    return min4;
  };
  module2.exports = minSatisfying;
});

// ../../node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module2.exports = minVersion;
});

// ../../node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports2, module2) => {
  var Range = require_range();
  var validRange = (range, options2) => {
    try {
      return new Range(range, options2).range || "*";
    } catch (er) {
      return null;
    }
  };
  module2.exports = validRange;
});

// ../../node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version3, range, hilo, options2) => {
    version3 = new SemVer(version3, options2);
    range = new Range(range, options2);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version3, range, options2)) {
      return false;
    }
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options2)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options2)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module2.exports = outside;
});

// ../../node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports2, module2) => {
  var outside = require_outside();
  var gtr = (version3, range, options2) => outside(version3, range, ">", options2);
  module2.exports = gtr;
});

// ../../node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports2, module2) => {
  var outside = require_outside();
  var ltr = (version3, range, options2) => outside(version3, range, "<", options2);
  module2.exports = ltr;
});

// ../../node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports2, module2) => {
  var Range = require_range();
  var intersects = (r1, r2, options2) => {
    r1 = new Range(r1, options2);
    r2 = new Range(r2, options2);
    return r1.intersects(r2, options2);
  };
  module2.exports = intersects;
});

// ../../node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports2, module2) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module2.exports = (versions, range, options2) => {
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options2));
    for (const version3 of v) {
      const included = satisfies(version3, range, options2);
      if (included) {
        prev = version3;
        if (!first) {
          first = version3;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set.push([first, null]);
    }
    const ranges = [];
    for (const [min4, max4] of set) {
      if (min4 === max4) {
        ranges.push(min4);
      } else if (!max4 && min4 === v[0]) {
        ranges.push("*");
      } else if (!max4) {
        ranges.push(`>=${min4}`);
      } else if (min4 === v[0]) {
        ranges.push(`<=${max4}`);
      } else {
        ranges.push(`${min4} - ${max4}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// ../../node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports2, module2) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options2 = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options2);
    dom = new Range(dom, options2);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options2);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options2) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options2.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options2.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options2);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options2);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options2);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options2)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options2)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options2)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options2.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options2.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options2);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options2)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options2);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options2)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a, b, options2) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options2);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  var lowerLT = (a, b, options2) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options2);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  module2.exports = subset;
});

// ../../node_modules/semver/index.js
var require_semver2 = __commonJS((exports2, module2) => {
  var internalRe = require_re();
  var constants = require_constants3();
  var SemVer = require_semver();
  var identifiers = require_identifiers();
  var parse2 = require_parse2();
  var valid = require_valid();
  var clean = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt = require_gt();
  var lt = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module2.exports = {
    parse: parse2,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// ../../node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS((exports2, module2) => {
  (function(t, e) {
    typeof exports2 == "object" && typeof module2 != "undefined" ? module2.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs = e();
  })(exports2, function() {
    var t = 1000, e = 60000, n = 3600000, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
      var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
      return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
    } }, m = function(t2, e2, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
    }, v = { s: m, z: function(t2) {
      var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t(e2, n2) {
      if (e2.date() < n2.date())
        return -t(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return t2 === undefined;
    } }, g = "en", D = {};
    D[g] = M;
    var p = "$isDayjsObject", S = function(t2) {
      return t2 instanceof _ || !(!t2 || !t2[p]);
    }, w = function t(e2, n2, r2) {
      var i2;
      if (!e2)
        return g;
      if (typeof e2 == "string") {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u2 = e2.split("-");
        if (!i2 && u2.length > 1)
          return t(u2[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, O = function(t2, e2) {
      if (S(t2))
        return t2.clone();
      var n2 = typeof e2 == "object" ? e2 : {};
      return n2.date = t2, n2.args = arguments, new _(n2);
    }, b = v;
    b.l = w, b.i = S, b.w = function(t2, e2) {
      return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _ = function() {
      function M2(t2) {
        this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
      }
      var m2 = M2.prototype;
      return m2.parse = function(t2) {
        this.$d = function(t3) {
          var { date: e2, utc: n2 } = t3;
          if (e2 === null)
            return new Date(NaN);
          if (b.u(e2))
            return new Date;
          if (e2 instanceof Date)
            return new Date(e2);
          if (typeof e2 == "string" && !/Z$/i.test(e2)) {
            var r2 = e2.match($2);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t2), this.init();
      }, m2.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m2.$utils = function() {
        return b;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t2, e2) {
        var n2 = O(t2);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t2, e2) {
        return O(t2) < this.startOf(e2);
      }, m2.isBefore = function(t2, e2) {
        return this.endOf(e2) < O(t2);
      }, m2.$g = function(t2, e2, n2) {
        return b.u(t2) ? this[e2] : this.set(n2, t2);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1000);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t2, e2) {
        var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
          var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $3 = function(t3, e3) {
          return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (f2) {
          case h:
            return r2 ? l2(1, 0) : l2(31, 11);
          case c:
            return r2 ? l2(1, M3) : l2(0, M3 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
            return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
          case a:
          case d:
            return $3(v2 + "Hours", 0);
          case u:
            return $3(v2 + "Minutes", 1);
          case s:
            return $3(v2 + "Seconds", 2);
          case i:
            return $3(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m2.$set = function(t2, e2) {
        var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $3 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === c || o2 === h) {
          var y2 = this.clone().set(d, 1);
          y2.$d[l2]($3), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          l2 && this.$d[l2]($3);
        return this.init(), this;
      }, m2.set = function(t2, e2) {
        return this.clone().$set(t2, e2);
      }, m2.get = function(t2) {
        return this[b.p(t2)]();
      }, m2.add = function(r2, f2) {
        var d2, l2 = this;
        r2 = Number(r2);
        var $3 = b.p(f2), y2 = function(t2) {
          var e2 = O(l2);
          return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
        };
        if ($3 === c)
          return this.set(c, this.$M + r2);
        if ($3 === h)
          return this.set(h, this.$y + r2);
        if ($3 === a)
          return y2(1);
        if ($3 === o)
          return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$3] || 1, m3 = this.$d.getTime() + r2 * M3;
        return b.w(m3, this);
      }, m2.subtract = function(t2, e2) {
        return this.add(-1 * t2, e2);
      }, m2.format = function(t2) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || l;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
          return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
        }, d2 = function(t3) {
          return b.s(s2 % 12 || 12, t3, "0");
        }, $3 = f2 || function(t3, e3, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        };
        return r2.replace(y, function(t3, r3) {
          return r3 || function(t4) {
            switch (t4) {
              case "YY":
                return String(e2.$y).slice(-2);
              case "YYYY":
                return b.s(e2.$y, 4, "0");
              case "M":
                return a2 + 1;
              case "MM":
                return b.s(a2 + 1, 2, "0");
              case "MMM":
                return h2(n2.monthsShort, a2, c2, 3);
              case "MMMM":
                return h2(c2, a2);
              case "D":
                return e2.$D;
              case "DD":
                return b.s(e2.$D, 2, "0");
              case "d":
                return String(e2.$W);
              case "dd":
                return h2(n2.weekdaysMin, e2.$W, o2, 2);
              case "ddd":
                return h2(n2.weekdaysShort, e2.$W, o2, 3);
              case "dddd":
                return o2[e2.$W];
              case "H":
                return String(s2);
              case "HH":
                return b.s(s2, 2, "0");
              case "h":
                return d2(1);
              case "hh":
                return d2(2);
              case "a":
                return $3(s2, u2, true);
              case "A":
                return $3(s2, u2, false);
              case "m":
                return String(u2);
              case "mm":
                return b.s(u2, 2, "0");
              case "s":
                return String(e2.$s);
              case "ss":
                return b.s(e2.$s, 2, "0");
              case "SSS":
                return b.s(e2.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t3) || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, l2) {
        var $3, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
          return b.m(y2, m3);
        };
        switch (M3) {
          case h:
            $3 = D2() / 12;
            break;
          case c:
            $3 = D2();
            break;
          case f:
            $3 = D2() / 3;
            break;
          case o:
            $3 = (g2 - v2) / 604800000;
            break;
          case a:
            $3 = (g2 - v2) / 86400000;
            break;
          case u:
            $3 = g2 / n;
            break;
          case s:
            $3 = g2 / e;
            break;
          case i:
            $3 = g2 / t;
            break;
          default:
            $3 = g2;
        }
        return l2 ? $3 : b.a($3);
      }, m2.daysInMonth = function() {
        return this.endOf(c).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t2, e2) {
        if (!t2)
          return this.$L;
        var n2 = this.clone(), r2 = w(t2, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return b.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), k = _.prototype;
    return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
      k[t2[1]] = function(e2) {
        return this.$g(e2, t2[0], t2[1]);
      };
    }), O.extend = function(t2, e2) {
      return t2.$i || (t2(e2, _, O), t2.$i = true), O;
    }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
      return O(1000 * t2);
    }, O.en = D[g], O.Ls = D, O.p = {}, O;
  });
});

// ../../node_modules/pm2/lib/tools/isbinaryfile.js
var require_isbinaryfile = __commonJS((exports2, module2) => {
  var isBinaryCheck = function(bytes, size2) {
    if (size2 === 0)
      return false;
    var suspicious_bytes = 0;
    var total_bytes = Math.min(size2, max_bytes);
    if (size2 >= 3 && bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191) {
      return false;
    }
    for (var i = 0;i < total_bytes; i++) {
      if (bytes[i] === 0) {
        return true;
      } else if ((bytes[i] < 7 || bytes[i] > 14) && (bytes[i] < 32 || bytes[i] > 127)) {
        if (bytes[i] > 193 && bytes[i] < 224 && i + 1 < total_bytes) {
          i++;
          if (bytes[i] > 127 && bytes[i] < 192) {
            continue;
          }
        } else if (bytes[i] > 223 && bytes[i] < 240 && i + 2 < total_bytes) {
          i++;
          if (bytes[i] > 127 && bytes[i] < 192 && bytes[i + 1] > 127 && bytes[i + 1] < 192) {
            i++;
            continue;
          }
        }
        suspicious_bytes++;
        if (i > 32 && suspicious_bytes * 100 / total_bytes > 10) {
          return true;
        }
      }
    }
    if (suspicious_bytes * 100 / total_bytes > 10) {
      return true;
    }
    return false;
  };
  var fs = __require("fs");
  var max_bytes = 512;
  module2.exports = function(bytes, size2) {
    if (size2 === undefined) {
      var file = bytes;
      try {
        if (!fs.statSync(file).isFile())
          return false;
      } catch (err) {
      }
      var descriptor = fs.openSync(file, "r");
      try {
        bytes = Buffer.alloc(max_bytes);
        size2 = fs.readSync(descriptor, bytes, 0, bytes.length, 0);
      } finally {
        fs.closeSync(descriptor);
      }
    } else if (typeof size2 === "function") {
      var file = bytes, callback = size2;
      fs.stat(file, function(err, stat) {
        if (err || !stat.isFile())
          return callback(null, false);
        fs.open(file, "r", function(err2, descriptor2) {
          if (err2)
            return callback(err2);
          var bytes2 = Buffer.alloc(max_bytes);
          fs.read(descriptor2, bytes2, 0, bytes2.length, 0, function(err3, size3, bytes3) {
            fs.close(descriptor2, function(err22) {
              if (err3 || err22)
                return callback(err3 || err22);
              return callback(null, isBinaryCheck(bytes3, size3));
            });
          });
        });
      });
    }
    return isBinaryCheck(bytes, size2);
  };
});

// ../../node_modules/pm2/lib/API/interpreter.json
var require_interpreter = __commonJS((exports2, module2) => {
  module2.exports = {
    ".sh": "bash",
    ".py": "python",
    ".rb": "ruby",
    ".php": "php",
    ".pl": "perl",
    ".js": "node",
    ".coffee": "coffee",
    ".ls": "lsc",
    ".ts": "bun",
    ".tsx": "bun"
  };
});

// ../../node_modules/pm2/lib/API/schema.json
var require_schema = __commonJS((exports2, module2) => {
  module2.exports = {
    script: {
      type: "string",
      require: true,
      alias: "exec",
      docDescription: "Path of the script to launch, required field"
    },
    name: {
      type: "string",
      docDefault: "Script filename without the extension (app for app.js)",
      docDescription: "Process name in the process list"
    },
    name_prefix: {
      type: "string"
    },
    filter_env: {
      type: [
        "boolean",
        "array",
        "string"
      ],
      docDefault: false,
      docDescription: "Enable filtering global environments"
    },
    namespace: {
      type: "string",
      docDefault: "default",
      docDescription: "Process namespace"
    },
    install_url: {
      type: "string"
    },
    cwd: {
      type: "string",
      docDefault: "CWD of the current environment (from your shell)",
      docDescription: "Current working directory to start the process with"
    },
    args: {
      type: [
        "array",
        "string"
      ],
      docDescription: "Arguments to pass to the script"
    },
    exec_interpreter: {
      type: "string",
      alias: "interpreter",
      docDefault: "node",
      docDescription: "Interpreter absolute path"
    },
    node_args: {
      type: [
        "array",
        "string"
      ],
      alias: ["interpreterArgs", "interpreter_args"],
      docDescription: "Arguments to pass to the interpreter"
    },
    out_file: {
      type: "string",
      alias: ["out", "output", "out_log"],
      docDefault: "~/.pm2/logs/<app_name>-out.log",
      docDescription: "File path for stdout (each line is appended to this file)"
    },
    error_file: {
      type: "string",
      alias: ["error", "err", "err_file", "err_log"],
      docDefault: "~/.pm2/logs/<app_name>-error.err",
      docDescription: "File path for stderr (each line is appended to this file)"
    },
    log_file: {
      type: [
        "boolean",
        "string"
      ],
      alias: "log",
      docDefault: "/dev/null",
      docDescription: "File path for combined stdout and stderr (each line is appended to this file)"
    },
    disable_logs: {
      type: "boolean",
      docDefault: false,
      docDescription: "Disable all logs storage"
    },
    log_type: {
      type: "string",
      docDescription: "Define a specific log output type, possible value: json"
    },
    log_date_format: {
      type: "string",
      docDescription: "Format for log timestamps in day.js format (eg YYYY-MM-DD HH:mm Z)"
    },
    time: {
      type: "boolean"
    },
    env: {
      type: [
        "object",
        "string"
      ],
      docDescription: "Specify environment variables to be injected"
    },
    "^env_\\S*$": {
      type: [
        "object",
        "string"
      ],
      docDescription: "Specify environment variables to be injected when using --env <env_name>"
    },
    max_memory_restart: {
      type: [
        "string",
        "number"
      ],
      regex: "^\\d+(G|M|K)?$",
      ext_type: "sbyte",
      desc: "it should be a NUMBER - byte, \"[NUMBER]G\"(Gigabyte), \"[NUMBER]M\"(Megabyte) or \"[NUMBER]K\"(Kilobyte)",
      docDescription: "Restart the app if an amount of memory is exceeded (format: /[0-9](K&#124;M&#124;G)?/ K for KB, 'M' for MB, 'G' for GB, default to B)"
    },
    pid_file: {
      type: "string",
      alias: "pid",
      docDefault: "~/.pm2/pids/app_name-id.pid",
      docDescription: "File path where the pid of the started process is written by pm2"
    },
    restart_delay: {
      type: "number",
      docDefault: 0,
      docDescription: "Time in ms to wait before restarting a crashing app"
    },
    exp_backoff_restart_delay: {
      type: "number",
      docDefault: 0,
      docDescription: "Restart Time in ms to wait before restarting a crashing app"
    },
    source_map_support: {
      type: "boolean",
      docDefault: true,
      docDescription: "Enable or disable the source map support"
    },
    disable_source_map_support: {
      type: "boolean",
      docDefault: false,
      docDescription: "Enable or disable the source map support"
    },
    wait_ready: {
      type: "boolean",
      docDefault: false,
      docDescription: "Make the process wait for a process.send('ready')"
    },
    instances: {
      type: "number",
      docDefault: 1,
      docDescription: "Number of instances to be started in cluster mode"
    },
    kill_timeout: {
      type: "number",
      docDefault: 1600,
      docDescription: "Time in ms before sending the final SIGKILL signal after SIGINT"
    },
    shutdown_with_message: {
      type: "boolean",
      docDefault: false,
      docDescription: "Shutdown an application with process.send('shutdown') instead of process.kill(pid, SIGINT)"
    },
    listen_timeout: {
      type: "number",
      docDescription: "Time in ms before forcing a reload if app is still not listening/has still note sent ready"
    },
    cron_restart: {
      type: [
        "string",
        "number"
      ],
      alias: "cron",
      docDescription: "A cron pattern to restart your app"
    },
    merge_logs: {
      type: "boolean",
      alias: "combine_logs",
      docDefault: false,
      docDescription: "In cluster mode, merge each type of logs into a single file (instead of having one for each cluster)"
    },
    vizion: {
      type: "boolean",
      default: true,
      docDefault: "True",
      docDescription: "Enable or disable the versioning metadatas (vizion library)"
    },
    autostart: {
      type: "boolean",
      default: true,
      docDefault: "True",
      docDescription: "Enable or disable auto start when adding process"
    },
    autorestart: {
      type: "boolean",
      default: true,
      docDefault: "True",
      docDescription: "Enable or disable auto restart after process failure"
    },
    stop_exit_codes: {
      type: [
        "array",
        "number"
      ],
      docDescription: "List of exit codes that should allow the process to stop (skip autorestart)."
    },
    watch_delay: {
      type: "number",
      docDefault: "True",
      docDescription: "Restart delay on file change detected"
    },
    watch: {
      type: [
        "boolean",
        "array",
        "string"
      ],
      docDefault: false,
      docDescription: "Enable or disable the watch mode"
    },
    ignore_watch: {
      type: [
        "array",
        "string"
      ],
      docDescription: "List of paths to ignore (regex)"
    },
    watch_options: {
      type: "object",
      docDescription: "Object that will be used as an options with chokidar (refer to chokidar documentation)"
    },
    min_uptime: {
      type: [
        "number",
        "string"
      ],
      regex: "^\\d+(h|m|s)?$",
      desc: "it should be a NUMBER - milliseconds, \"[NUMBER]h\"(hours), \"[NUMBER]m\"(minutes) or \"[NUMBER]s\"(seconds)",
      min: 100,
      ext_type: "stime",
      docDefault: 1000,
      docDescription: "Minimum uptime of the app to be considered started (format is /[0-9]+(h&#124;m&#124;s)?/, for hours, minutes, seconds, docDefault to ms)"
    },
    max_restarts: {
      type: "number",
      min: 0,
      docDefault: 16,
      docDescription: "Number of times a script is restarted when it exits in less than min_uptime"
    },
    execute_command: {
      type: "boolean"
    },
    exec_mode: {
      type: "string",
      regex: "^(cluster|fork)(_mode)?$",
      desc: "it should be \"cluster\"(\"cluster_mode\") or \"fork\"(\"fork_mode\") only",
      docDefault: "fork",
      docDescription: "Set the execution mode, possible values: fork&#124;cluster"
    },
    force: {
      type: "boolean",
      docDefault: false,
      docDescription: "Start a script even if it is already running (only the script path is considered)"
    },
    append_env_to_name: {
      type: "boolean",
      docDefault: false,
      docDescription: "Append the environment name to the app name"
    },
    post_update: {
      type: "array",
      docDescription: "List of commands executed after a pull/upgrade operation performed from Keymetrics dashboard"
    },
    trace: {
      type: [
        "boolean"
      ],
      docDefault: false,
      docDescription: "Enable or disable the transaction tracing"
    },
    disable_trace: {
      type: [
        "boolean"
      ],
      docDefault: true,
      docDescription: "Enable or disable the transaction tracing"
    },
    v8: {
      type: [
        "boolean"
      ]
    },
    event_loop_inspector: {
      type: [
        "boolean"
      ]
    },
    deep_monitoring: {
      type: [
        "boolean"
      ]
    },
    increment_var: {
      type: "string",
      docDescription: "Specify the name of an environment variable to inject which increments for each cluster"
    },
    instance_var: {
      type: "string",
      default: "NODE_APP_INSTANCE",
      docDefault: "NODE_APP_INSTANCE",
      docDescription: "Rename the NODE_APP_INSTANCE environment variable"
    },
    pmx: {
      type: ["boolean", "string"],
      default: true,
      docDefault: "True",
      docDescription: "Enable or disable pmx wrapping"
    },
    automation: {
      type: "boolean",
      default: true,
      docDefault: "True",
      docDescription: "Enable or disable pmx wrapping"
    },
    treekill: {
      type: "boolean",
      default: true,
      docDefault: "True",
      docDescription: "Only kill the main process, not detached children"
    },
    port: {
      type: "number",
      docDescription: "Shortcut to inject a PORT environment variable"
    },
    username: {
      type: "string",
      docDescription: "Current user that started the process"
    },
    uid: {
      type: [
        "number",
        "string"
      ],
      alias: "user",
      docDefault: "Current user uid",
      docDescription: "Set user id"
    },
    gid: {
      type: [
        "number",
        "string"
      ],
      docDefault: "Current user gid",
      docDescription: "Set group id"
    },
    windowsHide: {
      type: "boolean",
      docDefault: "True",
      docDescription: "Enable or disable the Windows popup when starting an app",
      default: true
    },
    kill_retry_time: {
      type: "number",
      default: 100
    },
    write: {
      type: "boolean"
    },
    io: {
      type: "object",
      docDescription: "Specify apm values and configuration"
    }
  };
});

// ../../node_modules/pm2/lib/tools/Config.js
var require_Config = __commonJS((exports2, module2) => {
  var util = __require("util");
  var Config = module2.exports = {
    _errMsgs: {
      require: '"%s" is required',
      type: 'Expect "%s" to be a typeof %s, but now is %s',
      regex: 'Verify "%s" with regex failed, %s',
      max: 'The maximum of "%s" is %s, but now is %s',
      min: 'The minimum of "%s" is %s, but now is %s'
    },
    get schema() {
      if (this._schema) {
        return this._schema;
      }
      this._schema = require_schema();
      for (var k in this._schema) {
        if (k.indexOf("\\") > 0) {
          continue;
        }
        var aliases = [
          k.split("_").map(function(n, i) {
            if (i != 0 && n && n.length > 1) {
              return n[0].toUpperCase() + n.slice(1);
            }
            return n;
          }).join("")
        ];
        if (this._schema[k].alias && Array.isArray(this._schema[k].alias)) {
          this._schema[k].alias.forEach(function(alias) {
            aliases.splice(0, 0, alias);
          });
        } else if (this._schema[k].alias)
          aliases.splice(0, 0, this._schema[k].alias);
        this._schema[k].alias = aliases;
      }
      return this._schema;
    }
  };
  Config.filterOptions = function(cmd) {
    var conf2 = {};
    var schema = this.schema;
    for (var key in schema) {
      var aliases = schema[key].alias;
      aliases && aliases.forEach(function(alias) {
        if (typeof cmd[alias] !== "undefined") {
          conf2[key] || (conf2[key] = cmd[alias]);
        }
      });
    }
    return conf2;
  };
  Config.validateJSON = function(json) {
    var conf2 = Object.assign({}, json), res = {};
    this._errors = [];
    var regexKeys = {}, defines = this.schema;
    for (var sk in defines) {
      if (sk.indexOf("\\") >= 0) {
        regexKeys[sk] = false;
        continue;
      }
      var aliases = defines[sk].alias;
      aliases && aliases.forEach(function(alias) {
        conf2[sk] || (conf2[sk] = json[alias]);
      });
      var val = conf2[sk];
      delete conf2[sk];
      if (val === undefined || val === null || (val = this._valid(sk, val)) === null) {
        if (typeof defines[sk].default !== "undefined")
          res[sk] = defines[sk].default;
        continue;
      }
      res[sk] = val;
    }
    var hasRegexKey = false;
    for (var k in regexKeys) {
      hasRegexKey = true;
      regexKeys[k] = new RegExp(k);
    }
    if (hasRegexKey) {
      for (var k in conf2) {
        for (var rk in regexKeys) {
          if (regexKeys[rk].test(k)) {
            if (this._valid(k, conf2[k], defines[rk])) {
              res[k] = conf2[k];
              delete conf2[k];
            }
          }
        }
      }
    }
    return { errors: this._errors, config: res };
  };
  Config._valid = function(key, value, sch) {
    var sch = sch || this.schema[key], scht = typeof sch.type == "string" ? [sch.type] : sch.type;
    var undef = typeof value == "undefined";
    if (this._error(sch.require && undef, "require", key)) {
      return null;
    }
    if (undef) {
      return null;
    }
    scht = scht.map(function(t) {
      return "[object " + t[0].toUpperCase() + t.slice(1) + "]";
    });
    var type2 = Object.prototype.toString.call(value), nt = "[object Number]";
    if (type2 != "[object Boolean]" && scht.indexOf(nt) >= 0 && !isNaN(value)) {
      value = parseFloat(value);
      type2 = nt;
    }
    if (this._error(!~scht.indexOf(type2), "type", key, scht.join(" / "), type2)) {
      return null;
    }
    if (this._error(type2 == "[object String]" && sch.regex && !new RegExp(sch.regex).test(value), "regex", key, sch.desc || "should match " + sch.regex)) {
      return null;
    }
    if (type2 == "[object Number]") {
      if (this._error(typeof sch.max != "undefined" && value > sch.max, "max", key, sch.max, value)) {
        return null;
      }
      if (this._error(typeof sch.min != "undefined" && value < sch.min, "min", key, sch.min, value)) {
        return null;
      }
    }
    if (scht.length > 1 && type2 != scht[0] && type2 == "[object String]") {
      if (scht[0] == "[object Array]") {
        value = value.split(/([\w\-]+\="[^"]*")|([\w\-]+\='[^']*')|"([^"]*)"|'([^']*)'|\s/).filter(function(v) {
          return v && v.trim();
        });
      }
    }
    if (sch.ext_type && type2 == "[object String]" && value.length >= 2) {
      var seed = {
        sbyte: {
          G: 1024 * 1024 * 1024,
          M: 1024 * 1024,
          K: 1024
        },
        stime: {
          h: 60 * 60 * 1000,
          m: 60 * 1000,
          s: 1000
        }
      }[sch.ext_type];
      if (seed) {
        value = parseFloat(value.slice(0, -1)) * seed[value.slice(-1)];
      }
    }
    return value;
  };
  Config._error = function(possible, type2) {
    if (possible) {
      var args2 = Array.prototype.slice.call(arguments);
      args2.splice(0, 2, this._errMsgs[type2]);
      this._errors && this._errors.push(util.format.apply(null, args2));
    }
    return possible;
  };
});

// ../../node_modules/pm2/package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "pm2",
    preferGlobal: true,
    version: "5.4.1",
    engines: {
      node: ">=12.0.0"
    },
    directories: {
      bin: "./bin",
      lib: "./lib",
      example: "./examples"
    },
    author: {
      name: "Strzelewicz Alexandre",
      email: "alexandre@pm2.io",
      url: "https://pm2.io"
    },
    maintainers: [
      {
        name: "Alexandre Strzelewicz",
        email: "alexandre@pm2.io"
      },
      {
        name: "Antoine Bluchet",
        email: "antoine@pm2.io"
      }
    ],
    contributors: [
      {
        name: "Alex Kocharin",
        email: "alex@kocharin.ru"
      },
      {
        name: "Antoine Bluchet",
        email: "soyuka@gmail.com"
      },
      {
        name: "Subhash Burramsetty"
      },
      {
        name: "Valentin Marchaud",
        email: "thisismac47@gmail.com"
      },
      {
        name: "Valentin Touffet",
        email: "contact@eywek.fr"
      },
      {
        name: "Florian Hermouet-Joscht",
        email: "florian@keymetrics.io"
      },
      {
        name: "Vincent Vallet",
        email: "wallet77@gmail.com"
      },
      {
        name: "Joni Shkurti",
        email: "jonishkurti90@gmail.com"
      },
      {
        name: "Jun Tjatse",
        email: "thisnamemeansnothing@gmail.com"
      },
      {
        name: "Xu Jingxin",
        email: "sailxjx@gmail.com"
      },
      {
        name: "Ben Postlethwaite",
        email: "post.ben.here@gmail.com"
      },
      {
        name: "Devo.ps",
        email: "contact@devo.ps"
      },
      {
        name: "Bret Copeland",
        email: "bret@atlantisflight.org"
      },
      {
        name: "John Hurliman",
        email: "jhurliman@jhurliman.org"
      },
      {
        name: "TruongSinh Tran-Nguyen",
        email: "i@truongsinh.pro"
      },
      {
        name: "Michael Hueuberger",
        email: "michael.heuberger@binarykitchen.com"
      },
      {
        name: "Chris Wiggins",
        email: "chris@chriswiggins.co.nz"
      }
    ],
    homepage: "http://pm2.keymetrics.io/",
    description: "Production process manager for Node.JS applications with a built-in load balancer.",
    main: "index.js",
    types: "types/index.d.ts",
    scripts: {
      "test:unit": "bash test/unit.sh",
      "test:e2e": "bash test/e2e.sh",
      test: "bash test/unit.sh && bash test/e2e.sh"
    },
    keywords: [
      "cli",
      "fault tolerant",
      "sysadmin",
      "tools",
      "pm2",
      "logs",
      "log",
      "json",
      "express",
      "hapi",
      "kraken",
      "reload",
      "load balancer",
      "lb",
      "load-balancer",
      "kubernetes",
      "k8s",
      "pm2-docker",
      "runtime",
      "source maps",
      "graceful",
      "microservice",
      "programmatic",
      "harmony",
      "node-pm2",
      "production",
      "keymetrics",
      "node.js monitoring",
      "strong-pm",
      "deploy",
      "deployment",
      "daemon",
      "supervisor",
      "supervisord",
      "nodemon",
      "pm2.io",
      "ghost",
      "ghost production",
      "monitoring",
      "keymetrics",
      "process manager",
      "forever",
      "profiling",
      "probes",
      "apm",
      "container",
      "forever-monitor",
      "keep process alive",
      "process configuration",
      "clustering",
      "cluster cli",
      "cluster",
      "docker",
      "cron",
      "devops",
      "dev ops"
    ],
    bin: {
      pm2: "bin/pm2",
      "pm2-dev": "bin/pm2-dev",
      "pm2-docker": "bin/pm2-docker",
      "pm2-runtime": "bin/pm2-runtime"
    },
    dependencies: {
      "@pm2/agent": "~2.0.0",
      "@pm2/js-api": "~0.8.0",
      "@pm2/io": "~6.0.0",
      "@pm2/pm2-version-check": "latest",
      async: "~3.2.0",
      blessed: "0.1.81",
      chalk: "3.0.0",
      chokidar: "^3.5.3",
      "cli-tableau": "^2.0.0",
      commander: "2.15.1",
      croner: "~4.1.92",
      dayjs: "~1.11.5",
      debug: "^4.3.1",
      enquirer: "2.3.6",
      eventemitter2: "5.0.1",
      fclone: "1.0.11",
      mkdirp: "1.0.4",
      needle: "2.4.0",
      pidusage: "~3.0",
      "pm2-axon": "~4.0.1",
      "pm2-axon-rpc": "~0.7.1",
      "pm2-deploy": "~1.0.2",
      "pm2-multimeter": "^0.1.2",
      promptly: "^2",
      semver: "^7.2",
      "source-map-support": "0.5.21",
      "sprintf-js": "1.1.2",
      vizion: "~2.2.1",
      "js-yaml": "~4.1.0"
    },
    optionalDependencies: {
      "pm2-sysmonit": "^1.2.8"
    },
    devDependencies: {
      mocha: "^10.4.0",
      should: "^13.2.3"
    },
    bugs: {
      url: "https://github.com/Unitech/pm2/issues"
    },
    repository: {
      type: "git",
      url: "git://github.com/Unitech/pm2.git"
    },
    license: "AGPL-3.0"
  };
});

// ../../node_modules/pm2/lib/tools/which.js
var require_which = __commonJS((exports2, module2) => {
  var statFollowLinks = function() {
    return fs.statSync.apply(fs, arguments);
  };
  var isWindowsPlatform = function() {
    return cst.IS_WINDOWS;
  };
  var splitPath = function(p) {
    return p ? p.split(path2.delimiter) : [];
  };
  var isExecutable = function(pathName) {
    try {
      fs.accessSync(pathName, FILE_EXECUTABLE_MODE);
    } catch (err) {
      return false;
    }
    return true;
  };
  var checkPath = function(pathName) {
    return fs.existsSync(pathName) && !statFollowLinks(pathName).isDirectory() && (isWindowsPlatform() || isExecutable(pathName));
  };
  var _which = function(cmd) {
    if (!cmd)
      console.error("must specify command");
    var options2 = {};
    var isWindows = isWindowsPlatform();
    var pathArray = splitPath(process.env.PATH);
    var queryMatches = [];
    if (cmd.indexOf("/") === -1) {
      var pathExtArray = [""];
      if (isWindows) {
        var pathExtEnv = process.env.PATHEXT || XP_DEFAULT_PATHEXT;
        pathExtArray = splitPath(pathExtEnv.toUpperCase());
      }
      for (var k = 0;k < pathArray.length; k++) {
        if (queryMatches.length > 0 && !options2.all)
          break;
        var attempt = path2.resolve(pathArray[k], cmd);
        if (isWindows) {
          attempt = attempt.toUpperCase();
        }
        var match = attempt.match(/\.[^<>:"/|?*.]+$/);
        if (match && pathExtArray.indexOf(match[0]) >= 0) {
          if (checkPath(attempt)) {
            queryMatches.push(attempt);
            break;
          }
        } else {
          for (var i = 0;i < pathExtArray.length; i++) {
            var ext = pathExtArray[i];
            var newAttempt = attempt + ext;
            if (checkPath(newAttempt)) {
              queryMatches.push(newAttempt);
              break;
            }
          }
        }
      }
    } else if (checkPath(cmd)) {
      queryMatches.push(path2.resolve(cmd));
    }
    if (queryMatches.length > 0) {
      return options2.all ? queryMatches : queryMatches[0];
    }
    return options2.all ? [] : null;
  };
  var fs = __require("fs");
  var path2 = __require("path");
  var cst = require_constants2();
  var XP_DEFAULT_PATHEXT = ".com;.exe;.bat;.cmd;.vbs;.vbe;.js;.jse;.wsf;.wsh";
  var FILE_EXECUTABLE_MODE = 1;
  module2.exports = _which;
});

// ../../node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS((exports2, module2) => {
  var { promisify } = __require("util");
  var fs = __require("fs");
  var optsArg = (opts) => {
    if (!opts)
      opts = { mode: 511, fs };
    else if (typeof opts === "object")
      opts = { mode: 511, fs, ...opts };
    else if (typeof opts === "number")
      opts = { mode: opts, fs };
    else if (typeof opts === "string")
      opts = { mode: parseInt(opts, 8), fs };
    else
      throw new TypeError("invalid options argument");
    opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir;
    opts.mkdirAsync = promisify(opts.mkdir);
    opts.stat = opts.stat || opts.fs.stat || fs.stat;
    opts.statAsync = promisify(opts.stat);
    opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync;
    opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync;
    return opts;
  };
  module2.exports = optsArg;
});

// ../../node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS((exports2, module2) => {
  var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
  var { resolve, parse: parse2 } = __require("path");
  var pathArg = (path2) => {
    if (/\0/.test(path2)) {
      throw Object.assign(new TypeError("path must be a string without null bytes"), {
        path: path2,
        code: "ERR_INVALID_ARG_VALUE"
      });
    }
    path2 = resolve(path2);
    if (platform === "win32") {
      const badWinChars = /[*|"<>?:]/;
      const { root } = parse2(path2);
      if (badWinChars.test(path2.substr(root.length))) {
        throw Object.assign(new Error("Illegal characters in path."), {
          path: path2,
          code: "EINVAL"
        });
      }
    }
    return path2;
  };
  module2.exports = pathArg;
});

// ../../node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS((exports2, module2) => {
  var { dirname } = __require("path");
  var findMade = (opts, parent, path2 = undefined) => {
    if (path2 === parent)
      return Promise.resolve();
    return opts.statAsync(parent).then((st) => st.isDirectory() ? path2 : undefined, (er) => er.code === "ENOENT" ? findMade(opts, dirname(parent), parent) : undefined);
  };
  var findMadeSync = (opts, parent, path2 = undefined) => {
    if (path2 === parent)
      return;
    try {
      return opts.statSync(parent).isDirectory() ? path2 : undefined;
    } catch (er) {
      return er.code === "ENOENT" ? findMadeSync(opts, dirname(parent), parent) : undefined;
    }
  };
  module2.exports = { findMade, findMadeSync };
});

// ../../node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS((exports2, module2) => {
  var { dirname } = __require("path");
  var mkdirpManual = (path2, opts, made) => {
    opts.recursive = false;
    const parent = dirname(path2);
    if (parent === path2) {
      return opts.mkdirAsync(path2, opts).catch((er) => {
        if (er.code !== "EISDIR")
          throw er;
      });
    }
    return opts.mkdirAsync(path2, opts).then(() => made || path2, (er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path2, opts, made2));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      return opts.statAsync(path2).then((st) => {
        if (st.isDirectory())
          return made;
        else
          throw er;
      }, () => {
        throw er;
      });
    });
  };
  var mkdirpManualSync = (path2, opts, made) => {
    const parent = dirname(path2);
    opts.recursive = false;
    if (parent === path2) {
      try {
        return opts.mkdirSync(path2, opts);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        else
          return;
      }
    }
    try {
      opts.mkdirSync(path2, opts);
      return made || path2;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path2, opts, mkdirpManualSync(parent, opts, made));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      try {
        if (!opts.statSync(path2).isDirectory())
          throw er;
      } catch (_) {
        throw er;
      }
    }
  };
  module2.exports = { mkdirpManual, mkdirpManualSync };
});

// ../../node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS((exports2, module2) => {
  var { dirname } = __require("path");
  var { findMade, findMadeSync } = require_find_made();
  var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
  var mkdirpNative = (path2, opts) => {
    opts.recursive = true;
    const parent = dirname(path2);
    if (parent === path2)
      return opts.mkdirAsync(path2, opts);
    return findMade(opts, path2).then((made) => opts.mkdirAsync(path2, opts).then(() => made).catch((er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(path2, opts);
      else
        throw er;
    }));
  };
  var mkdirpNativeSync = (path2, opts) => {
    opts.recursive = true;
    const parent = dirname(path2);
    if (parent === path2)
      return opts.mkdirSync(path2, opts);
    const made = findMadeSync(opts, path2);
    try {
      opts.mkdirSync(path2, opts);
      return made;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path2, opts);
      else
        throw er;
    }
  };
  module2.exports = { mkdirpNative, mkdirpNativeSync };
});

// ../../node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS((exports2, module2) => {
  var fs = __require("fs");
  var version3 = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
  var versArr = version3.replace(/^v/, "").split(".");
  var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
  var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs.mkdir;
  var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs.mkdirSync;
  module2.exports = { useNative, useNativeSync };
});

// ../../node_modules/mkdirp/index.js
var require_mkdirp = __commonJS((exports2, module2) => {
  var optsArg = require_opts_arg();
  var pathArg = require_path_arg();
  var { mkdirpNative, mkdirpNativeSync } = require_mkdirp_native();
  var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
  var { useNative, useNativeSync } = require_use_native();
  var mkdirp = (path2, opts) => {
    path2 = pathArg(path2);
    opts = optsArg(opts);
    return useNative(opts) ? mkdirpNative(path2, opts) : mkdirpManual(path2, opts);
  };
  var mkdirpSync = (path2, opts) => {
    path2 = pathArg(path2);
    opts = optsArg(opts);
    return useNativeSync(opts) ? mkdirpNativeSync(path2, opts) : mkdirpManualSync(path2, opts);
  };
  mkdirp.sync = mkdirpSync;
  mkdirp.native = (path2, opts) => mkdirpNative(pathArg(path2), optsArg(opts));
  mkdirp.manual = (path2, opts) => mkdirpManual(pathArg(path2), optsArg(opts));
  mkdirp.nativeSync = (path2, opts) => mkdirpNativeSync(pathArg(path2), optsArg(opts));
  mkdirp.manualSync = (path2, opts) => mkdirpManualSync(pathArg(path2), optsArg(opts));
  module2.exports = mkdirp;
});

// ../../node_modules/js-yaml/lib/common.js
var require_common2 = __commonJS((exports2, module2) => {
  var isNothing = function(subject) {
    return typeof subject === "undefined" || subject === null;
  };
  var isObject = function(subject) {
    return typeof subject === "object" && subject !== null;
  };
  var toArray = function(sequence) {
    if (Array.isArray(sequence))
      return sequence;
    else if (isNothing(sequence))
      return [];
    return [sequence];
  };
  var extend = function(target, source) {
    var index, length3, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index = 0, length3 = sourceKeys.length;index < length3; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }
    return target;
  };
  var repeat = function(string, count) {
    var result = "", cycle;
    for (cycle = 0;cycle < count; cycle += 1) {
      result += string;
    }
    return result;
  };
  var isNegativeZero2 = function(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
  };
  exports2.isNothing = isNothing;
  exports2.isObject = isObject;
  exports2.toArray = toArray;
  exports2.repeat = repeat;
  exports2.isNegativeZero = isNegativeZero2;
  exports2.extend = extend;
});

// ../../node_modules/js-yaml/lib/exception.js
var require_exception = __commonJS((exports2, module2) => {
  var formatError = function(exception, compact) {
    var where = "", message = exception.reason || "(unknown reason)";
    if (!exception.mark)
      return message;
    if (exception.mark.name) {
      where += 'in "' + exception.mark.name + '" ';
    }
    where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
    if (!compact && exception.mark.snippet) {
      where += "\n\n" + exception.mark.snippet;
    }
    return message + " " + where;
  };
  var YAMLException = function(reason, mark) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  };
  YAMLException.prototype = Object.create(Error.prototype);
  YAMLException.prototype.constructor = YAMLException;
  YAMLException.prototype.toString = function toString(compact) {
    return this.name + ": " + formatError(this, compact);
  };
  module2.exports = YAMLException;
});

// ../../node_modules/js-yaml/lib/snippet.js
var require_snippet = __commonJS((exports2, module2) => {
  var getLine = function(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = "";
    var tail = "";
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    if (position - lineStart > maxHalfLength) {
      head = " ... ";
      lineStart = position - maxHalfLength + head.length;
    }
    if (lineEnd - position > maxHalfLength) {
      tail = " ...";
      lineEnd = position + maxHalfLength - tail.length;
    }
    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
      pos: position - lineStart + head.length
    };
  };
  var padStart = function(string, max4) {
    return common2.repeat(" ", max4 - string.length) + string;
  };
  var makeSnippet = function(mark, options2) {
    options2 = Object.create(options2 || null);
    if (!mark.buffer)
      return null;
    if (!options2.maxLength)
      options2.maxLength = 79;
    if (typeof options2.indent !== "number")
      options2.indent = 1;
    if (typeof options2.linesBefore !== "number")
      options2.linesBefore = 3;
    if (typeof options2.linesAfter !== "number")
      options2.linesAfter = 2;
    var re = /\r?\n|\r|\0/g;
    var lineStarts = [0];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;
    while (match = re.exec(mark.buffer)) {
      lineEnds.push(match.index);
      lineStarts.push(match.index + match[0].length);
      if (mark.position <= match.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }
    if (foundLineNo < 0)
      foundLineNo = lineStarts.length - 1;
    var result = "", i, line;
    var lineNoLength = Math.min(mark.line + options2.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
    for (i = 1;i <= options2.linesBefore; i++) {
      if (foundLineNo - i < 0)
        break;
      line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);
      result = common2.repeat(" ", options2.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
    }
    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common2.repeat(" ", options2.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    result += common2.repeat("-", options2.indent + lineNoLength + 3 + line.pos) + "^" + "\n";
    for (i = 1;i <= options2.linesAfter; i++) {
      if (foundLineNo + i >= lineEnds.length)
        break;
      line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);
      result += common2.repeat(" ", options2.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    }
    return result.replace(/\n$/, "");
  };
  var common2 = require_common2();
  module2.exports = makeSnippet;
});

// ../../node_modules/js-yaml/lib/type.js
var require_type = __commonJS((exports2, module2) => {
  var compileStyleAliases = function(map) {
    var result = {};
    if (map !== null) {
      Object.keys(map).forEach(function(style) {
        map[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  };
  var Type = function(tag, options2) {
    options2 = options2 || {};
    Object.keys(options2).forEach(function(name2) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
        throw new YAMLException('Unknown option "' + name2 + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.options = options2;
    this.tag = tag;
    this.kind = options2["kind"] || null;
    this.resolve = options2["resolve"] || function() {
      return true;
    };
    this.construct = options2["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options2["instanceOf"] || null;
    this.predicate = options2["predicate"] || null;
    this.represent = options2["represent"] || null;
    this.representName = options2["representName"] || null;
    this.defaultStyle = options2["defaultStyle"] || null;
    this.multi = options2["multi"] || false;
    this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  };
  var YAMLException = require_exception();
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  module2.exports = Type;
});

// ../../node_modules/js-yaml/lib/schema.js
var require_schema2 = __commonJS((exports2, module2) => {
  var compileList = function(schema, name2) {
    var result = [];
    schema[name2].forEach(function(currentType) {
      var newIndex = result.length;
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
          newIndex = previousIndex;
        }
      });
      result[newIndex] = currentType;
    });
    return result;
  };
  var compileMap = function() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, index, length3;
    function collectType(type2) {
      if (type2.multi) {
        result.multi[type2.kind].push(type2);
        result.multi["fallback"].push(type2);
      } else {
        result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
      }
    }
    for (index = 0, length3 = arguments.length;index < length3; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  };
  var Schema = function(definition) {
    return this.extend(definition);
  };
  var YAMLException = require_exception();
  var Type = require_type();
  Schema.prototype.extend = function extend(definition) {
    var implicit = [];
    var explicit = [];
    if (definition instanceof Type) {
      explicit.push(definition);
    } else if (Array.isArray(definition)) {
      explicit = explicit.concat(definition);
    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      if (definition.implicit)
        implicit = implicit.concat(definition.implicit);
      if (definition.explicit)
        explicit = explicit.concat(definition.explicit);
    } else {
      throw new YAMLException("Schema.extend argument should be a Type, [ Type ], " + "or a schema definition ({ implicit: [...], explicit: [...] })");
    }
    implicit.forEach(function(type2) {
      if (!(type2 instanceof Type)) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      if (type2.loadKind && type2.loadKind !== "scalar") {
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
      if (type2.multi) {
        throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
      }
    });
    explicit.forEach(function(type2) {
      if (!(type2 instanceof Type)) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
    });
    var result = Object.create(Schema.prototype);
    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);
    result.compiledImplicit = compileList(result, "implicit");
    result.compiledExplicit = compileList(result, "explicit");
    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
    return result;
  };
  module2.exports = Schema;
});

// ../../node_modules/js-yaml/lib/type/str.js
var require_str = __commonJS((exports2, module2) => {
  var Type = require_type();
  module2.exports = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
});

// ../../node_modules/js-yaml/lib/type/seq.js
var require_seq = __commonJS((exports2, module2) => {
  var Type = require_type();
  module2.exports = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
});

// ../../node_modules/js-yaml/lib/type/map.js
var require_map = __commonJS((exports2, module2) => {
  var Type = require_type();
  module2.exports = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
});

// ../../node_modules/js-yaml/lib/schema/failsafe.js
var require_failsafe = __commonJS((exports2, module2) => {
  var Schema = require_schema2();
  module2.exports = new Schema({
    explicit: [
      require_str(),
      require_seq(),
      require_map()
    ]
  });
});

// ../../node_modules/js-yaml/lib/type/null.js
var require_null = __commonJS((exports2, module2) => {
  var resolveYamlNull = function(data) {
    if (data === null)
      return true;
    var max4 = data.length;
    return max4 === 1 && data === "~" || max4 === 4 && (data === "null" || data === "Null" || data === "NULL");
  };
  var constructYamlNull = function() {
    return null;
  };
  var isNull = function(object) {
    return object === null;
  };
  var Type = require_type();
  module2.exports = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
});

// ../../node_modules/js-yaml/lib/type/bool.js
var require_bool = __commonJS((exports2, module2) => {
  var resolveYamlBoolean = function(data) {
    if (data === null)
      return false;
    var max4 = data.length;
    return max4 === 4 && (data === "true" || data === "True" || data === "TRUE") || max4 === 5 && (data === "false" || data === "False" || data === "FALSE");
  };
  var constructYamlBoolean = function(data) {
    return data === "true" || data === "True" || data === "TRUE";
  };
  var isBoolean = function(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  };
  var Type = require_type();
  module2.exports = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
});

// ../../node_modules/js-yaml/lib/type/int.js
var require_int = __commonJS((exports2, module2) => {
  var isHexCode = function(c) {
    return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
  };
  var isOctCode = function(c) {
    return 48 <= c && c <= 55;
  };
  var isDecCode = function(c) {
    return 48 <= c && c <= 57;
  };
  var resolveYamlInteger = function(data) {
    if (data === null)
      return false;
    var max4 = data.length, index = 0, hasDigits = false, ch;
    if (!max4)
      return false;
    ch = data[index];
    if (ch === "-" || ch === "+") {
      ch = data[++index];
    }
    if (ch === "0") {
      if (index + 1 === max4)
        return true;
      ch = data[++index];
      if (ch === "b") {
        index++;
        for (;index < max4; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (ch !== "0" && ch !== "1")
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        index++;
        for (;index < max4; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (!isHexCode(data.charCodeAt(index)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "o") {
        index++;
        for (;index < max4; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (!isOctCode(data.charCodeAt(index)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
    }
    if (ch === "_")
      return false;
    for (;index < max4; index++) {
      ch = data[index];
      if (ch === "_")
        continue;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch === "_")
      return false;
    return true;
  };
  var constructYamlInteger = function(data) {
    var value = data, sign = 1, ch;
    if (value.indexOf("_") !== -1) {
      value = value.replace(/_/g, "");
    }
    ch = value[0];
    if (ch === "-" || ch === "+") {
      if (ch === "-")
        sign = -1;
      value = value.slice(1);
      ch = value[0];
    }
    if (value === "0")
      return 0;
    if (ch === "0") {
      if (value[1] === "b")
        return sign * parseInt(value.slice(2), 2);
      if (value[1] === "x")
        return sign * parseInt(value.slice(2), 16);
      if (value[1] === "o")
        return sign * parseInt(value.slice(2), 8);
    }
    return sign * parseInt(value, 10);
  };
  var isInteger2 = function(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common2.isNegativeZero(object));
  };
  var common2 = require_common2();
  var Type = require_type();
  module2.exports = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger2,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
});

// ../../node_modules/js-yaml/lib/type/float.js
var require_float = __commonJS((exports2, module2) => {
  var resolveYamlFloat = function(data) {
    if (data === null)
      return false;
    if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
      return false;
    }
    return true;
  };
  var constructYamlFloat = function(data) {
    var value, sign;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    if ("+-".indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
      return NaN;
    }
    return sign * parseFloat(value, 10);
  };
  var representYamlFloat = function(object, style) {
    var res;
    if (isNaN(object)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common2.isNegativeZero(object)) {
      return "-0.0";
    }
    res = object.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  };
  var isFloat = function(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common2.isNegativeZero(object));
  };
  var common2 = require_common2();
  var Type = require_type();
  var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?" + "|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?" + "|[-+]?\\.(?:inf|Inf|INF)" + "|\\.(?:nan|NaN|NAN))$");
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  module2.exports = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
});

// ../../node_modules/js-yaml/lib/schema/json.js
var require_json = __commonJS((exports2, module2) => {
  module2.exports = require_failsafe().extend({
    implicit: [
      require_null(),
      require_bool(),
      require_int(),
      require_float()
    ]
  });
});

// ../../node_modules/js-yaml/lib/type/timestamp.js
var require_timestamp = __commonJS((exports2, module2) => {
  var resolveYamlTimestamp = function(data) {
    if (data === null)
      return false;
    if (YAML_DATE_REGEXP.exec(data) !== null)
      return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
      return true;
    return false;
  };
  var constructYamlTimestamp = function(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null)
      match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null)
      throw new Error("Date resolve error");
    year = +match[1];
    month = +match[2] - 1;
    day = +match[3];
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 60000;
      if (match[9] === "-")
        delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta)
      date.setTime(date.getTime() - delta);
    return date;
  };
  var representYamlTimestamp = function(object) {
    return object.toISOString();
  };
  var Type = require_type();
  var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])" + "-([0-9][0-9])" + "-([0-9][0-9])$");
  var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])" + "-([0-9][0-9]?)" + "-([0-9][0-9]?)" + "(?:[Tt]|[ \\t]+)" + "([0-9][0-9]?)" + ":([0-9][0-9])" + ":([0-9][0-9])" + "(?:\\.([0-9]*))?" + "(?:[ \\t]*(Z|([-+])([0-9][0-9]?)" + "(?::([0-9][0-9]))?))?$");
  module2.exports = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
});

// ../../node_modules/js-yaml/lib/type/merge.js
var require_merge = __commonJS((exports2, module2) => {
  var resolveYamlMerge = function(data) {
    return data === "<<" || data === null;
  };
  var Type = require_type();
  module2.exports = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
});

// ../../node_modules/js-yaml/lib/type/binary.js
var require_binary = __commonJS((exports2, module2) => {
  var resolveYamlBinary = function(data) {
    if (data === null)
      return false;
    var code, idx, bitlen = 0, max4 = data.length, map = BASE64_MAP;
    for (idx = 0;idx < max4; idx++) {
      code = map.indexOf(data.charAt(idx));
      if (code > 64)
        continue;
      if (code < 0)
        return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  };
  var constructYamlBinary = function(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max4 = input.length, map = BASE64_MAP, bits = 0, result = [];
    for (idx = 0;idx < max4; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map.indexOf(input.charAt(idx));
    }
    tailbits = max4 % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    return new Uint8Array(result);
  };
  var representYamlBinary = function(object) {
    var result = "", bits = 0, idx, tail, max4 = object.length, map = BASE64_MAP;
    for (idx = 0;idx < max4; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      }
      bits = (bits << 8) + object[idx];
    }
    tail = max4 % 3;
    if (tail === 0) {
      result += map[bits >> 18 & 63];
      result += map[bits >> 12 & 63];
      result += map[bits >> 6 & 63];
      result += map[bits & 63];
    } else if (tail === 2) {
      result += map[bits >> 10 & 63];
      result += map[bits >> 4 & 63];
      result += map[bits << 2 & 63];
      result += map[64];
    } else if (tail === 1) {
      result += map[bits >> 2 & 63];
      result += map[bits << 4 & 63];
      result += map[64];
      result += map[64];
    }
    return result;
  };
  var isBinary = function(obj) {
    return Object.prototype.toString.call(obj) === "[object Uint8Array]";
  };
  var Type = require_type();
  var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
  module2.exports = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
});

// ../../node_modules/js-yaml/lib/type/omap.js
var require_omap = __commonJS((exports2, module2) => {
  var resolveYamlOmap = function(data) {
    if (data === null)
      return true;
    var objectKeys = [], index, length3, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length3 = object.length;index < length3; index += 1) {
      pair = object[index];
      pairHasKey = false;
      if (_toString.call(pair) !== "[object Object]")
        return false;
      for (pairKey in pair) {
        if (_hasOwnProperty.call(pair, pairKey)) {
          if (!pairHasKey)
            pairHasKey = true;
          else
            return false;
        }
      }
      if (!pairHasKey)
        return false;
      if (objectKeys.indexOf(pairKey) === -1)
        objectKeys.push(pairKey);
      else
        return false;
    }
    return true;
  };
  var constructYamlOmap = function(data) {
    return data !== null ? data : [];
  };
  var Type = require_type();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var _toString = Object.prototype.toString;
  module2.exports = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
});

// ../../node_modules/js-yaml/lib/type/pairs.js
var require_pairs = __commonJS((exports2, module2) => {
  var resolveYamlPairs = function(data) {
    if (data === null)
      return true;
    var index, length3, pair, keys3, result, object = data;
    result = new Array(object.length);
    for (index = 0, length3 = object.length;index < length3; index += 1) {
      pair = object[index];
      if (_toString.call(pair) !== "[object Object]")
        return false;
      keys3 = Object.keys(pair);
      if (keys3.length !== 1)
        return false;
      result[index] = [keys3[0], pair[keys3[0]]];
    }
    return true;
  };
  var constructYamlPairs = function(data) {
    if (data === null)
      return [];
    var index, length3, pair, keys3, result, object = data;
    result = new Array(object.length);
    for (index = 0, length3 = object.length;index < length3; index += 1) {
      pair = object[index];
      keys3 = Object.keys(pair);
      result[index] = [keys3[0], pair[keys3[0]]];
    }
    return result;
  };
  var Type = require_type();
  var _toString = Object.prototype.toString;
  module2.exports = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
});

// ../../node_modules/js-yaml/lib/type/set.js
var require_set = __commonJS((exports2, module2) => {
  var resolveYamlSet = function(data) {
    if (data === null)
      return true;
    var key, object = data;
    for (key in object) {
      if (_hasOwnProperty.call(object, key)) {
        if (object[key] !== null)
          return false;
      }
    }
    return true;
  };
  var constructYamlSet = function(data) {
    return data !== null ? data : {};
  };
  var Type = require_type();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  module2.exports = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
});

// ../../node_modules/js-yaml/lib/schema/default.js
var require_default = __commonJS((exports2, module2) => {
  module2.exports = require_json().extend({
    implicit: [
      require_timestamp(),
      require_merge()
    ],
    explicit: [
      require_binary(),
      require_omap(),
      require_pairs(),
      require_set()
    ]
  });
});

// ../../node_modules/js-yaml/lib/loader.js
var require_loader = __commonJS((exports2, module2) => {
  var _class = function(obj) {
    return Object.prototype.toString.call(obj);
  };
  var is_EOL = function(c) {
    return c === 10 || c === 13;
  };
  var is_WHITE_SPACE = function(c) {
    return c === 9 || c === 32;
  };
  var is_WS_OR_EOL = function(c) {
    return c === 9 || c === 32 || c === 10 || c === 13;
  };
  var is_FLOW_INDICATOR = function(c) {
    return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
  };
  var fromHexCode = function(c) {
    var lc;
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    lc = c | 32;
    if (97 <= lc && lc <= 102) {
      return lc - 97 + 10;
    }
    return -1;
  };
  var escapedHexLen = function(c) {
    if (c === 120) {
      return 2;
    }
    if (c === 117) {
      return 4;
    }
    if (c === 85) {
      return 8;
    }
    return 0;
  };
  var fromDecimalCode = function(c) {
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    return -1;
  };
  var simpleEscapeSequence = function(c) {
    return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "\t" : c === 9 ? "\t" : c === 110 ? `
` : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? `\r` : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
  };
  var charFromCodepoint = function(c) {
    if (c <= 65535) {
      return String.fromCharCode(c);
    }
    return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
  };
  var State = function(input, options2) {
    this.input = input;
    this.filename = options2["filename"] || null;
    this.schema = options2["schema"] || DEFAULT_SCHEMA;
    this.onWarning = options2["onWarning"] || null;
    this.legacy = options2["legacy"] || false;
    this.json = options2["json"] || false;
    this.listener = options2["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.firstTabInLine = -1;
    this.documents = [];
  };
  var generateError = function(state, message) {
    var mark = {
      name: state.filename,
      buffer: state.input.slice(0, -1),
      position: state.position,
      line: state.line,
      column: state.position - state.lineStart
    };
    mark.snippet = makeSnippet(mark);
    return new YAMLException(message, mark);
  };
  var throwError = function(state, message) {
    throw generateError(state, message);
  };
  var throwWarning = function(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  };
  var captureSegment = function(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      _result = state.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length;_position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError(state, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, "the stream contains non-printable characters");
      }
      state.result += _result;
    }
  };
  var mergeMappings = function(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common2.isObject(source)) {
      throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index = 0, quantity = sourceKeys.length;index < quantity; index += 1) {
      key = sourceKeys[index];
      if (!_hasOwnProperty.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  };
  var storeMappingPair = function(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index = 0, quantity = keyNode.length;index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
          keyNode[index] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length;index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.lineStart = startLineStart || state.lineStart;
        state.position = startPos || state.position;
        throwError(state, "duplicated mapping key");
      }
      if (keyNode === "__proto__") {
        Object.defineProperty(_result, keyNode, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: valueNode
        });
      } else {
        _result[keyNode] = valueNode;
      }
      delete overridableKeys[keyNode];
    }
    return _result;
  };
  var readLineBreak = function(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 10) {
      state.position++;
    } else if (ch === 13) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 10) {
        state.position++;
      }
    } else {
      throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
  };
  var skipSeparationSpace = function(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        if (ch === 9 && state.firstTabInLine === -1) {
          state.firstTabInLine = state.position;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 10 && ch !== 13 && ch !== 0);
      }
      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
  };
  var testDocumentSeparator = function(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);
      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }
    return false;
  };
  var writeFoldedLines = function(state, count) {
    if (count === 1) {
      state.result += " ";
    } else if (count > 1) {
      state.result += common2.repeat("\n", count - 1);
    }
  };
  var readPlainScalar = function(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
      return false;
    }
    if (ch === 63 || ch === 45) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch !== 0) {
      if (ch === 58) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 35) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  };
  var readSingleQuotedScalar = function(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 39) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 39) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (ch === 39) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a single quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
  };
  var readDoubleQuotedScalar = function(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 34) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 34) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 92) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (;hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, "expected hexadecimal character");
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, "unknown escape sequence");
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a double quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
  };
  var readFlowCollection = function(state, nodeIndent) {
    var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = Object.create(null), keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? "mapping" : "sequence";
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, "missed comma between flow collection entries");
      } else if (ch === 44) {
        throwError(state, "expected the node content, but found ','");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch === 63) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      _lineStart = state.lineStart;
      _pos = state.position;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch === 58) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === 44) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
  };
  var readBlockScalar = function(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 124) {
      folding = false;
    } else if (ch === 62) {
      folding = true;
    } else {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
      if (ch === 43 || ch === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
    }
    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += "\n";
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common2.repeat("\n", emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += " ";
          }
        } else {
          state.result += common2.repeat("\n", emptyLines);
        }
      } else {
        state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch) && ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  };
  var readBlockSequence = function(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.firstTabInLine !== -1)
      return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      if (ch !== 45) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a sequence entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "sequence";
      state.result = _result;
      return true;
    }
    return false;
  };
  var readBlockMapping = function(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.firstTabInLine !== -1)
      return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (!atExplicitKey && state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
        if (ch === 63) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state.position += 1;
        ch = following;
      } else {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          break;
        }
        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 58) {
            ch = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch)) {
              throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError(state, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
        }
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a mapping entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "mapping";
      state.result = _result;
    }
    return detected;
  };
  var readTagProperty = function(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 33)
      return false;
    if (state.tag !== null) {
      throwError(state, "duplication of a tag property");
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 60) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 62);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 33) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, "tag suffix cannot contain exclamation marks");
          }
        }
        ch = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError(state, "tag name is malformed: " + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  };
  var readAnchorProperty = function(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 38)
      return false;
    if (state.anchor !== null) {
      throwError(state, "duplication of an anchor property");
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  };
  var readAlias = function(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 42)
      return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  };
  var composeNode = function(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent2 = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
    if (state.listener !== null) {
      state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent2 = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent2 = true;
          } else if (readAlias(state)) {
            hasContent2 = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError(state, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent2 = true;
            if (state.tag === null) {
              state.tag = "?";
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent2 = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag === null) {
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    } else if (state.tag === "?") {
      if (state.result !== null && state.kind !== "scalar") {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length;typeIndex < typeQuantity; typeIndex += 1) {
        type2 = state.implicitTypes[typeIndex];
        if (type2.resolve(state.result)) {
          state.result = type2.construct(state.result);
          state.tag = type2.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (state.tag !== "!") {
      if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
        type2 = state.typeMap[state.kind || "fallback"][state.tag];
      } else {
        type2 = null;
        typeList = state.typeMap.multi[state.kind || "fallback"];
        for (typeIndex = 0, typeQuantity = typeList.length;typeIndex < typeQuantity; typeIndex += 1) {
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type2 = typeList[typeIndex];
            break;
          }
        }
      }
      if (!type2) {
        throwError(state, "unknown tag !<" + state.tag + ">");
      }
      if (state.result !== null && type2.kind !== state.kind) {
        throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
      }
      if (!type2.resolve(state.result, state.tag)) {
        throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
      } else {
        state.result = type2.construct(state.result, state.tag);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    }
    if (state.listener !== null) {
      state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent2;
  };
  var readDocument = function(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = Object.create(null);
    state.anchorMap = Object.create(null);
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch !== 37) {
        break;
      }
      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state, "directive name must not be less than one character in length");
      }
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch))
          break;
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch !== 0)
        readLineBreak(state);
      if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 46) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < state.length - 1) {
      throwError(state, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  };
  var loadDocuments = function(input, options2) {
    input = String(input);
    options2 = options2 || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += "\n";
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state = new State(input, options2);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, "null byte is not allowed in input");
    }
    state.input += "\0";
    while (state.input.charCodeAt(state.position) === 32) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < state.length - 1) {
      readDocument(state);
    }
    return state.documents;
  };
  var loadAll = function(input, iterator, options2) {
    if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
      options2 = iterator;
      iterator = null;
    }
    var documents = loadDocuments(input, options2);
    if (typeof iterator !== "function") {
      return documents;
    }
    for (var index = 0, length3 = documents.length;index < length3; index += 1) {
      iterator(documents[index]);
    }
  };
  var load = function(input, options2) {
    var documents = loadDocuments(input, options2);
    if (documents.length === 0) {
      return;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new YAMLException("expected a single document in the stream, but found more");
  };
  var common2 = require_common2();
  var YAMLException = require_exception();
  var makeSnippet = require_snippet();
  var DEFAULT_SCHEMA = require_default();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (i = 0;i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }
  var i;
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name2, args2) {
      var match, major, minor;
      if (state.version !== null) {
        throwError(state, "duplication of %YAML directive");
      }
      if (args2.length !== 1) {
        throwError(state, "YAML directive accepts exactly one argument");
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args2[0]);
      if (match === null) {
        throwError(state, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError(state, "unacceptable YAML version of the document");
      }
      state.version = args2[0];
      state.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state, name2, args2) {
      var handle, prefix;
      if (args2.length !== 2) {
        throwError(state, "TAG directive accepts exactly two arguments");
      }
      handle = args2[0];
      prefix = args2[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      try {
        prefix = decodeURIComponent(prefix);
      } catch (err) {
        throwError(state, "tag prefix is malformed: " + prefix);
      }
      state.tagMap[handle] = prefix;
    }
  };
  exports2.loadAll = loadAll;
  exports2.load = load;
});

// ../../node_modules/js-yaml/lib/dumper.js
var require_dumper = __commonJS((exports2, module2) => {
  var compileStyleMap = function(schema, map) {
    var result, keys3, index, length3, tag, style, type2;
    if (map === null)
      return {};
    result = {};
    keys3 = Object.keys(map);
    for (index = 0, length3 = keys3.length;index < length3; index += 1) {
      tag = keys3[index];
      style = String(map[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type2 = schema.compiledTypeMap["fallback"][tag];
      if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
        style = type2.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  };
  var encodeHex = function(character) {
    var string, handle, length3;
    string = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length3 = 2;
    } else if (character <= 65535) {
      handle = "u";
      length3 = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length3 = 8;
    } else {
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common2.repeat("0", length3 - string.length) + string;
  };
  var State = function(options2) {
    this.schema = options2["schema"] || DEFAULT_SCHEMA;
    this.indent = Math.max(1, options2["indent"] || 2);
    this.noArrayIndent = options2["noArrayIndent"] || false;
    this.skipInvalid = options2["skipInvalid"] || false;
    this.flowLevel = common2.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
    this.sortKeys = options2["sortKeys"] || false;
    this.lineWidth = options2["lineWidth"] || 80;
    this.noRefs = options2["noRefs"] || false;
    this.noCompatMode = options2["noCompatMode"] || false;
    this.condenseFlow = options2["condenseFlow"] || false;
    this.quotingType = options2["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes = options2["forceQuotes"] || false;
    this.replacer = typeof options2["replacer"] === "function" ? options2["replacer"] : null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  };
  var indentString = function(string, spaces) {
    var ind = common2.repeat(" ", spaces), position = 0, next = -1, result = "", line, length3 = string.length;
    while (position < length3) {
      next = string.indexOf("\n", position);
      if (next === -1) {
        line = string.slice(position);
        position = length3;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== "\n")
        result += ind;
      result += line;
    }
    return result;
  };
  var generateNextLine = function(state, level) {
    return "\n" + common2.repeat(" ", state.indent * level);
  };
  var testImplicitResolving = function(state, str) {
    var index, length3, type2;
    for (index = 0, length3 = state.implicitTypes.length;index < length3; index += 1) {
      type2 = state.implicitTypes[index];
      if (type2.resolve(str)) {
        return true;
      }
    }
    return false;
  };
  var isWhitespace = function(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  };
  var isPrintable = function(c) {
    return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
  };
  var isNsCharOrWhitespace = function(c) {
    return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
  };
  var isPlainSafe = function(c, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
    return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
  };
  var isPlainSafeFirst = function(c) {
    return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
  };
  var isPlainSafeLast = function(c) {
    return !isWhitespace(c) && c !== CHAR_COLON;
  };
  var codePointAt = function(string, pos) {
    var first = string.charCodeAt(pos), second;
    if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
      second = string.charCodeAt(pos + 1);
      if (second >= 56320 && second <= 57343) {
        return (first - 55296) * 1024 + second - 56320 + 65536;
      }
    }
    return first;
  };
  var needIndentIndicator = function(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  };
  var chooseScalarStyle = function(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
    if (singleLineOnly || forceQuotes) {
      for (i = 0;i < string.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      for (i = 0;i < string.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      if (plain && !forceQuotes && !testAmbiguousType(string)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  };
  var writeScalar = function(state, string, level, iskey, inblock) {
    state.dump = function() {
      if (string.length === 0) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }
      if (!state.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
        }
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string, lineWidth) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  };
  var blockHeader = function(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
  };
  var dropEndingNewline = function(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
  };
  var foldString = function(string, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = function() {
      var nextLF = string.indexOf("\n");
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }();
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    var match;
    while (match = lineRe.exec(string)) {
      var prefix = match[1], line = match[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  };
  var foldLine = function(line, width) {
    if (line === "" || line[0] === " ")
      return line;
    var breakRe = / [^ ]/g;
    var match;
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    while (match = breakRe.exec(line)) {
      next = match.index;
      if (next - start > width) {
        end = curr > start ? curr : next;
        result += "\n" + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += "\n";
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  };
  var escapeString = function(string) {
    var result = "";
    var char = 0;
    var escapeSeq;
    for (var i = 0;i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      escapeSeq = ESCAPE_SEQUENCES[char];
      if (!escapeSeq && isPrintable(char)) {
        result += string[i];
        if (char >= 65536)
          result += string[i + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }
    return result;
  };
  var writeFlowSequence = function(state, level, object) {
    var _result = "", _tag = state.tag, index, length3, value;
    for (index = 0, length3 = object.length;index < length3; index += 1) {
      value = object[index];
      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }
      if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
        if (_result !== "")
          _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
  };
  var writeBlockSequence = function(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length3, value;
    for (index = 0, length3 = object.length;index < length3; index += 1) {
      value = object[index];
      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }
      if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
        if (!compact || _result !== "") {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || "[]";
  };
  var writeFlowMapping = function(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length3, objectKey, objectValue, pairBuffer;
    for (index = 0, length3 = objectKeyList.length;index < length3; index += 1) {
      pairBuffer = "";
      if (_result !== "")
        pairBuffer += ", ";
      if (state.condenseFlow)
        pairBuffer += '"';
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024)
        pairBuffer += "? ";
      pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
  };
  var writeBlockMapping = function(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length3, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new YAMLException("sortKeys must be a boolean or a function");
    }
    for (index = 0, length3 = objectKeyList.length;index < length3; index += 1) {
      pairBuffer = "";
      if (!compact || _result !== "") {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}";
  };
  var detectType = function(state, object, explicit) {
    var _result, typeList, index, length3, type2, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index = 0, length3 = typeList.length;index < length3; index += 1) {
      type2 = typeList[index];
      if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        if (explicit) {
          if (type2.multi && type2.representName) {
            state.tag = type2.representName(object);
          } else {
            state.tag = type2.tag;
          }
        } else {
          state.tag = "?";
        }
        if (type2.represent) {
          style = state.styleMap[type2.tag] || type2.defaultStyle;
          if (_toString.call(type2.represent) === "[object Function]") {
            _result = type2.represent(object, style);
          } else if (_hasOwnProperty.call(type2.represent, style)) {
            _result = type2.represent[style](object, style);
          } else {
            throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  };
  var writeNode = function(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }
    var type2 = _toString.call(state.dump);
    var inblock = block;
    var tagStr;
    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type2 === "[object Object]") {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object Array]") {
        if (block && state.dump.length !== 0) {
          if (state.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state, level - 1, state.dump, compact);
          } else {
            writeBlockSequence(state, level, state.dump, compact);
          }
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object String]") {
        if (state.tag !== "?") {
          writeScalar(state, state.dump, level, iskey, inblock);
        }
      } else if (type2 === "[object Undefined]") {
        return false;
      } else {
        if (state.skipInvalid)
          return false;
        throw new YAMLException("unacceptable kind of an object to dump " + type2);
      }
      if (state.tag !== null && state.tag !== "?") {
        tagStr = encodeURI(state.tag[0] === "!" ? state.tag.slice(1) : state.tag).replace(/!/g, "%21");
        if (state.tag[0] === "!") {
          tagStr = "!" + tagStr;
        } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
          tagStr = "!!" + tagStr.slice(18);
        } else {
          tagStr = "!<" + tagStr + ">";
        }
        state.dump = tagStr + " " + state.dump;
      }
    }
    return true;
  };
  var getDuplicateReferences = function(object, state) {
    var objects = [], duplicatesIndexes = [], index, length3;
    inspectNode(object, objects, duplicatesIndexes);
    for (index = 0, length3 = duplicatesIndexes.length;index < length3; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length3);
  };
  var inspectNode = function(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length3;
    if (object !== null && typeof object === "object") {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);
        if (Array.isArray(object)) {
          for (index = 0, length3 = object.length;index < length3; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);
          for (index = 0, length3 = objectKeyList.length;index < length3; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  };
  var dump = function(input, options2) {
    options2 = options2 || {};
    var state = new State(options2);
    if (!state.noRefs)
      getDuplicateReferences(input, state);
    var value = input;
    if (state.replacer) {
      value = state.replacer.call({ "": value }, "", value);
    }
    if (writeNode(state, 0, value, true, true))
      return state.dump + "\n";
    return "";
  };
  var common2 = require_common2();
  var YAMLException = require_exception();
  var DEFAULT_SCHEMA = require_default();
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_BOM = 65279;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = '\\"';
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  var QUOTING_TYPE_SINGLE = 1;
  var QUOTING_TYPE_DOUBLE = 2;
  var STYLE_PLAIN = 1;
  var STYLE_SINGLE = 2;
  var STYLE_LITERAL = 3;
  var STYLE_FOLDED = 4;
  var STYLE_DOUBLE = 5;
  exports2.dump = dump;
});

// ../../node_modules/js-yaml/index.js
var require_js_yaml = __commonJS((exports2, module2) => {
  var renamed = function(from3, to) {
    return function() {
      throw new Error("Function yaml." + from3 + " is removed in js-yaml 4. " + "Use yaml." + to + " instead, which is now safe by default.");
    };
  };
  var loader = require_loader();
  var dumper = require_dumper();
  exports2.Type = require_type();
  exports2.Schema = require_schema2();
  exports2.FAILSAFE_SCHEMA = require_failsafe();
  exports2.JSON_SCHEMA = require_json();
  exports2.CORE_SCHEMA = require_json();
  exports2.DEFAULT_SCHEMA = require_default();
  exports2.load = loader.load;
  exports2.loadAll = loader.loadAll;
  exports2.dump = dumper.dump;
  exports2.YAMLException = require_exception();
  exports2.types = {
    binary: require_binary(),
    float: require_float(),
    map: require_map(),
    null: require_null(),
    pairs: require_pairs(),
    set: require_set(),
    timestamp: require_timestamp(),
    bool: require_bool(),
    int: require_int(),
    merge: require_merge(),
    omap: require_omap(),
    seq: require_seq(),
    str: require_str()
  };
  exports2.safeLoad = renamed("safeLoad", "load");
  exports2.safeLoadAll = renamed("safeLoadAll", "loadAll");
  exports2.safeDump = renamed("safeDump", "dump");
});

// ../../node_modules/croner/dist/croner.cjs
var require_croner = __commonJS((exports2, module2) => {
  (function(global2, factory) {
    typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Cron = factory());
  })(exports2, function() {
    function convertTZ(date, tzString) {
      return new Date(date.toLocaleString("en-US", { timeZone: tzString }));
    }
    function CronDate(date, timezone) {
      this.timezone = timezone;
      if (date && date instanceof Date) {
        this.fromDate(date);
      } else if (date === undefined) {
        this.fromDate(new Date);
      } else if (date && typeof date === "string") {
        this.fromString(date);
      } else if (date instanceof CronDate) {
        this.fromCronDate(date);
      } else {
        throw new TypeError("CronDate: Invalid type (" + typeof date + ") passed as parameter to CronDate constructor");
      }
    }
    CronDate.prototype.fromDate = function(date) {
      if (this.timezone) {
        date = convertTZ(date, this.timezone);
      }
      this.milliseconds = date.getMilliseconds();
      this.seconds = date.getSeconds();
      this.minutes = date.getMinutes();
      this.hours = date.getHours();
      this.days = date.getDate();
      this.months = date.getMonth();
      this.years = date.getFullYear();
    };
    CronDate.prototype.fromCronDate = function(date) {
      this.timezone = date.timezone;
      this.milliseconds = date.milliseconds;
      this.seconds = date.seconds;
      this.minutes = date.minutes;
      this.hours = date.hours;
      this.days = date.days;
      this.months = date.months;
      this.years = date.years;
    };
    CronDate.prototype.apply = function() {
      const newDate = new Date(this.years, this.months, this.days, this.hours, this.minutes, this.seconds, this.milliseconds);
      this.milliseconds = newDate.getMilliseconds();
      this.seconds = newDate.getSeconds();
      this.minutes = newDate.getMinutes();
      this.hours = newDate.getHours();
      this.days = newDate.getDate();
      this.months = newDate.getMonth();
      this.years = newDate.getFullYear();
    };
    CronDate.prototype.fromString = function(str) {
      const parsedDate = this.parseISOLocal(str);
      if (isNaN(parsedDate)) {
        throw new TypeError("CronDate: Provided string value for CronDate could not be parsed as date.");
      }
      this.fromDate(parsedDate);
    };
    CronDate.prototype.increment = function(pattern, rerun) {
      if (!rerun) {
        this.seconds += 1;
      }
      this.milliseconds = 0;
      const origTime = this.getTime(), findNext = (target, pattern2, offset, override) => {
        const startPos = override === undefined ? this[target] + offset : 0 + offset;
        for (let i = startPos;i < pattern2[target].length; i++) {
          if (pattern2[target][i]) {
            if (target === "days" && pattern2.lastDayOfMonth) {
              let baseDate = this.getDate(true);
              baseDate.setDate(i - offset + 1);
              if (baseDate.getMonth() !== this["months"]) {
                this[target] = i - offset;
                return true;
              }
            } else {
              this[target] = i - offset;
              return true;
            }
          }
        }
        return false;
      }, resetPrevious = (offset) => {
        while (doing + offset >= 0) {
          findNext(toDo[doing + offset][0], pattern, toDo[doing + offset][2], 0);
          doing--;
        }
      };
      const toDo = [
        ["seconds", "minutes", 0],
        ["minutes", "hours", 0],
        ["hours", "days", 0],
        ["days", "months", -1],
        ["months", "years", 0]
      ];
      let doing = 0;
      while (doing < 5) {
        let currentValue = this[toDo[doing][0]];
        if (!findNext(toDo[doing][0], pattern, toDo[doing][2])) {
          this[toDo[doing][1]]++;
          resetPrevious(0);
        } else if (currentValue !== this[toDo[doing][0]]) {
          resetPrevious(-1);
        }
        if (this.years >= 4000) {
          return null;
        }
        doing++;
      }
      while (!pattern.daysOfWeek[this.getDate(true).getDay()]) {
        this.days += 1;
        doing = 2;
        resetPrevious();
      }
      if (origTime != this.getTime()) {
        this.apply();
        return this.increment(pattern, true);
      } else {
        return this;
      }
    };
    CronDate.prototype.getDate = function(internal) {
      const targetDate = new Date(this.years, this.months, this.days, this.hours, this.minutes, this.seconds, this.milliseconds);
      if (internal || !this.timezone) {
        return targetDate;
      } else {
        const offset = convertTZ(targetDate, this.timezone).getTime() - targetDate.getTime();
        return new Date(targetDate.getTime() - offset);
      }
    };
    CronDate.prototype.getTime = function(internal) {
      return this.getDate(internal).getTime();
    };
    CronDate.prototype.parseISOLocal = function(dateTimeString) {
      const dateTimeStringSplit = dateTimeString.split(/\D/);
      if (dateTimeStringSplit.length < 6) {
        return NaN;
      }
      const year = parseInt(dateTimeStringSplit[0], 10), month = parseInt(dateTimeStringSplit[1], 10), day = parseInt(dateTimeStringSplit[2], 10), hour = parseInt(dateTimeStringSplit[3], 10), minute = parseInt(dateTimeStringSplit[4], 10), second = parseInt(dateTimeStringSplit[5], 10);
      if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hour) || isNaN(minute) || isNaN(second)) {
        return NaN;
      } else {
        let generatedDate;
        if (dateTimeString.indexOf("Z") > 0) {
          generatedDate = new Date(Date.UTC(year, month - 1, day, hour, minute, second));
          if (year == generatedDate.getUTCFullYear() && month == generatedDate.getUTCMonth() + 1 && day == generatedDate.getUTCDate() && hour == generatedDate.getUTCHours() && minute == generatedDate.getUTCMinutes() && second == generatedDate.getUTCSeconds()) {
            return generatedDate;
          } else {
            return NaN;
          }
        } else {
          generatedDate = new Date(year, month - 1, day, hour, minute, second);
          if (year == generatedDate.getFullYear() && month == generatedDate.getMonth() + 1 && day == generatedDate.getDate() && hour == generatedDate.getHours() && minute == generatedDate.getMinutes() && second == generatedDate.getSeconds()) {
            return generatedDate;
          } else {
            return NaN;
          }
        }
      }
    };
    function CronPattern(pattern, timezone) {
      this.pattern = pattern;
      this.timezone = timezone;
      this.seconds = Array(60).fill(0);
      this.minutes = Array(60).fill(0);
      this.hours = Array(24).fill(0);
      this.days = Array(31).fill(0);
      this.months = Array(12).fill(0);
      this.daysOfWeek = Array(8).fill(0);
      this.lastDayOfMonth = false;
      this.parse();
    }
    CronPattern.prototype.parse = function() {
      if (!(typeof this.pattern === "string" || this.pattern.constructor === String)) {
        throw new TypeError("CronPattern: Pattern has to be of type string.");
      }
      const parts = this.pattern.trim().replace(/\s+/g, " ").split(" ");
      if (parts.length < 5 || parts.length > 6) {
        throw new TypeError("CronPattern: invalid configuration format ('" + this.pattern + "'), exacly five or six space separated parts required.");
      }
      if (parts.length === 5) {
        parts.unshift("0");
      }
      if (parts[3].toUpperCase() == "L") {
        parts[3] = "28,29,30,31";
        this.lastDayOfMonth = true;
      }
      parts[4] = this.replaceAlphaMonths(parts[4]);
      parts[5] = this.replaceAlphaDays(parts[5]);
      let initDate = new CronDate(new Date, this.timezone).getDate(true);
      parts[0] = parts[0].replace("?", initDate.getSeconds());
      parts[1] = parts[1].replace("?", initDate.getMinutes());
      parts[2] = parts[2].replace("?", initDate.getHours());
      parts[3] = parts[3].replace("?", initDate.getDate());
      parts[4] = parts[4].replace("?", initDate.getMonth() + 1);
      parts[5] = parts[5].replace("?", initDate.getDay());
      this.throwAtIllegalCharacters(parts);
      this.partToArray("seconds", parts[0], 0);
      this.partToArray("minutes", parts[1], 0);
      this.partToArray("hours", parts[2], 0);
      this.partToArray("days", parts[3], -1);
      this.partToArray("months", parts[4], -1);
      this.partToArray("daysOfWeek", parts[5], 0);
      if (this.daysOfWeek[7]) {
        this.daysOfWeek[0] = 1;
      }
    };
    CronPattern.prototype.partToArray = function(type2, conf2, valueIndexOffset, recursed) {
      const arr = this[type2];
      if (conf2 === "*") {
        for (let i = 0;i < arr.length; i++) {
          arr[i] = 1;
        }
        return;
      }
      const split = conf2.split(",");
      if (split.length > 1) {
        for (let i = 0;i < split.length; i++) {
          this.partToArray(type2, split[i], valueIndexOffset, true);
        }
      } else if (conf2.indexOf("-") !== -1 && conf2.indexOf("/") !== -1) {
        if (recursed)
          throw new Error("CronPattern: Range with stepping cannot coexist with ,");
        this.handleRangeWithStepping(conf2, type2, valueIndexOffset);
      } else if (conf2.indexOf("-") !== -1) {
        if (recursed)
          throw new Error("CronPattern: Range with stepping cannot coexist with ,");
        this.handleRange(conf2, type2, valueIndexOffset);
      } else if (conf2.indexOf("/") !== -1) {
        if (recursed)
          throw new Error("CronPattern: Range with stepping cannot coexist with ,");
        this.handleStepping(conf2, type2, valueIndexOffset);
      } else {
        this.handleNumber(conf2, type2, valueIndexOffset);
      }
    };
    CronPattern.prototype.throwAtIllegalCharacters = function(parts) {
      const reValidCron = /[^/*0-9,-]+/;
      for (let i = 0;i < parts.length; i++) {
        if (reValidCron.test(parts[i])) {
          throw new TypeError("CronPattern: configuration entry " + i + " (" + parts[i] + ") contains illegal characters.");
        }
      }
    };
    CronPattern.prototype.handleNumber = function(conf2, type2, valueIndexOffset) {
      const i = parseInt(conf2, 10) + valueIndexOffset;
      if (i < 0 || i >= this[type2].length) {
        throw new TypeError("CronPattern: " + type2 + " value out of range: '" + conf2 + "'");
      }
      this[type2][i] = 1;
    };
    CronPattern.prototype.handleRangeWithStepping = function(conf2, type2, valueIndexOffset) {
      const matches = conf2.match(/^(\d+)-(\d+)\/(\d+)$/);
      if (matches === null)
        throw new TypeError("CronPattern: Syntax error, illegal range with stepping: '" + conf2 + "'");
      let [, lower, upper, steps] = matches;
      lower = parseInt(lower, 10) + valueIndexOffset;
      upper = parseInt(upper, 10) + valueIndexOffset;
      steps = parseInt(steps, 10);
      if (isNaN(lower))
        throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");
      if (isNaN(upper))
        throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");
      if (isNaN(steps))
        throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");
      if (steps === 0)
        throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");
      if (steps > this[type2].length)
        throw new TypeError("CronPattern: Syntax error, steps cannot be greater than maximum value of part (" + this[type2].length + ")");
      if (lower < 0 || upper >= this[type2].length)
        throw new TypeError("CronPattern: Value out of range: '" + conf2 + "'");
      if (lower > upper)
        throw new TypeError("CronPattern: From value is larger than to value: '" + conf2 + "'");
      for (let i = lower;i <= upper; i += steps) {
        this[type2][i] = 1;
      }
    };
    CronPattern.prototype.handleRange = function(conf2, type2, valueIndexOffset) {
      const split = conf2.split("-");
      if (split.length !== 2) {
        throw new TypeError("CronPattern: Syntax error, illegal range: '" + conf2 + "'");
      }
      const lower = parseInt(split[0], 10) + valueIndexOffset, upper = parseInt(split[1], 10) + valueIndexOffset;
      if (isNaN(lower)) {
        throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");
      } else if (isNaN(upper)) {
        throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");
      }
      if (lower < 0 || upper >= this[type2].length) {
        throw new TypeError("CronPattern: Value out of range: '" + conf2 + "'");
      }
      if (lower > upper) {
        throw new TypeError("CronPattern: From value is larger than to value: '" + conf2 + "'");
      }
      for (let i = lower;i <= upper; i++) {
        this[type2][i] = 1;
      }
    };
    CronPattern.prototype.handleStepping = function(conf2, type2) {
      const split = conf2.split("/");
      if (split.length !== 2) {
        throw new TypeError("CronPattern: Syntax error, illegal stepping: '" + conf2 + "'");
      }
      let start = 0;
      if (split[0] !== "*") {
        start = parseInt(split[0], 10);
      }
      const steps = parseInt(split[1], 10);
      if (isNaN(steps))
        throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");
      if (steps === 0)
        throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");
      if (steps > this[type2].length)
        throw new TypeError("CronPattern: Syntax error, steps cannot be greater than maximum value of part (" + this[type2].length + ")");
      for (let i = start;i < this[type2].length; i += steps) {
        this[type2][i] = 1;
      }
    };
    CronPattern.prototype.replaceAlphaDays = function(conf2) {
      return conf2.replace(/sun/gi, "0").replace(/mon/gi, "1").replace(/tue/gi, "2").replace(/wed/gi, "3").replace(/thu/gi, "4").replace(/fri/gi, "5").replace(/sat/gi, "6");
    };
    CronPattern.prototype.replaceAlphaMonths = function(conf2) {
      return conf2.replace(/jan/gi, "1").replace(/feb/gi, "2").replace(/mar/gi, "3").replace(/apr/gi, "4").replace(/may/gi, "5").replace(/jun/gi, "6").replace(/jul/gi, "7").replace(/aug/gi, "8").replace(/sep/gi, "9").replace(/oct/gi, "10").replace(/nov/gi, "11").replace(/dec/gi, "12");
    };
    const maxDelay = Math.pow(2, 32 - 1) - 1;
    function Cron(pattern, options2, func) {
      if (!(this instanceof Cron)) {
        return new Cron(pattern, options2, func);
      }
      if (typeof options2 === "function") {
        func = options2;
        options2 = undefined;
      }
      this.options = this.processOptions(options2);
      if (pattern && pattern instanceof Date) {
        this.once = new CronDate(pattern, this.options.timezone);
      } else if (pattern && typeof pattern === "string" && pattern.indexOf(":") > 0) {
        this.once = new CronDate(pattern, this.options.timezone);
      } else {
        this.pattern = new CronPattern(pattern, this.options.timezone);
      }
      if (func !== undefined) {
        this.fn = func;
        this.schedule();
      }
      return this;
    }
    Cron.prototype.processOptions = function(options2) {
      if (options2 === undefined) {
        options2 = {};
      }
      options2.paused = options2.paused === undefined ? false : options2.paused;
      options2.maxRuns = options2.maxRuns === undefined ? Infinity : options2.maxRuns;
      options2.catch = options2.catch === undefined ? false : options2.catch;
      options2.kill = false;
      if (options2.startAt) {
        options2.startAt = new CronDate(options2.startAt, options2.timezone);
      }
      if (options2.stopAt) {
        options2.stopAt = new CronDate(options2.stopAt, options2.timezone);
      }
      return options2;
    };
    Cron.prototype.next = function(prev) {
      prev = new CronDate(prev, this.options.timezone);
      const next = this._next(prev);
      return next ? next.getDate() : null;
    };
    Cron.prototype.enumerate = function(n, previous) {
      let enumeration = [];
      while (n-- && (previous = this.next(previous))) {
        enumeration.push(previous);
      }
      return enumeration;
    };
    Cron.prototype.running = function() {
      const msLeft = this.msToNext(this.previousrun);
      const running = !this.options.paused && this.fn !== undefined;
      return msLeft !== null && running;
    };
    Cron.prototype.previous = function() {
      return this.previousrun ? this.previousrun.getDate() : null;
    };
    Cron.prototype._next = function(prev) {
      if (this.options.startAt && prev && prev.getTime(true) < this.options.startAt.getTime(true)) {
        prev = this.options.startAt;
      }
      const nextRun = this.once || new CronDate(prev, this.options.timezone).increment(this.pattern);
      if (this.once && this.once.getTime(true) <= prev.getTime(true)) {
        return null;
      } else if (nextRun === null || this.options.maxRuns <= 0 || this.options.kill || this.options.stopAt && nextRun.getTime(true) >= this.options.stopAt.getTime(true)) {
        return null;
      } else {
        return nextRun;
      }
    };
    Cron.prototype.msToNext = function(prev) {
      prev = new CronDate(prev, this.options.timezone);
      const next = this._next(prev);
      if (next) {
        return next.getTime(true) - prev.getTime(true);
      } else {
        return null;
      }
    };
    Cron.prototype.stop = function() {
      this.options.kill = true;
      if (this.currentTimeout) {
        clearTimeout(this.currentTimeout);
      }
    };
    Cron.prototype.pause = function() {
      return (this.options.paused = true) && !this.options.kill;
    };
    Cron.prototype.resume = function() {
      return !(this.options.paused = false) && !this.options.kill;
    };
    Cron.prototype.schedule = function(func) {
      if (func && this.fn) {
        throw new Error("Cron: It is not allowed to schedule two functions using the same Croner instance.");
      } else if (func) {
        this.fn = func;
      }
      let waitMs = this.msToNext(this.previousrun);
      if (waitMs === null)
        return this;
      if (waitMs > maxDelay) {
        waitMs = maxDelay;
      }
      this.currentTimeout = setTimeout(() => {
        if (waitMs !== maxDelay && !this.options.paused) {
          this.options.maxRuns--;
          if (this.options.catch) {
            try {
              this.fn(this, this.options.context);
            } catch (_e) {
            }
          } else {
            this.fn(this, this.options.context);
          }
          this.previousrun = new CronDate(undefined, this.options.timezone);
        }
        this.schedule();
      }, waitMs);
      return this;
    };
    return Cron;
  });
});

// ../../node_modules/pm2/lib/tools/passwd.js
var require_passwd = __commonJS((exports2, module2) => {
  var fs = __require("fs");
  var getUsers = function() {
    return fs.readFileSync("/etc/passwd").toString().split("\n").filter(function(user) {
      return user.length && user[0] != "#";
    }).reduce(function(map, user) {
      var fields = user.split(":");
      map[fields[0]] = map[fields[2]] = {
        username: fields[0],
        password: fields[1],
        userId: fields[2],
        groupId: fields[3],
        name: fields[4].split(",")[0],
        homedir: fields[5],
        shell: fields[6]
      };
      return map;
    }, {});
  };
  var getGroups = function(cb) {
    var groups;
    try {
      groups = fs.readFileSync("/etc/group");
    } catch (e) {
      return e;
    }
    return groups.toString().split("\n").filter(function(group) {
      return group.length && group[0] != "#";
    }).reduce(function(map, group) {
      var fields = group.split(":");
      map[fields[0]] = map[fields[2]] = {
        name: fields[0],
        password: fields[1],
        id: fields[2],
        members: fields[3].split(",")
      };
      return map;
    }, {});
  };
  module2.exports = {
    getUsers,
    getGroups
  };
});

// ../../node_modules/pm2/lib/Common.js
var require_Common = __commonJS((exports2, module2) => {
  var homedir = function() {
    var env = process.env;
    var home = env.HOME;
    var user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;
    if (process.platform === "win32") {
      return env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;
    }
    if (process.platform === "darwin") {
      return home || (user ? "/Users/" + user : null);
    }
    if (process.platform === "linux") {
      return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
    }
    return home || null;
  };
  var resolveHome = function(filepath) {
    if (filepath[0] === "~") {
      return path2.join(homedir(), filepath.slice(1));
    }
    return filepath;
  };
  var warn2 = function(warning) {
    Common.printOut(cst.PREFIX_MSG_WARNING + warning);
  };
  var __dirname = "C:\\Users\\balle\\Documents\\GitHub\\echoesmd\\node_modules\\pm2\\lib";
  var fs = __require("fs");
  var path2 = __require("path");
  var os = __require("os");
  var util = __require("util");
  var chalk = require_source();
  var fclone = require_fclone();
  var semver = require_semver2();
  var dayjs = require_dayjs_min();
  var execSync = __require("child_process").execSync;
  var isBinary = require_isbinaryfile();
  var cst = require_constants2();
  var extItps = require_interpreter();
  var Config = require_Config();
  var pkg = require_package();
  var which = require_which();
  var Common = exports2;
  Common.determineSilentCLI = function() {
    var variadicArgsDashesPos = process.argv.indexOf("--");
    var s1opt = process.argv.indexOf("--silent");
    var s2opt = process.argv.indexOf("-s");
    if (process.env.PM2_SILENT || variadicArgsDashesPos > -1 && (s1opt != -1 && s1opt < variadicArgsDashesPos) && s2opt != -1 != s2opt < variadicArgsDashesPos || variadicArgsDashesPos == -1 && (s1opt > -1 || s2opt > -1)) {
      for (var key in console) {
        var code = key.charCodeAt(0);
        if (code >= 97 && code <= 122) {
          console[key] = function() {
          };
        }
      }
      process.env.PM2_DISCRETE_MODE = true;
    }
  };
  Common.printVersion = function() {
    var variadicArgsDashesPos = process.argv.indexOf("--");
    if (process.argv.indexOf("-v") > -1 && process.argv.indexOf("-v") < variadicArgsDashesPos) {
      console.log(pkg.version);
      process.exit(0);
    }
  };
  Common.lockReload = function() {
    try {
      var t1 = fs.readFileSync(cst.PM2_RELOAD_LOCKFILE).toString();
      if (t1 && t1 != "") {
        var diff = dayjs().diff(parseInt(t1));
        if (diff < cst.RELOAD_LOCK_TIMEOUT)
          return diff;
      }
    } catch (e) {
    }
    try {
      fs.writeFileSync(cst.PM2_RELOAD_LOCKFILE, dayjs().valueOf().toString());
      return 0;
    } catch (e) {
      console.error(e.message || e);
    }
  };
  Common.unlockReload = function() {
    try {
      fs.writeFileSync(cst.PM2_RELOAD_LOCKFILE, "");
    } catch (e) {
      console.error(e.message || e);
    }
  };
  Common.prepareAppConf = function(opts, app) {
    if (!app.script)
      return new Error("No script path - aborting");
    var cwd = null;
    if (app.cwd) {
      cwd = path2.resolve(app.cwd);
      process.env.PWD = app.cwd;
    }
    if (!app.node_args) {
      app.node_args = [];
    }
    if (app.port && app.env) {
      app.env.PORT = app.port;
    }
    cwd && cwd[0] != "/" && (cwd = path2.resolve(process.cwd(), cwd));
    cwd = cwd || opts.cwd;
    app.pm_exec_path = path2.resolve(cwd, app.script);
    if (!fs.existsSync(app.pm_exec_path)) {
      var ckd;
      if (ckd = which(app.script)) {
        if (typeof ckd !== "string")
          ckd = ckd.toString();
        app.pm_exec_path = ckd;
      } else
        return new Error(`Script not found: ${app.pm_exec_path}`);
    }
    if (app.disable_source_map_support != true) {
      try {
        fs.accessSync(app.pm_exec_path + ".map", fs.R_OK);
        app.source_map_support = true;
      } catch (e) {
      }
      delete app.disable_source_map_support;
    }
    delete app.script;
    var env = {};
    if (cst.PM2_PROGRAMMATIC || process.env.pm_id)
      Common.safeExtend(env, process.env);
    else
      env = process.env;
    function filterEnv(envObj) {
      if (app.filter_env == true)
        return {};
      if (typeof app.filter_env === "string") {
        delete envObj[app.filter_env];
        return envObj;
      }
      var new_env = {};
      var allowedKeys = app.filter_env.reduce((acc, current) => acc.filter((item) => !item.includes(current)), Object.keys(envObj));
      allowedKeys.forEach((key) => new_env[key] = envObj[key]);
      return new_env;
    }
    app.env = [
      {},
      app.filter_env && app.filter_env.length > 0 ? filterEnv(process.env) : env,
      app.env || {}
    ].reduce(function(e1, e2) {
      return Object.assign(e1, e2);
    });
    app.pm_cwd = cwd;
    try {
      Common.sink.resolveInterpreter(app);
    } catch (e) {
      return e;
    }
    Common.sink.determineExecMode(app);
    var formated_app_name = app.name.replace(/[^a-zA-Z0-9\\.\\-]/g, "-");
    ["log", "out", "error", "pid"].forEach(function(f) {
      var af = app[f + "_file"], ps, ext = f == "pid" ? "pid" : "log", isStd = !~["log", "pid"].indexOf(f);
      if (af)
        af = resolveHome(af);
      if (f == "log" && typeof af == "boolean" && af || f != "log" && !af) {
        ps = [cst["DEFAULT_" + ext.toUpperCase() + "_PATH"], formated_app_name + (isStd ? "-" + f : "") + "." + ext];
      } else if ((f != "log" || f == "log" && af) && af !== "NULL" && af !== "/dev/null") {
        ps = [cwd, af];
        var dir = path2.dirname(path2.resolve(cwd, af));
        if (!fs.existsSync(dir)) {
          Common.printError(cst.PREFIX_MSG_WARNING + "Folder does not exist: " + dir);
          Common.printOut(cst.PREFIX_MSG + "Creating folder: " + dir);
          try {
            require_mkdirp().sync(dir);
          } catch (err) {
            Common.printError(cst.PREFIX_MSG_ERR + "Could not create folder: " + path2.dirname(af));
            throw new Error("Could not create folder");
          }
        }
      }
      if (af !== "NULL" && af !== "/dev/null") {
        ps && (app["pm_" + (isStd ? f.substr(0, 3) + "_" : "") + ext + "_path"] = path2.resolve.apply(null, ps));
      } else if (path2.sep === "\\") {
        app["pm_" + (isStd ? f.substr(0, 3) + "_" : "") + ext + "_path"] = "\\\\.\\NUL";
      } else {
        app["pm_" + (isStd ? f.substr(0, 3) + "_" : "") + ext + "_path"] = "/dev/null";
      }
      delete app[f + "_file"];
    });
    return app;
  };
  Common.knonwConfigFileExtensions = {
    ".json": "json",
    ".yml": "yaml",
    ".yaml": "yaml",
    ".config.js": "js",
    ".config.cjs": "js",
    ".config.mjs": "mjs"
  };
  Common.isConfigFile = function(filename) {
    if (typeof filename !== "string")
      return null;
    for (let extension in Common.knonwConfigFileExtensions) {
      if (filename.indexOf(extension) !== -1) {
        return Common.knonwConfigFileExtensions[extension];
      }
    }
    return null;
  };
  Common.getConfigFileCandidates = function(name2) {
    return Object.keys(Common.knonwConfigFileExtensions).map((extension) => name2 + extension);
  };
  Common.parseConfig = function(confObj, filename) {
    var yamljs = require_js_yaml();
    var vm = __require("vm");
    var isConfigFile = Common.isConfigFile(filename);
    if (!filename || filename == "pipe" || filename == "none" || isConfigFile == "json") {
      var code = "(" + confObj + ")";
      var sandbox = {};
      return vm.runInThisContext(code, sandbox, {
        filename: path2.resolve(filename),
        displayErrors: false,
        timeout: 1000
      });
    } else if (isConfigFile == "yaml") {
      return yamljs.load(confObj.toString());
    } else if (isConfigFile == "js" || isConfigFile == "mjs") {
      var confPath = __require.resolve(path2.resolve(filename));
      delete __require.cache[confPath];
      return __require(confPath);
    }
  };
  Common.retErr = function(e) {
    if (!e)
      return new Error("Unidentified error");
    if (e instanceof Error)
      return e;
    return new Error(e);
  };
  Common.sink = {};
  Common.sink.determineCron = function(app) {
    if (app.cron_restart == 0 || app.cron_restart == "0") {
      Common.printOut(cst.PREFIX_MSG + "disabling cron restart");
      return;
    }
    if (app.cron_restart) {
      const Croner = require_croner();
      try {
        Common.printOut(cst.PREFIX_MSG + "cron restart at " + app.cron_restart);
        Croner(app.cron_restart);
      } catch (ex) {
        return new Error(`Cron pattern error: ${ex.message}`);
      }
    }
  };
  Common.sink.determineExecMode = function(app) {
    if (app.exec_mode)
      app.exec_mode = app.exec_mode.replace(/^(fork|cluster)$/, "$1_mode");
    if (!app.exec_mode && (app.instances >= 1 || app.instances === 0 || app.instances === -1) && app.exec_interpreter.indexOf("node") > -1) {
      app.exec_mode = "cluster_mode";
    } else if (!app.exec_mode) {
      app.exec_mode = "fork_mode";
    }
    if (typeof app.instances == "undefined")
      app.instances = 1;
  };
  var resolveNodeInterpreter = function(app) {
    if (app.exec_mode && app.exec_mode.indexOf("cluster") > -1) {
      Common.printError(cst.PREFIX_MSG_WARNING + chalk.bold.yellow("Choosing the Node.js version in cluster mode is not supported"));
      return false;
    }
    var nvm_path = cst.IS_WINDOWS ? process.env.NVM_HOME : process.env.NVM_DIR;
    if (!nvm_path) {
      Common.printError(cst.PREFIX_MSG_ERR + chalk.red("NVM is not available in PATH"));
      Common.printError(cst.PREFIX_MSG_ERR + chalk.red("Fallback to node in PATH"));
      var msg = cst.IS_WINDOWS ? "https://github.com/coreybutler/nvm-windows/releases/" : "$ curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | bash";
      Common.printOut(cst.PREFIX_MSG_ERR + chalk.bold("Install NVM:\n" + msg));
    } else {
      var node_version = app.exec_interpreter.split("@")[1];
      var path_to_node = cst.IS_WINDOWS ? "/v" + node_version + "/node.exe" : semver.satisfies(node_version, ">= 0.12.0") ? "/versions/node/v" + node_version + "/bin/node" : "/v" + node_version + "/bin/node";
      var nvm_node_path = path2.join(nvm_path, path_to_node);
      try {
        fs.accessSync(nvm_node_path);
      } catch (e) {
        Common.printOut(cst.PREFIX_MSG + "Installing Node v%s", node_version);
        var nvm_bin = path2.join(nvm_path, "nvm." + (cst.IS_WINDOWS ? "exe" : "sh"));
        var nvm_cmd = cst.IS_WINDOWS ? nvm_bin + " install " + node_version : ". " + nvm_bin + " ; nvm install " + node_version;
        Common.printOut(cst.PREFIX_MSG + "Executing: %s", nvm_cmd);
        execSync(nvm_cmd, {
          cwd: path2.resolve(process.cwd()),
          env: process.env,
          maxBuffer: 20 * 1024 * 1024
        });
        if (cst.IS_WINDOWS)
          nvm_node_path = nvm_node_path.replace(/node/, "node" + process.arch.slice(1));
      }
      Common.printOut(cst.PREFIX_MSG + chalk.green.bold("Setting Node to v%s (path=%s)"), node_version, nvm_node_path);
      app.exec_interpreter = nvm_node_path;
    }
  };
  Common.sink.resolveInterpreter = function(app) {
    var noInterpreter = !app.exec_interpreter;
    var extName = path2.extname(app.pm_exec_path);
    var betterInterpreter = extItps[extName];
    if (noInterpreter && betterInterpreter) {
      app.exec_interpreter = betterInterpreter;
      if (betterInterpreter == "python") {
        if (which("python") == null) {
          if (which("python3") == null)
            Common.printError(cst.PREFIX_MSG_WARNING + chalk.bold.yellow("python and python3 binaries not available in PATH"));
          else
            app.exec_interpreter = "python3";
        }
      }
    } else if (noInterpreter)
      app.exec_interpreter = isBinary(app.pm_exec_path) ? "none" : "node";
    else if (app.exec_interpreter.indexOf("node@") > -1)
      resolveNodeInterpreter(app);
    if (app.exec_interpreter.indexOf("python") > -1)
      app.env.PYTHONUNBUFFERED = "1";
    if (app.exec_interpreter == "lsc") {
      app.exec_interpreter = path2.resolve(__dirname, "../node_modules/.bin/lsc");
    }
    if (app.exec_interpreter == "coffee") {
      app.exec_interpreter = path2.resolve(__dirname, "../node_modules/.bin/coffee");
    }
    if (app.exec_interpreter != "none" && which(app.exec_interpreter) == null) {
      if (app.exec_interpreter == "node") {
        Common.warn(`Using builtin node.js version on version ${process.version}`);
        app.exec_interpreter = cst.BUILTIN_NODE_PATH;
      } else
        throw new Error(`Interpreter ${app.exec_interpreter} is NOT AVAILABLE in PATH. (type 'which ${app.exec_interpreter}' to double check.)`);
    }
    return app;
  };
  Common.deepCopy = Common.serialize = Common.clone = function(obj) {
    if (obj === null || obj === undefined)
      return {};
    return fclone(obj);
  };
  Common.errMod = function(msg) {
    if (process.env.PM2_SILENT || process.env.PM2_PROGRAMMATIC === "true")
      return false;
    if (msg instanceof Error)
      return console.error(msg.message);
    return console.error(`${cst.PREFIX_MSG_MOD_ERR}${msg}`);
  };
  Common.err = function(msg) {
    if (process.env.PM2_SILENT || process.env.PM2_PROGRAMMATIC === "true")
      return false;
    if (msg instanceof Error)
      return console.error(`${cst.PREFIX_MSG_ERR}${msg.message}`);
    return console.error(`${cst.PREFIX_MSG_ERR}${msg}`);
  };
  Common.printError = function(msg) {
    if (process.env.PM2_SILENT || process.env.PM2_PROGRAMMATIC === "true")
      return false;
    if (msg instanceof Error)
      return console.error(msg.message);
    return console.error.apply(console, arguments);
  };
  Common.log = function(msg) {
    if (process.env.PM2_SILENT || process.env.PM2_PROGRAMMATIC === "true")
      return false;
    return console.log(`${cst.PREFIX_MSG}${msg}`);
  };
  Common.info = function(msg) {
    if (process.env.PM2_SILENT || process.env.PM2_PROGRAMMATIC === "true")
      return false;
    return console.log(`${cst.PREFIX_MSG_INFO}${msg}`);
  };
  Common.warn = function(msg) {
    if (process.env.PM2_SILENT || process.env.PM2_PROGRAMMATIC === "true")
      return false;
    return console.log(`${cst.PREFIX_MSG_WARNING}${msg}`);
  };
  Common.logMod = function(msg) {
    if (process.env.PM2_SILENT || process.env.PM2_PROGRAMMATIC === "true")
      return false;
    return console.log(`${cst.PREFIX_MSG_MOD}${msg}`);
  };
  Common.printOut = function() {
    if (process.env.PM2_SILENT === "true" || process.env.PM2_PROGRAMMATIC === "true")
      return false;
    return console.log.apply(console, arguments);
  };
  Common.extend = function(destination, source) {
    if (typeof destination !== "object") {
      destination = {};
    }
    if (!source || typeof source !== "object") {
      return destination;
    }
    Object.keys(source).forEach(function(new_key) {
      if (source[new_key] != "[object Object]")
        destination[new_key] = source[new_key];
    });
    return destination;
  };
  Common.safeExtend = function(origin, add) {
    if (!add || typeof add != "object")
      return origin;
    var keysToIgnore = ["name", "exec_mode", "env", "args", "pm_cwd", "exec_interpreter", "pm_exec_path", "node_args", "pm_out_log_path", "pm_err_log_path", "pm_pid_path", "pm_id", "status", "pm_uptime", "created_at", "windowsHide", "username", "merge_logs", "kill_retry_time", "prev_restart_delay", "instance_var", "unstable_restarts", "restart_time", "axm_actions", "pmx_module", "command", "watch", "filter_env", "versioning", "vizion_runing", "MODULE_DEBUG", "pmx", "axm_options", "created_at", "watch", "vizion", "axm_dynamic", "axm_monitor", "instances", "automation", "autostart", "autorestart", "stop_exit_codes", "unstable_restart", "treekill", "exit_code", "vizion"];
    var keys3 = Object.keys(add);
    var i = keys3.length;
    while (i--) {
      if (keysToIgnore.indexOf(keys3[i]) == -1 && add[keys3[i]] != "[object Object]")
        origin[keys3[i]] = add[keys3[i]];
    }
    return origin;
  };
  Common.mergeEnvironmentVariables = function(app_env, env_name, deploy_conf) {
    var app = fclone(app_env);
    var new_conf = {
      env: {}
    };
    for (var key in app.env) {
      if (typeof app.env[key] == "object") {
        app.env[key] = JSON.stringify(app.env[key]);
      }
    }
    Object.assign(new_conf, app);
    if (env_name) {
      if (deploy_conf && deploy_conf[env_name] && deploy_conf[env_name]["env"]) {
        Object.assign(new_conf.env, deploy_conf[env_name]["env"]);
      }
      Object.assign(new_conf.env, app.env);
      if ("env_" + env_name in app) {
        Object.assign(new_conf.env, app["env_" + env_name]);
      } else {
        Common.printOut(cst.PREFIX_MSG_WARNING + chalk.bold("Environment [%s] is not defined in process file"), env_name);
      }
    }
    delete new_conf.exec_mode;
    var res = {
      current_conf: {}
    };
    Object.assign(res, new_conf.env);
    Object.assign(res.current_conf, new_conf);
    if (app.exec_interpreter && app.exec_interpreter.indexOf("@") > -1) {
      resolveNodeInterpreter(app);
      res.current_conf.exec_interpreter = app.exec_interpreter;
    }
    return res;
  };
  Common.resolveAppAttributes = function(opts, conf2) {
    var conf_copy = fclone(conf2);
    var app = Common.prepareAppConf(opts, conf_copy);
    if (app instanceof Error) {
      throw new Error(app.message);
    }
    return app;
  };
  Common.verifyConfs = function(appConfs) {
    if (!appConfs || appConfs.length == 0) {
      return [];
    }
    appConfs = [].concat(appConfs);
    var verifiedConf = [];
    for (var i = 0;i < appConfs.length; i++) {
      var app = appConfs[i];
      if (app.exec_mode)
        app.exec_mode = app.exec_mode.replace(/^(fork|cluster)$/, "$1_mode");
      if (app.cmd && !app.script) {
        app.script = app.cmd;
        delete app.cmd;
      }
      if (app.command && !app.script) {
        app.script = app.command;
        delete app.command;
      }
      if (!app.env) {
        app.env = {};
      }
      Common.renderApplicationName(app);
      if (app.execute_command == true) {
        app.exec_mode = "fork";
        delete app.execute_command;
      }
      app.username = Common.getCurrentUsername();
      if (app.script && app.script.indexOf(" ") > -1 && cst.IS_WINDOWS === false) {
        var _script = app.script;
        if (which("bash")) {
          app.script = "bash";
          app.args = ["-c", _script];
          if (!app.name) {
            app.name = _script;
          }
        } else if (which("sh")) {
          app.script = "sh";
          app.args = ["-c", _script];
          if (!app.name) {
            app.name = _script;
          }
        } else {
          warn2("bash or sh not available in $PATH, keeping script as is");
        }
      }
      if (app.time || process.env.ASZ_MODE) {
        app.log_date_format = "YYYY-MM-DDTHH:mm:ss";
      }
      if (app.uid || app.gid || app.user) {
        if (cst.IS_WINDOWS === true) {
          Common.printError(cst.PREFIX_MSG_ERR + "--uid and --git does not works on windows");
          return new Error("--uid and --git does not works on windows");
        }
        if (process.getuid && process.getuid() !== 0) {
          Common.printError(cst.PREFIX_MSG_ERR + "To use --uid and --gid please run pm2 as root");
          return new Error("To use UID and GID please run PM2 as root");
        }
        var passwd = require_passwd();
        var users;
        try {
          users = passwd.getUsers();
        } catch (e) {
          Common.printError(e);
          return new Error(e);
        }
        var user_info = users[app.uid || app.user];
        if (!user_info) {
          Common.printError(`${cst.PREFIX_MSG_ERR} User ${app.uid || app.user} cannot be found`);
          return new Error(`${cst.PREFIX_MSG_ERR} User ${app.uid || app.user} cannot be found`);
        }
        app.env.HOME = user_info.homedir;
        app.uid = parseInt(user_info.userId);
        if (app.gid) {
          var groups;
          try {
            groups = passwd.getGroups();
          } catch (e) {
            Common.printError(e);
            return new Error(e);
          }
          var group_info = groups[app.gid];
          if (!group_info) {
            Common.printError(`${cst.PREFIX_MSG_ERR} Group ${app.gid} cannot be found`);
            return new Error(`${cst.PREFIX_MSG_ERR} Group ${app.gid} cannot be found`);
          }
          app.gid = parseInt(group_info.id);
        } else {
          app.gid = parseInt(user_info.groupId);
        }
      }
      if (process.env.PM2_DEEP_MONITORING) {
        app.deep_monitoring = true;
      }
      if (app.automation == false) {
        app.pmx = false;
      }
      if (app.disable_trace) {
        app.trace = false;
        delete app.disable_trace;
      }
      if (app.instances == "max") {
        app.instances = 0;
      }
      if (typeof app.instances === "string") {
        app.instances = parseInt(app.instances) || 0;
      }
      if (app.exec_mode != "cluster_mode" && !app.instances && typeof app.merge_logs == "undefined") {
        app.merge_logs = true;
      }
      var ret;
      if (app.cron_restart) {
        if ((ret = Common.sink.determineCron(app)) instanceof Error)
          return ret;
      }
      var ret = Config.validateJSON(app);
      if (ret.errors && ret.errors.length > 0) {
        ret.errors.forEach(function(err) {
          warn2(err);
        });
        return new Error(ret.errors);
      }
      verifiedConf.push(ret.config);
    }
    return verifiedConf;
  };
  Common.getCurrentUsername = function() {
    var current_user = "";
    if (os.userInfo) {
      try {
        current_user = os.userInfo().username;
      } catch (err) {
      }
    }
    if (current_user === "") {
      current_user = process.env.USER || process.env.LNAME || process.env.USERNAME || process.env.SUDO_USER || process.env.C9_USER || process.env.LOGNAME;
    }
    return current_user;
  };
  Common.renderApplicationName = function(conf2) {
    if (!conf2.name && conf2.script) {
      conf2.name = conf2.script !== undefined ? path2.basename(conf2.script) : "undefined";
      var lastDot = conf2.name.lastIndexOf(".");
      if (lastDot > 0) {
        conf2.name = conf2.name.slice(0, lastDot);
      }
    }
  };
});

// ../../node_modules/pm2-axon-rpc/lib/server.js
var require_server = __commonJS((exports2, module2) => {
  var Server2 = function(sock) {
    if (typeof sock.format === "function")
      sock.format("json");
    this.sock = sock;
    this.methods = {};
    this.sock.on("message", this.onmessage.bind(this));
  };
  var params2 = function(fn) {
    var ret = fn.toString().replace(/\s/g, "").match(/^function *(\w*)\((.*?)\)/)[2];
    if (ret)
      return ret.split(/ *, */);
    return [];
  };
  var debug = require_src();
  module2.exports = Server2;
  Server2.prototype.methodDescriptions = function() {
    var obj = {};
    var fn;
    for (var name2 in this.methods) {
      fn = this.methods[name2];
      obj[name2] = {
        name: name2,
        params: params2(fn)
      };
    }
    return obj;
  };
  Server2.prototype.respondWithMethods = function(reply) {
    reply({ methods: this.methodDescriptions() });
  };
  Server2.prototype.onmessage = function(msg, reply) {
    if (msg.type == "methods")
      return this.respondWithMethods(reply);
    if (!reply) {
      console.error("reply false");
      return false;
    }
    var meth = msg.method;
    if (!meth)
      return reply({ error: ".method required" });
    var fn = this.methods[meth];
    if (!fn)
      return reply({ error: 'method "' + meth + '" does not exist' });
    var args2 = msg.args;
    if (!args2)
      return reply({ error: ".args required" });
    args2.push(function(err) {
      if (err) {
        if (err instanceof Error)
          return reply({ error: err.message, stack: err.stack });
        else
          return reply({ error: err });
      }
      var args3 = [].slice.call(arguments, 1);
      reply({ args: args3 });
    });
    fn.apply(null, args2);
  };
  Server2.prototype.expose = function(name2, fn) {
    if (arguments.length == 1) {
      for (var key in name2) {
        this.expose(key, name2[key]);
      }
    } else {
      debug('expose "%s"', name2);
      this.methods[name2] = fn;
    }
  };
});

// ../../node_modules/pm2-axon-rpc/lib/client.js
var require_client = __commonJS((exports2, module2) => {
  var Client = function(sock) {
    if (typeof sock.format === "function")
      sock.format("json");
    this.sock = sock;
  };
  module2.exports = Client;
  Client.prototype.call = function(name2) {
    var args2 = [].slice.call(arguments, 1, -1);
    var fn = arguments[arguments.length - 1];
    this.sock.send({
      type: "call",
      method: name2,
      args: args2
    }, function(msg) {
      if ("error" in msg) {
        var err = new Error(msg.error);
        err.stack = msg.stack || err.stack;
        fn(err);
      } else {
        msg.args.unshift(null);
        fn.apply(null, msg.args);
      }
    });
  };
  Client.prototype.methods = function(fn) {
    this.sock.send({
      type: "methods"
    }, function(msg) {
      fn(null, msg.methods);
    });
  };
});

// ../../node_modules/pm2-axon-rpc/index.js
var require_pm2_axon_rpc = __commonJS((exports2) => {
  exports2.Server = require_server();
  exports2.Client = require_client();
});

// ../../node_modules/pm2-axon/lib/configurable/lib/configurable.js
var require_configurable = __commonJS((exports2, module2) => {
  module2.exports = function(obj) {
    obj.settings = {};
    obj.set = function(name2, val) {
      if (arguments.length == 1) {
        for (var key in name2) {
          this.set(key, name2[key]);
        }
      } else {
        this.settings[name2] = val;
      }
      return this;
    };
    obj.get = function(name2) {
      return this.settings[name2];
    };
    obj.enable = function(name2) {
      return this.set(name2, true);
    };
    obj.disable = function(name2) {
      return this.set(name2, false);
    };
    obj.enabled = function(name2) {
      return !!this.get(name2);
    };
    obj.disabled = function(name2) {
      return !this.get(name2);
    };
    return obj;
  };
});

// ../../node_modules/amp/lib/encode.js
var require_encode = __commonJS((exports2, module2) => {
  var version3 = 1;
  module2.exports = function(args2) {
    var argc = args2.length;
    var len = 1;
    var off = 0;
    for (var i = 0;i < argc; i++) {
      len += 4 + args2[i].length;
    }
    var buf = new Buffer(len);
    buf[off++] = version3 << 4 | argc;
    for (var i = 0;i < argc; i++) {
      var arg = args2[i];
      buf.writeUInt32BE(arg.length, off);
      off += 4;
      arg.copy(buf, off);
      off += arg.length;
    }
    return buf;
  };
});

// ../../node_modules/amp/lib/stream.js
var require_stream2 = __commonJS((exports2, module2) => {
  var Parser = function(opts) {
    Stream.call(this, opts);
    this.state = "message";
    this._lenbuf = new Buffer(4);
  };
  var Stream = __require("stream").Writable;
  var encode = require_encode();
  module2.exports = Parser;
  Parser.prototype.__proto__ = Stream.prototype;
  Parser.prototype._write = function(chunk, encoding, fn) {
    for (var i = 0;i < chunk.length; i++) {
      switch (this.state) {
        case "message":
          var meta2 = chunk[i];
          this.version = meta2 >> 4;
          this.argv = meta2 & 15;
          this.state = "arglen";
          this._bufs = [new Buffer([meta2])];
          this._nargs = 0;
          this._leni = 0;
          break;
        case "arglen":
          this._lenbuf[this._leni++] = chunk[i];
          if (this._leni == 4) {
            this._arglen = this._lenbuf.readUInt32BE(0);
            var buf = new Buffer(4);
            buf[0] = this._lenbuf[0];
            buf[1] = this._lenbuf[1];
            buf[2] = this._lenbuf[2];
            buf[3] = this._lenbuf[3];
            this._bufs.push(buf);
            this._argcur = 0;
            this.state = "arg";
          }
          break;
        case "arg":
          var rem = this._arglen - this._argcur;
          var pos = Math.min(rem + i, chunk.length);
          var part = chunk.slice(i, pos);
          this._bufs.push(part);
          this._argcur += pos - i;
          var done = this._argcur == this._arglen;
          i = pos - 1;
          if (done)
            this._nargs++;
          if (this._nargs == this.argv) {
            this.state = "message";
            this.emit("data", Buffer.concat(this._bufs));
            break;
          }
          if (done) {
            this.state = "arglen";
            this._leni = 0;
          }
          break;
      }
    }
    fn();
  };
});

// ../../node_modules/amp/lib/decode.js
var require_decode = __commonJS((exports2, module2) => {
  module2.exports = function(buf) {
    var off = 0;
    var meta2 = buf[off++];
    var version3 = meta2 >> 4;
    var argv = meta2 & 15;
    var args2 = new Array(argv);
    for (var i = 0;i < argv; i++) {
      var len = buf.readUInt32BE(off);
      off += 4;
      var arg = buf.slice(off, off += len);
      args2[i] = arg;
    }
    return args2;
  };
});

// ../../node_modules/amp/index.js
var require_amp = __commonJS((exports2) => {
  exports2.Stream = require_stream2();
  exports2.encode = require_encode();
  exports2.decode = require_decode();
});

// ../../node_modules/amp-message/index.js
var require_amp_message = __commonJS((exports2, module2) => {
  var Message = function(args2) {
    if (Buffer.isBuffer(args2))
      args2 = decode(args2);
    this.args = args2 || [];
  };
  var decode = function(msg) {
    var args2 = amp.decode(msg);
    for (var i = 0;i < args2.length; i++) {
      args2[i] = unpack(args2[i]);
    }
    return args2;
  };
  var encode = function(args2) {
    var tmp = new Array(args2.length);
    for (var i = 0;i < args2.length; i++) {
      tmp[i] = pack(args2[i]);
    }
    return amp.encode(tmp);
  };
  var pack = function(arg) {
    if (Buffer.isBuffer(arg))
      return arg;
    if (typeof arg == "string")
      return new Buffer("s:" + arg);
    if (arg === undefined)
      arg = null;
    return new Buffer("j:" + JSON.stringify(arg));
  };
  var unpack = function(arg) {
    if (isJSON(arg))
      return JSON.parse(arg.slice(2));
    if (isString(arg))
      return arg.slice(2).toString();
    return arg;
  };
  var isString = function(arg) {
    return arg[0] == 115 && arg[1] == 58;
  };
  var isJSON = function(arg) {
    return arg[0] == 106 && arg[1] == 58;
  };
  var fmt = __require("util").format;
  var amp = require_amp();
  var methods = [
    "push",
    "pop",
    "shift",
    "unshift"
  ];
  module2.exports = Message;
  methods.forEach(function(method) {
    Message.prototype[method] = function() {
      return this.args[method].apply(this.args, arguments);
    };
  });
  Message.prototype.inspect = function() {
    return fmt("<Message args=%d size=%d>", this.args.length, this.toBuffer().length);
  };
  Message.prototype.toBuffer = function() {
    return encode(this.args);
  };
});

// ../../node_modules/pm2-axon/lib/sockets/sock.js
var require_sock = __commonJS((exports2, module2) => {
  var Socket = function() {
    var self2 = this;
    this.opts = {};
    this.server = null;
    this.socks = [];
    this.settings = {};
    this.set("hwm", Infinity);
    this.set("identity", String(process.pid));
    this.set("retry timeout", 100);
    this.set("retry max timeout", 5000);
  };
  var Emitter = __require("events").EventEmitter;
  var Configurable = require_configurable();
  var debug = require_src()("axon:sock");
  var Message = require_amp_message();
  var Parser = require_amp().Stream;
  var url = __require("url");
  var net = __require("net");
  var fs = __require("fs");
  var ignore = [
    "ECONNREFUSED",
    "ECONNRESET",
    "ETIMEDOUT",
    "EHOSTUNREACH",
    "ENETUNREACH",
    "ENETDOWN",
    "EPIPE",
    "ENOENT"
  ];
  module2.exports = Socket;
  Socket.prototype.__proto__ = Emitter.prototype;
  Configurable(Socket.prototype);
  Socket.prototype.use = function(plugin) {
    plugin(this);
    return this;
  };
  Socket.prototype.pack = function(args2) {
    var msg = new Message(args2);
    return msg.toBuffer();
  };
  Socket.prototype.closeSockets = function() {
    debug("closing %d connections", this.socks.length);
    this.socks.forEach(function(sock) {
      sock.destroy();
    });
  };
  Socket.prototype.close = function(fn) {
    debug("closing");
    this.closing = true;
    this.closeSockets();
    if (this.server)
      this.closeServer(fn);
  };
  Socket.prototype.closeServer = function(fn) {
    debug("closing server");
    this.server.on("close", this.emit.bind(this, "close"));
    this.server.close();
    fn && fn();
  };
  Socket.prototype.address = function() {
    if (!this.server)
      return;
    var addr = this.server.address();
    addr.string = "tcp://" + addr.address + ":" + addr.port;
    return addr;
  };
  Socket.prototype.removeSocket = function(sock) {
    var i = this.socks.indexOf(sock);
    if (!~i)
      return;
    debug("remove socket %d", i);
    this.socks.splice(i, 1);
  };
  Socket.prototype.addSocket = function(sock) {
    var parser = new Parser;
    var i = this.socks.push(sock) - 1;
    debug("add socket %d", i);
    sock.pipe(parser);
    parser.on("data", this.onmessage(sock));
  };
  Socket.prototype.handleErrors = function(sock) {
    var self2 = this;
    sock.on("error", function(err) {
      debug("error %s", err.code || err.message);
      self2.emit("socket error", err);
      self2.removeSocket(sock);
      if (!~ignore.indexOf(err.code))
        return self2.emit("error", err);
      debug("ignored %s", err.code);
      self2.emit("ignored error", err);
    });
  };
  Socket.prototype.onmessage = function(sock) {
    var self2 = this;
    return function(buf) {
      var msg = new Message(buf);
      self2.emit.apply(self2, ["message"].concat(msg.args), sock);
    };
  };
  Socket.prototype.connect = function(port, host, fn) {
    var self2 = this;
    if (this.type == "server")
      throw new Error("cannot connect() after bind()");
    if (typeof host == "function")
      fn = host, host = undefined;
    if (typeof port == "string") {
      port = url.parse(port);
      if (port.pathname) {
        fn = host;
        host = null;
        fn = undefined;
        port = port.pathname;
      } else {
        host = port.hostname || "0.0.0.0";
        port = parseInt(port.port, 10);
      }
    } else {
      host = host || "0.0.0.0";
    }
    var max4 = self2.get("retry max timeout");
    var sock = new net.Socket;
    sock.setNoDelay();
    this.type = "client";
    port = port;
    this.handleErrors(sock);
    sock.on("close", function() {
      self2.connected = false;
      self2.removeSocket(sock);
      if (self2.closing)
        return self2.emit("close");
      var retry = self2.retry || self2.get("retry timeout");
      if (retry === 0)
        return self2.emit("close");
      setTimeout(function() {
        debug("attempting reconnect");
        self2.emit("reconnect attempt");
        sock.destroy();
        self2.connect(port, host);
        self2.retry = Math.round(Math.min(max4, retry * 1.5));
      }, retry);
    });
    sock.on("connect", function() {
      debug("connect");
      self2.connected = true;
      self2.addSocket(sock);
      self2.retry = self2.get("retry timeout");
      self2.emit("connect");
      fn && fn();
    });
    debug("connect attempt %s:%s", host, port);
    sock.connect(port, host);
    return this;
  };
  Socket.prototype.onconnect = function(sock) {
    var self2 = this;
    var addr = null;
    if (sock.remoteAddress && sock.remotePort)
      addr = sock.remoteAddress + ":" + sock.remotePort;
    else if (sock.server && sock.server._pipeName)
      addr = sock.server._pipeName;
    debug("accept %s", addr);
    this.addSocket(sock);
    this.handleErrors(sock);
    this.emit("connect", sock);
    sock.on("close", function() {
      debug("disconnect %s", addr);
      self2.emit("disconnect", sock);
      self2.removeSocket(sock);
    });
  };
  Socket.prototype.bind = function(port, host, fn) {
    var self2 = this;
    if (this.type == "client")
      throw new Error("cannot bind() after connect()");
    if (typeof host == "function")
      fn = host, host = undefined;
    var unixSocket = false;
    if (typeof port == "string") {
      port = url.parse(port);
      if (port.pathname) {
        fn = host;
        host = null;
        port = port.pathname;
        unixSocket = true;
      } else {
        host = port.hostname || "0.0.0.0";
        port = parseInt(port.port, 10);
      }
    } else {
      host = host || "0.0.0.0";
    }
    this.type = "server";
    this.server = net.createServer(this.onconnect.bind(this));
    debug("bind %s:%s", host, port);
    this.server.on("listening", this.emit.bind(this, "bind"));
    if (unixSocket) {
      this.server.on("error", function(e) {
        debug("Got error while trying to bind", e.stack || e);
        if (e.code == "EADDRINUSE") {
          var clientSocket = new net.Socket;
          clientSocket.on("error", function(e2) {
            debug("Got sub-error", e2);
            if (e2.code == "ECONNREFUSED" || e2.code == "ENOENT") {
              try {
                fs.unlinkSync(port);
              } catch (e3) {
              }
              self2.server.listen(port, host, fn);
            }
          });
          clientSocket.connect({ path: port }, function() {
            if (fn)
              return fn(new Error("Process already listening on socket " + port));
          });
        } else {
          try {
            fs.unlinkSync(port);
          } catch (e2) {
          }
          self2.server.listen(port, host, fn);
        }
      });
    }
    this.server.listen(port, host, fn);
    return this;
  };
});

// ../../node_modules/pm2-axon/lib/utils.js
var require_utils = __commonJS((exports2) => {
  exports2.slice = function(args2) {
    var len = args2.length;
    var ret = new Array(len);
    for (var i = 0;i < len; i++) {
      ret[i] = args2[i];
    }
    return ret;
  };
});

// ../../node_modules/pm2-axon/lib/sockets/pub.js
var require_pub = __commonJS((exports2, module2) => {
  var PubSocket = function() {
    Socket.call(this);
  };
  var Socket = require_sock();
  var slice = require_utils().slice;
  module2.exports = PubSocket;
  PubSocket.prototype.__proto__ = Socket.prototype;
  PubSocket.prototype.send = function(msg) {
    var socks = this.socks;
    var len = socks.length;
    var buf = this.pack(arguments);
    for (var sock of socks) {
      if (sock.writable)
        sock.write(buf);
    }
    return this;
  };
  PubSocket.prototype.sendv2 = function(data, cb) {
    var socks = this.socks;
    var len = socks.length;
    var sock;
    if (len == 0)
      return process.nextTick(cb);
    var buf = this.pack([data]);
    var i = 0;
    socks.forEach(function(sock2) {
      if (sock2.writable)
        sock2.write(buf, function() {
          i++;
          if (i == len)
            process.nextTick(cb);
        });
      else {
        i++;
        if (i == len)
          process.nextTick(cb);
      }
    });
    return this;
  };
});

// ../../node_modules/pm2-axon/lib/sockets/pub-emitter.js
var require_pub_emitter = __commonJS((exports2, module2) => {
  var PubEmitterSocket = function() {
    this.sock = new PubSocket;
    this.emit = this.sock.send.bind(this.sock);
    this.bind = this.sock.bind.bind(this.sock);
    this.connect = this.sock.connect.bind(this.sock);
    this.close = this.sock.close.bind(this.sock);
  };
  var PubSocket = require_pub();
  module2.exports = PubEmitterSocket;
});

// ../../node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS((exports2, module2) => {
  module2.exports = (string) => {
    if (typeof string !== "string") {
      throw new TypeError("Expected a string");
    }
    return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  };
});

// ../../node_modules/pm2-axon/lib/sockets/sub.js
var require_sub = __commonJS((exports2, module2) => {
  var SubSocket = function() {
    Socket.call(this);
    this.subscriptions = [];
  };
  var toRegExp = function(str) {
    if (str instanceof RegExp)
      return str;
    str = escape2(str);
    str = str.replace(/\\\*/g, "(.+)");
    return new RegExp("^" + str + "$");
  };
  var debug = require_src()("axon:sub");
  var escape2 = require_escape_string_regexp();
  var Message = require_amp_message();
  var Socket = require_sock();
  module2.exports = SubSocket;
  SubSocket.prototype.__proto__ = Socket.prototype;
  SubSocket.prototype.hasSubscriptions = function() {
    return !!this.subscriptions.length;
  };
  SubSocket.prototype.matches = function(topic) {
    for (var i = 0;i < this.subscriptions.length; ++i) {
      if (this.subscriptions[i].test(topic)) {
        return true;
      }
    }
    return false;
  };
  SubSocket.prototype.onmessage = function(sock) {
    var subs = this.hasSubscriptions();
    var self2 = this;
    return function(buf) {
      var msg = new Message(buf);
      if (subs) {
        var topic = msg.args[0];
        if (!self2.matches(topic))
          return debug('not subscribed to "%s"', topic);
      }
      self2.emit.apply(self2, ["message"].concat(msg.args).concat(sock));
    };
  };
  SubSocket.prototype.subscribe = function(re) {
    debug('subscribe to "%s"', re);
    this.subscriptions.push(re = toRegExp(re));
    return re;
  };
  SubSocket.prototype.unsubscribe = function(re) {
    debug('unsubscribe from "%s"', re);
    re = toRegExp(re);
    for (var i = 0;i < this.subscriptions.length; ++i) {
      if (this.subscriptions[i].toString() === re.toString()) {
        this.subscriptions.splice(i--, 1);
      }
    }
  };
  SubSocket.prototype.clearSubscriptions = function() {
    this.subscriptions = [];
  };
  SubSocket.prototype.send = function() {
    throw new Error("subscribers cannot send messages");
  };
});

// ../../node_modules/pm2-axon/lib/sockets/sub-emitter.js
var require_sub_emitter = __commonJS((exports2, module2) => {
  var SubEmitterSocket = function() {
    this.sock = new SubSocket;
    this.sock.onmessage = this.onmessage.bind(this);
    this.bind = this.sock.bind.bind(this.sock);
    this.connect = this.sock.connect.bind(this.sock);
    this.close = this.sock.close.bind(this.sock);
    this.listeners = [];
  };
  var Message = require_amp_message();
  var SubSocket = require_sub();
  module2.exports = SubEmitterSocket;
  SubEmitterSocket.prototype.onmessage = function() {
    var listeners = this.listeners;
    var self2 = this;
    return function(buf) {
      var msg = new Message(buf);
      var topic = msg.shift();
      for (var i = 0;i < listeners.length; ++i) {
        var listener = listeners[i];
        var m = listener.re.exec(topic);
        if (!m)
          continue;
        listener.fn.apply(this, m.slice(1).concat(msg.args));
      }
    };
  };
  SubEmitterSocket.prototype.on = function(event, fn) {
    var re = this.sock.subscribe(event);
    this.listeners.push({
      event,
      re,
      fn
    });
    return this;
  };
  SubEmitterSocket.prototype.off = function(event) {
    for (var i = 0;i < this.listeners.length; ++i) {
      if (this.listeners[i].event === event) {
        this.sock.unsubscribe(this.listeners[i].re);
        this.listeners.splice(i--, 1);
      }
    }
    return this;
  };
});

// ../../node_modules/pm2-axon/lib/plugins/round-robin.js
var require_round_robin = __commonJS((exports2, module2) => {
  var slice = require_utils().slice;
  module2.exports = function(options2) {
    options2 = options2 || {};
    var fallback = options2.fallback || function() {
    };
    return function(sock) {
      fallback = fallback.bind(sock);
      var n = 0;
      sock.send = function() {
        var socks = this.socks;
        var len = socks.length;
        var sock2 = socks[n++ % len];
        var msg = slice(arguments);
        if (sock2 && sock2.writable) {
          sock2.write(this.pack(msg));
        } else {
          fallback(msg);
        }
      };
    };
  };
});

// ../../node_modules/pm2-axon/lib/plugins/queue.js
var require_queue = __commonJS((exports2, module2) => {
  var debug = require_src()("axon:queue");
  module2.exports = function(options2) {
    options2 = options2 || {};
    return function(sock) {
      sock.queue = [];
      sock.on("connect", function() {
        var prev = sock.queue;
        var len = prev.length;
        sock.queue = [];
        debug("flush %d messages", len);
        for (var i = 0;i < len; ++i) {
          this.send.apply(this, prev[i]);
        }
        sock.emit("flush", prev);
      });
      sock.enqueue = function(msg) {
        var hwm = sock.settings.hwm;
        if (sock.queue.length >= hwm)
          return drop(msg);
        sock.queue.push(msg);
      };
      function drop(msg) {
        debug("drop");
        sock.emit("drop", msg);
      }
    };
  };
});

// ../../node_modules/pm2-axon/lib/sockets/push.js
var require_push = __commonJS((exports2, module2) => {
  var PushSocket = function() {
    Socket.call(this);
    this.use(queue());
    this.use(roundrobin({ fallback: this.enqueue }));
  };
  var roundrobin = require_round_robin();
  var queue = require_queue();
  var Socket = require_sock();
  module2.exports = PushSocket;
  PushSocket.prototype.__proto__ = Socket.prototype;
});

// ../../node_modules/pm2-axon/lib/sockets/pull.js
var require_pull = __commonJS((exports2, module2) => {
  var PullSocket = function() {
    Socket.call(this);
  };
  var Socket = require_sock();
  module2.exports = PullSocket;
  PullSocket.prototype.__proto__ = Socket.prototype;
  PullSocket.prototype.send = function() {
    throw new Error("pull sockets should not send messages");
  };
});

// ../../node_modules/pm2-axon/lib/sockets/req.js
var require_req = __commonJS((exports2, module2) => {
  var ReqSocket = function() {
    Socket.call(this);
    this.n = 0;
    this.ids = 0;
    this.callbacks = {};
    this.identity = this.get("identity");
    this.use(queue());
  };
  var debug = require_src()("axon:req");
  var queue = require_queue();
  var slice = require_utils().slice;
  var Message = require_amp_message();
  var Socket = require_sock();
  module2.exports = ReqSocket;
  ReqSocket.prototype.__proto__ = Socket.prototype;
  ReqSocket.prototype.id = function() {
    return this.identity + ":" + this.ids++;
  };
  ReqSocket.prototype.onmessage = function() {
    var self2 = this;
    return function(buf) {
      var msg = new Message(buf);
      var id2 = msg.pop();
      var fn = self2.callbacks[id2];
      if (!fn)
        return debug("missing callback %s", id2);
      fn.apply(null, msg.args);
      delete self2.callbacks[id2];
    };
  };
  ReqSocket.prototype.send = function(msg) {
    var socks = this.socks;
    var len = socks.length;
    var sock = socks[this.n++ % len];
    var args2 = slice(arguments);
    if (sock) {
      var hasCallback = typeof args2[args2.length - 1] == "function";
      if (!hasCallback)
        args2.push(function() {
        });
      var fn = args2.pop();
      fn.id = this.id();
      this.callbacks[fn.id] = fn;
      args2.push(fn.id);
    }
    if (sock) {
      sock.write(this.pack(args2));
    } else {
      debug("no connected peers");
      this.enqueue(args2);
    }
  };
});

// ../../node_modules/pm2-axon/lib/sockets/rep.js
var require_rep = __commonJS((exports2, module2) => {
  var RepSocket = function() {
    Socket.call(this);
  };
  var slice = require_utils().slice;
  var debug = require_src()("axon:rep");
  var Message = require_amp_message();
  var Socket = require_sock();
  module2.exports = RepSocket;
  RepSocket.prototype.__proto__ = Socket.prototype;
  RepSocket.prototype.onmessage = function(sock) {
    var self2 = this;
    return function(buf) {
      var msg = new Message(buf);
      var args2 = msg.args;
      var id2 = args2.pop();
      args2.unshift("message");
      args2.push(reply);
      self2.emit.apply(self2, args2);
      function reply() {
        var fn = function() {
        };
        var args3 = slice(arguments);
        args3[0] = args3[0] || null;
        var hasCallback = typeof args3[args3.length - 1] == "function";
        if (hasCallback)
          fn = args3.pop();
        args3.push(id2);
        if (sock.writable) {
          sock.write(self2.pack(args3), function() {
            fn(true);
          });
          return true;
        } else {
          debug("peer went away");
          process.nextTick(function() {
            fn(false);
          });
          return false;
        }
      }
    };
  };
});

// ../../node_modules/pm2-axon/lib/index.js
var require_lib2 = __commonJS((exports2) => {
  exports2.PubEmitterSocket = require_pub_emitter();
  exports2.SubEmitterSocket = require_sub_emitter();
  exports2.PushSocket = require_push();
  exports2.PullSocket = require_pull();
  exports2.PubSocket = require_pub();
  exports2.SubSocket = require_sub();
  exports2.ReqSocket = require_req();
  exports2.RepSocket = require_rep();
  exports2.Socket = require_sock();
  exports2.types = {
    "pub-emitter": exports2.PubEmitterSocket,
    "sub-emitter": exports2.SubEmitterSocket,
    push: exports2.PushSocket,
    pull: exports2.PullSocket,
    pub: exports2.PubSocket,
    sub: exports2.SubSocket,
    req: exports2.ReqSocket,
    rep: exports2.RepSocket
  };
  exports2.socket = function(type2, options2) {
    var fn = exports2.types[type2];
    if (!fn)
      throw new Error('invalid socket type "' + type2 + '"');
    return new fn(options2);
  };
});

// ../../node_modules/@pm2/agent/node_modules/chalk/source/util.js
var require_util2 = __commonJS((exports2, module2) => {
  var stringReplaceAll = (string, substring, replacer) => {
    let index = string.indexOf(substring);
    if (index === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
      endIndex = index + substringLength;
      index = string.indexOf(substring, endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index - 1] === "\r";
      returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index + 1;
      index = string.indexOf("\n", endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  module2.exports = {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  };
});

// ../../node_modules/@pm2/agent/node_modules/chalk/source/templates.js
var require_templates2 = __commonJS((exports2, module2) => {
  var unescape2 = function(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES.get(c) || c;
  };
  var parseArguments = function(name2, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number)) {
        results.push(number);
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, character) => escape2 ? unescape2(escape2) : character));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
      }
    }
    return results;
  };
  var parseStyle = function(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name2 = matches[1];
      if (matches[2]) {
        const args2 = parseArguments(name2, matches[2]);
        results.push([name2].concat(args2));
      } else {
        results.push([name2]);
      }
    }
    return results;
  };
  var buildStyle = function(chalk, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk;
    for (const [styleName, styles2] of Object.entries(enabled)) {
      if (!Array.isArray(styles2)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
    }
    return current;
  };
  var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "\t"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  module2.exports = (chalk, temporary) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter) {
        chunk.push(unescape2(escapeCharacter));
      } else if (style) {
        const string = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
        styles.push({ inverse, styles: parseStyle(style) });
      } else if (close) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMsg);
    }
    return chunks.join("");
  };
});

// ../../node_modules/@pm2/agent/node_modules/chalk/source/index.js
var require_source2 = __commonJS((exports2, module2) => {
  var Chalk = function(options2) {
    return chalkFactory(options2);
  };
  var ansiStyles = require_ansi_styles();
  var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
  var {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  } = require_util2();
  var levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  var styles = Object.create(null);
  var applyOptions = (object, options2 = {}) => {
    if (options2.level > 3 || options2.level < 0) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options2.level === undefined ? colorLevel : options2.level;
  };

  class ChalkClass {
    constructor(options2) {
      return chalkFactory(options2);
    }
  }
  var chalkFactory = (options2) => {
    const chalk2 = {};
    applyOptions(chalk2, options2);
    chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
    Object.setPrototypeOf(chalk2, Chalk.prototype);
    Object.setPrototypeOf(chalk2.template, chalk2);
    chalk2.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    };
    chalk2.template.Instance = ChalkClass;
    return chalk2.template;
  };
  for (const [styleName, style] of Object.entries(ansiStyles)) {
    styles[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
        Object.defineProperty(this, styleName, { value: builder });
        return builder;
      }
    };
  }
  styles.visible = {
    get() {
      const builder = createBuilder(this, this._styler, true);
      Object.defineProperty(this, "visible", { value: builder });
      return builder;
    }
  };
  var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const model of usedModels) {
    styles[model] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  for (const model of usedModels) {
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, {
    ...styles,
    level: {
      enumerable: true,
      get() {
        return this._generator.level;
      },
      set(level) {
        this._generator.level = level;
      }
    }
  });
  var createStyler = (open, close, parent) => {
    let openAll;
    let closeAll;
    if (parent === undefined) {
      openAll = open;
      closeAll = close;
    } else {
      openAll = parent.openAll + open;
      closeAll = close + parent.closeAll;
    }
    return {
      open,
      close,
      openAll,
      closeAll,
      parent
    };
  };
  var createBuilder = (self2, _styler, _isEmpty) => {
    const builder = (...arguments_) => {
      return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    };
    builder.__proto__ = proto;
    builder._generator = self2;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
  };
  var applyStyle = (self2, string) => {
    if (self2.level <= 0 || !string) {
      return self2._isEmpty ? "" : string;
    }
    let styler = self2._styler;
    if (styler === undefined) {
      return string;
    }
    const { openAll, closeAll } = styler;
    if (string.indexOf("\x1B") !== -1) {
      while (styler !== undefined) {
        string = stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  };
  var template;
  var chalkTag = (chalk2, ...strings) => {
    const [firstString] = strings;
    if (!Array.isArray(firstString)) {
      return strings.join(" ");
    }
    const arguments_ = strings.slice(1);
    const parts = [firstString.raw[0]];
    for (let i = 1;i < firstString.length; i++) {
      parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
    }
    if (template === undefined) {
      template = require_templates2();
    }
    return template(chalk2, parts.join(""));
  };
  Object.defineProperties(Chalk.prototype, styles);
  var chalk = Chalk();
  chalk.supportsColor = stdoutColor;
  chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
  chalk.stderr.supportsColor = stderrColor;
  chalk.Level = {
    None: 0,
    Basic: 1,
    Ansi256: 2,
    TrueColor: 3,
    0: "None",
    1: "Basic",
    2: "Ansi256",
    3: "TrueColor"
  };
  module2.exports = chalk;
});

// ../../node_modules/@pm2/agent/constants.js
var require_constants4 = __commonJS((exports2, module2) => {
  var path2 = __require("path");
  var PM2_HOME;
  if (process.env.PM2_HOME) {
    PM2_HOME = process.env.PM2_HOME;
  } else if (process.env.HOME && !process.env.HOMEPATH) {
    PM2_HOME = path2.resolve(process.env.HOME, ".pm2");
  } else if (process.env.HOME || process.env.HOMEPATH) {
    PM2_HOME = path2.resolve(process.env.HOMEDRIVE, process.env.HOME || process.env.HOMEPATH, ".pm2");
  } else {
    PM2_HOME = path2.resolve("/etc", ".pm2");
  }
  var getUniqueId = () => {
    var s = [];
    var hexDigits = "0123456789abcdef";
    for (var i = 0;i < 36; i++) {
      s[i] = hexDigits.substr(Math.floor(Math.random() * 16), 1);
    }
    s[14] = "4";
    s[19] = hexDigits.substr(s[19] & 3 | 8, 1);
    s[8] = s[13] = s[18] = s[23] = "-";
    return s.join("");
  };
  var useIfDefined = (value, fallback) => {
    if (typeof value === "undefined") {
      return fallback;
    } else {
      return value === "true";
    }
  };
  var cst = {
    DEBUG: process.env.PM2_DEBUG || false,
    KEYMETRICS_ROOT_URL: process.env.KEYMETRICS_NODE || "https://root.keymetrics.io",
    PROTOCOL_VERSION: 1,
    COMPRESS_PROTOCOL: false,
    STATUS_INTERVAL: 1000,
    PACKET_QUEUE_SIZE: 200,
    PROXY: process.env.PM2_PROXY,
    LOGS_BUFFER: 8,
    CONTEXT_ON_ERROR: 4,
    TRANSACTION_FLUSH_INTERVAL: useIfDefined(process.env.PM2_DEBUG, false) ? 1000 : 30000,
    AGGREGATION_DURATION: useIfDefined(process.env.PM2_DEBUG, false) ? 0 : 60 * 10,
    TRACE_FLUSH_INTERVAL: useIfDefined(process.env.PM2_DEBUG, false) ? 1000 : 60000,
    PM2_HOME,
    DAEMON_RPC_PORT: path2.resolve(PM2_HOME, "rpc.sock"),
    DAEMON_PUB_PORT: path2.resolve(PM2_HOME, "pub.sock"),
    INTERACTOR_RPC_PORT: path2.resolve(PM2_HOME, "interactor.sock"),
    INTERACTOR_LOG_FILE_PATH: path2.resolve(PM2_HOME, "agent.log"),
    INTERACTOR_PID_PATH: path2.resolve(PM2_HOME, "agent.pid"),
    INTERACTION_CONF: path2.resolve(PM2_HOME, "agent.json5"),
    DUMP_FILE_PATH: path2.resolve(PM2_HOME, "dump.pm2"),
    UNIQUE_SERVER_ID: getUniqueId(),
    ENABLE_CONTEXT_ON_ERROR: useIfDefined(process.env.PM2_AGENT_ENABLE_CONTEXT_ON_ERROR, true),
    SUCCESS_EXIT: 0,
    ERROR_EXIT: 1
  };
  var keys3 = Object.keys(cst);
  keys3.forEach((key) => {
    var envKey = key.indexOf("PM2_") > -1 ? key : "PM2_" + key;
    if (process.env[envKey] && key !== "PM2_HOME" && key !== "PM2_ROOT_PATH") {
      cst[key] = process.env[envKey];
    }
  });
  if (process.platform === "win32" || process.platform === "win64") {
    cst.DAEMON_RPC_PORT = "\\\\.\\pipe\\rpc.sock";
    cst.DAEMON_PUB_PORT = "\\\\.\\pipe\\pub.sock";
    cst.INTERACTOR_RPC_PORT = "\\\\.\\pipe\\interactor.sock";
  }
  module2.exports = cst;
});

// ../../node_modules/@pm2/agent/src/InteractorClient.js
var require_InteractorClient = __commonJS((exports2, module2) => {
  var log = require_src()("interactor:client");
  var fs = __require("fs");
  var path2 = __require("path");
  var rpc = require_pm2_axon_rpc();
  var axon = require_lib2();
  var chalk = require_source2();
  var os = __require("os");
  var constants = require_constants4();
  var childProcess = __require("child_process");
  var printError = function(msg) {
    if (process.env.PM2_SILENT || process.env.PM2_PROGRAMMATIC)
      return false;
    if (msg instanceof Error)
      return console.error(msg.message);
    return console.error.apply(console, arguments);
  };
  var printOut = function(msg) {
    if (process.env.PM2_SILENT || process.env.PM2_PROGRAMMATIC)
      return false;
    return console.log.apply(console, arguments);
  };
  module2.exports = class InteractorDaemonizer {
    static ping(opts, cb) {
      if (typeof cb !== "function") {
        throw new Error("Missing parameters");
      } else if (typeof opts !== "object" || !opts || !opts.INTERACTOR_RPC_PORT) {
        return cb(new Error("Missing parameters"));
      }
      const req = axon.socket("req");
      const client = new rpc.Client(req);
      log("[PING INTERACTOR] Trying to connect to Interactor daemon");
      client.sock.once("reconnect attempt", (_) => {
        client.sock.close();
        log("Interactor Daemon not launched");
        return cb(null, false);
      });
      client.sock.once("connect", (_) => {
        client.sock.once("close", (_2) => {
          return cb(null, true);
        });
        client.sock.close();
        log("Interactor Daemon alive");
      });
      client.sock.once("error", (e) => {
        if (e.code === "EACCES") {
          fs.stat(opts.INTERACTOR_RPC_PORT, (e2, stats) => {
            if (stats.uid === 0) {
              console.error("Permission denied, activate current user");
              return process.exit(1);
            }
          });
        } else {
          console.error("unexpected error");
          console.error(e);
        }
      });
      req.connect(opts.INTERACTOR_RPC_PORT);
    }
    static killInteractorDaemon(conf2, cb) {
      process.env.PM2_INTERACTOR_PROCESSING = true;
      log("Killing interactor #1 ping");
      this.ping(conf2, (err, online) => {
        log(`Interactor is ${!online || err ? "offline" : "online"}`);
        if (!online || err) {
          return cb ? err ? cb(err) : cb(new Error("Interactor not launched")) : printError("Interactor not launched");
        }
        this.launchRPC(conf2, (err2, data) => {
          if (err2) {
            setTimeout((_) => {
              this.disconnectRPC(cb);
            }, 100);
            return false;
          }
          this.rpc.kill((err3) => {
            if (err3)
              printError(err3);
            setTimeout((_) => {
              this.disconnectRPC(cb);
            }, 100);
          });
          return false;
        });
        return false;
      });
    }
    static launchRPC(conf2, cb) {
      const req = axon.socket("req");
      this.rpc = {};
      this.client = new rpc.Client(req);
      log("Generating Interactor methods of RPC client");
      const generateMethods = (cb2) => {
        this.client.methods((err, methods) => {
          if (err)
            return cb2(err);
          Object.keys(methods).forEach((key) => {
            let method = methods[key];
            log("+ Adding %s method to interactor RPC client", method.name);
            ((name2) => {
              let self2 = this;
              this.rpc[name2] = function() {
                let args2 = Array.prototype.slice.call(arguments);
                args2.unshift(name2);
                self2.client.call.apply(self2.client, args2);
              };
            })(method.name);
          });
          return cb2();
        });
      };
      this.client.sock.once("reconnect attempt", (err) => {
        this.client.sock.removeAllListeners();
        return cb(err, { success: false, msg: "reconnect attempt" });
      });
      this.client.sock.once("error", (err) => {
        log("-- Error in error catch all on Interactor --", err);
        return cb(err, { success: false, msg: "reconnect attempt" });
      });
      this.client.sock.once("connect", () => {
        this.client.sock.removeAllListeners();
        generateMethods((_) => {
          log("Methods of RPC client for Interaction ready.");
          return cb(null, { success: true });
        });
      });
      this.client_sock = req.connect(conf2.INTERACTOR_RPC_PORT);
    }
    static daemonize(cst, conf2, cb) {
      const InteractorJS = path2.resolve(path2.dirname("InteractorClient.js"), "InteractorDaemon.js");
      const PM2Path = __require.main.filename;
      const testEnv = process.env.TRAVIS || "production".match(/test/);
      const out = testEnv ? 1 : fs.openSync(constants.INTERACTOR_LOG_FILE_PATH, "a");
      const err = testEnv ? 2 : fs.openSync(constants.INTERACTOR_LOG_FILE_PATH, "a");
      let binary = process.execPath;
      if (binary.indexOf("node") === -1) {
        binary = "node";
      }
      if (process.env.NODEJS_EXECUTABLE) {
        binary = process.env.NODEJS_EXECUTABLE;
      }
      const child = childProcess.spawn(binary, [InteractorJS], {
        silent: false,
        detached: true,
        cwd: process.cwd(),
        env: Object.assign({
          PM2_HOME: cst.PM2_HOME,
          PM2_MACHINE_NAME: conf2.machine_name,
          PM2_SECRET_KEY: conf2.secret_key,
          PM2_PUBLIC_KEY: conf2.public_key,
          PM2_REVERSE_INTERACT: conf2.reverse_interact,
          PM2_BINARY_PATH: PM2Path,
          KEYMETRICS_NODE: conf2.info_node,
          PM2_VERSION: conf2.pm2_version,
          DEBUG: process.env.DEBUG || "interactor:*,-interactor:axon,-interactor:websocket,-interactor:pm2:client,-interactor:push"
        }, process.env),
        stdio: ["ipc", out, err]
      });
      try {
        let prevPid = fs.readFileSync(constants.INTERACTOR_PID_PATH);
        prevPid = parseInt(prevPid);
        process.kill(prevPid);
      } catch (e) {
      }
      let pid = "";
      if (child.pid)
        pid = child.pid.toString();
      fs.writeFileSync(cst.INTERACTOR_PID_PATH, pid);
      child.on("close", (status) => {
        if (status === constants.ERROR_EXIT) {
          return cb(new Error("Agent has shutdown for unknown reason"));
        }
        return cb();
      });
      child.once("error", (err2) => {
        log("Error when launching Interactor, please check the agent logs");
        return cb(err2);
      });
      child.unref();
      const timeout = setTimeout((_) => {
        printOut(`${chalk.yellow("[PM2.IO][WARNING]")} Not managed to connect to PM2 Plus, retrying in background.`);
        child.removeAllListeners();
        child.disconnect();
        return cb(null, {}, child);
      }, 7000);
      child.once("message", (msg) => {
        clearTimeout(timeout);
        log("Interactor daemon launched :", msg);
        if (msg.log) {
          return cb(null, msg, child);
        }
        child.removeAllListeners("error");
        child.disconnect();
        if (msg.km_data && msg.km_data.error === true) {
          if (!process.env.PM2_SILENT) {
            console.log(chalk.red("[PM2.IO][ERROR]"), msg.km_data.msg);
            console.log(chalk.cyan("[PM2.IO]") + " Contact support contact@keymetrics.io and send us the error message");
          }
          return cb(msg);
        } else if (msg.km_data && msg.km_data.disabled === true) {
          if (!process.env.PM2_SILENT) {
            console.log(chalk.cyan("[PM2.IO]") + " Server DISABLED BY ADMINISTRATION contact support contact@keymetrics.io with reference to your public and secret keys)");
          }
          return cb(msg);
        } else if (msg.km_data && msg.km_data.error === true) {
          if (!process.env.PM2_SILENT) {
            console.log("%s %s (Public: %s) (Secret: %s) (Machine name: %s)", chalk.red("[PM2.IO][ERROR]"), msg.km_data.msg, msg.public_key, msg.secret_key, msg.machine_name);
          }
          return cb(msg);
        } else if (msg.km_data && msg.km_data.active === false && msg.km_data.pending === true) {
          if (!process.env.PM2_SILENT) {
            console.log("%s You must upgrade your bucket in order to monitor more servers.", chalk.red("[PM2.IO]"));
          }
          return cb(msg);
        }
        return cb(null, msg, child);
      });
    }
    static launchOrAttach(conf2, infos, cb) {
      this.ping(conf2, (err, online) => {
        if (!err && online) {
          log("Interactor online, restarting it...");
          this.launchRPC(conf2, (_) => {
            this.rpc.kill((ignoredErr) => {
              this.daemonize(conf2, infos, cb);
            });
          });
        } else {
          log("Interactor offline, launching it...");
          this.daemonize(conf2, infos, cb);
        }
      });
    }
    static update(conf2, cb) {
      this.ping(conf2, (err, online) => {
        if (err || !online) {
          return cb ? cb(new Error("Interactor not launched")) : printError("Interactor not launched");
        }
        this.launchRPC(conf2, (_) => {
          this.rpc.kill((err2) => {
            if (err2) {
              return cb ? cb(err2) : printError(err2);
            }
            printOut("Interactor successfully killed");
            setTimeout((_2) => {
              this.launchAndInteract(conf2, {}, (_3) => {
                return cb(null, { msg: "Daemon launched" });
              });
            }, 500);
          });
        });
      });
    }
    static getOrSetConf(cst, infos, cb) {
      infos = infos || {};
      let configuration = {
        version_management: {
          active: true
        }
      };
      let confFS = {};
      try {
        let fileContent = fs.readFileSync(cst.INTERACTION_CONF).toString();
        fileContent = fileContent.replace(/\s(\w+):/g, '"$1":');
        confFS = JSON.parse(fileContent);
        if (confFS.version_management) {
          configuration.version_management.active = confFS.version_management.active;
        }
      } catch (e) {
        log("Interaction file does not exists");
      }
      configuration.public_key = process.env.PM2_PUBLIC_KEY || process.env.KEYMETRICS_PUBLIC || infos.public_key || confFS.public_key;
      configuration.secret_key = process.env.PM2_SECRET_KEY || process.env.KEYMETRICS_SECRET || infos.secret_key || confFS.secret_key;
      configuration.machine_name = process.env.PM2_MACHINE_NAME || process.env.INSTANCE_NAME || infos.machine_name || confFS.machine_name || `${os.hostname()}-${__require("crypto").randomBytes(2).toString("hex")}`;
      configuration.pm2_version = process.env.PM2_VERSION || infos.pm2_version || confFS.pm2_version;
      configuration.reverse_interact = confFS.reverse_interact || true;
      configuration.info_node = process.env.KEYMETRICS_NODE || infos.info_node || confFS.info_node || cst.KEYMETRICS_ROOT_URL;
      if (!configuration.secret_key) {
        log("Secret key is not defined in configuration", configuration);
        return cb(new Error("secret key is not defined"));
      }
      if (!configuration.public_key) {
        log("Public key is not defined in configuration", configuration);
        return cb(new Error("public key is not defined"));
      }
      try {
        fs.writeFileSync(cst.INTERACTION_CONF, JSON.stringify(configuration, null, 4));
      } catch (e) {
        console.error("Error when writting configuration file %s", cst.INTERACTION_CONF);
        return cb(e);
      }
      if (configuration.info_node.indexOf("http") === -1) {
        configuration.info_node = `https://${configuration.info_node}`;
      }
      return cb(null, configuration);
    }
    static disconnectRPC(cb) {
      log("Disconnect RPC");
      if (!this.client_sock || !this.client_sock.close) {
        log("RPC not launched");
        return cb(null, {
          success: false,
          msg: "RPC connection to Interactor Daemon is not launched"
        });
      }
      if (this.client_sock.closing === true) {
        log("RPC already closed");
        return cb(null, {
          success: false,
          msg: "RPC closed"
        });
      }
      try {
        let timer;
        log("Closing RPC INTERACTOR");
        this.client_sock.once("close", (_) => {
          log("RPC INTERACTOR cleanly closed");
          clearTimeout(timer);
          return cb ? cb(null, { success: true }) : false;
        });
        timer = setTimeout((_) => {
          if (this.client_sock.destroy) {
            this.client_sock.destroy();
          }
          return cb ? cb(null, { success: true }) : false;
        }, 200);
        this.client_sock.close();
      } catch (err) {
        log("Error while closing RPC INTERACTOR : %s", err.message || err);
        return cb ? cb(err) : false;
      }
    }
    static launchAndInteract(cst, opts, cb) {
      if (process.env.PM2_AGENT_ONLINE) {
        return cb();
      }
      process.env.PM2_INTERACTOR_PROCESSING = true;
      this.getOrSetConf(Object.assign(cst, constants), opts, (err, conf2) => {
        if (err || !conf2)
          return cb(err || new Error("Cant retrieve configuration"));
        if (!process.env.PM2_SILENT) {
          console.log(chalk.cyan("[PM2 I/O]") + " Using: Public key: %s | Private key: %s | Machine name: %s", conf2.public_key, conf2.secret_key, conf2.machine_name);
        }
        return this.launchOrAttach(cst, conf2, cb);
      });
    }
    static getInteractInfo(cst, cb) {
      log("Getting interaction info");
      if (process.env.PM2_NO_INTERACTION)
        return cb(new Error("PM2_NO_INTERACTION set"));
      this.ping(cst, (err, online) => {
        if (err || !online)
          return cb(new Error("Interactor is offline"));
        this.launchRPC(cst, (_) => {
          this.rpc.getInfos((err2, infos) => {
            if (err2)
              return cb(err2);
            if (process.env.PM2_INTERACTOR_PROCESSING)
              return cb(null, infos);
            this.disconnectRPC(() => {
              return cb(null, infos);
            });
          });
        });
      });
    }
  };
});

// ../../node_modules/async/eachOf.js
var require_eachOf = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachOfArrayLike = function(coll, iteratee, callback) {
    callback = (0, _once2.default)(callback);
    var index = 0, completed = 0, { length: length3 } = coll, canceled = false;
    if (length3 === 0) {
      callback(null);
    }
    function iteratorCallback(err, value) {
      if (err === false) {
        canceled = true;
      }
      if (canceled === true)
        return;
      if (err) {
        callback(err);
      } else if (++completed === length3 || value === _breakLoop2.default) {
        callback(null);
      }
    }
    for (;index < length3; index++) {
      iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
    }
  };
  var eachOfGeneric = function(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
  };
  var eachOf = function(coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  var _eachOfLimit = require_eachOfLimit2();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _once = require_once();
  var _once2 = _interopRequireDefault(_once);
  var _onlyOnce = require_onlyOnce();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports2.default = (0, _awaitify2.default)(eachOf, 3);
  module2.exports = exports2.default;
});

// ../../node_modules/async/forEach.js
var require_forEach = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachLimit = function(coll, iteratee, callback) {
    return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _eachOf = require_eachOf();
  var _eachOf2 = _interopRequireDefault(_eachOf);
  var _withoutIndex = require_withoutIndex();
  var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports2.default = (0, _awaitify2.default)(eachLimit, 3);
  module2.exports = exports2.default;
});

// ../../node_modules/async/waterfall.js
var require_waterfall = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var waterfall = function(tasks, callback) {
    callback = (0, _once2.default)(callback);
    if (!Array.isArray(tasks))
      return callback(new Error("First argument to waterfall must be an array of functions"));
    if (!tasks.length)
      return callback();
    var taskIndex = 0;
    function nextTask(args2) {
      var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);
      task(...args2, (0, _onlyOnce2.default)(next));
    }
    function next(err, ...args2) {
      if (err === false)
        return;
      if (err || taskIndex === tasks.length) {
        return callback(err, ...args2);
      }
      nextTask(args2);
    }
    nextTask([]);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _once = require_once();
  var _once2 = _interopRequireDefault(_once);
  var _onlyOnce = require_onlyOnce();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports2.default = (0, _awaitify2.default)(waterfall);
  module2.exports = exports2.default;
});

// ../../node_modules/pm2/lib/tools/find-package-json.js
var require_find_package_json = __commonJS((exports2, module2) => {
  var parse2 = function(data) {
    data = data.toString("utf-8");
    if (data.charCodeAt(0) === 65279)
      data = data.slice(1);
    try {
      return JSON.parse(data);
    } catch (e) {
      return false;
    }
  };
  var path2 = __require("path");
  var fs = __require("fs");
  module2.exports = function find(root) {
    root = root || process.cwd();
    if (typeof root !== "string") {
      if (typeof root === "object" && typeof root.filename === "string") {
        root = root.filename;
      } else {
        throw new Error("Must pass a filename string or a module object to finder");
      }
    }
    return {
      next: function next() {
        if (root.match(/^(\w:\\|\/)$/))
          return {
            value: undefined,
            filename: undefined,
            done: true
          };
        var file = path2.join(root, "package.json"), data;
        root = path2.resolve(root, "..");
        if (fs.existsSync(file) && (data = parse2(fs.readFileSync(file)))) {
          data.__path = file;
          return {
            value: data,
            filename: file,
            done: false
          };
        }
        return next();
      }
    };
  };
});

// ../../node_modules/pm2/lib/Utility.js
var require_Utility = __commonJS((exports2, module2) => {
  var fclone = require_fclone();
  var fs = __require("fs");
  var cst = require_constants2();
  var waterfall = require_waterfall();
  var util = __require("util");
  var url = __require("url");
  var dayjs = require_dayjs_min();
  var findPackageJson = require_find_package_json();
  var Utility = module2.exports = {
    findPackageVersion: function(fullpath) {
      var version3;
      try {
        version3 = findPackageJson(fullpath).next().value.version;
      } catch (e) {
        version3 = "N/A";
      }
      return version3;
    },
    getDate: function() {
      return Date.now();
    },
    extendExtraConfig: function(proc, opts) {
      if (opts.env && opts.env.current_conf) {
        if (opts.env.current_conf.env && typeof opts.env.current_conf.env === "object" && Object.keys(opts.env.current_conf.env).length === 0)
          delete opts.env.current_conf.env;
        Utility.extendMix(proc.pm2_env, opts.env.current_conf);
        delete opts.env.current_conf;
      }
    },
    formatCLU: function(process2) {
      if (!process2.pm2_env) {
        return process2;
      }
      var obj = Utility.clone(process2.pm2_env);
      delete obj.env;
      return obj;
    },
    extend: function(destination, source) {
      if (!source || typeof source != "object")
        return destination;
      Object.keys(source).forEach(function(new_key) {
        if (source[new_key] != "[object Object]")
          destination[new_key] = source[new_key];
      });
      return destination;
    },
    extendMix: function(destination, source) {
      if (!source || typeof source != "object")
        return destination;
      Object.keys(source).forEach(function(new_key) {
        if (source[new_key] == "null")
          delete destination[new_key];
        else
          destination[new_key] = source[new_key];
      });
      return destination;
    },
    whichFileExists: function(file_arr) {
      var f = null;
      file_arr.some(function(file) {
        try {
          fs.statSync(file);
        } catch (e) {
          return false;
        }
        f = file;
        return true;
      });
      return f;
    },
    clone: function(obj) {
      if (obj === null || obj === undefined)
        return {};
      return fclone(obj);
    },
    overrideConsole: function(bus) {
      if (cst.PM2_LOG_DATE_FORMAT && typeof cst.PM2_LOG_DATE_FORMAT == "string") {
        let timestamp2 = function() {
          return `${dayjs(Date.now()).format(cst.PM2_LOG_DATE_FORMAT)}:`;
        };
        var timestamp = timestamp2;
        var hacks = ["info", "log", "error", "warn"], consoled = {};
        hacks.forEach(function(method) {
          consoled[method] = console[method];
        });
        hacks.forEach(function(k) {
          console[k] = function() {
            if (bus) {
              bus.emit("log:PM2", {
                process: {
                  pm_id: "PM2",
                  name: "PM2",
                  rev: null
                },
                at: Utility.getDate(),
                data: util.format.apply(this, arguments) + "\n"
              });
            }
            arguments[0] && (arguments[0] = timestamp2() + " PM2 " + k + ": " + arguments[0]);
            consoled[k].apply(console, arguments);
          };
        });
      }
    },
    startLogging: function(stds, callback) {
      var flows = [];
      var types2 = Object.keys(stds).sort(function(x, y) {
        return -x.charCodeAt(0) + y.charCodeAt(0);
      });
      (function createWS(io) {
        if (io.length != 1) {
          return false;
        }
        io = io[0];
        if (typeof stds[io] == "object" && !isNaN(stds[io].fd)) {
          return createWS(types2.splice(0, 1));
        }
        flows.push(function(next) {
          var file = stds[io];
          if (!file || file.indexOf("NULL") > -1 || file.indexOf("/dev/null") > -1)
            return next();
          stds[io] = fs.createWriteStream(file, { flags: "a" }).once("error", next).on("open", function() {
            stds[io].removeListener("error", next);
            stds[io].on("error", function(err) {
              console.error(err);
            });
            next();
          });
          stds[io]._file = file;
        });
        return createWS(types2.splice(0, 1));
      })(types2.splice(0, 1));
      waterfall(flows, callback);
    },
    getCanonicModuleName: function(module_name) {
      if (typeof module_name !== "string")
        return null;
      var canonic_module_name = module_name;
      if (canonic_module_name.match(/\.tgz($|\?)/)) {
        if (canonic_module_name.match(/^(.+\/)?([^\/]+)\.tgz($|\?)/)) {
          canonic_module_name = canonic_module_name.match(/^(.+\/)?([^\/]+)\.tgz($|\?)/)[2];
          if (canonic_module_name.match(/^(.+)-[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9_]+\.[0-9]+)?$/)) {
            canonic_module_name = canonic_module_name.match(/^(.+)-[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9_]+\.[0-9]+)?$/)[1];
          }
        }
      }
      if (canonic_module_name.indexOf("git+") !== -1) {
        canonic_module_name = canonic_module_name.split("/").pop();
      }
      if (canonic_module_name.indexOf("http") !== -1) {
        var uri = url.parse(canonic_module_name);
        canonic_module_name = uri.pathname.split("/").pop();
      } else if (canonic_module_name.indexOf("file://") === 0) {
        canonic_module_name = canonic_module_name.replace(/\/$/, "").split("/").pop();
      } else if (canonic_module_name.indexOf("/") !== -1) {
        if (canonic_module_name.charAt(0) !== "@") {
          canonic_module_name = canonic_module_name.split("/")[1];
        }
      }
      if (canonic_module_name.lastIndexOf("@") > 0) {
        canonic_module_name = canonic_module_name.substr(0, canonic_module_name.lastIndexOf("@"));
      }
      if (canonic_module_name.indexOf("#") !== -1) {
        canonic_module_name = canonic_module_name.split("#")[0];
      }
      if (canonic_module_name.indexOf(".git") !== -1) {
        canonic_module_name = canonic_module_name.replace(".git", "");
      }
      return canonic_module_name;
    },
    checkPathIsNull: function(path2) {
      return path2 === "NULL" || path2 === "/dev/null" || path2 === "\\\\.\\NUL";
    },
    generateUUID: function() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0;i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 16), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr(s[19] & 3 | 8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      return s.join("");
    }
  };
});

// ../../node_modules/eventemitter2/lib/eventemitter2.js
var require_eventemitter2 = __commonJS((exports2, module2) => {
  /*!
   * EventEmitter2
   * https://github.com/hij1nx/EventEmitter2
   *
   * Copyright (c) 2013 hij1nx
   * Licensed under the MIT license.
   */
  (function(undefined2) {
    var isArray2 = Array.isArray ? Array.isArray : function _isArray(obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    };
    var defaultMaxListeners = 10;
    function init2() {
      this._events = {};
      if (this._conf) {
        configure.call(this, this._conf);
      }
    }
    function configure(conf2) {
      if (conf2) {
        this._conf = conf2;
        conf2.delimiter && (this.delimiter = conf2.delimiter);
        this._maxListeners = conf2.maxListeners !== undefined2 ? conf2.maxListeners : defaultMaxListeners;
        conf2.wildcard && (this.wildcard = conf2.wildcard);
        conf2.newListener && (this._newListener = conf2.newListener);
        conf2.removeListener && (this._removeListener = conf2.removeListener);
        conf2.verboseMemoryLeak && (this.verboseMemoryLeak = conf2.verboseMemoryLeak);
        if (this.wildcard) {
          this.listenerTree = {};
        }
      } else {
        this._maxListeners = defaultMaxListeners;
      }
    }
    function logPossibleMemoryLeak(count, eventName) {
      var errorMsg = "(node) warning: possible EventEmitter memory " + "leak detected. " + count + " listeners added. " + "Use emitter.setMaxListeners() to increase limit.";
      if (this.verboseMemoryLeak) {
        errorMsg += " Event name: " + eventName + ".";
      }
      if (typeof process !== "undefined" && process.emitWarning) {
        var e = new Error(errorMsg);
        e.name = "MaxListenersExceededWarning";
        e.emitter = this;
        e.count = count;
        process.emitWarning(e);
      } else {
        console.error(errorMsg);
        if (console.trace) {
          console.trace();
        }
      }
    }
    function EventEmitter(conf2) {
      this._events = {};
      this._newListener = false;
      this._removeListener = false;
      this.verboseMemoryLeak = false;
      configure.call(this, conf2);
    }
    EventEmitter.EventEmitter2 = EventEmitter;
    function searchListenerTree(handlers, type2, tree, i) {
      if (!tree) {
        return [];
      }
      var listeners = [], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached, typeLength = type2.length, currentType = type2[i], nextType = type2[i + 1];
      if (i === typeLength && tree._listeners) {
        if (typeof tree._listeners === "function") {
          handlers && handlers.push(tree._listeners);
          return [tree];
        } else {
          for (leaf = 0, len = tree._listeners.length;leaf < len; leaf++) {
            handlers && handlers.push(tree._listeners[leaf]);
          }
          return [tree];
        }
      }
      if (currentType === "*" || currentType === "**" || tree[currentType]) {
        if (currentType === "*") {
          for (branch in tree) {
            if (branch !== "_listeners" && tree.hasOwnProperty(branch)) {
              listeners = listeners.concat(searchListenerTree(handlers, type2, tree[branch], i + 1));
            }
          }
          return listeners;
        } else if (currentType === "**") {
          endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === "*";
          if (endReached && tree._listeners) {
            listeners = listeners.concat(searchListenerTree(handlers, type2, tree, typeLength));
          }
          for (branch in tree) {
            if (branch !== "_listeners" && tree.hasOwnProperty(branch)) {
              if (branch === "*" || branch === "**") {
                if (tree[branch]._listeners && !endReached) {
                  listeners = listeners.concat(searchListenerTree(handlers, type2, tree[branch], typeLength));
                }
                listeners = listeners.concat(searchListenerTree(handlers, type2, tree[branch], i));
              } else if (branch === nextType) {
                listeners = listeners.concat(searchListenerTree(handlers, type2, tree[branch], i + 2));
              } else {
                listeners = listeners.concat(searchListenerTree(handlers, type2, tree[branch], i));
              }
            }
          }
          return listeners;
        }
        listeners = listeners.concat(searchListenerTree(handlers, type2, tree[currentType], i + 1));
      }
      xTree = tree["*"];
      if (xTree) {
        searchListenerTree(handlers, type2, xTree, i + 1);
      }
      xxTree = tree["**"];
      if (xxTree) {
        if (i < typeLength) {
          if (xxTree._listeners) {
            searchListenerTree(handlers, type2, xxTree, typeLength);
          }
          for (branch in xxTree) {
            if (branch !== "_listeners" && xxTree.hasOwnProperty(branch)) {
              if (branch === nextType) {
                searchListenerTree(handlers, type2, xxTree[branch], i + 2);
              } else if (branch === currentType) {
                searchListenerTree(handlers, type2, xxTree[branch], i + 1);
              } else {
                isolatedBranch = {};
                isolatedBranch[branch] = xxTree[branch];
                searchListenerTree(handlers, type2, { "**": isolatedBranch }, i + 1);
              }
            }
          }
        } else if (xxTree._listeners) {
          searchListenerTree(handlers, type2, xxTree, typeLength);
        } else if (xxTree["*"] && xxTree["*"]._listeners) {
          searchListenerTree(handlers, type2, xxTree["*"], typeLength);
        }
      }
      return listeners;
    }
    function growListenerTree(type2, listener) {
      type2 = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
      for (var i = 0, len = type2.length;i + 1 < len; i++) {
        if (type2[i] === "**" && type2[i + 1] === "**") {
          return;
        }
      }
      var tree = this.listenerTree;
      var name2 = type2.shift();
      while (name2 !== undefined2) {
        if (!tree[name2]) {
          tree[name2] = {};
        }
        tree = tree[name2];
        if (type2.length === 0) {
          if (!tree._listeners) {
            tree._listeners = listener;
          } else {
            if (typeof tree._listeners === "function") {
              tree._listeners = [tree._listeners];
            }
            tree._listeners.push(listener);
            if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
              tree._listeners.warned = true;
              logPossibleMemoryLeak.call(this, tree._listeners.length, name2);
            }
          }
          return true;
        }
        name2 = type2.shift();
      }
      return true;
    }
    EventEmitter.prototype.delimiter = ".";
    EventEmitter.prototype.setMaxListeners = function(n) {
      if (n !== undefined2) {
        this._maxListeners = n;
        if (!this._conf)
          this._conf = {};
        this._conf.maxListeners = n;
      }
    };
    EventEmitter.prototype.event = "";
    EventEmitter.prototype.once = function(event, fn) {
      return this._once(event, fn, false);
    };
    EventEmitter.prototype.prependOnceListener = function(event, fn) {
      return this._once(event, fn, true);
    };
    EventEmitter.prototype._once = function(event, fn, prepend) {
      this._many(event, 1, fn, prepend);
      return this;
    };
    EventEmitter.prototype.many = function(event, ttl, fn) {
      return this._many(event, ttl, fn, false);
    };
    EventEmitter.prototype.prependMany = function(event, ttl, fn) {
      return this._many(event, ttl, fn, true);
    };
    EventEmitter.prototype._many = function(event, ttl, fn, prepend) {
      var self2 = this;
      if (typeof fn !== "function") {
        throw new Error("many only accepts instances of Function");
      }
      function listener() {
        if (--ttl === 0) {
          self2.off(event, listener);
        }
        return fn.apply(this, arguments);
      }
      listener._origin = fn;
      this._on(event, listener, prepend);
      return self2;
    };
    EventEmitter.prototype.emit = function() {
      this._events || init2.call(this);
      var type2 = arguments[0];
      if (type2 === "newListener" && !this._newListener) {
        if (!this._events.newListener) {
          return false;
        }
      }
      var al = arguments.length;
      var args2, l, i, j;
      var handler;
      if (this._all && this._all.length) {
        handler = this._all.slice();
        if (al > 3) {
          args2 = new Array(al);
          for (j = 0;j < al; j++)
            args2[j] = arguments[j];
        }
        for (i = 0, l = handler.length;i < l; i++) {
          this.event = type2;
          switch (al) {
            case 1:
              handler[i].call(this, type2);
              break;
            case 2:
              handler[i].call(this, type2, arguments[1]);
              break;
            case 3:
              handler[i].call(this, type2, arguments[1], arguments[2]);
              break;
            default:
              handler[i].apply(this, args2);
          }
        }
      }
      if (this.wildcard) {
        handler = [];
        var ns = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
        searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
      } else {
        handler = this._events[type2];
        if (typeof handler === "function") {
          this.event = type2;
          switch (al) {
            case 1:
              handler.call(this);
              break;
            case 2:
              handler.call(this, arguments[1]);
              break;
            case 3:
              handler.call(this, arguments[1], arguments[2]);
              break;
            default:
              args2 = new Array(al - 1);
              for (j = 1;j < al; j++)
                args2[j - 1] = arguments[j];
              handler.apply(this, args2);
          }
          return true;
        } else if (handler) {
          handler = handler.slice();
        }
      }
      if (handler && handler.length) {
        if (al > 3) {
          args2 = new Array(al - 1);
          for (j = 1;j < al; j++)
            args2[j - 1] = arguments[j];
        }
        for (i = 0, l = handler.length;i < l; i++) {
          this.event = type2;
          switch (al) {
            case 1:
              handler[i].call(this);
              break;
            case 2:
              handler[i].call(this, arguments[1]);
              break;
            case 3:
              handler[i].call(this, arguments[1], arguments[2]);
              break;
            default:
              handler[i].apply(this, args2);
          }
        }
        return true;
      } else if (!this._all && type2 === "error") {
        if (arguments[1] instanceof Error) {
          throw arguments[1];
        } else {
          throw new Error("Uncaught, unspecified 'error' event.");
        }
        return false;
      }
      return !!this._all;
    };
    EventEmitter.prototype.emitAsync = function() {
      this._events || init2.call(this);
      var type2 = arguments[0];
      if (type2 === "newListener" && !this._newListener) {
        if (!this._events.newListener) {
          return Promise.resolve([false]);
        }
      }
      var promises = [];
      var al = arguments.length;
      var args2, l, i, j;
      var handler;
      if (this._all) {
        if (al > 3) {
          args2 = new Array(al);
          for (j = 1;j < al; j++)
            args2[j] = arguments[j];
        }
        for (i = 0, l = this._all.length;i < l; i++) {
          this.event = type2;
          switch (al) {
            case 1:
              promises.push(this._all[i].call(this, type2));
              break;
            case 2:
              promises.push(this._all[i].call(this, type2, arguments[1]));
              break;
            case 3:
              promises.push(this._all[i].call(this, type2, arguments[1], arguments[2]));
              break;
            default:
              promises.push(this._all[i].apply(this, args2));
          }
        }
      }
      if (this.wildcard) {
        handler = [];
        var ns = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
        searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
      } else {
        handler = this._events[type2];
      }
      if (typeof handler === "function") {
        this.event = type2;
        switch (al) {
          case 1:
            promises.push(handler.call(this));
            break;
          case 2:
            promises.push(handler.call(this, arguments[1]));
            break;
          case 3:
            promises.push(handler.call(this, arguments[1], arguments[2]));
            break;
          default:
            args2 = new Array(al - 1);
            for (j = 1;j < al; j++)
              args2[j - 1] = arguments[j];
            promises.push(handler.apply(this, args2));
        }
      } else if (handler && handler.length) {
        handler = handler.slice();
        if (al > 3) {
          args2 = new Array(al - 1);
          for (j = 1;j < al; j++)
            args2[j - 1] = arguments[j];
        }
        for (i = 0, l = handler.length;i < l; i++) {
          this.event = type2;
          switch (al) {
            case 1:
              promises.push(handler[i].call(this));
              break;
            case 2:
              promises.push(handler[i].call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler[i].call(this, arguments[1], arguments[2]));
              break;
            default:
              promises.push(handler[i].apply(this, args2));
          }
        }
      } else if (!this._all && type2 === "error") {
        if (arguments[1] instanceof Error) {
          return Promise.reject(arguments[1]);
        } else {
          return Promise.reject("Uncaught, unspecified 'error' event.");
        }
      }
      return Promise.all(promises);
    };
    EventEmitter.prototype.on = function(type2, listener) {
      return this._on(type2, listener, false);
    };
    EventEmitter.prototype.prependListener = function(type2, listener) {
      return this._on(type2, listener, true);
    };
    EventEmitter.prototype.onAny = function(fn) {
      return this._onAny(fn, false);
    };
    EventEmitter.prototype.prependAny = function(fn) {
      return this._onAny(fn, true);
    };
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prototype._onAny = function(fn, prepend) {
      if (typeof fn !== "function") {
        throw new Error("onAny only accepts instances of Function");
      }
      if (!this._all) {
        this._all = [];
      }
      if (prepend) {
        this._all.unshift(fn);
      } else {
        this._all.push(fn);
      }
      return this;
    };
    EventEmitter.prototype._on = function(type2, listener, prepend) {
      if (typeof type2 === "function") {
        this._onAny(type2, listener);
        return this;
      }
      if (typeof listener !== "function") {
        throw new Error("on only accepts instances of Function");
      }
      this._events || init2.call(this);
      if (this._newListener)
        this.emit("newListener", type2, listener);
      if (this.wildcard) {
        growListenerTree.call(this, type2, listener);
        return this;
      }
      if (!this._events[type2]) {
        this._events[type2] = listener;
      } else {
        if (typeof this._events[type2] === "function") {
          this._events[type2] = [this._events[type2]];
        }
        if (prepend) {
          this._events[type2].unshift(listener);
        } else {
          this._events[type2].push(listener);
        }
        if (!this._events[type2].warned && this._maxListeners > 0 && this._events[type2].length > this._maxListeners) {
          this._events[type2].warned = true;
          logPossibleMemoryLeak.call(this, this._events[type2].length, type2);
        }
      }
      return this;
    };
    EventEmitter.prototype.off = function(type2, listener) {
      if (typeof listener !== "function") {
        throw new Error("removeListener only takes instances of Function");
      }
      var handlers, leafs = [];
      if (this.wildcard) {
        var ns = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
        leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
      } else {
        if (!this._events[type2])
          return this;
        handlers = this._events[type2];
        leafs.push({ _listeners: handlers });
      }
      for (var iLeaf = 0;iLeaf < leafs.length; iLeaf++) {
        var leaf = leafs[iLeaf];
        handlers = leaf._listeners;
        if (isArray2(handlers)) {
          var position = -1;
          for (var i = 0, length3 = handlers.length;i < length3; i++) {
            if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
              position = i;
              break;
            }
          }
          if (position < 0) {
            continue;
          }
          if (this.wildcard) {
            leaf._listeners.splice(position, 1);
          } else {
            this._events[type2].splice(position, 1);
          }
          if (handlers.length === 0) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type2];
            }
          }
          if (this._removeListener)
            this.emit("removeListener", type2, listener);
          return this;
        } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
          if (this.wildcard) {
            delete leaf._listeners;
          } else {
            delete this._events[type2];
          }
          if (this._removeListener)
            this.emit("removeListener", type2, listener);
        }
      }
      function recursivelyGarbageCollect(root) {
        if (root === undefined2) {
          return;
        }
        var keys3 = Object.keys(root);
        for (var i2 in keys3) {
          var key = keys3[i2];
          var obj = root[key];
          if (obj instanceof Function || typeof obj !== "object" || obj === null)
            continue;
          if (Object.keys(obj).length > 0) {
            recursivelyGarbageCollect(root[key]);
          }
          if (Object.keys(obj).length === 0) {
            delete root[key];
          }
        }
      }
      recursivelyGarbageCollect(this.listenerTree);
      return this;
    };
    EventEmitter.prototype.offAny = function(fn) {
      var i = 0, l = 0, fns;
      if (fn && this._all && this._all.length > 0) {
        fns = this._all;
        for (i = 0, l = fns.length;i < l; i++) {
          if (fn === fns[i]) {
            fns.splice(i, 1);
            if (this._removeListener)
              this.emit("removeListenerAny", fn);
            return this;
          }
        }
      } else {
        fns = this._all;
        if (this._removeListener) {
          for (i = 0, l = fns.length;i < l; i++)
            this.emit("removeListenerAny", fns[i]);
        }
        this._all = [];
      }
      return this;
    };
    EventEmitter.prototype.removeListener = EventEmitter.prototype.off;
    EventEmitter.prototype.removeAllListeners = function(type2) {
      if (type2 === undefined2) {
        !this._events || init2.call(this);
        return this;
      }
      if (this.wildcard) {
        var ns = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
        var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
        for (var iLeaf = 0;iLeaf < leafs.length; iLeaf++) {
          var leaf = leafs[iLeaf];
          leaf._listeners = null;
        }
      } else if (this._events) {
        this._events[type2] = null;
      }
      return this;
    };
    EventEmitter.prototype.listeners = function(type2) {
      if (this.wildcard) {
        var handlers = [];
        var ns = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
        searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
        return handlers;
      }
      this._events || init2.call(this);
      if (!this._events[type2])
        this._events[type2] = [];
      if (!isArray2(this._events[type2])) {
        this._events[type2] = [this._events[type2]];
      }
      return this._events[type2];
    };
    EventEmitter.prototype.eventNames = function() {
      return Object.keys(this._events);
    };
    EventEmitter.prototype.listenerCount = function(type2) {
      return this.listeners(type2).length;
    };
    EventEmitter.prototype.listenersAny = function() {
      if (this._all) {
        return this._all;
      } else {
        return [];
      }
    };
    if (typeof define === "function" && define.amd) {
      define(function() {
        return EventEmitter;
      });
    } else if (typeof exports2 === "object") {
      module2.exports = EventEmitter;
    } else {
      window.EventEmitter2 = EventEmitter;
    }
  })();
});

// ../../node_modules/vizion/lib/cliCommand.js
var require_cliCommand = __commonJS((exports2, module2) => {
  var getPlatform = function() {
    switch (process.platform) {
      case "win32":
      case "win64":
        return PLATFORM.WINDOWS;
      default:
        return PLATFORM.UNIX;
    }
  };
  var getCdCommand = function() {
    switch (this.platform) {
      case PLATFORM.WINDOWS:
        return function cdToPath(folder) {
          return "cd \"" + folder + "\"";
        };
      case PLATFORM.UNIX:
        return function cdToPath(folder) {
          return "cd '" + folder + "'";
        };
    }
  };
  var getCleanseCommand = function(setEnvVar) {
    switch (this.platform) {
      case PLATFORM.WINDOWS:
        return function(cmd) {
          var envCmd = setEnvVar();
          if (!envCmd.length)
            return cmd;
          return [envCmd, cmd].join(" ");
        };
      case PLATFORM.UNIX:
        return function(cmd) {
          return [setEnvVar("LC_ALL", "en_US.UTF-8"), cmd].join(" ");
        };
    }
  };
  var getSetEnv = function() {
    switch (this.platform) {
      case PLATFORM.WINDOWS:
        return function(k, v) {
          if (!k)
            return "";
          return "SET ".concat([k, v].join("="));
        };
      case PLATFORM.UNIX:
        return function(k, v) {
          if (!k)
            return "";
          return [k, v].join("=");
        };
    }
  };
  var getConcatenator = function() {
    switch (this.platform) {
      case PLATFORM.WINDOWS:
        return function(cmds) {
          return cmds.join(" && ");
        };
      case PLATFORM.UNIX:
        return function(cmds) {
          var cmdText = "";
          for (var i = 0;i < cmds.length; i++) {
            cmdText += cmds[i];
            if (i < cmds.length - 1)
              cmdText += ";";
          }
          return cmdText;
        };
    }
  };
  var PLATFORM = {
    WINDOWS: "WINDOWS",
    UNIX: "UNIX"
  };
  var cliCommand = function getExecutor() {
    this.platform = getPlatform();
    var cdTo = getCdCommand.call(this);
    var concat = getConcatenator.call(this);
    var setEnvVar = getSetEnv.call(this);
    var cleanse = getCleanseCommand.call(this, setEnvVar);
    return function(folder, cmd) {
      var cmds = [];
      cmds.push(cdTo(folder));
      cmds.push(cleanse(cmd));
      return concat(cmds);
    };
  }();
  module2.exports = cliCommand;
});

// ../../node_modules/vizion/lib/hg/hg.js
var require_hg = __commonJS((exports2, module2) => {
  var error = function(repoType, task, errorMsg, cb) {
    if (halt)
      return false;
    console.error("[Repo-Parser] An error occured while " + task + " in a " + repoType + " repository: " + errorMsg);
    halt = true;
    return cb("[Repo-Parser] An error occured while " + task + " in a " + repoType + " repository: " + errorMsg);
  };
  var checkReturn = function(dataArray, cb) {
    if (halt) {
      return false;
    }
    if (Object.keys(dataArray).length > 6) {
      Object.keys(dataArray).forEach(function(key) {
        if (typeof dataArray[key] === "string") {
          dataArray[key] = dataArray[key].replace(/\n/g, "");
        }
      });
      cb(null, dataArray);
    }
  };
  var exec = __require("child_process").exec;
  var fs = __require("fs");
  var cliCommand = require_cliCommand();
  var halt = false;
  exports2.parse = function parseHg(folder, cb) {
    var data = {};
    data.type = "mercurial";
    data.commit_history = [];
    exec(cliCommand(folder, "hg paths default"), function(err, stdout, stderr) {
      if (err !== null) {
        error("mercurial", "fetching path", stderr, cb);
      } else {
        data.url = stdout;
        checkReturn(data, cb);
      }
    });
    exec(cliCommand(folder, "hg log --limit 1 --template 'changeset: {rev}:{node|short}\nsummary: {desc}'"), function(err, stdout, stderr) {
      if (err !== null) {
        error("mercurial", "fetching log", stderr, cb);
      } else {
        var changeset = stdout.match(/^changeset:\s+([^\n]+)$/m);
        var summary = stdout.match(/^summary:\s+([^\n]+)$/m);
        data.revision = changeset[1];
        data.comment = summary[1];
        checkReturn(data, cb);
      }
    });
    exec(cliCommand(folder, "hg branch"), function(err, stdout, stderr) {
      if (err !== null) {
        error("mercurial", "fetching branch", stderr, cb);
      } else {
        data.branch = stdout;
        checkReturn(data, cb);
      }
    });
    fs.stat(folder + ".hg", function(err, stats) {
      if (err !== null) {
        error("mercurial", "fetching stats", "no error available", cb);
      } else {
        data.update_time = stats.mtime;
        checkReturn(data, cb);
      }
    });
  };
});

// ../../node_modules/lodash/isArray.js
var require_isArray = __commonJS((exports2, module2) => {
  var isArray2 = Array.isArray;
  module2.exports = isArray2;
});

// ../../node_modules/lodash/noop.js
var require_noop = __commonJS((exports2, module2) => {
  var noop = function() {
  };
  module2.exports = noop;
});

// ../../node_modules/vizion/node_modules/async/internal/once.js
var require_once2 = __commonJS((exports2, module2) => {
  var once = function(fn) {
    return function() {
      if (fn === null)
        return;
      var callFn = fn;
      fn = null;
      callFn.apply(this, arguments);
    };
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = once;
  module2.exports = exports2["default"];
});

// ../../node_modules/vizion/node_modules/async/internal/slice.js
var require_slice = __commonJS((exports2, module2) => {
  var slice = function(arrayLike, start) {
    start = start | 0;
    var newLen = Math.max(arrayLike.length - start, 0);
    var newArr = Array(newLen);
    for (var idx = 0;idx < newLen; idx++) {
      newArr[idx] = arrayLike[start + idx];
    }
    return newArr;
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = slice;
  module2.exports = exports2["default"];
});

// ../../node_modules/vizion/node_modules/async/internal/onlyOnce.js
var require_onlyOnce2 = __commonJS((exports2, module2) => {
  var onlyOnce = function(fn) {
    return function() {
      if (fn === null)
        throw new Error("Callback was already called.");
      var callFn = fn;
      fn = null;
      callFn.apply(this, arguments);
    };
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = onlyOnce;
  module2.exports = exports2["default"];
});

// ../../node_modules/lodash/isObject.js
var require_isObject = __commonJS((exports2, module2) => {
  var isObject = function(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  };
  module2.exports = isObject;
});

// ../../node_modules/vizion/node_modules/async/internal/initialParams.js
var require_initialParams2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = function(fn) {
    return function() {
      var args2 = (0, _slice2.default)(arguments);
      var callback = args2.pop();
      fn.call(this, args2, callback);
    };
  };
  var _slice = require_slice();
  var _slice2 = _interopRequireDefault(_slice);
  module2.exports = exports2["default"];
});

// ../../node_modules/vizion/node_modules/async/internal/setImmediate.js
var require_setImmediate2 = __commonJS((exports2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var fallback = function(fn) {
    setTimeout(fn, 0);
  };
  var wrap = function(defer) {
    return function(fn) {
      var args2 = (0, _slice2.default)(arguments, 1);
      defer(function() {
        fn.apply(null, args2);
      });
    };
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.hasNextTick = exports2.hasSetImmediate = undefined;
  exports2.fallback = fallback;
  exports2.wrap = wrap;
  var _slice = require_slice();
  var _slice2 = _interopRequireDefault(_slice);
  var hasSetImmediate = exports2.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
  var hasNextTick = exports2.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
  var _defer;
  if (hasSetImmediate) {
    _defer = setImmediate;
  } else if (hasNextTick) {
    _defer = process.nextTick;
  } else {
    _defer = fallback;
  }
  exports2.default = wrap(_defer);
});

// ../../node_modules/vizion/node_modules/async/asyncify.js
var require_asyncify2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var asyncify = function(func) {
    return (0, _initialParams2.default)(function(args2, callback) {
      var result;
      try {
        result = func.apply(this, args2);
      } catch (e) {
        return callback(e);
      }
      if ((0, _isObject2.default)(result) && typeof result.then === "function") {
        result.then(function(value) {
          invokeCallback(callback, null, value);
        }, function(err) {
          invokeCallback(callback, err.message ? err : new Error(err));
        });
      } else {
        callback(null, result);
      }
    });
  };
  var invokeCallback = function(callback, error, value) {
    try {
      callback(error, value);
    } catch (e) {
      (0, _setImmediate2.default)(rethrow, e);
    }
  };
  var rethrow = function(error) {
    throw error;
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = asyncify;
  var _isObject = require_isObject();
  var _isObject2 = _interopRequireDefault(_isObject);
  var _initialParams = require_initialParams2();
  var _initialParams2 = _interopRequireDefault(_initialParams);
  var _setImmediate = require_setImmediate2();
  var _setImmediate2 = _interopRequireDefault(_setImmediate);
  module2.exports = exports2["default"];
});

// ../../node_modules/vizion/node_modules/async/internal/wrapAsync.js
var require_wrapAsync2 = __commonJS((exports2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isAsync = function(fn) {
    return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction";
  };
  var wrapAsync = function(asyncFn) {
    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.isAsync = undefined;
  var _asyncify = require_asyncify2();
  var _asyncify2 = _interopRequireDefault(_asyncify);
  var supportsSymbol = typeof Symbol === "function";
  exports2.default = wrapAsync;
  exports2.isAsync = isAsync;
});

// ../../node_modules/vizion/node_modules/async/waterfall.js
var require_waterfall2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = function(tasks, callback) {
    callback = (0, _once2.default)(callback || _noop2.default);
    if (!(0, _isArray2.default)(tasks))
      return callback(new Error("First argument to waterfall must be an array of functions"));
    if (!tasks.length)
      return callback();
    var taskIndex = 0;
    function nextTask(args2) {
      var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);
      args2.push((0, _onlyOnce2.default)(next));
      task.apply(null, args2);
    }
    function next(err) {
      if (err || taskIndex === tasks.length) {
        return callback.apply(null, arguments);
      }
      nextTask((0, _slice2.default)(arguments, 1));
    }
    nextTask([]);
  };
  var _isArray = require_isArray();
  var _isArray2 = _interopRequireDefault(_isArray);
  var _noop = require_noop();
  var _noop2 = _interopRequireDefault(_noop);
  var _once = require_once2();
  var _once2 = _interopRequireDefault(_once);
  var _slice = require_slice();
  var _slice2 = _interopRequireDefault(_slice);
  var _onlyOnce = require_onlyOnce2();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _wrapAsync = require_wrapAsync2();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  module2.exports = exports2["default"];
});

// ../../node_modules/ini/ini.js
var require_ini = __commonJS((exports2) => {
  var encode = function(obj, opt) {
    var children = [];
    var out = "";
    if (typeof opt === "string") {
      opt = {
        section: opt,
        whitespace: false
      };
    } else {
      opt = opt || {};
      opt.whitespace = opt.whitespace === true;
    }
    var separator = opt.whitespace ? " = " : "=";
    Object.keys(obj).forEach(function(k, _, __) {
      var val = obj[k];
      if (val && Array.isArray(val)) {
        val.forEach(function(item) {
          out += safe(k + "[]") + separator + safe(item) + "\n";
        });
      } else if (val && typeof val === "object")
        children.push(k);
      else
        out += safe(k) + separator + safe(val) + eol;
    });
    if (opt.section && out.length)
      out = "[" + safe(opt.section) + "]" + eol + out;
    children.forEach(function(k, _, __) {
      var nk = dotSplit(k).join("\\.");
      var section = (opt.section ? opt.section + "." : "") + nk;
      var child = encode(obj[k], {
        section,
        whitespace: opt.whitespace
      });
      if (out.length && child.length)
        out += eol;
      out += child;
    });
    return out;
  };
  var dotSplit = function(str) {
    return str.replace(/\1/g, "\x02LITERAL\\1LITERAL\x02").replace(/\\\./g, "\x01").split(/\./).map(function(part) {
      return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "\x01");
    });
  };
  var decode = function(str) {
    var out = {};
    var p = out;
    var section = null;
    var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
    var lines = str.split(/[\r\n]+/g);
    lines.forEach(function(line, _, __) {
      if (!line || line.match(/^\s*[;#]/))
        return;
      var match = line.match(re);
      if (!match)
        return;
      if (match[1] !== undefined) {
        section = unsafe(match[1]);
        if (section === "__proto__") {
          p = {};
          return;
        }
        p = out[section] = out[section] || {};
        return;
      }
      var key = unsafe(match[2]);
      if (key === "__proto__")
        return;
      var value = match[3] ? unsafe(match[4]) : true;
      switch (value) {
        case "true":
        case "false":
        case "null":
          value = JSON.parse(value);
      }
      if (key.length > 2 && key.slice(-2) === "[]") {
        key = key.substring(0, key.length - 2);
        if (key === "__proto__")
          return;
        if (!p[key])
          p[key] = [];
        else if (!Array.isArray(p[key]))
          p[key] = [p[key]];
      }
      if (Array.isArray(p[key]))
        p[key].push(value);
      else
        p[key] = value;
    });
    Object.keys(out).filter(function(k, _, __) {
      if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k]))
        return false;
      var parts = dotSplit(k);
      var p2 = out;
      var l = parts.pop();
      var nl = l.replace(/\\\./g, ".");
      parts.forEach(function(part, _2, __2) {
        if (part === "__proto__")
          return;
        if (!p2[part] || typeof p2[part] !== "object")
          p2[part] = {};
        p2 = p2[part];
      });
      if (p2 === out && nl === l)
        return false;
      p2[nl] = out[k];
      return true;
    }).forEach(function(del, _, __) {
      delete out[del];
    });
    return out;
  };
  var isQuoted = function(val) {
    return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
  };
  var safe = function(val) {
    return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
  };
  var unsafe = function(val, doUnesc) {
    val = (val || "").trim();
    if (isQuoted(val)) {
      if (val.charAt(0) === "'")
        val = val.substr(1, val.length - 2);
      try {
        val = JSON.parse(val);
      } catch (_) {
      }
    } else {
      var esc = false;
      var unesc = "";
      for (var i = 0, l = val.length;i < l; i++) {
        var c = val.charAt(i);
        if (esc) {
          if ("\\;#".indexOf(c) !== -1)
            unesc += c;
          else
            unesc += "\\" + c;
          esc = false;
        } else if (";#".indexOf(c) !== -1)
          break;
        else if (c === "\\")
          esc = true;
        else
          unesc += c;
      }
      if (esc)
        unesc += "\\";
      return unesc.trim();
    }
    return val;
  };
  exports2.parse = exports2.decode = decode;
  exports2.stringify = exports2.encode = encode;
  exports2.safe = safe;
  exports2.unsafe = unsafe;
  var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
});

// ../../node_modules/vizion/lib/helper.js
var require_helper = __commonJS((exports2, module2) => {
  var trimNewLine = function(input) {
    return typeof input === "string" ? input.replace(/\n/g, "") : input;
  };
  var get = function(object, path2) {
    const pathArray = path2.split(".");
    let result = object;
    while (result != null && pathArray.length) {
      const pathItem = pathArray.shift();
      if (pathItem in result) {
        result = result[pathItem];
      } else {
        return;
      }
    }
    return result;
  };
  var last2 = function(array) {
    var length3 = array == null ? 0 : array.length;
    return length3 ? array[length3 - 1] : undefined;
  };
  module2.exports = {
    get,
    last: last2,
    trimNewLine
  };
});

// ../../node_modules/vizion/node_modules/async/whilst.js
var require_whilst = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var whilst = function(test, iteratee, callback) {
    callback = (0, _onlyOnce2.default)(callback || _noop2.default);
    var _iteratee = (0, _wrapAsync2.default)(iteratee);
    if (!test())
      return callback(null);
    var next = function(err) {
      if (err)
        return callback(err);
      if (test())
        return _iteratee(next);
      var args2 = (0, _slice2.default)(arguments, 1);
      callback.apply(null, [null].concat(args2));
    };
    _iteratee(next);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = whilst;
  var _noop = require_noop();
  var _noop2 = _interopRequireDefault(_noop);
  var _slice = require_slice();
  var _slice2 = _interopRequireDefault(_slice);
  var _onlyOnce = require_onlyOnce2();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _wrapAsync = require_wrapAsync2();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  module2.exports = exports2["default"];
});

// ../../node_modules/bodec/bodec.js
var require_bodec = __commonJS((exports2, module2) => {
  var isBinary = function(value) {
    return value && typeof value === "object" && value instanceof Uint8Array || value.constructor.name === "Uint8Array";
  };
  var create8 = function(length3) {
    return new Uint8Array(length3);
  };
  var join = function(chunks) {
    var length3 = chunks.length;
    var total = 0;
    for (var i = 0;i < length3; i++) {
      total += chunks[i].length;
    }
    var binary = create8(total);
    var offset = 0;
    for (i = 0;i < length3; i++) {
      var chunk = chunks[i];
      copy2(chunk, binary, offset);
      offset += chunk.length;
    }
    return binary;
  };
  var slice = function(binary, start, end) {
    if (end === undefined) {
      end = binary.length;
      if (start === undefined)
        start = 0;
    }
    return binary.subarray(start, end);
  };
  var copy2 = function(source, binary, offset) {
    var length3 = source.length;
    if (offset === undefined) {
      offset = 0;
      if (binary === undefined)
        binary = create8(length3);
    }
    for (var i = 0;i < length3; i++) {
      binary[i + offset] = source[i];
    }
    return binary;
  };
  var toHex = function(binary, start, end) {
    var hex = "";
    if (end === undefined) {
      end = binary.length;
      if (start === undefined)
        start = 0;
    }
    for (var i = start;i < end; i++) {
      var byte = binary[i];
      hex += String.fromCharCode(nibbleToCode(byte >> 4)) + String.fromCharCode(nibbleToCode(byte & 15));
    }
    return hex;
  };
  var fromHex = function(hex, binary, offset) {
    var length3 = hex.length / 2;
    if (offset === undefined) {
      offset = 0;
      if (binary === undefined)
        binary = create8(length3);
    }
    var j = 0;
    for (var i = 0;i < length3; i++) {
      binary[offset + i] = codeToNibble(hex.charCodeAt(j++)) << 4 | codeToNibble(hex.charCodeAt(j++));
    }
    return binary;
  };
  var toBase64 = function(binary, start, end) {
    return btoa(toRaw(binary, start, end));
  };
  var fromBase64 = function(base64, binary, offset) {
    return fromRaw(atob(base64), binary, offset);
  };
  var nibbleToCode = function(nibble) {
    nibble |= 0;
    return nibble + (nibble < 10 ? 48 : 87) | 0;
  };
  var codeToNibble = function(code) {
    code |= 0;
    return code - (code & 64 ? 87 : 48) | 0;
  };
  var toUnicode = function(binary, start, end) {
    return decodeUtf82(toRaw(binary, start, end));
  };
  var fromUnicode = function(unicode, binary, offset) {
    return fromRaw(encodeUtf84(unicode), binary, offset);
  };
  var decodeHex = function(hex) {
    var j = 0, l = hex.length;
    var raw = "";
    while (j < l) {
      raw += String.fromCharCode(codeToNibble(hex.charCodeAt(j++)) << 4 | codeToNibble(hex.charCodeAt(j++)));
    }
    return raw;
  };
  var encodeHex = function(raw) {
    var hex = "";
    var length3 = raw.length;
    for (var i = 0;i < length3; i++) {
      var byte = raw.charCodeAt(i);
      hex += String.fromCharCode(nibbleToCode(byte >> 4)) + String.fromCharCode(nibbleToCode(byte & 15));
    }
    return hex;
  };
  var decodeBase64 = function(base64) {
    return atob(base64);
  };
  var encodeBase64 = function(raw) {
    return btoa(raw);
  };
  var decodeUtf82 = function(utf8) {
    return decodeURIComponent(escape(utf8));
  };
  var encodeUtf84 = function(unicode) {
    return unescape(encodeURIComponent(unicode));
  };
  var toRaw = function(binary, start, end) {
    var raw = "";
    if (end === undefined) {
      end = binary.length;
      if (start === undefined)
        start = 0;
    }
    for (var i = start;i < end; i++) {
      raw += String.fromCharCode(binary[i]);
    }
    return raw;
  };
  var fromRaw = function(raw, binary, offset) {
    var length3 = raw.length;
    if (offset === undefined) {
      offset = 0;
      if (binary === undefined)
        binary = create8(length3);
    }
    for (var i = 0;i < length3; i++) {
      binary[offset + i] = raw.charCodeAt(i);
    }
    return binary;
  };
  var toArray = function(binary, start, end) {
    if (end === undefined) {
      end = binary.length;
      if (start === undefined)
        start = 0;
    }
    var length3 = end - start;
    var array = new Array(length3);
    for (var i = 0;i < length3; i++) {
      array[i] = binary[i + start];
    }
    return array;
  };
  var fromArray = function(array, binary, offset) {
    var length3 = array.length;
    if (offset === undefined) {
      offset = 0;
      if (binary === undefined)
        binary = create8(length3);
    }
    for (var i = 0;i < length3; i++) {
      binary[offset + i] = array[i];
    }
    return binary;
  };
  var isNode2 = typeof process === "object" && typeof process.versions === "object" && process.versions.node && process.__atom_type !== "renderer";
  if (isNode2) {
    nodeRequire = __require;
    module2.exports = nodeRequire("./bodec-node.js");
  } else {
    module2.exports = {
      Binary: Uint8Array,
      isBinary,
      create: create8,
      join,
      copy: copy2,
      slice,
      toRaw,
      fromRaw,
      toUnicode,
      fromUnicode,
      toHex,
      fromHex,
      toBase64,
      fromBase64,
      toArray,
      fromArray,
      decodeHex,
      encodeHex,
      decodeBase64,
      encodeBase64,
      encodeUtf8: encodeUtf84,
      decodeUtf8: decodeUtf82,
      nibbleToCode,
      codeToNibble
    };
  }
  var nodeRequire;
});

// ../../node_modules/pako/lib/utils/common.js
var require_common3 = __commonJS((exports2) => {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  exports2.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p in source) {
        if (source.hasOwnProperty(p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports2.shrinkBuf = function(buf, size2) {
    if (buf.length === size2) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size2);
    }
    buf.length = size2;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i = 0;i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function(chunks) {
      var i, l, len, pos, chunk, result;
      len = 0;
      for (i = 0, l = chunks.length;i < l; i++) {
        len += chunks[i].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i = 0, l = chunks.length;i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i = 0;i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports2.setTyped = function(on) {
    if (on) {
      exports2.Buf8 = Uint8Array;
      exports2.Buf16 = Uint16Array;
      exports2.Buf32 = Int32Array;
      exports2.assign(exports2, fnTyped);
    } else {
      exports2.Buf8 = Array;
      exports2.Buf16 = Array;
      exports2.Buf32 = Array;
      exports2.assign(exports2, fnUntyped);
    }
  };
  exports2.setTyped(TYPED_OK);
});

// ../../node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS((exports2) => {
  var zero = function(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  };
  var StaticTreeDesc = function(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  };
  var TreeDesc = function(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  };
  var d_code = function(dist2) {
    return dist2 < 256 ? _dist_code[dist2] : _dist_code[256 + (dist2 >>> 7)];
  };
  var put_short = function(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  };
  var send_bits = function(s, value, length3) {
    if (s.bi_valid > Buf_size - length3) {
      s.bi_buf |= value << s.bi_valid & 65535;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length3 - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 65535;
      s.bi_valid += length3;
    }
  };
  var send_code = function(s, c, tree) {
    send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  };
  var bi_reverse = function(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  };
  var bi_flush = function(s) {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  };
  var gen_bitlen = function(s, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h;
    var n, m;
    var bits;
    var xbits;
    var f;
    var overflow = 0;
    for (bits = 0;bits <= MAX_BITS; bits++) {
      s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1;h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > max_code) {
        continue;
      }
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base) {
        xbits = extra[n - base];
      }
      f = tree[n * 2];
      s.opt_len += f * (bits + xbits);
      if (has_stree) {
        s.static_len += f * (stree[n * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) {
        bits--;
      }
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length;bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > max_code) {
          continue;
        }
        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  };
  var gen_codes = function(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n;
    for (bits = 1;bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0;n <= max_code; n++) {
      var len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  };
  var tr_static_init = function() {
    var n;
    var bits;
    var length3;
    var code;
    var dist2;
    var bl_count = new Array(MAX_BITS + 1);
    length3 = 0;
    for (code = 0;code < LENGTH_CODES - 1; code++) {
      base_length[code] = length3;
      for (n = 0;n < 1 << extra_lbits[code]; n++) {
        _length_code[length3++] = code;
      }
    }
    _length_code[length3 - 1] = code;
    dist2 = 0;
    for (code = 0;code < 16; code++) {
      base_dist[code] = dist2;
      for (n = 0;n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist2++] = code;
      }
    }
    dist2 >>= 7;
    for (;code < D_CODES; code++) {
      base_dist[code] = dist2 << 7;
      for (n = 0;n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist2++] = code;
      }
    }
    for (bits = 0;bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n = 0;n < D_CODES; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  };
  var init_block = function(s) {
    var n;
    for (n = 0;n < L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0;n < D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0;n < BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  };
  var bi_windup = function(s) {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  };
  var copy_block = function(s, buf, len, header) {
    bi_windup(s);
    if (header) {
      put_short(s, len);
      put_short(s, ~len);
    }
    utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
    s.pending += len;
  };
  var smaller = function(tree, n, m, depth) {
    var _n2 = n * 2;
    var _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  };
  var pqdownheap = function(s, tree, k) {
    var v = s.heap[k];
    var j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  };
  var compress_block = function(s, ltree, dtree) {
    var dist2;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s.last_lit !== 0) {
      do {
        dist2 = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist2 === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }
          dist2--;
          code = d_code(dist2);
          send_code(s, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist2 -= base_dist[code];
            send_bits(s, dist2, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    send_code(s, END_BLOCK, ltree);
  };
  var build_tree = function(s, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n, m;
    var max_code = -1;
    var node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for (n = 0;n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1;n >= 1; n--) {
      pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  };
  var scan_tree = function(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0;n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };
  var send_tree = function(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0;n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count--;
        }
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };
  var build_bl_tree = function(s) {
    var max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for (max_blindex = BL_CODES - 1;max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  };
  var send_all_trees = function(s, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for (rank = 0;rank < blcodes; rank++) {
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  };
  var detect_data_type = function(s) {
    var black_mask = 4093624447;
    var n;
    for (n = 0;n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n = 32;n < LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  };
  var _tr_init = function(s) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  };
  var _tr_stored_block = function(s, buf, stored_len, last2) {
    send_bits(s, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
    copy_block(s, buf, stored_len, true);
  };
  var _tr_align = function(s) {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  };
  var _tr_flush_block = function(s, buf, stored_len, last2) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN) {
        s.strm.data_type = detect_data_type(s);
      }
      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s, buf, stored_len, last2);
    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last2) {
      bi_windup(s);
    }
  };
  var _tr_tally = function(s, dist2, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist2 >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist2 & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist2 === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist2--;
      s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s.dyn_dtree[d_code(dist2) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  };
  var utils = require_common3();
  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
  var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
  var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  var static_init_done = false;
  exports2._tr_init = _tr_init;
  exports2._tr_stored_block = _tr_stored_block;
  exports2._tr_flush_block = _tr_flush_block;
  exports2._tr_tally = _tr_tally;
  exports2._tr_align = _tr_align;
});

// ../../node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS((exports2, module2) => {
  var adler32 = function(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2000 ? 2000 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  };
  module2.exports = adler32;
});

// ../../node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS((exports2, module2) => {
  var makeTable = function() {
    var c, table = [];
    for (var n = 0;n < 256; n++) {
      c = n;
      for (var k = 0;k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  };
  var crc32 = function(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc ^= -1;
    for (var i = pos;i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  };
  var crcTable = makeTable();
  module2.exports = crc32;
});

// ../../node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS((exports2, module2) => {
  module2.exports = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
  };
});

// ../../node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS((exports2) => {
  var err = function(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  };
  var rank = function(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  };
  var zero = function(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  };
  var flush_pending = function(strm) {
    var s = strm.state;
    var len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  };
  var flush_block_only = function(s, last2) {
    trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  };
  var put_byte = function(s, b) {
    s.pending_buf[s.pending++] = b;
  };
  var putShortMSB = function(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  };
  var read_buf = function(strm, buf, start, size2) {
    var len = strm.avail_in;
    if (len > size2) {
      len = size2;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  };
  var longest_match = function(s, cur_match) {
    var chain_length = s.max_chain_length;
    var scan = s.strstart;
    var match;
    var len;
    var best_len = s.prev_length;
    var nice_match = s.nice_match;
    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s.window;
    var wmask = s.w_mask;
    var prev = s.prev;
    var strend = s.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  };
  var fill_window = function(s) {
    var _w_size = s.w_size;
    var p, n, m, more, str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
        while (s.insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  };
  var deflate_stored = function(s, flush) {
    var max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (;; ) {
      if (s.lookahead <= 1) {
        fill_window(s);
        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      var max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  };
  var deflate_fast = function(s, flush) {
    var hash_head;
    var bflush;
    for (;; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;
          do {
            s.strstart++;
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);
          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
        }
      } else {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_slow = function(s, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (;; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_rle = function(s, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s.window;
    for (;; ) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_huff = function(s, flush) {
    var bflush;
    for (;; ) {
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var Config = function(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  };
  var lm_init = function(s) {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  };
  var DeflateState = function() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils.Buf16(MAX_BITS + 1);
    this.heap = new utils.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  };
  var deflateResetKeep = function(strm) {
    var s;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = Z_NO_FLUSH;
    trees._tr_init(s);
    return Z_OK;
  };
  var deflateReset = function(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  };
  var deflateSetHeader = function(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  };
  var deflateInit2 = function(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s = new DeflateState;
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new utils.Buf8(s.w_size * 2);
    s.head = new utils.Buf16(s.hash_size);
    s.prev = new utils.Buf16(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new utils.Buf8(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
  };
  var deflateInit = function(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  };
  var deflate = function(strm, flush) {
    var old_flush, s;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s.strm = strm;
    old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
        } else {
          put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
        s.status = NAME_STATE;
      }
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
        s.status = COMMENT_STATE;
      }
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
        s.status = HCRC_STATE;
      }
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = BUSY_STATE;
        }
      } else {
        s.status = BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
      var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees._tr_align(s);
        } else if (flush !== Z_BLOCK) {
          trees._tr_stored_block(s, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      put_byte(s, strm.adler >> 16 & 255);
      put_byte(s, strm.adler >> 24 & 255);
      put_byte(s, strm.total_in & 255);
      put_byte(s, strm.total_in >> 8 & 255);
      put_byte(s, strm.total_in >> 16 & 255);
      put_byte(s, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
  };
  var deflateEnd = function(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  };
  var deflateSetDictionary = function(strm, dictionary) {
    var dictLength = dictionary.length;
    var s;
    var str, n;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    s = strm.state;
    wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      tmpDict = new utils.Buf8(s.w_size);
      utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      str = s.strstart;
      n = s.lookahead - (MIN_MATCH - 1);
      do {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK;
  };
  var utils = require_common3();
  var trees = require_trees();
  var adler32 = require_adler32();
  var crc32 = require_crc32();
  var msg = require_messages();
  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  var configuration_table;
  configuration_table = [
    new Config(0, 0, 0, 0, deflate_stored),
    new Config(4, 4, 8, 4, deflate_fast),
    new Config(4, 5, 16, 8, deflate_fast),
    new Config(4, 6, 32, 32, deflate_fast),
    new Config(4, 4, 16, 16, deflate_slow),
    new Config(8, 16, 32, 32, deflate_slow),
    new Config(8, 16, 128, 128, deflate_slow),
    new Config(8, 32, 128, 256, deflate_slow),
    new Config(32, 128, 258, 1024, deflate_slow),
    new Config(32, 258, 258, 4096, deflate_slow)
  ];
  exports2.deflateInit = deflateInit;
  exports2.deflateInit2 = deflateInit2;
  exports2.deflateReset = deflateReset;
  exports2.deflateResetKeep = deflateResetKeep;
  exports2.deflateSetHeader = deflateSetHeader;
  exports2.deflate = deflate;
  exports2.deflateEnd = deflateEnd;
  exports2.deflateSetDictionary = deflateSetDictionary;
  exports2.deflateInfo = "pako deflate (from Nodeca project)";
});

// ../../node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS((exports2) => {
  var buf2binstring = function(buf, len) {
    if (len < 65537) {
      if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
        return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
      }
    }
    var result = "";
    for (var i = 0;i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  };
  var utils = require_common3();
  var STR_APPLY_OK = true;
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (__) {
    STR_APPLY_OK = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new utils.Buf8(256);
  for (q = 0;q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  var q;
  _utf8len[254] = _utf8len[254] = 1;
  exports2.string2buf = function(str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
    for (m_pos = 0;m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new utils.Buf8(buf_len);
    for (i = 0, m_pos = 0;i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  };
  exports2.buf2binstring = function(buf) {
    return buf2binstring(buf, buf.length);
  };
  exports2.binstring2buf = function(str) {
    var buf = new utils.Buf8(str.length);
    for (var i = 0, len = buf.length;i < len; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  };
  exports2.buf2string = function(buf, max4) {
    var i, out, c, c_len;
    var len = max4 || buf.length;
    var utf16buf = new Array(len * 2);
    for (out = 0, i = 0;i < len; ) {
      c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      c_len = _utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  exports2.utf8border = function(buf, max4) {
    var pos;
    max4 = max4 || buf.length;
    if (max4 > buf.length) {
      max4 = buf.length;
    }
    pos = max4 - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max4;
    }
    if (pos === 0) {
      return max4;
    }
    return pos + _utf8len[buf[pos]] > max4 ? pos : max4;
  };
});

// ../../node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS((exports2, module2) => {
  var ZStream = function() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  };
  module2.exports = ZStream;
});

// ../../node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS((exports2) => {
  var Deflate = function(options2) {
    if (!(this instanceof Deflate))
      return new Deflate(options2);
    this.options = utils.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ""
    }, options2 || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream;
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      var dict;
      if (typeof opt.dictionary === "string") {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  };
  var deflate = function(input, options2) {
    var deflator = new Deflate(options2);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg;
    }
    return deflator.result;
  };
  var deflateRaw = function(input, options2) {
    options2 = options2 || {};
    options2.raw = true;
    return deflate(input, options2);
  };
  var gzip = function(input, options2) {
    options2 = options2 || {};
    options2.gzip = true;
    return deflate(input, options2);
  };
  var zlib_deflate = require_deflate();
  var utils = require_common3();
  var strings = require_strings();
  var msg = require_messages();
  var ZStream = require_zstream();
  var toString = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  Deflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status, _mode;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  exports2.Deflate = Deflate;
  exports2.deflate = deflate;
  exports2.deflateRaw = deflateRaw;
  exports2.gzip = gzip;
});

// ../../node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS((exports2, module2) => {
  var BAD = 30;
  var TYPE = 12;
  module2.exports = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last2;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist2;
    var from3;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last2 = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (;; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (;; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist2 = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist2 += hold & (1 << op) - 1;
                    if (dist2 > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist2 > op) {
                      op = dist2 - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from3 = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from3 += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from3++];
                          } while (--op);
                          from3 = _out - dist2;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from3 += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from3++];
                          } while (--op);
                          from3 = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from3++];
                            } while (--op);
                            from3 = _out - dist2;
                            from_source = output;
                          }
                        }
                      } else {
                        from3 += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from3++];
                          } while (--op);
                          from3 = _out - dist2;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from3++];
                        output[_out++] = from_source[from3++];
                        output[_out++] = from_source[from3++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from3++];
                        if (len > 1) {
                          output[_out++] = from_source[from3++];
                        }
                      }
                    } else {
                      from3 = _out - dist2;
                      do {
                        output[_out++] = output[from3++];
                        output[_out++] = output[from3++];
                        output[_out++] = output[from3++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from3++];
                        if (len > 1) {
                          output[_out++] = output[from3++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last2 && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
});

// ../../node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS((exports2, module2) => {
  var utils = require_common3();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  module2.exports = function inflate_table(type2, lens, lens_index, codes, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min4 = 0, max4 = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count = new utils.Buf16(MAXBITS + 1);
    var offs = new utils.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0;len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0;sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max4 = MAXBITS;max4 >= 1; max4--) {
      if (count[max4] !== 0) {
        break;
      }
    }
    if (root > max4) {
      root = max4;
    }
    if (max4 === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min4 = 1;min4 < max4; min4++) {
      if (count[min4] !== 0) {
        break;
      }
    }
    if (root < min4) {
      root = min4;
    }
    left = 1;
    for (len = 1;len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type2 === CODES || max4 !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1;len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0;sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type2 === CODES) {
      base = extra = work;
      end = 19;
    } else if (type2 === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min4;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    var i = 0;
    for (;; ) {
      i++;
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min4 = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max4) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min4;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max4) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
});

// ../../node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS((exports2) => {
  var zswap32 = function(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  };
  var InflateState = function() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils.Buf16(320);
    this.work = new utils.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  };
  var inflateResetKeep = function(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK;
  };
  var inflateReset = function(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  };
  var inflateReset2 = function(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  };
  var inflateInit2 = function(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    state = new InflateState;
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  };
  var inflateInit = function(strm) {
    return inflateInit2(strm, DEF_WBITS);
  };
  var fixedtables = function(state) {
    if (virgin) {
      var sym;
      lenfix = new utils.Buf32(512);
      distfix = new utils.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  };
  var updatewindow = function(strm, src, end, copy2) {
    var dist2;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils.Buf8(state.wsize);
    }
    if (copy2 >= state.wsize) {
      utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist2 = state.wsize - state.wnext;
      if (dist2 > copy2) {
        dist2 = copy2;
      }
      utils.arraySet(state.window, src, end - copy2, dist2, state.wnext);
      copy2 -= dist2;
      if (copy2) {
        utils.arraySet(state.window, src, end - copy2, copy2, 0);
        state.wnext = copy2;
        state.whave = state.wsize;
      } else {
        state.wnext += dist2;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist2;
        }
      }
    }
    return 0;
  };
  var inflate = function(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy2;
    var from3;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils.Buf8(4);
    var opts;
    var n;
    var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (;; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy2 = state.length;
              if (copy2 > have) {
                copy2 = have;
              }
              if (copy2) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(state.head.extra, input, next, copy2, len);
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy2, next);
                }
                have -= copy2;
                next += copy2;
                state.length -= copy2;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy2 = 0;
              do {
                len = input[next + copy2++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy2 < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy2 = 0;
              do {
                len = input[next + copy2++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy2 < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy2 = state.length;
            if (copy2) {
              if (copy2 > have) {
                copy2 = have;
              }
              if (copy2 > left) {
                copy2 = left;
              }
              if (copy2 === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy2, put);
              have -= copy2;
              next += copy2;
              left -= copy2;
              put += copy2;
              state.length -= copy2;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (;; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy2 = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy2 = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy2 = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy2 > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy2--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (;; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (;; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy2 = _out - left;
            if (state.offset > copy2) {
              copy2 = state.offset - copy2;
              if (copy2 > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy2 > state.wnext) {
                copy2 -= state.wnext;
                from3 = state.wsize - copy2;
              } else {
                from3 = state.wnext - copy2;
              }
              if (copy2 > state.length) {
                copy2 = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from3 = put - state.offset;
              copy2 = state.length;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            left -= copy2;
            state.length -= copy2;
            do {
              output[put++] = from_source[from3++];
            } while (--copy2);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  };
  var inflateEnd = function(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK;
  };
  var inflateGetHeader = function(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return Z_OK;
  };
  var inflateSetDictionary = function(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK;
  };
  var utils = require_common3();
  var adler32 = require_adler32();
  var crc32 = require_crc32();
  var inflate_fast = require_inffast();
  var inflate_table = require_inftrees();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  var virgin = true;
  var lenfix;
  var distfix;
  exports2.inflateReset = inflateReset;
  exports2.inflateReset2 = inflateReset2;
  exports2.inflateResetKeep = inflateResetKeep;
  exports2.inflateInit = inflateInit;
  exports2.inflateInit2 = inflateInit2;
  exports2.inflate = inflate;
  exports2.inflateEnd = inflateEnd;
  exports2.inflateGetHeader = inflateGetHeader;
  exports2.inflateSetDictionary = inflateSetDictionary;
  exports2.inflateInfo = "pako inflate (from Nodeca project)";
});

// ../../node_modules/pako/lib/zlib/constants.js
var require_constants5 = __commonJS((exports2, module2) => {
  module2.exports = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
});

// ../../node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS((exports2, module2) => {
  var GZheader = function() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  };
  module2.exports = GZheader;
});

// ../../node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS((exports2) => {
  var Inflate = function(options2) {
    if (!(this instanceof Inflate))
      return new Inflate(options2);
    this.options = utils.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, options2 || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream;
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== c.Z_OK) {
      throw new Error(msg[status]);
    }
    this.header = new GZheader;
    zlib_inflate.inflateGetHeader(this.strm, this.header);
  };
  var inflate = function(input, options2) {
    var inflator = new Inflate(options2);
    inflator.push(input, true);
    if (inflator.err) {
      throw inflator.msg;
    }
    return inflator.result;
  };
  var inflateRaw = function(input, options2) {
    options2 = options2 || {};
    options2.raw = true;
    return inflate(input, options2);
  };
  var zlib_inflate = require_inflate();
  var utils = require_common3();
  var strings = require_strings();
  var c = require_constants5();
  var msg = require_messages();
  var ZStream = require_zstream();
  var GZheader = require_gzheader();
  var toString = Object.prototype.toString;
  Inflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;
    var status, _mode;
    var next_out_utf8, tail, utf8str;
    var dict;
    var allowBufError = false;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings.binstring2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
      if (status === c.Z_NEED_DICT && dictionary) {
        if (typeof dictionary === "string") {
          dict = strings.string2buf(dictionary);
        } else if (toString.call(dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(dictionary);
        } else {
          dict = dictionary;
        }
        status = zlib_inflate.inflateSetDictionary(this.strm, dict);
      }
      if (status === c.Z_BUF_ERROR && allowBufError === true) {
        status = c.Z_OK;
        allowBufError = false;
      }
      if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
            tail = strm.next_out - next_out_utf8;
            utf8str = strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) {
              utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
            }
            this.onData(utf8str);
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      }
      if (strm.avail_in === 0 && strm.avail_out === 0) {
        allowBufError = true;
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
    if (status === c.Z_STREAM_END) {
      _mode = c.Z_FINISH;
    }
    if (_mode === c.Z_FINISH) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === c.Z_OK;
    }
    if (_mode === c.Z_SYNC_FLUSH) {
      this.onEnd(c.Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate.prototype.onEnd = function(status) {
    if (status === c.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  exports2.Inflate = Inflate;
  exports2.inflate = inflate;
  exports2.inflateRaw = inflateRaw;
  exports2.ungzip = inflate;
});

// ../../node_modules/pako/index.js
var require_pako = __commonJS((exports2, module2) => {
  var assign2 = require_common3().assign;
  var deflate = require_deflate2();
  var inflate = require_inflate2();
  var constants = require_constants5();
  var pako = {};
  assign2(pako, deflate, inflate, constants);
  module2.exports = pako;
});

// ../../node_modules/js-git/lib/inflate.js
var require_inflate3 = __commonJS((exports2, module2) => {
  var pako = require_pako();
  var Binary = require_bodec().Binary;
  if (Binary === Uint8Array) {
    module2.exports = pako.inflate;
  } else {
    module2.exports = function inflate(value) {
      return new Binary(pako.inflate(new Uint8Array(value)));
    };
  }
});

// ../../node_modules/js-git/lib/deflate.js
var require_deflate3 = __commonJS((exports2, module2) => {
  var pako = require_pako();
  var Binary = require_bodec().Binary;
  if (Binary === Uint8Array) {
    module2.exports = pako.deflate;
  } else {
    module2.exports = function deflate(value) {
      return new Binary(pako.deflate(new Uint8Array(value)));
    };
  }
});

// ../../node_modules/js-git/lib/modes.js
var require_modes = __commonJS((exports2, module2) => {
  var masks = {
    mask: parseInt("100000", 8),
    blob: parseInt("140000", 8),
    file: parseInt("160000", 8)
  };
  var modes = module2.exports = {
    isBlob: function(mode) {
      return (mode & masks.blob) === masks.mask;
    },
    isFile: function(mode) {
      return (mode & masks.file) === masks.mask;
    },
    toType: function(mode) {
      if (mode === modes.commit)
        return "commit";
      if (mode === modes.tree)
        return "tree";
      if ((mode & masks.blob) === masks.mask)
        return "blob";
      return "unknown";
    },
    tree: parseInt("40000", 8),
    blob: parseInt("100644", 8),
    file: parseInt("100644", 8),
    exec: parseInt("100755", 8),
    sym: parseInt("120000", 8),
    commit: parseInt("160000", 8)
  };
});

// ../../node_modules/js-git/lib/object-codec.js
var require_object_codec = __commonJS((exports2) => {
  var encodeBlob = function(body) {
    if (!bodec.isBinary(body))
      throw new TypeError("Blobs must be binary values");
    return body;
  };
  var treeMap = function(key) {
    var entry = this[key];
    return {
      name: key,
      mode: entry.mode,
      hash: entry.hash
    };
  };
  var treeSort = function(a, b) {
    var aa = a.mode === modes.tree ? a.name + "/" : a.name;
    var bb = b.mode === modes.tree ? b.name + "/" : b.name;
    return aa > bb ? 1 : aa < bb ? -1 : 0;
  };
  var encodeTree = function(body) {
    var tree = "";
    if (Array.isArray(body))
      throw new TypeError("Tree must be in object form");
    var list = Object.keys(body).map(treeMap, body).sort(treeSort);
    for (var i = 0, l = list.length;i < l; i++) {
      var entry = list[i];
      tree += entry.mode.toString(8) + " " + bodec.encodeUtf8(entry.name) + "\0" + bodec.decodeHex(entry.hash);
    }
    return bodec.fromRaw(tree);
  };
  var encodeTag = function(body) {
    var str = "object " + body.object + "\ntype " + body.type + "\ntag " + body.tag + "\ntagger " + formatPerson(body.tagger) + "\n\n" + body.message;
    return bodec.fromUnicode(str);
  };
  var encodeCommit = function(body) {
    var str = "tree " + body.tree;
    for (var i = 0, l = body.parents.length;i < l; ++i) {
      str += "\nparent " + body.parents[i];
    }
    str += "\nauthor " + formatPerson(body.author) + "\ncommitter " + formatPerson(body.committer) + "\n\n" + body.message;
    return bodec.fromUnicode(str);
  };
  var formatPerson = function(person) {
    return safe(person.name) + " <" + safe(person.email) + "> " + formatDate(person.date);
  };
  var safe = function(string) {
    return string.replace(/(?:^[\.,:;<>"']+|[\0\n<>]+|[\.,:;<>"']+$)/gm, "");
  };
  var two = function(num) {
    return (num < 10 ? "0" : "") + num;
  };
  var formatDate = function(date) {
    var seconds, offset;
    if (date.seconds) {
      seconds = date.seconds;
      offset = date.offset;
    } else {
      seconds = Math.floor(date.getTime() / 1000);
      offset = date.getTimezoneOffset();
    }
    var neg = "+";
    if (offset <= 0)
      offset = -offset;
    else
      neg = "-";
    offset = neg + two(Math.floor(offset / 60)) + two(offset % 60);
    return seconds + " " + offset;
  };
  var frame = function(obj) {
    var type2 = obj.type;
    var body = obj.body;
    if (!bodec.isBinary(body))
      body = encoders[type2](body);
    return bodec.join([
      bodec.fromRaw(type2 + " " + body.length + "\0"),
      body
    ]);
  };
  var decodeBlob = function(body) {
    return body;
  };
  var decodeTree = function(body) {
    var i = 0;
    var length3 = body.length;
    var start;
    var mode;
    var name2;
    var hash;
    var tree = {};
    while (i < length3) {
      start = i;
      i = indexOf(body, 32, start);
      if (i < 0)
        throw new SyntaxError("Missing space");
      mode = parseOct(body, start, i++);
      start = i;
      i = indexOf(body, 0, start);
      name2 = bodec.toUnicode(body, start, i++);
      hash = bodec.toHex(body, i, i += 20);
      tree[name2] = {
        mode,
        hash
      };
    }
    return tree;
  };
  var decodeCommit = function(body) {
    var i = 0;
    var start;
    var key;
    var parents = [];
    var commit = {
      tree: "",
      parents,
      author: "",
      committer: "",
      message: ""
    };
    while (body[i] !== 10) {
      start = i;
      i = indexOf(body, 32, start);
      if (i < 0)
        throw new SyntaxError("Missing space");
      key = bodec.toRaw(body, start, i++);
      start = i;
      i = indexOf(body, 10, start);
      if (i < 0)
        throw new SyntaxError("Missing linefeed");
      var value = bodec.toUnicode(body, start, i++);
      if (key === "parent") {
        parents.push(value);
      } else {
        if (key === "author" || key === "committer") {
          value = decodePerson(value);
        }
        commit[key] = value;
      }
    }
    i++;
    commit.message = bodec.toUnicode(body, i, body.length);
    return commit;
  };
  var decodeTag = function(body) {
    var i = 0;
    var start;
    var key;
    var tag = {};
    while (body[i] !== 10) {
      start = i;
      i = indexOf(body, 32, start);
      if (i < 0)
        throw new SyntaxError("Missing space");
      key = bodec.toRaw(body, start, i++);
      start = i;
      i = indexOf(body, 10, start);
      if (i < 0)
        throw new SyntaxError("Missing linefeed");
      var value = bodec.toUnicode(body, start, i++);
      if (key === "tagger")
        value = decodePerson(value);
      tag[key] = value;
    }
    i++;
    tag.message = bodec.toUnicode(body, i, body.length);
    return tag;
  };
  var decodePerson = function(string) {
    var match = string.match(/^([^<]*) <([^>]*)> ([^ ]*) (.*)$/);
    if (!match)
      throw new Error("Improperly formatted person string");
    return {
      name: match[1],
      email: match[2],
      date: {
        seconds: parseInt(match[3], 10),
        offset: parseInt(match[4], 10) / 100 * -60
      }
    };
  };
  var deframe = function(buffer, decode) {
    var space = indexOf(buffer, 32);
    if (space < 0)
      throw new Error("Invalid git object buffer");
    var nil = indexOf(buffer, 0, space);
    if (nil < 0)
      throw new Error("Invalid git object buffer");
    var body = bodec.slice(buffer, nil + 1);
    var size2 = parseDec(buffer, space + 1, nil);
    if (size2 !== body.length)
      throw new Error("Invalid body length.");
    var type2 = bodec.toRaw(buffer, 0, space);
    return {
      type: type2,
      body: decode ? decoders[type2](body) : body
    };
  };
  var indexOf = function(buffer, byte, i) {
    i |= 0;
    var length3 = buffer.length;
    for (;; i++) {
      if (i >= length3)
        return -1;
      if (buffer[i] === byte)
        return i;
    }
  };
  var parseOct = function(buffer, start, end) {
    var val = 0;
    while (start < end) {
      val = (val << 3) + buffer[start++] - 48;
    }
    return val;
  };
  var parseDec = function(buffer, start, end) {
    var val = 0;
    while (start < end) {
      val = val * 10 + buffer[start++] - 48;
    }
    return val;
  };
  var bodec = require_bodec();
  var modes = require_modes();
  var encoders = exports2.encoders = {
    blob: encodeBlob,
    tree: encodeTree,
    commit: encodeCommit,
    tag: encodeTag
  };
  exports2.frame = frame;
  var decoders = exports2.decoders = {
    blob: decodeBlob,
    tree: decodeTree,
    commit: decodeCommit,
    tag: decodeTag
  };
  exports2.deframe = deframe;
  exports2.treeMap = treeMap;
  exports2.treeSort = treeSort;
});

// ../../node_modules/js-git/lib/inflate-stream.js
var require_inflate_stream = __commonJS((exports2, module2) => {
  var Inflate = require_pako().Inflate;
  var Binary = require_bodec().Binary;
  module2.exports = function inflateStream() {
    var inf = new Inflate;
    var b = new Uint8Array(1);
    var empty = new Binary(0);
    return {
      write: write4,
      recycle,
      flush: Binary === Uint8Array ? flush : flushConvert
    };
    function write4(byte) {
      b[0] = byte;
      inf.push(b);
      return !inf.ended;
    }
    function recycle() {
      inf = new Inflate;
    }
    function flush() {
      return inf.result || empty;
    }
    function flushConvert() {
      return inf.result ? new Binary(inf.result) : empty;
    }
  };
});

// ../../node_modules/git-sha1/git-sha1.js
var require_git_sha1 = __commonJS((exports2, module2) => {
  var createNode = function() {
    var shasum = crypto.createHash("sha1");
    return {
      update: function(buffer) {
        return shasum.update(buffer);
      },
      digest: function() {
        return shasum.digest("hex");
      }
    };
  };
  var createJs = function(sync) {
    var h0 = 1732584193;
    var h1 = 4023233417;
    var h2 = 2562383102;
    var h3 = 271733878;
    var h4 = 3285377520;
    var block, offset = 0, shift = 24;
    var totalLength = 0;
    if (sync)
      block = shared;
    else
      block = new Uint32Array(80);
    return { update, digest };
    function update(chunk) {
      if (typeof chunk === "string")
        return updateString(chunk);
      var length3 = chunk.length;
      totalLength += length3 * 8;
      for (var i = 0;i < length3; i++) {
        write4(chunk[i]);
      }
    }
    function updateString(string) {
      var length3 = string.length;
      totalLength += length3 * 8;
      for (var i = 0;i < length3; i++) {
        write4(string.charCodeAt(i));
      }
    }
    function write4(byte) {
      block[offset] |= (byte & 255) << shift;
      if (shift) {
        shift -= 8;
      } else {
        offset++;
        shift = 24;
      }
      if (offset === 16)
        processBlock();
    }
    function digest() {
      write4(128);
      if (offset > 14 || offset === 14 && shift < 24) {
        processBlock();
      }
      offset = 14;
      shift = 24;
      write4(0);
      write4(0);
      write4(totalLength > 1099511627775 ? totalLength / 1099511627776 : 0);
      write4(totalLength > 4294967295 ? totalLength / 4294967296 : 0);
      for (var s = 24;s >= 0; s -= 8) {
        write4(totalLength >> s);
      }
      return toHex(h0) + toHex(h1) + toHex(h2) + toHex(h3) + toHex(h4);
    }
    function processBlock() {
      for (var i = 16;i < 80; i++) {
        var w = block[i - 3] ^ block[i - 8] ^ block[i - 14] ^ block[i - 16];
        block[i] = w << 1 | w >>> 31;
      }
      var a = h0;
      var b = h1;
      var c = h2;
      var d = h3;
      var e = h4;
      var f, k;
      for (i = 0;i < 80; i++) {
        if (i < 20) {
          f = d ^ b & (c ^ d);
          k = 1518500249;
        } else if (i < 40) {
          f = b ^ c ^ d;
          k = 1859775393;
        } else if (i < 60) {
          f = b & c | d & (b | c);
          k = 2400959708;
        } else {
          f = b ^ c ^ d;
          k = 3395469782;
        }
        var temp = (a << 5 | a >>> 27) + f + e + k + (block[i] | 0);
        e = d;
        d = c;
        c = b << 30 | b >>> 2;
        b = a;
        a = temp;
      }
      h0 = h0 + a | 0;
      h1 = h1 + b | 0;
      h2 = h2 + c | 0;
      h3 = h3 + d | 0;
      h4 = h4 + e | 0;
      offset = 0;
      for (i = 0;i < 16; i++) {
        block[i] = 0;
      }
    }
    function toHex(word) {
      var hex = "";
      for (var i = 28;i >= 0; i -= 4) {
        hex += (word >> i & 15).toString(16);
      }
      return hex;
    }
  };
  var isNode2 = typeof process === "object" && typeof process.versions === "object" && process.versions.node && process.__atom_type !== "renderer";
  var shared;
  var create8;
  var crypto;
  if (isNode2) {
    nodeRequire = __require;
    crypto = nodeRequire("crypto");
    create8 = createNode;
  } else {
    shared = new Uint32Array(80);
    create8 = createJs;
  }
  var nodeRequire;
  module2.exports = function sha1(buffer) {
    if (buffer === undefined)
      return create8(false);
    var shasum = create8(true);
    shasum.update(buffer);
    return shasum.digest();
  };
});

// ../../node_modules/js-git/lib/pack-codec.js
var require_pack_codec = __commonJS((exports2) => {
  var parseEntry = function(chunk) {
    var offset = 0;
    var byte = chunk[offset++];
    var type3 = numToType[byte >> 4 & 7];
    var size2 = byte & 15;
    var left = 4;
    while (byte & 128) {
      byte = chunk[offset++];
      size2 |= (byte & 127) << left;
      left += 7;
    }
    size2 = size2 >>> 0;
    var ref;
    if (type3 === "ref-delta") {
      ref = bodec.toHex(bodec.slice(chunk, offset, offset += 20));
    } else if (type3 === "ofs-delta") {
      byte = chunk[offset++];
      ref = byte & 127;
      while (byte & 128) {
        byte = chunk[offset++];
        ref = ref + 1 << 7 | byte & 127;
      }
    }
    var body = inflate(bodec.slice(chunk, offset));
    if (body.length !== size2) {
      throw new Error("Size mismatch");
    }
    var result = {
      type: type3,
      body
    };
    if (typeof ref !== "undefined") {
      result.ref = ref;
    }
    return result;
  };
  var decodePack = function(emit) {
    var state = $pack;
    var sha1sum = sha1();
    var inf = inflateStream();
    var offset = 0;
    var position = 0;
    var version3 = 1262698832;
    var num2 = 0;
    var type3 = 0;
    var length3 = 0;
    var ref = null;
    var checksum = "";
    var start = 0;
    var parts = [];
    return function(chunk) {
      if (chunk === undefined) {
        if (num2 || checksum.length < 40)
          throw new Error("Unexpected end of input stream");
        return emit();
      }
      for (var i = 0, l = chunk.length;i < l; i++) {
        if (!state)
          throw new Error("Unexpected extra bytes: " + bodec.slice(chunk, i));
        state = state(chunk[i], i, chunk);
        position++;
      }
      if (!state)
        return;
      if (state !== $checksum)
        sha1sum.update(chunk);
      var buff = inf.flush();
      if (buff.length) {
        parts.push(buff);
      }
    };
    function $pack(byte) {
      if ((version3 & 255) === byte) {
        version3 >>>= 8;
        return version3 ? $pack : $version;
      }
      throw new Error("Invalid packfile header");
    }
    function $version(byte) {
      version3 = version3 << 8 | byte;
      if (++offset < 4)
        return $version;
      if (version3 >= 2 && version3 <= 3) {
        offset = 0;
        return $num;
      }
      throw new Error("Invalid version number " + num2);
    }
    function $num(byte) {
      num2 = num2 << 8 | byte;
      if (++offset < 4)
        return $num;
      offset = 0;
      emit({ version: version3, num: num2 });
      return $header;
    }
    function $header(byte) {
      if (start === 0)
        start = position;
      type3 = byte >> 4 & 7;
      length3 = byte & 15;
      if (byte & 128) {
        offset = 4;
        return $header2;
      }
      return afterHeader();
    }
    function $header2(byte) {
      length3 |= (byte & 127) << offset;
      if (byte & 128) {
        offset += 7;
        return $header2;
      }
      return afterHeader();
    }
    function afterHeader() {
      offset = 0;
      if (type3 === 6) {
        ref = 0;
        return $ofsDelta;
      }
      if (type3 === 7) {
        ref = "";
        return $refDelta;
      }
      return $body;
    }
    function $ofsDelta(byte) {
      ref = byte & 127;
      if (byte & 128)
        return $ofsDelta2;
      return $body;
    }
    function $ofsDelta2(byte) {
      ref = ref + 1 << 7 | byte & 127;
      if (byte & 128)
        return $ofsDelta2;
      return $body;
    }
    function $refDelta(byte) {
      ref += toHex(byte);
      if (++offset < 20)
        return $refDelta;
      return $body;
    }
    function toHex(num3) {
      return num3 < 16 ? "0" + num3.toString(16) : num3.toString(16);
    }
    function emitObject() {
      var body = bodec.join(parts);
      if (body.length !== length3) {
        throw new Error("Body length mismatch");
      }
      var item = {
        type: numToType[type3],
        size: length3,
        body,
        offset: start
      };
      if (ref)
        item.ref = ref;
      parts.length = 0;
      start = 0;
      offset = 0;
      type3 = 0;
      length3 = 0;
      ref = null;
      emit(item);
    }
    function $body(byte, i, chunk) {
      if (inf.write(byte))
        return $body;
      var buf = inf.flush();
      if (buf.length !== length3)
        throw new Error("Length mismatch, expected " + length3 + " got " + buf.length);
      inf.recycle();
      if (buf.length) {
        parts.push(buf);
      }
      emitObject();
      if (--num2)
        return $header;
      sha1sum.update(bodec.slice(chunk, 0, i + 1));
      return $checksum;
    }
    function $checksum(byte) {
      checksum += toHex(byte);
      if (++offset < 20)
        return $checksum;
      var actual = sha1sum.digest();
      if (checksum !== actual)
        throw new Error("Checksum mismatch: " + actual + " != " + checksum);
    }
  };
  var encodePack = function(emit) {
    var sha1sum = sha1();
    var left;
    return function(item) {
      if (item === undefined) {
        if (left !== 0)
          throw new Error("Some items were missing");
        return emit();
      }
      if (typeof item.num === "number") {
        if (left !== undefined)
          throw new Error("Header already sent");
        left = item.num;
        write4(packHeader(item.num));
      } else if (typeof item.type === "string" && bodec.isBinary(item.body)) {
        if (typeof left !== "number")
          throw new Error("Headers not sent yet");
        if (!left)
          throw new Error("All items already sent");
        write4(packFrame(item));
        if (!--left) {
          emit(bodec.fromHex(sha1sum.digest()));
        }
      } else {
        throw new Error("Invalid item");
      }
    };
    function write4(chunk) {
      sha1sum.update(chunk);
      emit(chunk);
    }
  };
  var packHeader = function(length3) {
    return bodec.fromArray([
      80,
      65,
      67,
      75,
      0,
      0,
      0,
      2,
      length3 >> 24,
      length3 >> 16 & 255,
      length3 >> 8 & 255,
      length3 & 255
    ]);
  };
  var packFrame = function(item) {
    var length3 = item.body.length;
    var head = [typeToNum[item.type] << 4 | length3 & 15];
    var i = 0;
    length3 >>= 4;
    while (length3) {
      head[i++] |= 128;
      head[i] = length3 & 127;
      length3 >>= 7;
    }
    if (typeof item.ref === "number") {
      var offset = item.ref;
      i += Math.floor(Math.log(offset) / Math.log(128)) + 1;
      head[i] = offset & 127;
      while (offset >>= 7) {
        head[--i] = 128 | --offset & 127;
      }
    }
    var parts = [bodec.fromArray(head)];
    if (typeof item.ref === "string") {
      parts.push(bodec.fromHex(item.ref));
    }
    parts.push(deflate(item.body));
    return bodec.join(parts);
  };
  var inflateStream = require_inflate_stream();
  var inflate = require_inflate3();
  var deflate = require_deflate3();
  var sha1 = require_git_sha1();
  var bodec = require_bodec();
  var typeToNum = {
    commit: 1,
    tree: 2,
    blob: 3,
    tag: 4,
    "ofs-delta": 6,
    "ref-delta": 7
  };
  var numToType = {};
  for (type2 in typeToNum) {
    num = typeToNum[type2];
    numToType[num] = type2;
  }
  var num;
  var type2;
  exports2.parseEntry = parseEntry;
  exports2.decodePack = decodePack;
  exports2.encodePack = encodePack;
});

// ../../node_modules/js-git/lib/apply-delta.js
var require_apply_delta = __commonJS((exports2, module2) => {
  var applyDelta = function(delta, base) {
    var deltaOffset = 0;
    if (base.length !== readLength()) {
      throw new Error("Base length mismatch");
    }
    var outOffset = 0;
    var out = bodec.create(readLength());
    while (deltaOffset < delta.length) {
      var byte = delta[deltaOffset++];
      if (byte & 128) {
        var offset = 0;
        var length3 = 0;
        if (byte & 1)
          offset |= delta[deltaOffset++] << 0;
        if (byte & 2)
          offset |= delta[deltaOffset++] << 8;
        if (byte & 4)
          offset |= delta[deltaOffset++] << 16;
        if (byte & 8)
          offset |= delta[deltaOffset++] << 24;
        if (byte & 16)
          length3 |= delta[deltaOffset++] << 0;
        if (byte & 32)
          length3 |= delta[deltaOffset++] << 8;
        if (byte & 64)
          length3 |= delta[deltaOffset++] << 16;
        if (length3 === 0)
          length3 = 65536;
        bodec.copy(bodec.slice(base, offset, offset + length3), out, outOffset);
        outOffset += length3;
      } else if (byte) {
        bodec.copy(bodec.slice(delta, deltaOffset, deltaOffset + byte), out, outOffset);
        deltaOffset += byte;
        outOffset += byte;
      } else
        throw new Error("Invalid delta opcode");
    }
    if (outOffset !== out.length) {
      throw new Error("Size mismatch in check");
    }
    return out;
    function readLength() {
      var byte2 = delta[deltaOffset++];
      var length4 = byte2 & 127;
      var shift = 7;
      while (byte2 & 128) {
        byte2 = delta[deltaOffset++];
        length4 |= (byte2 & 127) << shift;
        shift += 7;
      }
      return length4;
    }
  };
  var bodec = require_bodec();
  module2.exports = applyDelta;
});

// ../../node_modules/js-git/mixins/fs-db.js
var require_fs_db = __commonJS((exports2, module2) => {
  var parseIndex = function(buffer) {
    if (readUint32(buffer, 0) !== 4285812579 || readUint32(buffer, 4) !== 2) {
      throw new Error("Only v2 pack indexes supported");
    }
    var hashOffset = 8 + 255 * 4;
    var length3 = readUint32(buffer, hashOffset);
    hashOffset += 4;
    var crcOffset = hashOffset + 20 * length3;
    var lengthOffset = crcOffset + 4 * length3;
    var largeOffset = lengthOffset + 4 * length3;
    var checkOffset = largeOffset;
    var indexes = new Array(length3);
    for (var i = 0;i < length3; i++) {
      var start = hashOffset + i * 20;
      var hash = bodec.toHex(bodec.slice(buffer, start, start + 20));
      var crc = readUint32(buffer, crcOffset + i * 4);
      var offset = readUint32(buffer, lengthOffset + i * 4);
      if (offset & 2147483648) {
        offset = largeOffset + (offset & 2147483647) * 8;
        checkOffset = Math.max(checkOffset, offset + 8);
        offset = readUint64(buffer, offset);
      }
      indexes[i] = {
        hash,
        offset,
        crc
      };
    }
    var packChecksum = bodec.toHex(bodec.slice(buffer, checkOffset, checkOffset + 20));
    var checksum = bodec.toHex(bodec.slice(buffer, checkOffset + 20, checkOffset + 40));
    if (sha1(bodec.slice(buffer, 0, checkOffset + 20)) !== checksum) {
      throw new Error("Checksum mistmatch");
    }
    var byHash = {};
    indexes.sort(function(a, b) {
      return a.offset - b.offset;
    });
    indexes.forEach(function(data) {
      byHash[data.hash] = {
        offset: data.offset,
        crc: data.crc
      };
    });
    var offsets = indexes.map(function(entry) {
      return entry.offset;
    }).sort(function(a, b) {
      return a - b;
    });
    return {
      offsets,
      byHash,
      checksum: packChecksum
    };
  };
  var readUint32 = function(buffer, offset) {
    return (buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3] << 0) >>> 0;
  };
  var readUint64 = function(buffer, offset) {
    var hi = (buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3] << 0) >>> 0;
    var lo = (buffer[offset + 4] << 24 | buffer[offset + 5] << 16 | buffer[offset + 6] << 8 | buffer[offset + 7] << 0) >>> 0;
    return hi * 4294967296 + lo;
  };
  var bodec = require_bodec();
  var inflate = require_inflate3();
  var deflate = require_deflate3();
  var codec = require_object_codec();
  var parsePackEntry = require_pack_codec().parseEntry;
  var applyDelta = require_apply_delta();
  var sha1 = require_git_sha1();
  var pathJoin = __require("path").join;
  module2.exports = function(repo, fs) {
    var cachedIndexes = {};
    repo.loadAs = loadAs;
    repo.saveAs = saveAs;
    repo.loadRaw = loadRaw;
    repo.saveRaw = saveRaw;
    repo.readRef = readRef;
    repo.updateRef = updateRef;
    repo.hasHash = hasHash;
    repo.init = init2;
    repo.setShallow = setShallow;
    function init2(ref, callback) {
      if (!callback)
        return init2.bind(null, ref);
      ref = ref || "refs/heads/master";
      var path2 = pathJoin(repo.rootPath, "HEAD");
      fs.writeFile(path2, "ref: " + ref, callback);
    }
    function setShallow(ref, callback) {
      if (!callback)
        return setShallow.bind(null, ref);
      var path2 = pathJoin(repo.rootPath, "shallow");
      fs.writeFile(path2, ref, callback);
    }
    function updateRef(ref, hash, callback) {
      if (!callback)
        return updateRef.bind(repo, ref, hash);
      var path2 = pathJoin(repo.rootPath, ref);
      var lock = path2 + ".lock";
      fs.writeFile(lock, bodec.fromRaw(hash + "\n"), function(err) {
        if (err)
          return callback(err);
        fs.rename(lock, path2, callback);
      });
    }
    function readRef(ref, callback) {
      if (!callback)
        return readRef.bind(repo, ref);
      var path2 = pathJoin(repo.rootPath, ref);
      fs.readFile(path2, function(err, binary) {
        if (err)
          return callback(err);
        if (binary === undefined) {
          return readPackedRef(ref, callback);
        }
        var hash;
        try {
          hash = bodec.toRaw(binary).trim();
        } catch (err2) {
          return callback(err2);
        }
        callback(null, hash);
      });
    }
    function readPackedRef(ref, callback) {
      var path2 = pathJoin(repo.rootPath, "packed-refs");
      fs.readFile(path2, function(err, binary) {
        if (binary === undefined)
          return callback(err);
        var hash;
        try {
          var text = bodec.toRaw(binary);
          var index = text.indexOf(ref);
          if (index >= 0) {
            hash = text.substring(index - 41, index - 1);
          }
        } catch (err2) {
          return callback(err2);
        }
        callback(null, hash);
      });
    }
    function saveAs(type2, body, callback) {
      if (!callback)
        return saveAs.bind(repo, type2, body);
      var raw, hash;
      try {
        raw = codec.frame({
          type: type2,
          body: codec.encoders[type2](body)
        });
        hash = sha1(raw);
      } catch (err) {
        return callback(err);
      }
      saveRaw(hash, raw, function(err) {
        if (err)
          return callback(err);
        callback(null, hash);
      });
    }
    function saveRaw(hash, raw, callback) {
      if (!callback)
        return saveRaw.bind(repo, hash, raw);
      var buffer, path2;
      try {
        if (sha1(raw) !== hash) {
          throw new Error("Save data does not match hash");
        }
        buffer = deflate(raw);
        path2 = hashToPath(hash);
      } catch (err) {
        return callback(err);
      }
      loadRaw(hash, function(err, data) {
        if (data)
          return callback();
        var tmp = path2.replace(/[0-9a-f]+$/, "tmp_obj_" + Math.random().toString(36).substr(2));
        fs.writeFile(tmp, buffer, function(err2) {
          if (err2)
            return callback(err2);
          fs.rename(tmp, path2, callback);
        });
      });
    }
    function loadAs(type2, hash, callback) {
      if (!callback)
        return loadAs.bind(repo, type2, hash);
      loadRaw(hash, function(err, raw) {
        if (raw === undefined)
          return callback(err);
        var body;
        try {
          raw = codec.deframe(raw);
          if (raw.type !== type2)
            throw new TypeError("Type mismatch");
          body = codec.decoders[raw.type](raw.body);
        } catch (err2) {
          return callback(err2);
        }
        callback(null, body);
      });
    }
    function hasHash(hash, callback) {
      if (!callback)
        return hasHash.bind(repo, hash);
      loadRaw(hash, function(err, body) {
        if (err)
          return callback(err);
        return callback(null, !!body);
      });
    }
    function loadRaw(hash, callback) {
      if (!callback)
        return loadRaw.bind(repo, hash);
      var path2 = hashToPath(hash);
      fs.readFile(path2, function(err, buffer) {
        if (err)
          return callback(err);
        if (buffer) {
          var raw;
          try {
            raw = inflate(buffer);
          } catch (err2) {
            return callback(err2);
          }
          return callback(null, raw);
        }
        return loadRawPacked(hash, callback);
      });
    }
    function loadRawPacked(hash, callback) {
      var packDir = pathJoin(repo.rootPath, "objects/pack");
      var packHashes = [];
      fs.readDir(packDir, function(err, entries) {
        if (!entries)
          return callback(err);
        entries.forEach(function(name2) {
          var match = name2.match(/pack-([0-9a-f]{40}).idx/);
          if (match)
            packHashes.push(match[1]);
        });
        start();
      });
      function start() {
        var packHash = packHashes.pop();
        var offsets;
        if (!packHash)
          return callback();
        if (!cachedIndexes[packHash])
          loadIndex(packHash);
        else
          onIndex();
        function loadIndex() {
          var indexFile = pathJoin(packDir, "pack-" + packHash + ".idx");
          fs.readFile(indexFile, function(err, buffer) {
            if (!buffer)
              return callback(err);
            try {
              cachedIndexes[packHash] = parseIndex(buffer);
            } catch (err2) {
              return callback(err2);
            }
            onIndex();
          });
        }
        function onIndex() {
          var cached = cachedIndexes[packHash];
          var packFile = pathJoin(packDir, "pack-" + packHash + ".pack");
          var index = cached.byHash[hash];
          if (!index)
            return start();
          offsets = cached.offsets;
          loadChunk(packFile, index.offset, callback);
        }
        function loadChunk(packFile, start2, callback2) {
          var index = offsets.indexOf(start2);
          if (index < 0) {
            var error = new Error("Can't find chunk starting at " + start2);
            return callback2(error);
          }
          var end = index + 1 < offsets.length ? offsets[index + 1] : -20;
          fs.readChunk(packFile, start2, end, function(err, chunk) {
            if (!chunk)
              return callback2(err);
            var raw;
            try {
              var entry = parsePackEntry(chunk);
              if (entry.type === "ref-delta") {
                return loadRaw.call(repo, entry.ref, onBase);
              } else if (entry.type === "ofs-delta") {
                return loadChunk(packFile, start2 - entry.ref, onBase);
              }
              raw = codec.frame(entry);
            } catch (err2) {
              return callback2(err2);
            }
            callback2(null, raw);
            function onBase(err2, base) {
              if (!base)
                return callback2(err2);
              var object = codec.deframe(base);
              var buffer;
              try {
                object.body = applyDelta(entry.body, object.body);
                buffer = codec.frame(object);
              } catch (err3) {
                return callback2(err3);
              }
              callback2(null, buffer);
            }
          });
        }
      }
    }
    function hashToPath(hash) {
      return pathJoin(repo.rootPath, "objects", hash.substring(0, 2), hash.substring(2));
    }
  };
});

// ../../node_modules/git-node-fs/lib/node-fs.js
var require_node_fs = __commonJS((exports2, module2) => {
  var readFile = function(path2, callback) {
    nodeFs.readFile(path2, function(err, binary) {
      if (err) {
        if (err.code === "ENOENT")
          return callback();
        return callback(err);
      }
      return callback(null, binary);
    });
  };
  var readChunk = function(path2, start, end, callback) {
    if (end < 0) {
      return readLastChunk(path2, start, end, callback);
    }
    var stream2 = nodeFs.createReadStream(path2, {
      start,
      end: end - 1
    });
    var chunks = [];
    stream2.on("readable", function() {
      var chunk = stream2.read();
      if (chunk === null)
        return callback(null, Buffer.concat(chunks));
      return chunks.push(chunk);
    });
    stream2.on("error", function(err) {
      if (err.code === "ENOENT")
        return callback();
      return callback(err);
    });
  };
  var readLastChunk = function(path2, start, end, callback) {
    nodeFs.open(path2, "r", function(err, fd) {
      if (err) {
        if (err.code === "EACCES")
          return callback();
        return callback(err);
      }
      var buffer = new Buffer(4096);
      var length3 = 0;
      read();
      start = null;
      function read() {
        if (buffer.length - length3 === 0) {
          grow();
        }
        nodeFs.read(fd, buffer, length3, buffer.length - length3, start, onread);
      }
      function onread(err2, bytesRead) {
        if (err2)
          return callback(err2);
        length3 += bytesRead;
        if (bytesRead === 0) {
          return callback(null, buffer.slice(0, buffer.length + end));
        }
        read();
      }
      function grow() {
        var newBuffer = new Buffer(buffer.length * 2);
        buffer.copy(newBuffer);
        buffer = newBuffer;
      }
    });
  };
  var writeFile = function(path2, binary, callback) {
    mkdirp(nodePath.dirname(path2), function(err) {
      if (err)
        return callback(err);
      nodeFs.writeFile(path2, binary, callback);
    });
  };
  var rename = function(oldPath, newPath, callback) {
    var oldBase = nodePath.dirname(oldPath);
    var newBase = nodePath.dirname(newPath);
    if (oldBase === newBase) {
      return nodeFs.rename(oldPath, newPath, callback);
    }
    mkdirp(nodePath.dirname(path), function(err) {
      if (err)
        return callback(err);
      nodeFs.rename(oldPath, newPath, callback);
    });
  };
  var readDir = function(path2, callback) {
    nodeFs.readdir(path2, function(err, names) {
      if (err) {
        if (err.code === "ENOENT")
          return callback();
        return callback(err);
      }
      return callback(null, names);
    });
  };
  var mkdirp = function(path2, callback) {
    nodeFs.mkdir(path2, function(err) {
      if (err) {
        if (err.code === "ENOENT") {
          return mkdirp(nodePath.dirname(path2), function(err2) {
            if (err2)
              return callback(err2);
            nodeFs.mkdir(path2, function(err3) {
              if (err3 && err3.code !== "EEXIST")
                return callback(err3);
              return callback();
            });
          });
        }
        if (err.code === "EEXIST")
          return callback();
        return callback(err);
      }
      callback();
    });
  };
  var nodeFs = __require("fs");
  var nodePath = __require("path");
  var fs = module2.exports = {};
  fs.readFile = readFile;
  fs.readChunk = readChunk;
  fs.writeFile = writeFile;
  fs.readDir = readDir;
  fs.rename = rename;
});

// ../../node_modules/git-node-fs/mixins/fs-db.js
var require_fs_db2 = __commonJS((exports2, module2) => {
  var fsDb = require_fs_db();
  var nodeFs = require_node_fs();
  module2.exports = function(repo, rootPath) {
    repo.rootPath = rootPath;
    fsDb(repo, nodeFs);
  };
});

// ../../node_modules/js-git/mixins/walkers.js
var require_walkers = __commonJS((exports2, module2) => {
  var logWalk = function(ref, callback) {
    if (!callback)
      return logWalk.bind(this, ref);
    var last2, seen = {};
    var repo = this;
    if (!repo.readRef)
      return onShallow();
    return repo.readRef("shallow", onShallow);
    function onShallow(err, shallow) {
      last2 = shallow;
      resolveRef(repo, ref, onHash);
    }
    function onHash(err, hash) {
      if (err)
        return callback(err);
      return repo.loadAs("commit", hash, function(err2, commit) {
        if (commit === undefined)
          return callback(err2);
        commit.hash = hash;
        seen[hash] = true;
        return callback(null, walk(commit, scan, loadKey, compare));
      });
    }
    function scan(commit) {
      if (last2 === commit)
        return [];
      return commit.parents.filter(function(hash) {
        return !seen[hash];
      });
    }
    function loadKey(hash, callback2) {
      return repo.loadAs("commit", hash, function(err, commit) {
        if (!commit)
          return callback2(err || new Error("Missing commit " + hash));
        commit.hash = hash;
        if (hash === last2)
          commit.last = true;
        return callback2(null, commit);
      });
    }
  };
  var compare = function(commit, other) {
    return commit.author.date < other.author.date;
  };
  var treeWalk = function(hash, callback) {
    if (!callback)
      return treeWalk.bind(this, hash);
    var repo = this;
    return repo.loadAs("tree", hash, onTree);
    function onTree(err, body) {
      if (!body)
        return callback(err || new Error("Missing tree " + hash));
      var tree = {
        mode: modes.tree,
        hash,
        body,
        path: "/"
      };
      return callback(null, walk(tree, treeScan, treeLoadKey, treeCompare));
    }
    function treeLoadKey(entry, callback2) {
      if (entry.mode !== modes.tree)
        return callback2(null, entry);
      var type2 = modes.toType(entry.mode);
      return repo.loadAs(type2, entry.hash, function(err, body) {
        if (err)
          return callback2(err);
        entry.body = body;
        return callback2(null, entry);
      });
    }
  };
  var treeScan = function(object) {
    if (object.mode !== modes.tree)
      return [];
    var tree = object.body;
    return Object.keys(tree).map(function(name2) {
      var entry = tree[name2];
      var path2 = object.path + name2;
      if (entry.mode === modes.tree)
        path2 += "/";
      return {
        mode: entry.mode,
        hash: entry.hash,
        path: path2
      };
    });
  };
  var treeCompare = function(first, second) {
    return first.path < second.path;
  };
  var resolveRef = function(repo, hashish, callback) {
    if (/^[0-9a-f]{40}$/.test(hashish)) {
      return callback(null, hashish);
    }
    repo.readRef(hashish, function(err, hash) {
      if (!hash)
        return callback(err || new Error("Bad ref " + hashish));
      callback(null, hash);
    });
  };
  var walk = function(seed, scan, loadKey, compare2) {
    var queue = [seed];
    var working = 0, error, cb;
    return { read, abort };
    function read(callback) {
      if (!callback)
        return read;
      if (cb)
        return callback(new Error("Only one read at a time"));
      if (working) {
        cb = callback;
        return;
      }
      var item = queue.shift();
      if (!item)
        return callback();
      try {
        scan(item).forEach(onKey);
      } catch (err) {
        return callback(err);
      }
      return callback(null, item);
    }
    function abort(callback) {
      return callback();
    }
    function onError(err) {
      if (cb) {
        var callback = cb;
        cb = null;
        return callback(err);
      }
      error = err;
    }
    function onKey(key) {
      working++;
      loadKey(key, onItem);
    }
    function onItem(err, item) {
      working--;
      if (err)
        return onError(err);
      var index = queue.length;
      while (index && compare2(item, queue[index - 1]))
        index--;
      queue.splice(index, 0, item);
      if (!working && cb) {
        var callback = cb;
        cb = null;
        return read(callback);
      }
    }
  };
  var modes = require_modes();
  module2.exports = function(repo) {
    repo.logWalk = logWalk;
    repo.treeWalk = treeWalk;
  };
  module2.exports.walk = walk;
});

// ../../node_modules/vizion/lib/git/js-git-service.js
var require_js_git_service = __commonJS((exports2, module2) => {
  var path2 = __require("path");
  var whilst = require_whilst();
  var helper = require_helper();
  var jsGitService = {};
  jsGitService.loadRepo = function(folder) {
    var repo = {};
    require_fs_db2()(repo, path2.join(folder, ".git"));
    require_walkers()(repo);
    return repo;
  };
  jsGitService.getHeadCommit = function(folder, remote, cb) {
    if (cb === undefined) {
      cb = remote;
      remote = null;
    }
    var repo = jsGitService.loadRepo(folder);
    var ref = remote ? "refs/remotes/" + remote + "/HEAD" : "HEAD";
    jsGitService.getLastCommitByRef(repo, ref, cb);
  };
  jsGitService.getLastCommit = function(folder, branch, remote, cb) {
    if (cb === undefined) {
      cb = remote;
      remote = null;
    }
    var repo = jsGitService.loadRepo(folder);
    var ref = remote ? "refs/remotes/origin/" + branch : "refs/heads/" + branch;
    jsGitService.getLastCommitByRef(repo, ref, cb);
  };
  jsGitService.getLastCommitByRef = function(repo, ref, cb) {
    repo.readRef(ref, function(err, commitHash) {
      if (err) {
        return cb(err);
      }
      if (!commitHash) {
        return cb(null);
      }
      repo.logWalk(commitHash.replace(/ref: /g, ""), function(err2, logStream) {
        if (err2) {
          return cb(err2);
        }
        if (!logStream) {
          return cb(null);
        }
        logStream.read(function(err3, commit) {
          if (err3) {
            return cb(err3);
          }
          cb(null, commit);
        });
      });
    });
  };
  jsGitService.getCommitByHash = function(repo, hash, cb) {
    repo.loadAs("commit", hash, function(err, commit) {
      if (err) {
        return cb(err);
      }
      cb(null, commit);
    });
  };
  jsGitService.getCommitHistory = function(folder, n, branch, remote, cb) {
    var commitHistory = [];
    if (cb === undefined) {
      cb = remote;
      remote = null;
    }
    var repo = jsGitService.loadRepo(folder);
    var ref;
    if (branch === "HEAD") {
      ref = remote ? "refs/remotes/" + remote + "/HEAD" : "HEAD";
    } else {
      ref = remote ? "refs/remotes/origin/" + branch : "refs/heads/" + branch;
    }
    jsGitService.getLastCommitByRef(repo, ref, function(err, commit) {
      if (err) {
        return cb(err);
      }
      if (!commit) {
        return cb(null, commitHistory);
      }
      commitHistory.push(commit);
      var count = 1;
      var parentCommitHash = helper.last(commit.parents);
      whilst(function() {
        return count < n && parentCommitHash;
      }, function(callback) {
        jsGitService.getCommitByHash(repo, parentCommitHash, function(err2, commit2) {
          if (err2) {
            return callback(err2);
          }
          if (!commit2) {
            parentCommitHash = null;
            return callback(null);
          }
          commit2.hash = parentCommitHash;
          count++;
          commitHistory.push(commit2);
          parentCommitHash = helper.last(commit2.parents);
          callback(null);
        });
      }, function(err2) {
        if (err2) {
          return cb(err2);
        }
        return cb(null, commitHistory);
      });
    });
  };
  jsGitService.getRefHash = function(folder, branch, remote, cb) {
    var repo = jsGitService.loadRepo(folder);
    repo.readRef("refs/remotes/" + remote + "/" + branch, cb);
  };
  module2.exports = jsGitService;
});

// ../../node_modules/vizion/lib/git/git.js
var require_git = __commonJS((exports2, module2) => {
  var fs = __require("fs");
  var waterfall = require_waterfall2();
  var exec = __require("child_process").exec;
  var ini = require_ini();
  var path2 = __require("path");
  var helper = require_helper();
  var cliCommand = require_cliCommand();
  var jsGitService = require_js_git_service();
  var git = {};
  var TIMEOUT = 5000;
  var MAXBUFFER = 1024 * 64;
  git.parseGitConfig = function(folder, cb) {
    fs.readFile(path2.join(folder, ".git/config"), "utf-8", function(err, data) {
      if (err) {
        return cb(err);
      }
      var config = ini.parse(data);
      cb(null, config);
    });
  };
  git.getUrl = function(folder, cb) {
    git.parseGitConfig(folder, function(err, config) {
      if (err) {
        return cb(err);
      }
      var data = {};
      data.type = "git";
      data.url = helper.get(config, 'remote "origin".url');
      cb(null, data);
    });
  };
  git.getCommitInfo = function(folder, data, cb) {
    jsGitService.getHeadCommit(folder, function(err, commit) {
      if (err) {
        return cb(err);
      }
      data.revision = helper.get(commit, "hash");
      data.comment = helper.get(commit, "message");
      cb(null, data);
    });
  };
  git.getStaged = function(folder, data, cb) {
    exec(cliCommand(folder, "git status -s"), { timeout: TIMEOUT, maxBuffer: MAXBUFFER }, function(err, stdout, stderr) {
      if (err) {
        return cb(err);
      }
      data.unstaged = stdout === "" ? false : true;
      return cb(null, data);
    });
  };
  git.getBranch = function(folder, data, cb) {
    fs.readFile(path2.join(folder, ".git/HEAD"), "utf-8", function(err, content) {
      if (err) {
        return cb(err);
      }
      var regex = /ref: refs\/heads\/(.*)/;
      var match = regex.exec(content);
      data.branch = match ? match[1] : "HEAD";
      return cb(null, data);
    });
  };
  git.getRemote = function(folder, data, cb) {
    git.parseGitConfig(folder, function(err, config) {
      if (err) {
        return cb(err);
      }
      data.remotes = [];
      Object.keys(config).map(function(key) {
        var regex = /remote "(.*)"/;
        var match = regex.exec(key);
        if (match) {
          data.remotes.push(match[1]);
        }
      });
      data.remote = data.remotes.indexOf("origin") === -1 ? data.remotes[0] : "origin";
      cb(null, data);
    });
  };
  git.isCurrentBranchOnRemote = function(folder, data, cb) {
    jsGitService.getRefHash(folder, data.branch, data.remote, function(err, hash) {
      if (err) {
        return cb(err);
      }
      data.branch_exists_on_remote = !!hash;
      return cb(null, data);
    });
  };
  git.getPrevNext = function(folder, data, cb) {
    var remote = data.branch_exists_on_remote ? data.remote : null;
    jsGitService.getCommitHistory(folder, 100, data.branch, remote, function(err, commitHistory) {
      if (err) {
        return cb(err);
      }
      var currentCommitIndex = commitHistory.findIndex(({ hash }) => hash === data.revision);
      if (currentCommitIndex === -1) {
        data.ahead = true;
        data.next_rev = null;
        data.prev_rev = null;
      } else {
        data.ahead = false;
        data.next_rev = currentCommitIndex === 0 ? null : commitHistory[currentCommitIndex - 1].hash;
        data.prev_rev = currentCommitIndex === commitHistory.length - 1 ? null : commitHistory[currentCommitIndex + 1].hash;
      }
      cb(null, data);
    });
  };
  git.getUpdateTime = function(folder, data, cb) {
    fs.stat(folder + ".git", function(err, stats) {
      if (err) {
        return cb(err);
      }
      data.update_time = helper.trimNewLine(stats.mtime);
      return cb(null, data);
    });
  };
  git.getTags = function(folder, data, cb) {
    exec(cliCommand(folder, "git tag"), { timeout: TIMEOUT, maxBuffer: MAXBUFFER }, function(err, stdout, stderr) {
      if (err) {
        return cb(err);
      }
      if (stdout.length) {
        data.tags = stdout.split("\n");
        data.tags.pop();
        data.tags = data.tags.slice(0, 10);
      }
      return cb(null, data);
    });
  };
  git.parse = function(folder, cb) {
    waterfall([
      git.getUrl.bind(null, folder),
      git.getCommitInfo.bind(null, folder),
      git.getStaged.bind(null, folder),
      git.getBranch.bind(null, folder),
      git.getRemote.bind(null, folder),
      git.isCurrentBranchOnRemote.bind(null, folder),
      git.getPrevNext.bind(null, folder),
      git.getUpdateTime.bind(null, folder),
      git.getTags.bind(null, folder)
    ], function(err, data) {
      if (err) {
        return cb(err);
      }
      return cb(null, data);
    });
  };
  git.isUpdated = function(folder, cb) {
    waterfall([
      git.getCommitInfo.bind(null, folder, {}),
      git.getBranch.bind(null, folder),
      git.getRemote.bind(null, folder),
      git.isCurrentBranchOnRemote.bind(null, folder)
    ], function(err, data) {
      if (err) {
        return cb(err);
      }
      exec(cliCommand(folder, "git remote update"), { timeout: 60000, maxBuffer: MAXBUFFER }, function(err2, stdout, stderr) {
        if (err2) {
          return cb(err2);
        }
        var remote = data.branch_exists_on_remote ? data.remote : null;
        jsGitService.getLastCommit(folder, data.branch, remote, function(err3, commit) {
          if (err3) {
            return cb(err3);
          }
          var res = {
            new_revision: commit.hash,
            current_revision: data.revision,
            is_up_to_date: commit.hash === data.revision
          };
          return cb(null, res);
        });
      });
    });
  };
  git.revert = function(args2, cb) {
    var ret = {};
    var command = cliCommand(args2.folder, "git reset --hard " + args2.revision);
    ret.output = "";
    ret.output += command + "\n";
    ret.success = true;
    exec(command, { timeout: TIMEOUT, maxBuffer: MAXBUFFER }, function(err, stdout, stderr) {
      ret.output += stdout;
      if (err !== null || stderr.substring(0, 6) === "fatal:")
        ret.success = false;
      return cb(null, ret);
    });
  };
  git.update = function(folder, cb) {
    git.isUpdated(folder, function(err, data) {
      if (err) {
        return cb(err);
      }
      var res = {};
      if (data.is_up_to_date === true) {
        res.success = false;
        res.current_revision = data.new_revision;
        return cb(null, res);
      } else {
        git.revert({ folder, revision: data.new_revision }, function(err2, dt) {
          if (err2) {
            return cb(err2);
          }
          res.output = dt.output;
          res.success = dt.success;
          res.current_revision = dt.success ? data.new_revision : data.current_revision;
          return cb(null, res);
        });
      }
    });
  };
  git.prev = function(folder, cb) {
    waterfall([
      git.getCommitInfo.bind(null, folder, {}),
      git.getBranch.bind(null, folder),
      git.getRemote.bind(null, folder),
      git.isCurrentBranchOnRemote.bind(null, folder),
      git.getPrevNext.bind(null, folder)
    ], function(err, data) {
      if (err) {
        return cb(err);
      }
      var res = {};
      if (data.prev_rev !== null) {
        git.revert({ folder, revision: data.prev_rev }, function(err2, meta2) {
          if (err2) {
            return cb(err2);
          }
          res.output = meta2.output;
          res.success = meta2.success;
          res.current_revision = res.success ? data.prev_rev : data.revision;
          return cb(null, res);
        });
      } else {
        res.success = false;
        res.current_revision = data.revision;
        return cb(null, res);
      }
    });
  };
  git.next = function(folder, cb) {
    waterfall([
      git.getCommitInfo.bind(null, folder, {}),
      git.getBranch.bind(null, folder),
      git.getRemote.bind(null, folder),
      git.isCurrentBranchOnRemote.bind(null, folder),
      git.getPrevNext.bind(null, folder)
    ], function(err, data) {
      if (err) {
        return cb(err);
      }
      var res = {};
      if (data.next_rev !== null) {
        git.revert({ folder, revision: data.next_rev }, function(err2, meta2) {
          if (err2) {
            return cb(err2);
          }
          res.output = meta2.output;
          res.success = meta2.success;
          res.current_revision = res.success ? data.next_rev : data.revision;
          return cb(null, res);
        });
      } else {
        res.success = false;
        res.current_revision = data.revision;
        return cb(null, res);
      }
    });
  };
  module2.exports = git;
});

// ../../node_modules/vizion/lib/svn/svn.js
var require_svn = __commonJS((exports2, module2) => {
  var fs = __require("fs");
  var waterfall = require_waterfall2();
  var exec = __require("child_process").exec;
  var cliCommand = require_cliCommand();
  var svn = {};
  svn.parse = function(folder, cb) {
    var getMeta = function(cb2) {
      exec(cliCommand(folder, "svn info"), function(err, stdout, stderr) {
        if (err !== null)
          return cb2(err);
        var data = {};
        data.type = "svn";
        data.url = stdout.match(/Repository Root: ([^\n]+)/);
        if (data.url && typeof data.url === "object") {
          data.url = data.url[1];
        }
        var match = stdout.match(/Relative URL: \^\/([^\n]+)/);
        if (match) {
          var relativeUrl = match[1];
          if (relativeUrl.match(/^trunk/)) {
            data.branch = "trunk";
          } else if (relativeUrl.match(/^branch/)) {
            match = relativeUrl.match(/^branch(?:es)?\/([^/]+)(?:\/|$)/);
            if (match) {
              data.branch = match[1];
            }
          }
        }
        match = stdout.match(/Last Changed Rev: ([^\n]+)/);
        if (match) {
          data.revision = match[1];
        }
        match = stdout.match(/Last Changed Date: ([^\n]+)/);
        if (match) {
          var date = new Date(match[1]);
          data.update_time = date;
        }
        return cb2(null, data);
      });
    };
    var getRevComment = function(data, cb2) {
      var rev = data.revision || "BASE";
      exec(cliCommand(folder, "svn log -r " + rev), function(err, stdout, stderr) {
        if (err !== null)
          return cb2(err);
        if (rev === "BASE") {
          data.revision = stdout.match(/^(r[0-9]+)\s\|/m);
          if (data.revision)
            data.revision = data.revision[1];
        }
        data.comment = stdout.match(/lines?\s*\n((.|\n)*)\n-{72}\n$/);
        if (data.comment)
          data.comment = data.comment[1].replace(/\n/g, "");
        if (!data.update_time) {
          data.update_time = stdout.match(/-+\n(.*?)\n/);
          if (data.update_time)
            data.update_time = new Date(data.update_time[1].split(" | ")[2]);
        }
        cb2(null, data);
      });
    };
    var getDate = function(data, cb2) {
      if (data.update_time)
        return cb2(null, data);
      fs.stat(folder + ".svn", function(err, stats) {
        if (err !== null)
          return cb2(err);
        data.update_time = stats.mtime;
        return cb2(null, data);
      });
    };
    waterfall([getMeta, getRevComment, getDate], function(err, data) {
      if (err !== null)
        return cb(err);
      return cb(null, data);
    });
  };
  svn.isUpdated = function(folder, cb) {
    var res = {};
    var getRev = function(str) {
      var matches = str.match(/Changed Rev: ([^\n]+)/);
      if (matches)
        matches = matches[1];
      return matches;
    };
    exec(cliCommand(folder, "svn info"), function(err, stdout, stderr) {
      if (err !== null)
        return cb(err);
      var current_rev = getRev(stdout);
      exec(cliCommand(folder, "svn info -r HEAD"), function(err2, stdout2, stderr2) {
        if (err2 !== null)
          return cb(err2);
        var recent_rev = getRev(stdout2);
        res.is_up_to_date = recent_rev === current_rev;
        res.new_revision = recent_rev;
        res.current_revision = current_rev;
        return cb(null, res);
      });
    });
  };
  svn.update = function(folder, cb) {
    var res = {};
    exec(cliCommand(folder, "svn update"), function(err, stdout, stderr) {
      if (err !== null)
        return cb(err);
      var new_rev = stdout.match(/Updated to revision ([^\.]+)/);
      if (new_rev === null) {
        res.success = false;
        var old_rev = stdout.match(/At revision ([^\.]+)/);
        res.current_revision = old_rev ? old_rev[1] : null;
      } else {
        res.success = true;
        res.current_revision = new_rev[1];
      }
      return cb(null, res);
    });
  };
  module2.exports = svn;
});

// ../../node_modules/lodash/_freeGlobal.js
var require__freeGlobal = __commonJS((exports2, module2) => {
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  module2.exports = freeGlobal;
});

// ../../node_modules/lodash/_root.js
var require__root = __commonJS((exports2, module2) => {
  var freeGlobal = require__freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  module2.exports = root;
});

// ../../node_modules/lodash/_Symbol.js
var require__Symbol = __commonJS((exports2, module2) => {
  var root = require__root();
  var Symbol2 = root.Symbol;
  module2.exports = Symbol2;
});

// ../../node_modules/lodash/_getRawTag.js
var require__getRawTag = __commonJS((exports2, module2) => {
  var getRawTag = function(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  };
  var Symbol2 = require__Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  module2.exports = getRawTag;
});

// ../../node_modules/lodash/_objectToString.js
var require__objectToString = __commonJS((exports2, module2) => {
  var objectToString = function(value) {
    return nativeObjectToString.call(value);
  };
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  module2.exports = objectToString;
});

// ../../node_modules/lodash/_baseGetTag.js
var require__baseGetTag = __commonJS((exports2, module2) => {
  var baseGetTag = function(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  };
  var Symbol2 = require__Symbol();
  var getRawTag = require__getRawTag();
  var objectToString = require__objectToString();
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  module2.exports = baseGetTag;
});

// ../../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS((exports2, module2) => {
  var isFunction = function(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  };
  var baseGetTag = require__baseGetTag();
  var isObject = require_isObject();
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  module2.exports = isFunction;
});

// ../../node_modules/lodash/isLength.js
var require_isLength = __commonJS((exports2, module2) => {
  var isLength = function(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER4;
  };
  var MAX_SAFE_INTEGER4 = 9007199254740991;
  module2.exports = isLength;
});

// ../../node_modules/lodash/isArrayLike.js
var require_isArrayLike2 = __commonJS((exports2, module2) => {
  var isArrayLike = function(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  };
  var isFunction = require_isFunction();
  var isLength = require_isLength();
  module2.exports = isArrayLike;
});

// ../../node_modules/vizion/node_modules/async/internal/getIterator.js
var require_getIterator2 = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = function(coll) {
    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
  };
  var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator;
  module2.exports = exports2["default"];
});

// ../../node_modules/lodash/_baseTimes.js
var require__baseTimes = __commonJS((exports2, module2) => {
  var baseTimes = function(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  };
  module2.exports = baseTimes;
});

// ../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS((exports2, module2) => {
  var isObjectLike = function(value) {
    return value != null && typeof value == "object";
  };
  module2.exports = isObjectLike;
});

// ../../node_modules/lodash/_baseIsArguments.js
var require__baseIsArguments = __commonJS((exports2, module2) => {
  var baseIsArguments = function(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  };
  var baseGetTag = require__baseGetTag();
  var isObjectLike = require_isObjectLike();
  var argsTag = "[object Arguments]";
  module2.exports = baseIsArguments;
});

// ../../node_modules/lodash/isArguments.js
var require_isArguments = __commonJS((exports2, module2) => {
  var baseIsArguments = require__baseIsArguments();
  var isObjectLike = require_isObjectLike();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  module2.exports = isArguments;
});

// ../../node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS((exports2, module2) => {
  var stubFalse = function() {
    return false;
  };
  module2.exports = stubFalse;
});

// ../../node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS((exports2, module2) => {
  var root = require__root();
  var stubFalse = require_stubFalse();
  var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root.Buffer : undefined;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined;
  var isBuffer = nativeIsBuffer || stubFalse;
  module2.exports = isBuffer;
});

// ../../node_modules/lodash/_isIndex.js
var require__isIndex = __commonJS((exports2, module2) => {
  var isIndex = function(value, length3) {
    var type2 = typeof value;
    length3 = length3 == null ? MAX_SAFE_INTEGER4 : length3;
    return !!length3 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length3);
  };
  var MAX_SAFE_INTEGER4 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  module2.exports = isIndex;
});

// ../../node_modules/lodash/_baseIsTypedArray.js
var require__baseIsTypedArray = __commonJS((exports2, module2) => {
  var baseIsTypedArray = function(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  };
  var baseGetTag = require__baseGetTag();
  var isLength = require_isLength();
  var isObjectLike = require_isObjectLike();
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  module2.exports = baseIsTypedArray;
});

// ../../node_modules/lodash/_baseUnary.js
var require__baseUnary = __commonJS((exports2, module2) => {
  var baseUnary = function(func) {
    return function(value) {
      return func(value);
    };
  };
  module2.exports = baseUnary;
});

// ../../node_modules/lodash/_nodeUtil.js
var require__nodeUtil = __commonJS((exports2, module2) => {
  var freeGlobal = require__freeGlobal();
  var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module2.exports = nodeUtil;
});

// ../../node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS((exports2, module2) => {
  var baseIsTypedArray = require__baseIsTypedArray();
  var baseUnary = require__baseUnary();
  var nodeUtil = require__nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  module2.exports = isTypedArray;
});

// ../../node_modules/lodash/_arrayLikeKeys.js
var require__arrayLikeKeys = __commonJS((exports2, module2) => {
  var arrayLikeKeys = function(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length3 = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length3)))) {
        result.push(key);
      }
    }
    return result;
  };
  var baseTimes = require__baseTimes();
  var isArguments = require_isArguments();
  var isArray2 = require_isArray();
  var isBuffer = require_isBuffer();
  var isIndex = require__isIndex();
  var isTypedArray = require_isTypedArray();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module2.exports = arrayLikeKeys;
});

// ../../node_modules/lodash/_isPrototype.js
var require__isPrototype = __commonJS((exports2, module2) => {
  var isPrototype = function(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  };
  var objectProto = Object.prototype;
  module2.exports = isPrototype;
});

// ../../node_modules/lodash/_overArg.js
var require__overArg = __commonJS((exports2, module2) => {
  var overArg = function(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  };
  module2.exports = overArg;
});

// ../../node_modules/lodash/_nativeKeys.js
var require__nativeKeys = __commonJS((exports2, module2) => {
  var overArg = require__overArg();
  var nativeKeys = overArg(Object.keys, Object);
  module2.exports = nativeKeys;
});

// ../../node_modules/lodash/_baseKeys.js
var require__baseKeys = __commonJS((exports2, module2) => {
  var baseKeys = function(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  };
  var isPrototype = require__isPrototype();
  var nativeKeys = require__nativeKeys();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module2.exports = baseKeys;
});

// ../../node_modules/lodash/keys.js
var require_keys = __commonJS((exports2, module2) => {
  var keys3 = function(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  };
  var arrayLikeKeys = require__arrayLikeKeys();
  var baseKeys = require__baseKeys();
  var isArrayLike = require_isArrayLike2();
  module2.exports = keys3;
});

// ../../node_modules/vizion/node_modules/async/internal/iterator.js
var require_iterator2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var createArrayIterator = function(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
      return ++i < len ? { value: coll[i], key: i } : null;
    };
  };
  var createES2015Iterator = function(iterator2) {
    var i = -1;
    return function next() {
      var item = iterator2.next();
      if (item.done)
        return null;
      i++;
      return { value: item.value, key: i };
    };
  };
  var createObjectIterator = function(obj) {
    var okeys = (0, _keys2.default)(obj);
    var i = -1;
    var len = okeys.length;
    return function next() {
      var key = okeys[++i];
      if (key === "__proto__") {
        return next();
      }
      return i < len ? { value: obj[key], key } : null;
    };
  };
  var iterator = function(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
      return createArrayIterator(coll);
    }
    var iterator2 = (0, _getIterator2.default)(coll);
    return iterator2 ? createES2015Iterator(iterator2) : createObjectIterator(coll);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = iterator;
  var _isArrayLike = require_isArrayLike2();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _getIterator = require_getIterator2();
  var _getIterator2 = _interopRequireDefault(_getIterator);
  var _keys = require_keys();
  var _keys2 = _interopRequireDefault(_keys);
  module2.exports = exports2["default"];
});

// ../../node_modules/vizion/node_modules/async/internal/breakLoop.js
var require_breakLoop2 = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = {};
  module2.exports = exports2["default"];
});

// ../../node_modules/vizion/node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit3 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var _eachOfLimit = function(limit) {
    return function(obj, iteratee, callback) {
      callback = (0, _once2.default)(callback || _noop2.default);
      if (limit <= 0 || !obj) {
        return callback(null);
      }
      var nextElem = (0, _iterator2.default)(obj);
      var done = false;
      var running = 0;
      var looping = false;
      function iterateeCallback(err, value) {
        running -= 1;
        if (err) {
          done = true;
          callback(err);
        } else if (value === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        } else if (!looping) {
          replenish();
        }
      }
      function replenish() {
        looping = true;
        while (running < limit && !done) {
          var elem = nextElem();
          if (elem === null) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running += 1;
          iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
        }
        looping = false;
      }
      replenish();
    };
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = _eachOfLimit;
  var _noop = require_noop();
  var _noop2 = _interopRequireDefault(_noop);
  var _once = require_once2();
  var _once2 = _interopRequireDefault(_once);
  var _iterator = require_iterator2();
  var _iterator2 = _interopRequireDefault(_iterator);
  var _onlyOnce = require_onlyOnce2();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _breakLoop = require_breakLoop2();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  module2.exports = exports2["default"];
});

// ../../node_modules/vizion/node_modules/async/internal/withoutIndex.js
var require_withoutIndex2 = __commonJS((exports2, module2) => {
  var _withoutIndex = function(iteratee) {
    return function(value, index, callback) {
      return iteratee(value, callback);
    };
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = _withoutIndex;
  module2.exports = exports2["default"];
});

// ../../node_modules/vizion/node_modules/async/eachLimit.js
var require_eachLimit2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachLimit = function(coll, limit, iteratee, callback) {
    (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = eachLimit;
  var _eachOfLimit = require_eachOfLimit3();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _withoutIndex = require_withoutIndex2();
  var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
  var _wrapAsync = require_wrapAsync2();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  module2.exports = exports2["default"];
});

// ../../node_modules/vizion/node_modules/async/internal/doLimit.js
var require_doLimit = __commonJS((exports2, module2) => {
  var doLimit = function(fn, limit) {
    return function(iterable, iteratee, callback) {
      return fn(iterable, limit, iteratee, callback);
    };
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = doLimit;
  module2.exports = exports2["default"];
});

// ../../node_modules/vizion/node_modules/async/eachSeries.js
var require_eachSeries = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _eachLimit = require_eachLimit2();
  var _eachLimit2 = _interopRequireDefault(_eachLimit);
  var _doLimit = require_doLimit();
  var _doLimit2 = _interopRequireDefault(_doLimit);
  exports2.default = (0, _doLimit2.default)(_eachLimit2.default, 1);
  module2.exports = exports2["default"];
});

// ../../node_modules/vizion/lib/identify.js
var require_identify = __commonJS((exports2, module2) => {
  var fs = __require("fs");
  var eachSeries = require_eachSeries();
  module2.exports = function(folder, cb) {
    if (folder[folder.length - 1] !== "/")
      folder += "/";
    eachSeries(["git", "hg", "svn"], function(type2, callback) {
      fs.exists(folder + "." + type2, function(exists) {
        if (exists)
          return callback(type2);
        else
          return callback();
      });
    }, function(final) {
      return cb(final ? final : "No versioning system found", folder);
    });
  };
});

// ../../node_modules/vizion/lib/vizion.js
var require_vizion = __commonJS((exports2, module2) => {
  var ALL = {};
  var vizion = {};
  ALL.hg = require_hg();
  ALL.git = require_git();
  ALL.svn = require_svn();
  var identify = require_identify();
  vizion.analyze = function(argv, cb) {
    var _folder = argv.folder != null ? argv.folder : ".";
    identify(_folder, function(type2, folder) {
      if (ALL[type2])
        return ALL[type2].parse(folder, cb);
      else
        return cb("Error vizion::analyze() for given folder: " + folder);
    });
  };
  vizion.isUpToDate = function(argv, cb) {
    var _folder = argv.folder != null ? argv.folder : ".";
    identify(_folder, function(type2, folder) {
      if (ALL[type2])
        return ALL[type2].isUpdated(folder, cb);
      else
        return cb("Error vizion::isUpToDate() for given folder: " + folder);
    });
  };
  vizion.update = function(argv, cb) {
    var _folder = argv.folder != null ? argv.folder : ".";
    identify(_folder, function(type2, folder) {
      if (ALL[type2])
        return ALL[type2].update(folder, cb);
      else
        return cb("Error vizion::update() for given folder: " + folder);
    });
  };
  vizion.revertTo = function(argv, cb) {
    var revision = argv.revision ? argv.revision : false;
    var _folder = argv.folder != null ? argv.folder : ".";
    if (!(revision && /^[A-Fa-f0-9]+$/.test(revision)))
      return cb({ msg: "Cannot revert to an invalid commit revision", path: _folder });
    identify(_folder, function(type2, folder) {
      if (ALL[type2])
        return ALL[type2].revert({ folder, revision }, cb);
      else
        return cb("Error vizion::analyze() for given folder: " + folder);
    });
  };
  vizion.prev = function(argv, cb) {
    var _folder = argv.folder != null ? argv.folder : ".";
    identify(_folder, function(type2, folder) {
      if (ALL[type2])
        return ALL[type2].prev(folder, cb);
      else
        return cb("Error vizion::prev() for given folder: " + folder);
    });
  };
  vizion.next = function(argv, cb) {
    var _folder = argv.folder != null ? argv.folder : ".";
    identify(_folder, function(type2, folder) {
      if (ALL[type2])
        return ALL[type2].next(folder, cb);
      else
        return cb("Error vizion::next() for given folder: " + folder);
    });
  };
  module2.exports = vizion;
});

// ../../node_modules/async/internal/map.js
var require_map2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var _asyncMap = function(eachfn, arr, iteratee, callback) {
    arr = arr || [];
    var results = [];
    var counter = 0;
    var _iteratee = (0, _wrapAsync2.default)(iteratee);
    return eachfn(arr, (value, _, iterCb) => {
      var index = counter++;
      _iteratee(value, (err, v) => {
        results[index] = v;
        iterCb(err);
      });
    }, (err) => {
      callback(err, results);
    });
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = _asyncMap;
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  module2.exports = exports2.default;
});

// ../../node_modules/async/mapLimit.js
var require_mapLimit = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var mapLimit = function(coll, limit, iteratee, callback) {
    return (0, _map3.default)((0, _eachOfLimit2.default)(limit), coll, iteratee, callback);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _map2 = require_map2();
  var _map3 = _interopRequireDefault(_map2);
  var _eachOfLimit = require_eachOfLimit();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports2.default = (0, _awaitify2.default)(mapLimit, 4);
  module2.exports = exports2.default;
});

// ../../node_modules/async/internal/range.js
var require_range2 = __commonJS((exports2, module2) => {
  var range = function(size2) {
    var result = Array(size2);
    while (size2--) {
      result[size2] = size2;
    }
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = range;
  module2.exports = exports2.default;
});

// ../../node_modules/async/timesLimit.js
var require_timesLimit = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var timesLimit = function(count, limit, iteratee, callback) {
    var _iteratee = (0, _wrapAsync2.default)(iteratee);
    return (0, _mapLimit2.default)((0, _range2.default)(count), limit, _iteratee, callback);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = timesLimit;
  var _mapLimit = require_mapLimit();
  var _mapLimit2 = _interopRequireDefault(_mapLimit);
  var _range = require_range2();
  var _range2 = _interopRequireDefault(_range);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  module2.exports = exports2.default;
});

// ../../node_modules/async/eachSeries.js
var require_eachSeries2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachSeries = function(coll, iteratee, callback) {
    return (0, _eachLimit2.default)(coll, 1, iteratee, callback);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _eachLimit = require_eachLimit();
  var _eachLimit2 = _interopRequireDefault(_eachLimit);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports2.default = (0, _awaitify2.default)(eachSeries, 3);
  module2.exports = exports2.default;
});

// ../../node_modules/pm2/lib/Configuration.js
var require_Configuration = __commonJS((exports2, module2) => {
  var splitKey = function(key) {
    var values = [key];
    if (key.indexOf(".") > -1)
      values = key.match(/(?:[^."]+|"[^"]*")+/g).map(function(dt) {
        return dt.replace(/"/g, "");
      });
    else if (key.indexOf(":") > -1)
      values = key.match(/(?:[^:"]+|"[^"]*")+/g).map(function(dt) {
        return dt.replace(/"/g, "");
      });
    return values;
  };
  var serializeConfiguration = function(json_conf) {
    return JSON.stringify(json_conf, null, 4);
  };
  var Configuration = module2.exports = {};
  var fs = __require("fs");
  var Common = require_Common();
  var eachSeries = require_eachSeries2();
  var cst = require_constants2();
  Configuration.set = function(key, value, cb) {
    fs.readFile(cst.PM2_MODULE_CONF_FILE, function(err, data) {
      if (err)
        return cb(err);
      var json_conf = JSON.parse(data);
      var values = splitKey(key);
      if (values.length > 0) {
        var levels = values;
        var tmp = json_conf;
        levels.forEach(function(key2, index) {
          if (index == levels.length - 1)
            tmp[key2] = value;
          else if (!tmp[key2]) {
            tmp[key2] = {};
            tmp = tmp[key2];
          } else {
            if (typeof tmp[key2] != "object")
              tmp[key2] = {};
            tmp = tmp[key2];
          }
        });
      } else {
        if (json_conf[key] && typeof json_conf[key] === "string")
          Common.printOut(cst.PREFIX_MSG + "Replacing current value key %s by %s", key, value);
        json_conf[key] = value;
      }
      fs.writeFile(cst.PM2_MODULE_CONF_FILE, serializeConfiguration(json_conf), function(err2, data2) {
        if (err2)
          return cb(err2);
        return cb(null, json_conf);
      });
      return false;
    });
  };
  Configuration.unset = function(key, cb) {
    fs.readFile(cst.PM2_MODULE_CONF_FILE, function(err, data) {
      if (err)
        return cb(err);
      var json_conf = JSON.parse(data);
      var values = splitKey(key);
      if (values.length > 0) {
        var levels = values;
        var tmp = json_conf;
        levels.forEach(function(key2, index) {
          if (index == levels.length - 1)
            delete tmp[key2];
          else if (!tmp[key2]) {
            tmp[key2] = {};
            tmp = tmp[key2];
          } else {
            if (typeof tmp[key2] != "object")
              tmp[key2] = {};
            tmp = tmp[key2];
          }
        });
      } else
        delete json_conf[key];
      if (err)
        return cb(err);
      if (key === "all")
        json_conf = {};
      fs.writeFile(cst.PM2_MODULE_CONF_FILE, serializeConfiguration(json_conf), function(err2, data2) {
        if (err2)
          return cb(err2);
        return cb(null, json_conf);
      });
      return false;
    });
  };
  Configuration.setSyncIfNotExist = function(key, value) {
    try {
      var conf2 = JSON.parse(fs.readFileSync(cst.PM2_MODULE_CONF_FILE));
    } catch (e) {
      return null;
    }
    var values = splitKey(key);
    var exists = false;
    if (values.length > 1 && conf2 && conf2[values[0]]) {
      exists = Object.keys(conf2[values[0]]).some(function(key2) {
        if (key2 == values[1])
          return true;
        return false;
      });
    }
    if (exists === false)
      return Configuration.setSync(key, value);
    return null;
  };
  Configuration.setSync = function(key, value) {
    try {
      var data = fs.readFileSync(cst.PM2_MODULE_CONF_FILE);
    } catch (e) {
      return null;
    }
    var json_conf = JSON.parse(data);
    var values = splitKey(key);
    if (values.length > 0) {
      var levels = values;
      var tmp = json_conf;
      levels.forEach(function(key2, index) {
        if (index == levels.length - 1)
          tmp[key2] = value;
        else if (!tmp[key2]) {
          tmp[key2] = {};
          tmp = tmp[key2];
        } else {
          if (typeof tmp[key2] != "object")
            tmp[key2] = {};
          tmp = tmp[key2];
        }
      });
    } else {
      if (json_conf[key] && typeof json_conf[key] === "string")
        Common.printOut(cst.PREFIX_MSG + "Replacing current value key %s by %s", key, value);
      json_conf[key] = value;
    }
    if (key === "all")
      json_conf = {};
    try {
      fs.writeFileSync(cst.PM2_MODULE_CONF_FILE, serializeConfiguration(json_conf));
      return json_conf;
    } catch (e) {
      console.error(e.message);
      return null;
    }
  };
  Configuration.unsetSync = function(key) {
    try {
      var data = fs.readFileSync(cst.PM2_MODULE_CONF_FILE);
    } catch (e) {
      return null;
    }
    var json_conf = JSON.parse(data);
    var values = splitKey(key);
    if (values.length > 0) {
      var levels = values;
      var tmp = json_conf;
      levels.forEach(function(key2, index) {
        if (index == levels.length - 1)
          delete tmp[key2];
        else if (!tmp[key2]) {
          tmp[key2] = {};
          tmp = tmp[key2];
        } else {
          if (typeof tmp[key2] != "object")
            tmp[key2] = {};
          tmp = tmp[key2];
        }
      });
    } else
      delete json_conf[key];
    if (key === "all")
      json_conf = {};
    try {
      fs.writeFileSync(cst.PM2_MODULE_CONF_FILE, serializeConfiguration(json_conf));
    } catch (e) {
      console.error(e.message);
      return null;
    }
  };
  Configuration.multiset = function(serial, cb) {
    var arrays = [];
    serial = serial.match(/(?:[^ "]+|"[^"]*")+/g);
    while (serial.length > 0)
      arrays.push(serial.splice(0, 2));
    eachSeries(arrays, function(el, next) {
      Configuration.set(el[0], el[1], next);
    }, cb);
  };
  Configuration.get = function(key, cb) {
    Configuration.getAll(function(err, data) {
      var climb = splitKey(key);
      climb.some(function(val) {
        if (!data[val]) {
          data = null;
          return true;
        }
        data = data[val];
        return false;
      });
      if (!data)
        return cb({ err: "Unknown key" }, null);
      return cb(null, data);
    });
  };
  Configuration.getSync = function(key) {
    try {
      var data = Configuration.getAllSync();
    } catch (e) {
      return null;
    }
    var climb = splitKey(key);
    climb.some(function(val) {
      if (!data[val]) {
        data = null;
        return true;
      }
      data = data[val];
      return false;
    });
    if (!data)
      return null;
    return data;
  };
  Configuration.getAll = function(cb) {
    fs.readFile(cst.PM2_MODULE_CONF_FILE, function(err, data) {
      if (err)
        return cb(err);
      return cb(null, JSON.parse(data));
    });
  };
  Configuration.getAllSync = function() {
    try {
      return JSON.parse(fs.readFileSync(cst.PM2_MODULE_CONF_FILE));
    } catch (e) {
      console.error(e.stack || e);
      return {};
    }
  };
});

// ../../node_modules/pm2/lib/Event.js
var require_Event = __commonJS((exports2, module2) => {
  var Utility = require_Utility();
  module2.exports = function(God) {
    God.notify = function(action_name, data, manually) {
      God.bus.emit("process:event", {
        event: action_name,
        manually: typeof manually == "undefined" ? false : true,
        process: Utility.formatCLU(data),
        at: Utility.getDate()
      });
    };
    God.notifyByProcessId = function(opts, cb) {
      if (typeof opts.id === "undefined") {
        return cb(new Error("process id missing"));
      }
      var proc = God.clusters_db[opts.id];
      if (!proc) {
        return cb(new Error("process id doesnt exists"));
      }
      God.bus.emit("process:event", {
        event: opts.action_name,
        manually: typeof opts.manually == "undefined" ? false : true,
        process: Utility.formatCLU(proc),
        at: Utility.getDate()
      });
      process.nextTick(function() {
        return cb ? cb(null) : false;
      });
      return false;
    };
  };
});

// ../../node_modules/pm2/lib/TreeKill.js
var require_TreeKill = __commonJS((exports2, module2) => {
  var killAll = function(tree, signal, callback) {
    var killed = {};
    try {
      Object.keys(tree).forEach(function(pid) {
        tree[pid].forEach(function(pidpid) {
          if (!killed[pidpid]) {
            killPid(pidpid, signal);
            killed[pidpid] = 1;
          }
        });
        if (!killed[pid]) {
          killPid(pid, signal);
          killed[pid] = 1;
        }
      });
    } catch (err) {
      if (callback) {
        return callback(err);
      } else {
        console.error(err);
      }
    }
    if (callback) {
      return callback();
    }
  };
  var killPid = function(pid, signal) {
    try {
      process.kill(parseInt(pid, 10), signal);
    } catch (err) {
      if (err.code !== "ESRCH")
        console.error(err);
    }
  };
  var buildProcessTree = function(parentPid, tree, pidsToProcess, spawnChildProcessesList, cb) {
    var ps = spawnChildProcessesList(parentPid);
    var allData = "";
    ps.on("error", function(err) {
      console.error(err);
    });
    if (ps.stdout) {
      ps.stdout.on("data", function(data) {
        data = data.toString("ascii");
        allData += data;
      });
    }
    var onClose = function(code) {
      delete pidsToProcess[parentPid];
      if (code !== 0) {
        if (Object.keys(pidsToProcess).length == 0) {
          cb();
        }
        return;
      }
      var pids = allData.match(/\d+/g) || [];
      if (pids.length === 0)
        return cb();
      pids.forEach(function(pid) {
        pid = parseInt(pid, 10);
        tree[parentPid].push(pid);
        tree[pid] = [];
        pidsToProcess[pid] = 1;
        buildProcessTree(pid, tree, pidsToProcess, spawnChildProcessesList, cb);
      });
    };
    ps.on("close", onClose);
  };
  var childProcess = __require("child_process");
  var spawn = childProcess.spawn;
  var exec = childProcess.exec;
  module2.exports = function(pid, signal, callback) {
    var tree = {};
    var pidsToProcess = {};
    tree[pid] = [];
    pidsToProcess[pid] = 1;
    switch (process.platform) {
      case "win32":
        exec("taskkill /pid " + pid + " /T /F", { windowsHide: true }, callback);
        break;
      case "darwin":
        buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
          return spawn("pgrep", ["-P", parentPid]);
        }, function() {
          killAll(tree, signal, callback);
        });
        break;
      default:
        buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
          return spawn("ps", ["-o", "pid", "--no-headers", "--ppid", parentPid]);
        }, function() {
          killAll(tree, signal, callback);
        });
        break;
    }
  };
});

// ../../node_modules/pm2/lib/God/Methods.js
var require_Methods = __commonJS((exports2, module2) => {
  var p = __require("path");
  var treekill = require_TreeKill();
  var cst = require_constants2();
  module2.exports = function(God) {
    God.logAndGenerateError = function(err) {
      if (err instanceof Error) {
        console.trace(err);
        return err;
      }
      console.error(err);
      return new Error(err);
    };
    God.getProcesses = function() {
      return God.clusters_db;
    };
    God.getFormatedProcess = function getFormatedProcesses(id2) {
      if (God.clusters_db[id2])
        return {
          pid: God.clusters_db[id2].process.pid,
          name: God.clusters_db[id2].pm2_env.name,
          pm2_env: God.clusters_db[id2].pm2_env,
          pm_id: God.clusters_db[id2].pm2_env.pm_id
        };
      return {};
    };
    God.getFormatedProcesses = function getFormatedProcesses() {
      var keys3 = Object.keys(God.clusters_db);
      var arr = new Array;
      var kl = keys3.length;
      for (var i = 0;i < kl; i++) {
        var key = keys3[i];
        if (!God.clusters_db[key])
          continue;
        if (isNaN(God.clusters_db[key].pm2_env.pm_id))
          continue;
        arr.push({
          pid: God.clusters_db[key].process.pid,
          name: God.clusters_db[key].pm2_env.name,
          pm2_env: God.clusters_db[key].pm2_env,
          pm_id: God.clusters_db[key].pm2_env.pm_id
        });
      }
      return arr;
    };
    God.findProcessById = function findProcessById(id2) {
      return God.clusters_db[id2] ? God.clusters_db[id2] : null;
    };
    God.findByName = function(name2) {
      var db = God.clusters_db;
      var arr = [];
      if (name2 == "all") {
        for (var key in db) {
          if (typeof God.clusters_db[key].pm2_env.pm_id === "number")
            arr.push(db[key]);
        }
        return arr;
      }
      for (var key in db) {
        if (God.clusters_db[key].pm2_env.name == name2 || God.clusters_db[key].pm2_env.pm_exec_path == p.resolve(name2)) {
          arr.push(db[key]);
        }
      }
      return arr;
    };
    God.checkProcess = function(pid) {
      if (!pid)
        return false;
      try {
        process.kill(pid, 0);
        return true;
      } catch (err) {
        return false;
      }
    };
    God.processIsDead = function(pid, pm2_env, cb, sigkill) {
      if (!pid)
        return cb({ type: "param:missing", msg: "no pid passed" });
      var timeout = null;
      var kill_timeout = pm2_env && pm2_env.kill_timeout ? pm2_env.kill_timeout : cst.KILL_TIMEOUT;
      var mode = pm2_env.exec_mode;
      var timer = setInterval(function() {
        if (God.checkProcess(pid) === false) {
          console.log("pid=%d msg=process killed", pid);
          clearTimeout(timeout);
          clearInterval(timer);
          return cb(null, true);
        }
        console.log("pid=%d msg=failed to kill - retrying in %dms", pid, pm2_env.kill_retry_time);
        return false;
      }, pm2_env.kill_retry_time);
      timeout = setTimeout(function() {
        clearInterval(timer);
        if (sigkill) {
          console.log("Process with pid %d could not be killed", pid);
          return cb({ type: "timeout", msg: "timeout" });
        } else {
          console.log("Process with pid %d still alive after %sms, sending it SIGKILL now...", pid, kill_timeout);
          if (pm2_env.treekill !== true) {
            try {
              process.kill(parseInt(pid), "SIGKILL");
            } catch (e) {
              console.error("[SimpleKill][SIGKILL] %s pid can not be killed", pid, e.stack, e.message);
            }
            return God.processIsDead(pid, pm2_env, cb, true);
          } else {
            treekill(parseInt(pid), "SIGKILL", function(err) {
              return God.processIsDead(pid, pm2_env, cb, true);
            });
          }
        }
      }, kill_timeout);
      return false;
    };
    God.killProcess = function(pid, pm2_env, cb) {
      if (!pid)
        return cb({ msg: "no pid passed or null" });
      if (typeof pm2_env.pm_id === "number" && (cst.KILL_USE_MESSAGE || pm2_env.shutdown_with_message == true)) {
        var proc = God.clusters_db[pm2_env.pm_id];
        if (proc && proc.send) {
          try {
            proc.send("shutdown");
          } catch (e) {
            console.error(`[AppKill] Cannot send "shutdown" message to ${pid}`);
            console.error(e.stack, e.message);
          }
          return God.processIsDead(pid, pm2_env, cb);
        } else {
          console.log(`[AppKill] ${pid} pid cannot be notified with send()`);
        }
      }
      if (pm2_env.treekill !== true) {
        try {
          process.kill(parseInt(pid), cst.KILL_SIGNAL);
        } catch (e) {
          console.error("[SimpleKill] %s pid can not be killed", pid, e.stack, e.message);
        }
        return God.processIsDead(pid, pm2_env, cb);
      } else {
        treekill(parseInt(pid), cst.KILL_SIGNAL, function(err) {
          return God.processIsDead(pid, pm2_env, cb);
        });
      }
    };
    God.getNewId = function() {
      return God.next_id++;
    };
    God.resetState = function(pm2_env) {
      pm2_env.created_at = Date.now();
      pm2_env.unstable_restarts = 0;
      pm2_env.prev_restart_delay = 0;
    };
  };
});

// ../../node_modules/pm2/lib/God/ForkMode.js
var require_ForkMode = __commonJS((exports2, module2) => {
  var log = require_src()("pm2:fork_mode");
  var fs = __require("fs");
  var Utility = require_Utility();
  var path2 = __require("path");
  var dayjs = require_dayjs_min();
  var semver = require_semver2();
  module2.exports = function ForkMode(God) {
    God.forkMode = function forkMode(pm2_env, cb) {
      var command = "";
      var args2 = [];
      console.log(`App [${pm2_env.name}:${pm2_env.pm_id}] starting in -fork mode-`);
      var spawn = __require("child_process").spawn;
      var interpreter = pm2_env.exec_interpreter || "node";
      var pidFile = pm2_env.pm_pid_path;
      if (interpreter !== "none") {
        command = interpreter;
        if (pm2_env.node_args && Array.isArray(pm2_env.node_args)) {
          args2 = args2.concat(pm2_env.node_args);
        }
        if (process.env.PM2_NODE_OPTIONS) {
          args2 = args2.concat(process.env.PM2_NODE_OPTIONS.split(" "));
        }
        if (interpreter === "node" || RegExp("node$").test(interpreter)) {
          args2.push(path2.resolve(path2.dirname("ForkMode.js"), "..", "ProcessContainerFork.js"));
        } else
          args2.push(pm2_env.pm_exec_path);
      } else {
        command = pm2_env.pm_exec_path;
        args2 = [];
      }
      if (pm2_env.args) {
        args2 = args2.concat(pm2_env.args);
      }
      var stds = {
        out: pm2_env.pm_out_log_path,
        err: pm2_env.pm_err_log_path
      };
      if ("pm_log_path" in pm2_env) {
        stds.std = pm2_env.pm_log_path;
      }
      log("stds: %j", stds);
      Utility.startLogging(stds, function(err, result) {
        if (err) {
          God.logAndGenerateError(err);
          return cb(err);
        }
        try {
          var options2 = {
            env: pm2_env,
            detached: true,
            cwd: pm2_env.pm_cwd || process.cwd(),
            stdio: ["pipe", "pipe", "pipe", "ipc"]
          };
          if (typeof pm2_env.windowsHide === "boolean") {
            options2.windowsHide = pm2_env.windowsHide;
          } else {
            options2.windowsHide = true;
          }
          if (pm2_env.uid) {
            options2.uid = pm2_env.uid;
          }
          if (pm2_env.gid) {
            options2.gid = pm2_env.gid;
          }
          var cspr = spawn(command, args2, options2);
        } catch (e) {
          God.logAndGenerateError(e);
          return cb(e);
        }
        if (!cspr || !cspr.stderr || !cspr.stdout) {
          var fatalError = new Error("Process could not be forked properly, check your system health");
          God.logAndGenerateError(fatalError);
          return cb(fatalError);
        }
        cspr.process = {};
        cspr.process.pid = cspr.pid;
        cspr.pm2_env = pm2_env;
        function transformLogToJson(pm2_env2, type2, data) {
          return JSON.stringify({
            message: data.toString(),
            timestamp: pm2_env2.log_date_format ? dayjs().format(pm2_env2.log_date_format) : new Date().toISOString(),
            type: type2,
            process_id: cspr.pm2_env.pm_id,
            app_name: cspr.pm2_env.name
          }) + "\n";
        }
        function prefixLogWithDate(pm2_env2, data) {
          var log_data = [];
          log_data = data.toString().split("\n");
          if (log_data.length > 1)
            log_data.pop();
          log_data = log_data.map((line) => `${dayjs().format(pm2_env2.log_date_format)}: ${line}\n`);
          log_data = log_data.join("");
          return log_data;
        }
        cspr.stderr.on("data", function forkErrData(data) {
          var log_data = null;
          if (pm2_env.disable_logs === true)
            return false;
          if (pm2_env.log_type && pm2_env.log_type === "json")
            log_data = transformLogToJson(pm2_env, "err", data);
          else if (pm2_env.log_date_format)
            log_data = prefixLogWithDate(pm2_env, data);
          else
            log_data = data.toString();
          God.bus.emit("log:err", {
            process: {
              pm_id: cspr.pm2_env.pm_id,
              name: cspr.pm2_env.name,
              rev: cspr.pm2_env.versioning && cspr.pm2_env.versioning.revision ? cspr.pm2_env.versioning.revision : null,
              namespace: cspr.pm2_env.namespace
            },
            at: Utility.getDate(),
            data: log_data
          });
          if (Utility.checkPathIsNull(pm2_env.pm_err_log_path) && (!pm2_env.pm_log_path || Utility.checkPathIsNull(pm2_env.pm_log_path))) {
            return false;
          }
          stds.std && stds.std.write && stds.std.write(log_data);
          stds.err && stds.err.write && stds.err.write(log_data);
        });
        cspr.stdout.on("data", function forkOutData(data) {
          var log_data = null;
          if (pm2_env.disable_logs === true)
            return false;
          if (pm2_env.log_type && pm2_env.log_type === "json")
            log_data = transformLogToJson(pm2_env, "out", data);
          else if (pm2_env.log_date_format)
            log_data = prefixLogWithDate(pm2_env, data);
          else
            log_data = data.toString();
          God.bus.emit("log:out", {
            process: {
              pm_id: cspr.pm2_env.pm_id,
              name: cspr.pm2_env.name,
              rev: cspr.pm2_env.versioning && cspr.pm2_env.versioning.revision ? cspr.pm2_env.versioning.revision : null,
              namespace: cspr.pm2_env.namespace
            },
            at: Utility.getDate(),
            data: log_data
          });
          if (Utility.checkPathIsNull(pm2_env.pm_out_log_path) && (!pm2_env.pm_log_path || Utility.checkPathIsNull(pm2_env.pm_log_path)))
            return false;
          stds.std && stds.std.write && stds.std.write(log_data);
          stds.out && stds.out.write && stds.out.write(log_data);
        });
        cspr.on("message", function forkMessage(msg) {
          if (msg.data && msg.type) {
            process.nextTick(function() {
              return God.bus.emit(msg.type ? msg.type : "process:msg", {
                at: Utility.getDate(),
                data: msg.data,
                process: {
                  pm_id: cspr.pm2_env.pm_id,
                  name: cspr.pm2_env.name,
                  versioning: cspr.pm2_env.versioning,
                  namespace: cspr.pm2_env.namespace
                }
              });
            });
          } else {
            if (typeof msg == "object" && "node_version" in msg) {
              cspr.pm2_env.node_version = msg.node_version;
              return false;
            }
            return God.bus.emit("process:msg", {
              at: Utility.getDate(),
              raw: msg,
              process: {
                pm_id: cspr.pm2_env.pm_id,
                name: cspr.pm2_env.name,
                namespace: cspr.pm2_env.namespace
              }
            });
          }
        });
        try {
          var pid = cspr.pid;
          if (typeof pid !== "undefined")
            fs.writeFileSync(pidFile, pid.toString());
        } catch (e) {
          console.error(e.stack || e);
        }
        cspr.once("exit", function forkClose(status) {
          try {
            for (var k in stds) {
              if (stds[k] && stds[k].destroy)
                stds[k].destroy();
              else if (stds[k] && stds[k].end)
                stds[k].end();
              else if (stds[k] && stds[k].close)
                stds[k].close();
              stds[k] = stds[k]._file;
            }
          } catch (e) {
            God.logAndGenerateError(e);
          }
        });
        cspr._reloadLogs = function(cb2) {
          try {
            for (var k in stds) {
              if (stds[k] && stds[k].destroy)
                stds[k].destroy();
              else if (stds[k] && stds[k].end)
                stds[k].end();
              else if (stds[k] && stds[k].close)
                stds[k].close();
              stds[k] = stds[k]._file;
            }
          } catch (e) {
            God.logAndGenerateError(e);
          }
          Utility.startLogging(stds, cb2);
        };
        cspr.unref();
        return cb(null, cspr);
      });
    };
  };
});

// ../../node_modules/pm2/lib/God/ClusterMode.js
var require_ClusterMode = __commonJS((exports2, module2) => {
  var cluster = __require("cluster");
  var Utility = require_Utility();
  var pkg = require_package();
  module2.exports = function ClusterMode(God) {
    God.nodeApp = function nodeApp(env_copy, cb) {
      var clu = null;
      console.log(`App [${env_copy.name}:${env_copy.pm_id}] starting in -cluster mode-`);
      if (env_copy.node_args && Array.isArray(env_copy.node_args)) {
        cluster.settings.execArgv = env_copy.node_args;
      }
      env_copy._pm2_version = pkg.version;
      try {
        clu = cluster.fork({ pm2_env: JSON.stringify(env_copy), windowsHide: true });
      } catch (e) {
        God.logAndGenerateError(e);
        return cb(e);
      }
      clu.pm2_env = env_copy;
      clu.on("message", function cluMessage(msg) {
        if (msg.data && msg.type) {
          return God.bus.emit(msg.type ? msg.type : "process:msg", {
            at: Utility.getDate(),
            data: msg.data,
            process: {
              pm_id: clu.pm2_env.pm_id,
              name: clu.pm2_env.name,
              rev: clu.pm2_env.versioning && clu.pm2_env.versioning.revision ? clu.pm2_env.versioning.revision : null,
              namespace: clu.pm2_env.namespace
            }
          });
        } else {
          if (typeof msg == "object" && "node_version" in msg) {
            clu.pm2_env.node_version = msg.node_version;
            return false;
          }
          return God.bus.emit("process:msg", {
            at: Utility.getDate(),
            raw: msg,
            process: {
              pm_id: clu.pm2_env.pm_id,
              name: clu.pm2_env.name,
              namespace: clu.pm2_env.namespace
            }
          });
        }
      });
      return cb(null, clu);
    };
  };
});

// ../../node_modules/pm2/lib/God/Reload.js
var require_Reload = __commonJS((exports2, module2) => {
  var softReload = function(God, id2, cb) {
    var t_key = "_old_" + id2;
    God.clusters_db[t_key] = God.clusters_db[id2];
    delete God.clusters_db[id2];
    var old_worker = God.clusters_db[t_key];
    var new_env = Utility.clone(old_worker.pm2_env);
    God.resetState(new_env);
    new_env.restart_time += 1;
    old_worker.pm2_env.pm_id = t_key;
    old_worker.pm_id = t_key;
    God.executeApp(new_env, function(err, new_worker) {
      if (err)
        return cb(err);
      var timer = null;
      var onListen = function() {
        clearTimeout(timer);
        softCleanDeleteProcess();
        console.log("-softReload- New worker listening");
      };
      new_worker.once("listening", onListen);
      timer = setTimeout(function() {
        new_worker.removeListener("listening", onListen);
        softCleanDeleteProcess();
      }, new_env.listen_timeout || cst.GRACEFUL_LISTEN_TIMEOUT);
      var softCleanDeleteProcess = function() {
        var cleanUp = function() {
          clearTimeout(timer);
          console.log("-softReload- Old worker disconnected");
          return God.deleteProcessId(t_key, cb);
        };
        old_worker.once("disconnect", cleanUp);
        try {
          if (old_worker.state != "dead" && old_worker.state != "disconnected")
            old_worker.send && old_worker.send("shutdown");
          else {
            clearTimeout(timer);
            console.error("Worker %d is already disconnected", old_worker.pm2_env.pm_id);
            return God.deleteProcessId(t_key, cb);
          }
        } catch (e) {
          clearTimeout(timer);
          console.error("Worker %d is already disconnected", old_worker.pm2_env.pm_id);
          return God.deleteProcessId(t_key, cb);
        }
        timer = setTimeout(function() {
          old_worker.removeListener("disconnect", cleanUp);
          return God.deleteProcessId(t_key, cb);
        }, cst.GRACEFUL_TIMEOUT);
        return false;
      };
      return false;
    });
    return false;
  };
  var hardReload = function(God, id2, wait_msg, cb) {
    var t_key = "_old_" + id2;
    God.clusters_db[t_key] = God.clusters_db[id2];
    delete God.clusters_db[id2];
    var old_worker = God.clusters_db[t_key];
    var new_env = Utility.clone(old_worker.pm2_env);
    new_env.restart_time += 1;
    God.resetState(new_env);
    old_worker.pm2_env.pm_id = t_key;
    old_worker.pm_id = t_key;
    var timer = null;
    var readySignalSent = false;
    var onListen = function() {
      clearTimeout(timer);
      readySignalSent = true;
      console.log("-reload- New worker listening");
      return God.deleteProcessId(t_key, cb);
    };
    var listener = function(packet) {
      if (packet.raw === "ready" && packet.process.name === old_worker.pm2_env.name && packet.process.pm_id === id2) {
        God.bus.removeListener("process:msg", listener);
        return onListen();
      }
    };
    if (wait_msg !== "listening") {
      God.bus.on("process:msg", listener);
    }
    God.executeApp(new_env, function(err, new_worker) {
      if (err)
        return cb(err);
      if (wait_msg === "listening") {
        new_worker.once("listening", onListen);
      }
      timer = setTimeout(function() {
        if (readySignalSent) {
          return;
        }
        if (wait_msg === "listening")
          new_worker.removeListener(wait_msg, onListen);
        else
          God.bus.removeListener("process:msg", listener);
        return God.deleteProcessId(t_key, cb);
      }, new_env.listen_timeout || cst.GRACEFUL_LISTEN_TIMEOUT);
      return false;
    });
    return false;
  };
  var cst = require_constants2();
  var Utility = require_Utility();
  module2.exports = function(God) {
    God.softReloadProcessId = function(opts, cb) {
      var id2 = opts.id;
      var env = opts.env || {};
      if (!(id2 in God.clusters_db))
        return cb(new Error(`pm_id ${id2} not available in ${id2}`));
      if (God.clusters_db[id2].pm2_env.status == cst.ONLINE_STATUS && God.clusters_db[id2].pm2_env.exec_mode == "cluster_mode" && !God.clusters_db[id2].pm2_env.wait_ready) {
        Utility.extend(God.clusters_db[id2].pm2_env.env, opts.env);
        Utility.extendExtraConfig(God.clusters_db[id2], opts);
        return softReload(God, id2, cb);
      } else {
        console.log("Process %s in a stopped status, starting it", id2);
        return God.restartProcessId(opts, cb);
      }
    };
    God.reloadProcessId = function(opts, cb) {
      var id2 = opts.id;
      var env = opts.env || {};
      if (!(id2 in God.clusters_db))
        return cb(new Error("PM2 ID unknown"));
      if (God.clusters_db[id2].pm2_env.status == cst.ONLINE_STATUS && God.clusters_db[id2].pm2_env.exec_mode == "cluster_mode") {
        Utility.extend(God.clusters_db[id2].pm2_env.env, opts.env);
        Utility.extendExtraConfig(God.clusters_db[id2], opts);
        var wait_msg = God.clusters_db[id2].pm2_env.wait_ready ? "ready" : "listening";
        return hardReload(God, id2, wait_msg, cb);
      } else {
        console.log("Process %s in a stopped status, starting it", id2);
        return God.restartProcessId(opts, cb);
      }
    };
  };
});

// ../../node_modules/pidusage/lib/bin.js
var require_bin = __commonJS((exports2, module2) => {
  var run2 = function(cmd, args2, options2, done) {
    if (typeof options2 === "function") {
      done = options2;
      options2 = undefined;
    }
    let executed = false;
    const ch = spawn(cmd, args2, options2);
    let stdout = "";
    let stderr = "";
    ch.stdout.on("data", function(d) {
      stdout += d.toString();
    });
    ch.stderr.on("data", function(d) {
      stderr += d.toString();
    });
    ch.on("error", function(err) {
      if (executed)
        return;
      executed = true;
      done(new Error(err));
    });
    ch.on("close", function(code, signal) {
      if (executed)
        return;
      executed = true;
      if (stderr) {
        return done(new Error(stderr));
      }
      done(null, stdout, code);
    });
  };
  var spawn = __require("child_process").spawn;
  module2.exports = run2;
});

// ../../node_modules/pidusage/lib/history.js
var require_history = __commonJS((exports2, module2) => {
  var get = function(pid, maxage) {
    if (maxage <= 0) {
      return;
    }
    if (history[pid] !== undefined) {
      expiration[pid] = Date.now() + (maxage || DEFAULT_MAXAGE);
    }
    return history[pid];
  };
  var set = function(pid, object, maxage, onExpire) {
    if (object === undefined || maxage <= 0)
      return;
    expiration[pid] = Date.now() + (maxage || DEFAULT_MAXAGE);
    if (history[pid] === undefined) {
      size2++;
      sheduleInvalidator(maxage);
    }
    history[pid] = object;
    if (onExpire) {
      expireListeners[pid] = onExpire;
    }
  };
  var sheduleInvalidator = function(maxage) {
    if (size2 > 0) {
      if (interval === null) {
        interval = setInterval(runInvalidator, (maxage || DEFAULT_MAXAGE) / 2);
        if (typeof interval.unref === "function") {
          interval.unref();
        }
      }
      return;
    }
    if (interval !== null) {
      clearInterval(interval);
      interval = null;
    }
  };
  var runInvalidator = function() {
    const now = Date.now();
    const pids = Object.keys(expiration);
    for (let i = 0;i < pids.length; i++) {
      const pid = pids[i];
      if (expiration[pid] < now) {
        size2--;
        if (expireListeners[pid]) {
          expireListeners[pid](history[pid]);
        }
        delete history[pid];
        delete expiration[pid];
        delete expireListeners[pid];
      }
    }
    sheduleInvalidator();
  };
  var deleteLoop = function(obj) {
    for (const i in obj) {
      delete obj[i];
    }
  };
  var clear = function() {
    if (interval !== null) {
      clearInterval(interval);
      interval = null;
    }
    deleteLoop(history);
    deleteLoop(expiration);
    deleteLoop(expireListeners);
  };
  var DEFAULT_MAXAGE = 60000;
  var expiration = {};
  var history = {};
  var expireListeners = {};
  var size2 = 0;
  var interval = null;
  module2.exports = {
    get,
    set,
    clear
  };
});

// ../../node_modules/pidusage/lib/ps.js
var require_ps = __commonJS((exports2, module2) => {
  var parseTime = function(timestr, centisec) {
    let time = 0;
    const tpart = timestr.split(/-|:|\./);
    let i = tpart.length - 1;
    if (i >= 0 && centisec && PLATFORM === "darwin") {
      time += parseInt(tpart[i--], 10) * 10;
    }
    if (i >= 0) {
      time += parseInt(tpart[i--], 10) * 1000;
    }
    if (i >= 0) {
      time += parseInt(tpart[i--], 10) * 60000;
    }
    if (i >= 0) {
      time += parseInt(tpart[i--], 10) * 3600000;
    }
    if (i >= 0) {
      time += parseInt(tpart[i--], 10) * 86400000;
    }
    return time;
  };
  var ps = function(pids, options2, done) {
    const pArg = pids.join(",");
    let args2 = ["-o", "etime,pid,ppid,pcpu,rss,time", "-p", pArg];
    if (PLATFORM === "aix" || PLATFORM === "os400") {
      args2 = ["-o", "etime,pid,ppid,pcpu,rssize,time", "-p", pArg];
    }
    bin("ps", args2, function(err, stdout, code) {
      if (err) {
        if (PLATFORM === "os390" && /no matching processes found/.test(err)) {
          err = new Error("No matching pid found");
          err.code = "ENOENT";
        }
        return done(err);
      }
      if (code === 1) {
        const error = new Error("No matching pid found");
        error.code = "ENOENT";
        return done(error);
      }
      if (code !== 0) {
        return done(new Error("pidusage ps command exited with code " + code));
      }
      const date = Date.now();
      stdout = stdout.split(os.EOL);
      const statistics = {};
      for (let i = 1;i < stdout.length; i++) {
        const line = stdout[i].trim().split(/\s+/);
        if (!line || line.length !== 6) {
          continue;
        }
        const pid = parseInt(line[1], 10);
        let hst = history.get(pid, options2.maxage);
        if (hst === undefined)
          hst = {};
        const ppid = parseInt(line[2], 10);
        const memory = parseInt(line[4], 10) * 1024;
        const etime = parseTime(line[0]);
        const ctime = parseTime(line[5], true);
        const total = ctime - (hst.ctime || 0);
        const seconds = Math.abs(hst.elapsed !== undefined ? etime - hst.elapsed : etime);
        const cpu = seconds > 0 ? total / seconds * 100 : 0;
        statistics[pid] = {
          cpu,
          memory,
          ppid,
          pid,
          ctime,
          elapsed: etime,
          timestamp: date
        };
        history.set(pid, statistics[pid], options2.maxage);
      }
      done(null, statistics);
    });
  };
  var os = __require("os");
  var bin = require_bin();
  var history = require_history();
  var PLATFORM = os.platform();
  module2.exports = ps;
});

// ../../node_modules/pidusage/lib/helpers/parallel.js
var require_parallel2 = __commonJS((exports2, module2) => {
  var parallel = function(fns, options2, done) {
    if (typeof options2 === "function") {
      done = options2;
      options2 = {};
    }
    let keys3;
    if (!Array.isArray(fns)) {
      keys3 = Object.keys(fns);
    }
    const length3 = keys3 ? keys3.length : fns.length;
    let pending = length3;
    const results = keys3 ? {} : [];
    function each(i, err, result) {
      results[i] = result;
      if (--pending === 0 || err && !options2.graceful) {
        if (options2.graceful && err && length3 > 1) {
          err = null;
        }
        done && done(err, results);
        done = null;
      }
    }
    if (keys3) {
      keys3.forEach(function(key) {
        fns[key](function(err, res) {
          each(key, err, res);
        });
      });
    } else {
      fns.forEach(function(fn, i) {
        fn(function(err, res) {
          each(i, err, res);
        });
      });
    }
  };
  module2.exports = parallel;
});

// ../../node_modules/pidusage/lib/helpers/cpu.js
var require_cpu = __commonJS((exports2, module2) => {
  var updateCpu = function(cpu, next) {
    if (cpu !== null) {
      getRealUptime(function(err, uptime) {
        if (err)
          return next(err);
        cpu.uptime = uptime;
        next(null, cpu);
      });
      return;
    }
    parallel([
      getClockAndPageSize,
      getRealUptime
    ], function(err, data) {
      if (err)
        return next(err);
      cpu = {
        clockTick: data[0].clockTick,
        pageSize: data[0].pageSize,
        uptime: data[1]
      };
      next(null, cpu);
    });
  };
  var getRealUptime = function(next) {
    fs.readFile("/proc/uptime", "utf8", function(err, uptime) {
      if (err || uptime === undefined) {
        if (!process.env.PIDUSAGE_SILENT) {
          console.warn("[pidusage] We couldn't find uptime from /proc/uptime, using os.uptime() value");
        }
        return next(null, os.uptime() || new Date / 1000);
      }
      return next(null, parseFloat(uptime.split(" ")[0]));
    });
  };
  var getClockAndPageSize = function(next) {
    parallel([
      function getClockTick(cb) {
        getconf("CLK_TCK", { default: 100 }, cb);
      },
      function getPageSize(cb) {
        getconf("PAGESIZE", { default: 4096 }, cb);
      }
    ], function(err, data) {
      if (err)
        return next(err);
      next(null, { clockTick: data[0], pageSize: data[1] });
    });
  };
  var getconf = function(keyword, options2, next) {
    if (typeof options2 === "function") {
      next = options2;
      options2 = { default: "" };
    }
    exec("getconf " + keyword, function(error, stdout, stderr) {
      if (error !== null) {
        if (!process.env.PIDUSAGE_SILENT) {
          console.error('Error while calling "getconf ' + keyword + '"', error);
        }
        return next(null, options2.default);
      }
      stdout = parseInt(stdout);
      if (!isNaN(stdout)) {
        return next(null, stdout);
      }
      return next(null, options2.default);
    });
  };
  var os = __require("os");
  var fs = __require("fs");
  var exec = __require("child_process").exec;
  var parallel = require_parallel2();
  module2.exports = updateCpu;
});

// ../../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports2, module2) => {
  var copyProps = function(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  };
  var SafeBuffer = function(arg, encodingOrOffset, length3) {
    return Buffer2(arg, encodingOrOffset, length3);
  };
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length3) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length3);
  };
  SafeBuffer.alloc = function(size2, fill, encoding) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size2);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size2);
  };
  SafeBuffer.allocUnsafeSlow = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size2);
  };
});

// ../../node_modules/pidusage/lib/procfile.js
var require_procfile = __commonJS((exports2, module2) => {
  var noop = function() {
  };
  var open = function(path3, history2, cb) {
    if (history2.fd) {
      return cb(null, history2.fd);
    }
    fs.open(path3, "r", cb);
  };
  var close = function(history2) {
    if (history2.fd) {
      fs.close(history2.fd, noop);
    }
  };
  var readUntilEnd = function(fd, buf, cb) {
    let firstRead = false;
    if (typeof buf === "function") {
      cb = buf;
      buf = Buffer2.alloc(SIZE);
      firstRead = true;
    }
    fs.read(fd, buf, 0, SIZE, 0, function(err, bytesRead, buffer) {
      if (err) {
        cb(err);
        return;
      }
      const data = Buffer2.concat([buf, buffer], firstRead ? bytesRead : buf.length + bytesRead);
      if (bytesRead === SIZE) {
        readUntilEnd(fd, data, cb);
        return;
      }
      cb(null, buf);
    });
  };
  var readProcFile = function(pid, options2, done) {
    let hst = history.get(pid, options2.maxage);
    let again = false;
    if (hst === undefined) {
      again = true;
      hst = {};
    }
    open(path2.join("/proc", "" + pid, "stat"), hst, function(err, fd) {
      if (err) {
        if (err.code === "ENOENT") {
          err.message = "No matching pid found";
        }
        return done(err, null);
      }
      if (err) {
        return done(err);
      }
      readUntilEnd(fd, function(err2, buffer) {
        if (err2) {
          return done(err2);
        }
        let infos = buffer.toString("utf8");
        const date = Date.now();
        const index = infos.lastIndexOf(")");
        infos = infos.substr(index + 2).split(" ");
        const stat = {
          ppid: parseInt(infos[1]),
          utime: parseFloat(infos[11]) * 1000 / cpuInfo.clockTick,
          stime: parseFloat(infos[12]) * 1000 / cpuInfo.clockTick,
          cutime: parseFloat(infos[13]) * 1000 / cpuInfo.clockTick,
          cstime: parseFloat(infos[14]) * 1000 / cpuInfo.clockTick,
          start: parseFloat(infos[19]) * 1000 / cpuInfo.clockTick,
          rss: parseFloat(infos[21]),
          uptime: cpuInfo.uptime * 1000,
          fd
        };
        const memory = stat.rss * cpuInfo.pageSize;
        const childrens = options2.childrens ? stat.cutime + stat.cstime : 0;
        const total = stat.stime - (hst.stime || 0) + stat.utime - (hst.utime || 0) + childrens;
        const seconds = Math.abs(hst.uptime !== undefined ? stat.uptime - hst.uptime : stat.start - stat.uptime);
        const cpu = seconds > 0 ? total / seconds * 100 : 0;
        history.set(pid, stat, options2.maxage, close);
        if (again) {
          return readProcFile(pid, options2, done);
        }
        return done(null, {
          cpu,
          memory,
          ctime: stat.utime + stat.stime,
          elapsed: stat.uptime - stat.start,
          timestamp: date,
          pid,
          ppid: stat.ppid
        });
      });
    });
  };
  var procfile = function(pids, options2, done) {
    updateCpu(cpuInfo, function(err, result) {
      if (err)
        return done(err);
      cpuInfo = result;
      const fns = {};
      pids.forEach(function(pid, i) {
        fns[pid] = function(cb) {
          readProcFile(pid, options2, cb);
        };
      });
      parallel(fns, { graceful: true }, done);
    });
  };
  var fs = __require("fs");
  var path2 = __require("path");
  var updateCpu = require_cpu();
  var parallel = require_parallel2();
  var history = require_history();
  var cpuInfo = null;
  var Buffer2 = require_safe_buffer().Buffer;
  var SIZE = 1024;
  module2.exports = procfile;
});

// ../../node_modules/pidusage/lib/wmic.js
var require_wmic = __commonJS((exports2, module2) => {
  var parseDate = function(datestr) {
    const year = datestr.substring(0, 4);
    const month = datestr.substring(4, 6);
    const day = datestr.substring(6, 8);
    const hour = datestr.substring(8, 10);
    const minutes = datestr.substring(10, 12);
    const seconds = datestr.substring(12, 14);
    const useconds = datestr.substring(15, 21);
    const sign = datestr.substring(21, 22);
    const tmz = parseInt(datestr.substring(22, 25), 10);
    const tmzh = Math.floor(tmz / 60);
    const tmzm = tmz % 60;
    return new Date(year + "-" + month + "-" + day + "T" + hour + ":" + minutes + ":" + seconds + "." + useconds + sign + (tmzh > 9 ? tmzh : "0" + tmzh) + "" + (tmzm > 9 ? tmzm : "0" + tmzm));
  };
  var wmic = function(pids, options2, done) {
    let whereClause = "ProcessId=" + pids[0];
    for (let i = 1;i < pids.length; i++) {
      whereClause += " or " + "ProcessId=" + pids[i];
    }
    const args2 = [
      "PROCESS",
      "where",
      '"' + whereClause + '"',
      "get",
      "CreationDate,KernelModeTime,ParentProcessId,ProcessId,UserModeTime,WorkingSetSize"
    ];
    bin("wmic", args2, { windowsHide: true, windowsVerbatimArguments: true }, function(err, stdout, code) {
      if (err) {
        if (err.message.indexOf("No Instance(s) Available.") !== -1) {
          const error = new Error("No matching pid found");
          error.code = "ENOENT";
          return done(error);
        }
        return done(err);
      }
      if (code !== 0) {
        return done(new Error("pidusage wmic command exited with code " + code));
      }
      const date = Date.now();
      const uptime = Math.floor(os.uptime() || date / 1000);
      stdout = stdout.split(os.EOL);
      let again = false;
      const statistics = {};
      for (let i = 1;i < stdout.length; i++) {
        const line = stdout[i].trim().split(/\s+/);
        if (!line || line.length !== 6) {
          continue;
        }
        const creation = parseDate(line[0]);
        const ppid = parseInt(line[2], 10);
        const pid = parseInt(line[3], 10);
        const kerneltime = Math.round(parseInt(line[1], 10) / 1e4);
        const usertime = Math.round(parseInt(line[4], 10) / 1e4);
        const memory = parseInt(line[5], 10);
        let hst = history.get(pid, options2.maxage);
        if (hst === undefined) {
          again = true;
          hst = { ctime: kerneltime + usertime, uptime };
        }
        const total = (kerneltime + usertime - hst.ctime) / 1000;
        const seconds = uptime - hst.uptime;
        const cpu = seconds > 0 ? total / seconds * 100 : 0;
        history.set(pid, { ctime: usertime + kerneltime, uptime }, options2.maxage);
        statistics[pid] = {
          cpu,
          memory,
          ppid,
          pid,
          ctime: usertime + kerneltime,
          elapsed: date - creation.getTime(),
          timestamp: date
        };
      }
      if (again) {
        return wmic(pids, options2, function(err2, stats) {
          if (err2)
            return done(err2);
          done(null, Object.assign(statistics, stats));
        });
      }
      done(null, statistics);
    });
  };
  var os = __require("os");
  var bin = require_bin();
  var history = require_history();
  module2.exports = wmic;
});

// ../../node_modules/pidusage/lib/stats.js
var require_stats = __commonJS((exports2, module2) => {
  var get = function(pids, options2, callback) {
    let fn = stat;
    if (platform !== "win" && options2.usePs === true) {
      fn = requireMap.ps();
    }
    if (fn === undefined) {
      return callback(new Error(os.platform() + " is not supported yet, please open an issue (https://github.com/soyuka/pidusage)"));
    }
    let single = false;
    if (!Array.isArray(pids)) {
      single = true;
      pids = [pids];
    }
    if (pids.length === 0) {
      return callback(new TypeError("You must provide at least one pid"));
    }
    for (let i = 0;i < pids.length; i++) {
      pids[i] = parseInt(pids[i], 10);
      if (isNaN(pids[i]) || pids[i] < 0) {
        return callback(new TypeError("One of the pids provided is invalid"));
      }
    }
    fn(pids, options2, function(err, stats) {
      if (err) {
        return callback(err);
      }
      if (single) {
        callback(null, stats[pids[0]]);
      } else {
        callback(null, stats);
      }
    });
  };
  var fs = __require("fs");
  var os = __require("os");
  var requireMap = {
    ps: () => require_ps(),
    procfile: () => require_procfile(),
    wmic: () => require_wmic()
  };
  var platformToMethod = {
    aix: "ps",
    os400: "ps",
    android: "procfile",
    alpine: "procfile",
    darwin: "ps",
    freebsd: "ps",
    os390: "ps",
    linux: "procfile",
    netbsd: "procfile",
    openbsd: "ps",
    sunos: "ps",
    win: "wmic"
  };
  var platform = os.platform();
  if (fs.existsSync("/etc/alpine-release")) {
    platform = "alpine";
  }
  if (platform.match(/^win/)) {
    platform = "win";
  }
  var stat;
  try {
    stat = requireMap[platformToMethod[platform]]();
  } catch (err) {
  }
  module2.exports = get;
});

// ../../node_modules/pidusage/index.js
var require_pidusage = __commonJS((exports2, module2) => {
  var pidusage = function(pids, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    if (options2 === undefined) {
      options2 = {};
    }
    options2 = Object.assign({
      usePs: /^true$/i.test(process.env.PIDUSAGE_USE_PS),
      maxage: process.env.PIDUSAGE_MAXAGE
    }, options2);
    if (typeof callback === "function") {
      stats(pids, options2, callback);
      return;
    }
    return new Promise(function(resolve, reject) {
      stats(pids, options2, function(err, data) {
        if (err)
          return reject(err);
        resolve(data);
      });
    });
  };
  var stats = require_stats();
  module2.exports = pidusage;
  module2.exports.clear = require_history().clear;
});

// ../../node_modules/pm2/lib/God/ActionMethods.js
var require_ActionMethods = __commonJS((exports2, module2) => {
  var filterBadProcess = function(pro) {
    if (pro.pm2_env.status !== cst.ONLINE_STATUS) {
      return false;
    }
    if (pro.pm2_env.axm_options && pro.pm2_env.axm_options.pid) {
      if (isNaN(pro.pm2_env.axm_options.pid)) {
        return false;
      }
    }
    return true;
  };
  var getProcessId = function(pro) {
    var pid = pro.pid;
    if (pro.pm2_env.axm_options && pro.pm2_env.axm_options.pid) {
      pid = pro.pm2_env.axm_options.pid;
    }
    return pid;
  };
  var fs = __require("fs");
  var path2 = __require("path");
  var eachLimit = require_eachLimit();
  var os = __require("os");
  var p = path2;
  var cst = require_constants2();
  var pkg = require_package();
  var pidusage = require_pidusage();
  var util = __require("util");
  var debug = require_src()("pm2:ActionMethod");
  var Utility = require_Utility();
  module2.exports = function(God) {
    God.getMonitorData = function getMonitorData(env, cb) {
      var processes = God.getFormatedProcesses();
      var pids = processes.filter(filterBadProcess).map(function(pro, i) {
        var pid = getProcessId(pro);
        return pid;
      });
      if (pids.length === 0) {
        return cb(null, processes.map(function(pro) {
          pro["monit"] = {
            memory: 0,
            cpu: 0
          };
          return pro;
        }));
      }
      pidusage(pids, function retPidUsage(err, statistics) {
        if (err) {
          console.error("Error caught while calling pidusage");
          console.error(err);
          return cb(null, processes.map(function(pro) {
            pro["monit"] = {
              memory: 0,
              cpu: 0
            };
            return pro;
          }));
        }
        if (!statistics) {
          console.error("Statistics is not defined!");
          return cb(null, processes.map(function(pro) {
            pro["monit"] = {
              memory: 0,
              cpu: 0
            };
            return pro;
          }));
        }
        processes = processes.map(function(pro) {
          if (filterBadProcess(pro) === false) {
            pro["monit"] = {
              memory: 0,
              cpu: 0
            };
            return pro;
          }
          var pid = getProcessId(pro);
          var stat = statistics[pid];
          if (!stat) {
            pro["monit"] = {
              memory: 0,
              cpu: 0
            };
            return pro;
          }
          pro["monit"] = {
            memory: stat.memory,
            cpu: Math.round(stat.cpu * 10) / 10
          };
          return pro;
        });
        cb(null, processes);
      });
    };
    God.dumpProcessList = function(cb) {
      var process_list = [];
      var apps = Utility.clone(God.getFormatedProcesses());
      var that = this;
      if (!apps[0]) {
        debug("[PM2] Did not override dump file because list of processes is empty");
        return cb(null, { success: true, process_list });
      }
      function fin(err) {
        if (process_list.length === 0) {
          if (!fs.existsSync(cst.DUMP_FILE_PATH) && typeof that.clearDump === "function") {
            that.clearDump(function() {
            });
          }
          return cb(null, { success: true, process_list });
        }
        try {
          if (fs.existsSync(cst.DUMP_FILE_PATH)) {
            fs.writeFileSync(cst.DUMP_BACKUP_FILE_PATH, fs.readFileSync(cst.DUMP_FILE_PATH));
          }
        } catch (e) {
          console.error(e.stack || e);
        }
        try {
          fs.writeFileSync(cst.DUMP_FILE_PATH, JSON.stringify(process_list));
        } catch (e) {
          console.error(e.stack || e);
          try {
            if (fs.existsSync(cst.DUMP_BACKUP_FILE_PATH)) {
              fs.writeFileSync(cst.DUMP_FILE_PATH, fs.readFileSync(cst.DUMP_BACKUP_FILE_PATH));
            }
          } catch (e2) {
            fs.unlinkSync(cst.DUMP_FILE_PATH);
            console.error(e2.stack || e2);
          }
        }
        return cb(null, { success: true, process_list });
      }
      function saveProc(apps2) {
        if (!apps2[0])
          return fin(null);
        delete apps2[0].pm2_env.instances;
        delete apps2[0].pm2_env.pm_id;
        if (!apps2[0].pm2_env.pmx_module)
          process_list.push(apps2[0].pm2_env);
        apps2.shift();
        return saveProc(apps2);
      }
      saveProc(apps);
    };
    God.ping = function(env, cb) {
      return cb(null, { msg: "pong" });
    };
    God.notifyKillPM2 = function() {
      God.pm2_being_killed = true;
    };
    God.duplicateProcessId = function(id2, cb) {
      if (!(id2 in God.clusters_db))
        return cb(God.logAndGenerateError(id2 + " id unknown"), {});
      if (!God.clusters_db[id2] || !God.clusters_db[id2].pm2_env)
        return cb(God.logAndGenerateError("Error when getting proc || proc.pm2_env"), {});
      var proc = Utility.clone(God.clusters_db[id2].pm2_env);
      delete proc.created_at;
      delete proc.pm_id;
      delete proc.unique_id;
      proc.unique_id = Utility.generateUUID();
      God.injectVariables(proc, function inject(_err, proc2) {
        return God.executeApp(Utility.clone(proc2), function(err, clu) {
          if (err)
            return cb(err);
          God.notify("start", clu, true);
          return cb(err, Utility.clone(clu));
        });
      });
    };
    God.startProcessId = function(id2, cb) {
      if (!(id2 in God.clusters_db))
        return cb(God.logAndGenerateError(id2 + " id unknown"), {});
      var proc = God.clusters_db[id2];
      if (proc.pm2_env.status == cst.ONLINE_STATUS)
        return cb(God.logAndGenerateError("process already online"), {});
      if (proc.pm2_env.status == cst.LAUNCHING_STATUS)
        return cb(God.logAndGenerateError("process already started"), {});
      if (proc.process && proc.process.pid)
        return cb(God.logAndGenerateError("Process with pid " + proc.process.pid + " already exists"), {});
      return God.executeApp(God.clusters_db[id2].pm2_env, function(err, proc2) {
        return cb(err, Utility.clone(proc2));
      });
    };
    God.stopProcessId = function(id2, cb) {
      if (typeof id2 == "object" && "id" in id2)
        id2 = id2.id;
      if (!(id2 in God.clusters_db))
        return cb(God.logAndGenerateError(id2 + " : id unknown"), {});
      var proc = God.clusters_db[id2];
      clearTimeout(proc.pm2_env.restart_task);
      if (proc.pm2_env.status == cst.STOPPED_STATUS) {
        proc.process.pid = 0;
        return cb(null, God.getFormatedProcess(id2));
      }
      if (proc.state && proc.state === "none")
        return setTimeout(function() {
          God.stopProcessId(id2, cb);
        }, 250);
      console.log("Stopping app:%s id:%s", proc.pm2_env.name, proc.pm2_env.pm_id);
      proc.pm2_env.status = cst.STOPPING_STATUS;
      if (!proc.process.pid) {
        console.error("app=%s id=%d does not have a pid", proc.pm2_env.name, proc.pm2_env.pm_id);
        proc.pm2_env.status = cst.STOPPED_STATUS;
        return cb(null, { error: true, message: "could not kill process w/o pid" });
      }
      God.killProcess(proc.process.pid, proc.pm2_env, function(err) {
        proc.pm2_env.status = cst.STOPPED_STATUS;
        God.notify("exit", proc);
        if (err && err.type && err.type === "timeout") {
          console.error("app=%s id=%d pid=%s could not be stopped", proc.pm2_env.name, proc.pm2_env.pm_id, proc.process.pid);
          proc.pm2_env.status = cst.ERRORED_STATUS;
          return cb(null, God.getFormatedProcess(id2));
        }
        if (proc.pm2_env.pm_id.toString().indexOf("_old_") !== 0) {
          try {
            fs.unlinkSync(proc.pm2_env.pm_pid_path);
          } catch (e) {
          }
        }
        if (proc.pm2_env.axm_actions)
          proc.pm2_env.axm_actions = [];
        if (proc.pm2_env.axm_monitor)
          proc.pm2_env.axm_monitor = {};
        proc.process.pid = 0;
        return cb(null, God.getFormatedProcess(id2));
      });
    };
    God.resetMetaProcessId = function(id2, cb) {
      if (!(id2 in God.clusters_db))
        return cb(God.logAndGenerateError(id2 + " id unknown"), {});
      if (!God.clusters_db[id2] || !God.clusters_db[id2].pm2_env)
        return cb(God.logAndGenerateError("Error when getting proc || proc.pm2_env"), {});
      God.clusters_db[id2].pm2_env.created_at = Utility.getDate();
      God.clusters_db[id2].pm2_env.unstable_restarts = 0;
      God.clusters_db[id2].pm2_env.restart_time = 0;
      return cb(null, God.getFormatedProcesses());
    };
    God.deleteProcessId = function(id2, cb) {
      God.deleteCron(id2);
      God.stopProcessId(id2, function(err, proc) {
        if (err)
          return cb(God.logAndGenerateError(err), {});
        delete God.clusters_db[id2];
        if (Object.keys(God.clusters_db).length == 0)
          God.next_id = 0;
        return cb(null, proc);
      });
      return false;
    };
    God.restartProcessId = function(opts, cb) {
      var id2 = opts.id;
      var env = opts.env || {};
      if (typeof id2 === "undefined")
        return cb(God.logAndGenerateError("opts.id not passed to restartProcessId", opts));
      if (!(id2 in God.clusters_db))
        return cb(God.logAndGenerateError("God db process id unknown"), {});
      var proc = God.clusters_db[id2];
      God.resetState(proc.pm2_env);
      God.deleteCron(id2);
      Utility.extend(proc.pm2_env.env, env);
      Utility.extendExtraConfig(proc, opts);
      if (God.pm2_being_killed) {
        return cb(God.logAndGenerateError("[RestartProcessId] PM2 is being killed, stopping restart procedure..."));
      }
      if (proc.pm2_env.status === cst.ONLINE_STATUS || proc.pm2_env.status === cst.LAUNCHING_STATUS) {
        God.stopProcessId(id2, function(err) {
          if (God.pm2_being_killed)
            return cb(God.logAndGenerateError("[RestartProcessId] PM2 is being killed, stopping restart procedure..."));
          proc.pm2_env.restart_time += 1;
          return God.startProcessId(id2, cb);
        });
        return false;
      } else {
        debug("[restart] process not online, starting it");
        return God.startProcessId(id2, cb);
      }
    };
    God.restartProcessName = function(name2, cb) {
      var processes = God.findByName(name2);
      if (processes && processes.length === 0)
        return cb(God.logAndGenerateError("Unknown process"), {});
      eachLimit(processes, cst.CONCURRENT_ACTIONS, function(proc, next) {
        if (God.pm2_being_killed)
          return next("[Watch] PM2 is being killed, stopping restart procedure...");
        if (proc.pm2_env.status === cst.ONLINE_STATUS)
          return God.restartProcessId({ id: proc.pm2_env.pm_id }, next);
        else if (proc.pm2_env.status !== cst.STOPPING_STATUS && proc.pm2_env.status !== cst.LAUNCHING_STATUS)
          return God.startProcessId(proc.pm2_env.pm_id, next);
        else
          return next(util.format("[Watch] Process name %s is being stopped so I won\'t restart it", name2));
      }, function(err) {
        if (err)
          return cb(God.logAndGenerateError(err));
        return cb(null, God.getFormatedProcesses());
      });
      return false;
    };
    God.sendSignalToProcessId = function(opts, cb) {
      var id2 = opts.process_id;
      var signal = opts.signal;
      if (!(id2 in God.clusters_db))
        return cb(God.logAndGenerateError(id2 + " id unknown"), {});
      var proc = God.clusters_db[id2];
      try {
        process.kill(God.clusters_db[id2].process.pid, signal);
      } catch (e) {
        return cb(God.logAndGenerateError("Error when sending signal (signal unknown)"), {});
      }
      return cb(null, God.getFormatedProcesses());
    };
    God.sendSignalToProcessName = function(opts, cb) {
      var processes = God.findByName(opts.process_name);
      var signal = opts.signal;
      if (processes && processes.length === 0)
        return cb(God.logAndGenerateError("Unknown process name"), {});
      eachLimit(processes, cst.CONCURRENT_ACTIONS, function(proc, next) {
        if (proc.pm2_env.status == cst.ONLINE_STATUS || proc.pm2_env.status == cst.LAUNCHING_STATUS) {
          try {
            process.kill(proc.process.pid, signal);
          } catch (e) {
            return next(e);
          }
        }
        return setTimeout(next, 200);
      }, function(err) {
        if (err)
          return cb(God.logAndGenerateError(err), {});
        return cb(null, God.getFormatedProcesses());
      });
    };
    God.stopWatch = function(method, value, fn) {
      var env = null;
      if (method == "stopAll" || method == "deleteAll") {
        var processes = God.getFormatedProcesses();
        processes.forEach(function(proc) {
          God.clusters_db[proc.pm_id].pm2_env.watch = false;
          God.watch.disable(proc.pm2_env);
        });
      } else {
        if (method.indexOf("ProcessId") !== -1) {
          env = God.clusters_db[value];
        } else if (method.indexOf("ProcessName") !== -1) {
          env = God.clusters_db[God.findByName(value)];
        }
        if (env) {
          God.watch.disable(env.pm2_env);
          env.pm2_env.watch = false;
        }
      }
      return fn(null, { success: true });
    };
    God.toggleWatch = function(method, value, fn) {
      var env = null;
      if (method == "restartProcessId") {
        env = God.clusters_db[value.id];
      } else if (method == "restartProcessName") {
        env = God.clusters_db[God.findByName(value)];
      }
      if (env) {
        env.pm2_env.watch = !env.pm2_env.watch;
        if (env.pm2_env.watch)
          God.watch.enable(env.pm2_env);
        else
          God.watch.disable(env.pm2_env);
      }
      return fn(null, { success: true });
    };
    God.startWatch = function(method, value, fn) {
      var env = null;
      if (method == "restartProcessId") {
        env = God.clusters_db[value.id];
      } else if (method == "restartProcessName") {
        env = God.clusters_db[God.findByName(value)];
      }
      if (env) {
        if (env.pm2_env.watch)
          return fn(null, { success: true, notrestarted: true });
        God.watch.enable(env.pm2_env);
        env.pm2_env.watch = true;
      }
      return fn(null, { success: true });
    };
    God.reloadLogs = function(opts, cb) {
      console.log("Reloading logs...");
      var processIds = Object.keys(God.clusters_db);
      processIds.forEach(function(id2) {
        var cluster = God.clusters_db[id2];
        console.log("Reloading logs for process id %d", id2);
        if (cluster && cluster.pm2_env) {
          if (cluster.send && cluster.pm2_env.exec_mode == "cluster_mode") {
            try {
              cluster.send({
                type: "log:reload"
              });
            } catch (e) {
              console.error(e.message || e);
            }
          } else if (cluster._reloadLogs) {
            cluster._reloadLogs(function(err) {
              if (err)
                God.logAndGenerateError(err);
            });
          }
        }
      });
      return cb(null, {});
    };
    God.sendLineToStdin = function(packet, cb) {
      if (typeof packet.pm_id == "undefined" || !packet.line)
        return cb(God.logAndGenerateError("pm_id or line field missing"), {});
      var pm_id = packet.pm_id;
      var line = packet.line;
      var proc = God.clusters_db[pm_id];
      if (!proc)
        return cb(God.logAndGenerateError("Process with ID <" + pm_id + "> unknown."), {});
      if (proc.pm2_env.exec_mode == "cluster_mode")
        return cb(God.logAndGenerateError("Cannot send line to processes in cluster mode"), {});
      if (proc.pm2_env.status != cst.ONLINE_STATUS && proc.pm2_env.status != cst.LAUNCHING_STATUS)
        return cb(God.logAndGenerateError("Process with ID <" + pm_id + "> offline."), {});
      try {
        proc.stdin.write(line, function() {
          return cb(null, {
            pm_id,
            line
          });
        });
      } catch (e) {
        return cb(God.logAndGenerateError(e), {});
      }
    };
    God.sendDataToProcessId = function(packet, cb) {
      if (typeof packet.id == "undefined" || typeof packet.data == "undefined" || !packet.topic)
        return cb(God.logAndGenerateError("ID, DATA or TOPIC field is missing"), {});
      var pm_id = packet.id;
      var data = packet.data;
      var proc = God.clusters_db[pm_id];
      if (!proc)
        return cb(God.logAndGenerateError("Process with ID <" + pm_id + "> unknown."), {});
      if (proc.pm2_env.status != cst.ONLINE_STATUS && proc.pm2_env.status != cst.LAUNCHING_STATUS)
        return cb(God.logAndGenerateError("Process with ID <" + pm_id + "> offline."), {});
      try {
        proc.send(packet);
      } catch (e) {
        return cb(God.logAndGenerateError(e), {});
      }
      return cb(null, {
        success: true,
        data: packet
      });
    };
    God.msgProcess = function(cmd, cb) {
      if ("id" in cmd) {
        var id2 = cmd.id;
        if (!(id2 in God.clusters_db))
          return cb(God.logAndGenerateError(id2 + " id unknown"), {});
        var proc = God.clusters_db[id2];
        var action_exist = false;
        proc.pm2_env.axm_actions.forEach(function(action) {
          if (action.action_name == cmd.msg) {
            action_exist = true;
            action.output = [];
          }
        });
        if (action_exist == false) {
          return cb(God.logAndGenerateError("Action doesn\'t exist " + cmd.msg + " for " + proc.pm2_env.name), {});
        }
        if (proc.pm2_env.status == cst.ONLINE_STATUS || proc.pm2_env.status == cst.LAUNCHING_STATUS) {
          if (cmd.opts == null && !cmd.uuid)
            proc.send(cmd.msg);
          else
            proc.send(cmd);
          return cb(null, { process_count: 1, success: true });
        } else
          return cb(God.logAndGenerateError(id2 + " : id offline"), {});
      } else if ("name" in cmd) {
        var name2 = cmd.name;
        var arr = Object.keys(God.clusters_db);
        var sent = 0;
        (function ex(arr2) {
          if (arr2[0] == null || !arr2) {
            return cb(null, {
              process_count: sent,
              success: true
            });
          }
          var id3 = arr2[0];
          if (!God.clusters_db[id3] || !God.clusters_db[id3].pm2_env) {
            arr2.shift();
            return ex(arr2);
          }
          var proc_env = God.clusters_db[id3].pm2_env;
          const isActionAvailable = proc_env.axm_actions.find((action) => action.action_name === cmd.msg) !== undefined;
          if (isActionAvailable === false) {
            arr2.shift();
            return ex(arr2);
          }
          if ((p.basename(proc_env.pm_exec_path) == name2 || proc_env.name == name2 || proc_env.namespace == name2 || name2 == "all") && (proc_env.status == cst.ONLINE_STATUS || proc_env.status == cst.LAUNCHING_STATUS)) {
            proc_env.axm_actions.forEach(function(action) {
              if (action.action_name == cmd.msg) {
                action_exist = true;
              }
            });
            if (action_exist == false || proc_env.axm_actions.length == 0) {
              arr2.shift();
              return ex(arr2);
            }
            if (cmd.opts == null)
              God.clusters_db[id3].send(cmd.msg);
            else
              God.clusters_db[id3].send(cmd);
            sent++;
            arr2.shift();
            return ex(arr2);
          } else {
            arr2.shift();
            return ex(arr2);
          }
          return false;
        })(arr);
      } else
        return cb(God.logAndGenerateError("method requires name or id field"), {});
      return false;
    };
    God.getVersion = function(env, cb) {
      process.nextTick(function() {
        return cb(null, pkg.version);
      });
    };
    God.monitor = function Monitor(pm_id, cb) {
      if (!God.clusters_db[pm_id] || !God.clusters_db[pm_id].pm2_env)
        return cb(new Error("Unknown pm_id"));
      God.clusters_db[pm_id].pm2_env._km_monitored = true;
      return cb(null, { success: true, pm_id });
    };
    God.unmonitor = function Monitor(pm_id, cb) {
      if (!God.clusters_db[pm_id] || !God.clusters_db[pm_id].pm2_env)
        return cb(new Error("Unknown pm_id"));
      God.clusters_db[pm_id].pm2_env._km_monitored = false;
      return cb(null, { success: true, pm_id });
    };
    God.getReport = function(arg, cb) {
      var report = {
        pm2_version: pkg.version,
        node_version: "N/A",
        node_path: process.env["_"] || "not found",
        argv0: process.argv0,
        argv: process.argv,
        user: process.env.USER,
        uid: cst.IS_WINDOWS === false && process.geteuid ? process.geteuid() : "N/A",
        gid: cst.IS_WINDOWS === false && process.getegid ? process.getegid() : "N/A",
        env: process.env,
        managed_apps: Object.keys(God.clusters_db).length,
        started_at: God.started_at
      };
      if (process.versions && process.versions.node) {
        report.node_version = process.versions.node;
      }
      process.nextTick(function() {
        return cb(null, report);
      });
    };
  };
});

// ../../node_modules/picomatch/lib/constants.js
var require_constants6 = __commonJS((exports2, module2) => {
  var path2 = __require("path");
  var WIN_SLASH = "\\\\/";
  var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
  var DOT_LITERAL = "\\.";
  var PLUS_LITERAL = "\\+";
  var QMARK_LITERAL = "\\?";
  var SLASH_LITERAL = "\\/";
  var ONE_CHAR = "(?=.)";
  var QMARK = "[^/]";
  var END_ANCHOR = `(?:${SLASH_LITERAL}|\$)`;
  var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
  var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
  var NO_DOT = `(?!${DOT_LITERAL})`;
  var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
  var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
  var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
  var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
  var STAR = `${QMARK}*?`;
  var POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  };
  var WINDOWS_CHARS = {
    ...POSIX_CHARS,
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|\$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|\$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|\$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|\$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|\$)`
  };
  var POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  module2.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    CHAR_0: 48,
    CHAR_9: 57,
    CHAR_UPPERCASE_A: 65,
    CHAR_LOWERCASE_A: 97,
    CHAR_UPPERCASE_Z: 90,
    CHAR_LOWERCASE_Z: 122,
    CHAR_LEFT_PARENTHESES: 40,
    CHAR_RIGHT_PARENTHESES: 41,
    CHAR_ASTERISK: 42,
    CHAR_AMPERSAND: 38,
    CHAR_AT: 64,
    CHAR_BACKWARD_SLASH: 92,
    CHAR_CARRIAGE_RETURN: 13,
    CHAR_CIRCUMFLEX_ACCENT: 94,
    CHAR_COLON: 58,
    CHAR_COMMA: 44,
    CHAR_DOT: 46,
    CHAR_DOUBLE_QUOTE: 34,
    CHAR_EQUAL: 61,
    CHAR_EXCLAMATION_MARK: 33,
    CHAR_FORM_FEED: 12,
    CHAR_FORWARD_SLASH: 47,
    CHAR_GRAVE_ACCENT: 96,
    CHAR_HASH: 35,
    CHAR_HYPHEN_MINUS: 45,
    CHAR_LEFT_ANGLE_BRACKET: 60,
    CHAR_LEFT_CURLY_BRACE: 123,
    CHAR_LEFT_SQUARE_BRACKET: 91,
    CHAR_LINE_FEED: 10,
    CHAR_NO_BREAK_SPACE: 160,
    CHAR_PERCENT: 37,
    CHAR_PLUS: 43,
    CHAR_QUESTION_MARK: 63,
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    CHAR_RIGHT_CURLY_BRACE: 125,
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    CHAR_SEMICOLON: 59,
    CHAR_SINGLE_QUOTE: 39,
    CHAR_SPACE: 32,
    CHAR_TAB: 9,
    CHAR_UNDERSCORE: 95,
    CHAR_VERTICAL_LINE: 124,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    SEP: path2.sep,
    extglobChars(chars) {
      return {
        "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
        "?": { type: "qmark", open: "(?:", close: ")?" },
        "+": { type: "plus", open: "(?:", close: ")+" },
        "*": { type: "star", open: "(?:", close: ")*" },
        "@": { type: "at", open: "(?:", close: ")" }
      };
    },
    globChars(win32) {
      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
  };
});

// ../../node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS((exports2) => {
  var path2 = __require("path");
  var win32 = process.platform === "win32";
  var {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = require_constants6();
  exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
  exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
  exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
  exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
  exports2.removeBackslashes = (str) => {
    return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
      return match === "\\" ? "" : match;
    });
  };
  exports2.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split(".").map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
      return true;
    }
    return false;
  };
  exports2.isWindows = (options2) => {
    if (options2 && typeof options2.windows === "boolean") {
      return options2.windows;
    }
    return win32 === true || path2.sep === "\\";
  };
  exports2.escapeLast = (input, char, lastIdx) => {
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1)
      return input;
    if (input[idx - 1] === "\\")
      return exports2.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
  };
  exports2.removePrefix = (input, state = {}) => {
    let output = input;
    if (output.startsWith("./")) {
      output = output.slice(2);
      state.prefix = "./";
    }
    return output;
  };
  exports2.wrapOutput = (input, state = {}, options2 = {}) => {
    const prepend = options2.contains ? "" : "^";
    const append = options2.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append}`;
    if (state.negated === true) {
      output = `(?:^(?!${output}).*\$)`;
    }
    return output;
  };
});

// ../../node_modules/picomatch/lib/scan.js
var require_scan = __commonJS((exports2, module2) => {
  var utils = require_utils2();
  var {
    CHAR_ASTERISK,
    CHAR_AT,
    CHAR_BACKWARD_SLASH,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_EXCLAMATION_MARK,
    CHAR_FORWARD_SLASH,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_LEFT_PARENTHESES,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_PLUS,
    CHAR_QUESTION_MARK,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_RIGHT_PARENTHESES,
    CHAR_RIGHT_SQUARE_BRACKET
  } = require_constants6();
  var isPathSeparator = (code) => {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  };
  var depth = (token) => {
    if (token.isPrefix !== true) {
      token.depth = token.isGlobstar ? Infinity : 1;
    }
  };
  var scan = (input, options2) => {
    const opts = options2 || {};
    const length3 = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let negatedExtglob = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = { value: "", depth: 0, isGlob: false };
    const eos = () => index >= length3;
    const peek = () => str.charCodeAt(index + 1);
    const advance = () => {
      prev = code;
      return str.charCodeAt(++index);
    };
    while (index < length3) {
      code = advance();
      let next;
      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token.backslashes = true;
        code = advance();
        if (code === CHAR_LEFT_CURLY_BRACE) {
          braceEscaped = true;
        }
        continue;
      }
      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
        braces++;
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }
          if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (braceEscaped !== true && code === CHAR_COMMA) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_RIGHT_CURLY_BRACE) {
            braces--;
            if (braces === 0) {
              braceEscaped = false;
              isBrace = token.isBrace = true;
              finished = true;
              break;
            }
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_FORWARD_SLASH) {
        slashes.push(index);
        tokens.push(token);
        token = { value: "", depth: 0, isGlob: false };
        if (finished === true)
          continue;
        if (prev === CHAR_DOT && index === start + 1) {
          start += 2;
          continue;
        }
        lastIndex = index + 1;
        continue;
      }
      if (opts.noext !== true) {
        const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          isExtglob = token.isExtglob = true;
          finished = true;
          if (code === CHAR_EXCLAMATION_MARK && index === start) {
            negatedExtglob = true;
          }
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
      }
      if (code === CHAR_ASTERISK) {
        if (prev === CHAR_ASTERISK)
          isGlobstar = token.isGlobstar = true;
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_QUESTION_MARK) {
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        while (eos() !== true && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isBracket = token.isBracket = true;
            isGlob = token.isGlob = true;
            finished = true;
            break;
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
        negated = token.negated = true;
        start++;
        continue;
      }
      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_LEFT_PARENTHESES) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES) {
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (isGlob === true) {
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
    }
    if (opts.noext === true) {
      isExtglob = false;
      isGlob = false;
    }
    let base = str;
    let prefix = "";
    let glob = "";
    if (start > 0) {
      prefix = str.slice(0, start);
      str = str.slice(start);
      lastIndex -= start;
    }
    if (base && isGlob === true && lastIndex > 0) {
      base = str.slice(0, lastIndex);
      glob = str.slice(lastIndex);
    } else if (isGlob === true) {
      base = "";
      glob = str;
    } else {
      base = str;
    }
    if (base && base !== "" && base !== "/" && base !== str) {
      if (isPathSeparator(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }
    if (opts.unescape === true) {
      if (glob)
        glob = utils.removeBackslashes(glob);
      if (base && backslashes === true) {
        base = utils.removeBackslashes(base);
      }
    }
    const state = {
      prefix,
      input,
      start,
      base,
      glob,
      isBrace,
      isBracket,
      isGlob,
      isExtglob,
      isGlobstar,
      negated,
      negatedExtglob
    };
    if (opts.tokens === true) {
      state.maxDepth = 0;
      if (!isPathSeparator(code)) {
        tokens.push(token);
      }
      state.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
      let prevIndex;
      for (let idx = 0;idx < slashes.length; idx++) {
        const n = prevIndex ? prevIndex + 1 : start;
        const i = slashes[idx];
        const value = input.slice(n, i);
        if (opts.tokens) {
          if (idx === 0 && start !== 0) {
            tokens[idx].isPrefix = true;
            tokens[idx].value = prefix;
          } else {
            tokens[idx].value = value;
          }
          depth(tokens[idx]);
          state.maxDepth += tokens[idx].depth;
        }
        if (idx !== 0 || value !== "") {
          parts.push(value);
        }
        prevIndex = i;
      }
      if (prevIndex && prevIndex + 1 < input.length) {
        const value = input.slice(prevIndex + 1);
        parts.push(value);
        if (opts.tokens) {
          tokens[tokens.length - 1].value = value;
          depth(tokens[tokens.length - 1]);
          state.maxDepth += tokens[tokens.length - 1].depth;
        }
      }
      state.slashes = slashes;
      state.parts = parts;
    }
    return state;
  };
  module2.exports = scan;
});

// ../../node_modules/picomatch/lib/parse.js
var require_parse3 = __commonJS((exports2, module2) => {
  var constants = require_constants6();
  var utils = require_utils2();
  var {
    MAX_LENGTH,
    POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS
  } = constants;
  var expandRange = (args2, options2) => {
    if (typeof options2.expandRange === "function") {
      return options2.expandRange(...args2, options2);
    }
    args2.sort();
    const value = `[${args2.join("-")}]`;
    try {
      new RegExp(value);
    } catch (ex) {
      return args2.map((v) => utils.escapeRegex(v)).join("..");
    }
    return value;
  };
  var syntaxError = (type2, char) => {
    return `Missing ${type2}: "${char}" - use "\\\\${char}" to match literal characters`;
  };
  var parse2 = (input, options2) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    input = REPLACEMENTS[input] || input;
    const opts = { ...options2 };
    const max4 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;
    if (len > max4) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max4}`);
    }
    const bos = { type: "bos", value: "", output: opts.prepend || "" };
    const tokens = [bos];
    const capture = opts.capture ? "" : "?:";
    const win32 = utils.isWindows(options2);
    const PLATFORM_CHARS = constants.globChars(win32);
    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
    const {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS;
    const globstar = (opts2) => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? "" : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    if (typeof opts.noext === "boolean") {
      opts.noextglob = opts.noext;
    }
    const state = {
      input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: false,
      tokens
    };
    input = utils.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    const eos = () => state.index === len - 1;
    const peek = state.peek = (n = 1) => input[state.index + n];
    const advance = state.advance = () => input[++state.index] || "";
    const remaining = () => input.slice(state.index + 1);
    const consume = (value2 = "", num = 0) => {
      state.consumed += value2;
      state.index += num;
    };
    const append = (token) => {
      state.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };
    const negate = () => {
      let count = 1;
      while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
        advance();
        state.start++;
        count++;
      }
      if (count % 2 === 0) {
        return false;
      }
      state.negated = true;
      state.start++;
      return true;
    };
    const increment = (type2) => {
      state[type2]++;
      stack.push(type2);
    };
    const decrement = (type2) => {
      state[type2]--;
      stack.pop();
    };
    const push = (tok) => {
      if (prev.type === "globstar") {
        const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
        const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
        if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "star";
          prev.value = "*";
          prev.output = star;
          state.output += prev.output;
        }
      }
      if (extglobs.length && tok.type !== "paren") {
        extglobs[extglobs.length - 1].inner += tok.value;
      }
      if (tok.value || tok.output)
        append(tok);
      if (prev && prev.type === "text" && tok.type === "text") {
        prev.value += tok.value;
        prev.output = (prev.output || "") + tok.value;
        return;
      }
      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };
    const extglobOpen = (type2, value2) => {
      const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      const output = (opts.capture ? "(" : "") + token.open;
      increment("parens");
      push({ type: type2, value: value2, output: state.output ? "" : ONE_CHAR });
      push({ type: "paren", extglob: true, value: advance(), output });
      extglobs.push(token);
    };
    const extglobClose = (token) => {
      let output = token.close + (opts.capture ? ")" : "");
      let rest;
      if (token.type === "negate") {
        let extglobStar = star;
        if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
          extglobStar = globstar(opts);
        }
        if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
          output = token.close = `)\$))${extglobStar}`;
        }
        if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
          const expression = parse2(rest, { ...options2, fastpaths: false }).output;
          output = token.close = `)${expression})${extglobStar})`;
        }
        if (token.prev.type === "bos") {
          state.negatedExtglob = true;
        }
      }
      push({ type: "paren", extglob: true, value, output });
      decrement("parens");
    };
    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      let backslashes = false;
      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
        if (first === "\\") {
          backslashes = true;
          return m;
        }
        if (first === "?") {
          if (esc) {
            return esc + first + (rest ? QMARK.repeat(rest.length) : "");
          }
          if (index === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
          }
          return QMARK.repeat(chars.length);
        }
        if (first === ".") {
          return DOT_LITERAL.repeat(chars.length);
        }
        if (first === "*") {
          if (esc) {
            return esc + first + (rest ? star : "");
          }
          return star;
        }
        return esc ? m : `\\${m}`;
      });
      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, "");
        } else {
          output = output.replace(/\\+/g, (m) => {
            return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
          });
        }
      }
      if (output === input && opts.contains === true) {
        state.output = input;
        return state;
      }
      state.output = utils.wrapOutput(output, state, options2);
      return state;
    }
    while (!eos()) {
      value = advance();
      if (value === "\0") {
        continue;
      }
      if (value === "\\") {
        const next = peek();
        if (next === "/" && opts.bash !== true) {
          continue;
        }
        if (next === "." || next === ";") {
          continue;
        }
        if (!next) {
          value += "\\";
          push({ type: "text", value });
          continue;
        }
        const match = /^\\+/.exec(remaining());
        let slashes = 0;
        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;
          if (slashes % 2 !== 0) {
            value += "\\";
          }
        }
        if (opts.unescape === true) {
          value = advance();
        } else {
          value += advance();
        }
        if (state.brackets === 0) {
          push({ type: "text", value });
          continue;
        }
      }
      if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
        if (opts.posix !== false && value === ":") {
          const inner = prev.value.slice(1);
          if (inner.includes("[")) {
            prev.posix = true;
            if (inner.includes(":")) {
              const idx = prev.value.lastIndexOf("[");
              const pre = prev.value.slice(0, idx);
              const rest2 = prev.value.slice(idx + 2);
              const posix = POSIX_REGEX_SOURCE[rest2];
              if (posix) {
                prev.value = pre + posix;
                state.backtrack = true;
                advance();
                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }
                continue;
              }
            }
          }
        }
        if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
          value = `\\${value}`;
        }
        if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
          value = `\\${value}`;
        }
        if (opts.posix === true && value === "!" && prev.value === "[") {
          value = "^";
        }
        prev.value += value;
        append({ value });
        continue;
      }
      if (state.quotes === 1 && value !== '"') {
        value = utils.escapeRegex(value);
        prev.value += value;
        append({ value });
        continue;
      }
      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;
        if (opts.keepQuotes === true) {
          push({ type: "text", value });
        }
        continue;
      }
      if (value === "(") {
        increment("parens");
        push({ type: "paren", value });
        continue;
      }
      if (value === ")") {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError("opening", "("));
        }
        const extglob = extglobs[extglobs.length - 1];
        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }
        push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
        decrement("parens");
        continue;
      }
      if (value === "[") {
        if (opts.nobracket === true || !remaining().includes("]")) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("closing", "]"));
          }
          value = `\\${value}`;
        } else {
          increment("brackets");
        }
        push({ type: "bracket", value });
        continue;
      }
      if (value === "]") {
        if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
          push({ type: "text", value, output: `\\${value}` });
          continue;
        }
        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "["));
          }
          push({ type: "text", value, output: `\\${value}` });
          continue;
        }
        decrement("brackets");
        const prevValue = prev.value.slice(1);
        if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
          value = `/${value}`;
        }
        prev.value += value;
        append({ value });
        if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
          continue;
        }
        const escaped = utils.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length);
        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        }
        prev.value = `(${capture}${escaped}|${prev.value})`;
        state.output += prev.value;
        continue;
      }
      if (value === "{" && opts.nobrace !== true) {
        increment("braces");
        const open = {
          type: "brace",
          value,
          output: "(",
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open);
        push(open);
        continue;
      }
      if (value === "}") {
        const brace = braces[braces.length - 1];
        if (opts.nobrace === true || !brace) {
          push({ type: "text", value, output: value });
          continue;
        }
        let output = ")";
        if (brace.dots === true) {
          const arr = tokens.slice();
          const range = [];
          for (let i = arr.length - 1;i >= 0; i--) {
            tokens.pop();
            if (arr[i].type === "brace") {
              break;
            }
            if (arr[i].type !== "dots") {
              range.unshift(arr[i].value);
            }
          }
          output = expandRange(range, opts);
          state.backtrack = true;
        }
        if (brace.comma !== true && brace.dots !== true) {
          const out = state.output.slice(0, brace.outputIndex);
          const toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = "\\{";
          value = output = "\\}";
          state.output = out;
          for (const t of toks) {
            state.output += t.output || t.value;
          }
        }
        push({ type: "brace", value, output });
        decrement("braces");
        braces.pop();
        continue;
      }
      if (value === "|") {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }
        push({ type: "text", value });
        continue;
      }
      if (value === ",") {
        let output = value;
        const brace = braces[braces.length - 1];
        if (brace && stack[stack.length - 1] === "braces") {
          brace.comma = true;
          output = "|";
        }
        push({ type: "comma", value, output });
        continue;
      }
      if (value === "/") {
        if (prev.type === "dot" && state.index === state.start + 1) {
          state.start = state.index + 1;
          state.consumed = "";
          state.output = "";
          tokens.pop();
          prev = bos;
          continue;
        }
        push({ type: "slash", value, output: SLASH_LITERAL });
        continue;
      }
      if (value === ".") {
        if (state.braces > 0 && prev.type === "dot") {
          if (prev.value === ".")
            prev.output = DOT_LITERAL;
          const brace = braces[braces.length - 1];
          prev.type = "dots";
          prev.output += value;
          prev.value += value;
          brace.dots = true;
          continue;
        }
        if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
          push({ type: "text", value, output: DOT_LITERAL });
          continue;
        }
        push({ type: "dot", value, output: DOT_LITERAL });
        continue;
      }
      if (value === "?") {
        const isGroup = prev && prev.value === "(";
        if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("qmark", value);
          continue;
        }
        if (prev && prev.type === "paren") {
          const next = peek();
          let output = value;
          if (next === "<" && !utils.supportsLookbehinds()) {
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          }
          if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
            output = `\\${value}`;
          }
          push({ type: "text", value, output });
          continue;
        }
        if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
          push({ type: "qmark", value, output: QMARK_NO_DOT });
          continue;
        }
        push({ type: "qmark", value, output: QMARK });
        continue;
      }
      if (value === "!") {
        if (opts.noextglob !== true && peek() === "(") {
          if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
            extglobOpen("negate", value);
            continue;
          }
        }
        if (opts.nonegate !== true && state.index === 0) {
          negate();
          continue;
        }
      }
      if (value === "+") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("plus", value);
          continue;
        }
        if (prev && prev.value === "(" || opts.regex === false) {
          push({ type: "plus", value, output: PLUS_LITERAL });
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
          push({ type: "plus", value });
          continue;
        }
        push({ type: "plus", value: PLUS_LITERAL });
        continue;
      }
      if (value === "@") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          push({ type: "at", extglob: true, value, output: "" });
          continue;
        }
        push({ type: "text", value });
        continue;
      }
      if (value !== "*") {
        if (value === "$" || value === "^") {
          value = `\\${value}`;
        }
        const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
        if (match) {
          value += match[0];
          state.index += match[0].length;
        }
        push({ type: "text", value });
        continue;
      }
      if (prev && (prev.type === "globstar" || prev.star === true)) {
        prev.type = "star";
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state.backtrack = true;
        state.globstar = true;
        consume(value);
        continue;
      }
      let rest = remaining();
      if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
        extglobOpen("star", value);
        continue;
      }
      if (prev.type === "star") {
        if (opts.noglobstar === true) {
          consume(value);
          continue;
        }
        const prior = prev.prev;
        const before = prior.prev;
        const isStart = prior.type === "slash" || prior.type === "bos";
        const afterStar = before && (before.type === "star" || before.type === "globstar");
        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
          push({ type: "star", value, output: "" });
          continue;
        }
        const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
        const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
        if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
          push({ type: "star", value, output: "" });
          continue;
        }
        while (rest.slice(0, 3) === "/**") {
          const after = input[state.index + 4];
          if (after && after !== "/") {
            break;
          }
          rest = rest.slice(3);
          consume("/**", 3);
        }
        if (prior.type === "bos" && eos()) {
          prev.type = "globstar";
          prev.value += value;
          prev.output = globstar(opts);
          state.output = prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
          prev.value += value;
          state.globstar = true;
          state.output += prior.output + prev.output;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
          const end = rest[1] !== undefined ? "|$" : "";
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
          prev.value += value;
          state.output += prior.output + prev.output;
          state.globstar = true;
          consume(value + advance());
          push({ type: "slash", value: "/", output: "" });
          continue;
        }
        if (prior.type === "bos" && rest[0] === "/") {
          prev.type = "globstar";
          prev.value += value;
          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
          state.output = prev.output;
          state.globstar = true;
          consume(value + advance());
          push({ type: "slash", value: "/", output: "" });
          continue;
        }
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = "globstar";
        prev.output = globstar(opts);
        prev.value += value;
        state.output += prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }
      const token = { type: "star", value, output: star };
      if (opts.bash === true) {
        token.output = ".*?";
        if (prev.type === "bos" || prev.type === "slash") {
          token.output = nodot + token.output;
        }
        push(token);
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
        token.output = value;
        push(token);
        continue;
      }
      if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
        if (prev.type === "dot") {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state.output += nodot;
          prev.output += nodot;
        }
        if (peek() !== "*") {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }
      push(token);
    }
    while (state.brackets > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "]"));
      state.output = utils.escapeLast(state.output, "[");
      decrement("brackets");
    }
    while (state.parens > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", ")"));
      state.output = utils.escapeLast(state.output, "(");
      decrement("parens");
    }
    while (state.braces > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "}"));
      state.output = utils.escapeLast(state.output, "{");
      decrement("braces");
    }
    if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
      push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
    }
    if (state.backtrack === true) {
      state.output = "";
      for (const token of state.tokens) {
        state.output += token.output != null ? token.output : token.value;
        if (token.suffix) {
          state.output += token.suffix;
        }
      }
    }
    return state;
  };
  parse2.fastpaths = (input, options2) => {
    const opts = { ...options2 };
    const max4 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    const len = input.length;
    if (len > max4) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max4}`);
    }
    input = REPLACEMENTS[input] || input;
    const win32 = utils.isWindows(options2);
    const {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? "" : "?:";
    const state = { negated: false, prefix: "" };
    let star = opts.bash === true ? ".*?" : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    const globstar = (opts2) => {
      if (opts2.noglobstar === true)
        return star;
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create8 = (str) => {
      switch (str) {
        case "*":
          return `${nodot}${ONE_CHAR}${star}`;
        case ".*":
          return `${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*.*":
          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*/*":
          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
        case "**":
          return nodot + globstar(opts);
        case "**/*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
        case "**/*.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "**/.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
        default: {
          const match = /^(.*?)\.(\w+)$/.exec(str);
          if (!match)
            return;
          const source2 = create8(match[1]);
          if (!source2)
            return;
          return source2 + DOT_LITERAL + match[2];
        }
      }
    };
    const output = utils.removePrefix(input, state);
    let source = create8(output);
    if (source && opts.strictSlashes !== true) {
      source += `${SLASH_LITERAL}?`;
    }
    return source;
  };
  module2.exports = parse2;
});

// ../../node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS((exports2, module2) => {
  var path2 = __require("path");
  var scan = require_scan();
  var parse2 = require_parse3();
  var utils = require_utils2();
  var constants = require_constants6();
  var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
  var picomatch = (glob, options2, returnState = false) => {
    if (Array.isArray(glob)) {
      const fns = glob.map((input) => picomatch(input, options2, returnState));
      const arrayMatcher = (str) => {
        for (const isMatch of fns) {
          const state2 = isMatch(str);
          if (state2)
            return state2;
        }
        return false;
      };
      return arrayMatcher;
    }
    const isState = isObject(glob) && glob.tokens && glob.input;
    if (glob === "" || typeof glob !== "string" && !isState) {
      throw new TypeError("Expected pattern to be a non-empty string");
    }
    const opts = options2 || {};
    const posix = utils.isWindows(options2);
    const regex = isState ? picomatch.compileRe(glob, options2) : picomatch.makeRe(glob, options2, false, true);
    const state = regex.state;
    delete regex.state;
    let isIgnored = () => false;
    if (opts.ignore) {
      const ignoreOpts = { ...options2, ignore: null, onMatch: null, onResult: null };
      isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false) => {
      const { isMatch, match, output } = picomatch.test(input, regex, options2, { glob, posix });
      const result = { glob, state, regex, posix, input, output, match, isMatch };
      if (typeof opts.onResult === "function") {
        opts.onResult(result);
      }
      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (isIgnored(input)) {
        if (typeof opts.onIgnore === "function") {
          opts.onIgnore(result);
        }
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (typeof opts.onMatch === "function") {
        opts.onMatch(result);
      }
      return returnObject ? result : true;
    };
    if (returnState) {
      matcher.state = state;
    }
    return matcher;
  };
  picomatch.test = (input, regex, options2, { glob, posix } = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected input to be a string");
    }
    if (input === "") {
      return { isMatch: false, output: "" };
    }
    const opts = options2 || {};
    const format = opts.format || (posix ? utils.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format ? format(input) : input;
    if (match === false) {
      output = format ? format(input) : input;
      match = output === glob;
    }
    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch.matchBase(input, regex, options2, posix);
      } else {
        match = regex.exec(output);
      }
    }
    return { isMatch: Boolean(match), match, output };
  };
  picomatch.matchBase = (input, glob, options2, posix = utils.isWindows(options2)) => {
    const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options2);
    return regex.test(path2.basename(input));
  };
  picomatch.isMatch = (str, patterns, options2) => picomatch(patterns, options2)(str);
  picomatch.parse = (pattern, options2) => {
    if (Array.isArray(pattern))
      return pattern.map((p) => picomatch.parse(p, options2));
    return parse2(pattern, { ...options2, fastpaths: false });
  };
  picomatch.scan = (input, options2) => scan(input, options2);
  picomatch.compileRe = (state, options2, returnOutput = false, returnState = false) => {
    if (returnOutput === true) {
      return state.output;
    }
    const opts = options2 || {};
    const prepend = opts.contains ? "" : "^";
    const append = opts.contains ? "" : "$";
    let source = `${prepend}(?:${state.output})${append}`;
    if (state && state.negated === true) {
      source = `^(?!${source}).*\$`;
    }
    const regex = picomatch.toRegex(source, options2);
    if (returnState === true) {
      regex.state = state;
    }
    return regex;
  };
  picomatch.makeRe = (input, options2 = {}, returnOutput = false, returnState = false) => {
    if (!input || typeof input !== "string") {
      throw new TypeError("Expected a non-empty string");
    }
    let parsed = { negated: false, fastpaths: true };
    if (options2.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
      parsed.output = parse2.fastpaths(input, options2);
    }
    if (!parsed.output) {
      parsed = parse2(input, options2);
    }
    return picomatch.compileRe(parsed, options2, returnOutput, returnState);
  };
  picomatch.toRegex = (source, options2) => {
    try {
      const opts = options2 || {};
      return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err) {
      if (options2 && options2.debug === true)
        throw err;
      return /$^/;
    }
  };
  picomatch.constants = constants;
  module2.exports = picomatch;
});

// ../../node_modules/readdirp/index.js
var require_readdirp = __commonJS((exports2, module2) => {
  var fs = __require("fs");
  var { Readable } = __require("stream");
  var sysPath = __require("path");
  var { promisify } = __require("util");
  var picomatch = require_picomatch();
  var readdir = promisify(fs.readdir);
  var stat = promisify(fs.stat);
  var lstat = promisify(fs.lstat);
  var realpath = promisify(fs.realpath);
  var BANG = "!";
  var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
  var NORMAL_FLOW_ERRORS = new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
  var FILE_TYPE = "files";
  var DIR_TYPE = "directories";
  var FILE_DIR_TYPE = "files_directories";
  var EVERYTHING_TYPE = "all";
  var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
  var isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);
  var [maj, min4] = process.versions.node.split(".").slice(0, 2).map((n) => Number.parseInt(n, 10));
  var wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min4 >= 5);
  var normalizeFilter = (filter) => {
    if (filter === undefined)
      return;
    if (typeof filter === "function")
      return filter;
    if (typeof filter === "string") {
      const glob = picomatch(filter.trim());
      return (entry) => glob(entry.basename);
    }
    if (Array.isArray(filter)) {
      const positive = [];
      const negative = [];
      for (const item of filter) {
        const trimmed = item.trim();
        if (trimmed.charAt(0) === BANG) {
          negative.push(picomatch(trimmed.slice(1)));
        } else {
          positive.push(picomatch(trimmed));
        }
      }
      if (negative.length > 0) {
        if (positive.length > 0) {
          return (entry) => positive.some((f) => f(entry.basename)) && !negative.some((f) => f(entry.basename));
        }
        return (entry) => !negative.some((f) => f(entry.basename));
      }
      return (entry) => positive.some((f) => f(entry.basename));
    }
  };

  class ReaddirpStream extends Readable {
    static get defaultOptions() {
      return {
        root: ".",
        fileFilter: (path2) => true,
        directoryFilter: (path2) => true,
        type: FILE_TYPE,
        lstat: false,
        depth: 2147483648,
        alwaysStat: false
      };
    }
    constructor(options2 = {}) {
      super({
        objectMode: true,
        autoDestroy: true,
        highWaterMark: options2.highWaterMark || 4096
      });
      const opts = { ...ReaddirpStream.defaultOptions, ...options2 };
      const { root, type: type2 } = opts;
      this._fileFilter = normalizeFilter(opts.fileFilter);
      this._directoryFilter = normalizeFilter(opts.directoryFilter);
      const statMethod = opts.lstat ? lstat : stat;
      if (wantBigintFsStats) {
        this._stat = (path2) => statMethod(path2, { bigint: true });
      } else {
        this._stat = statMethod;
      }
      this._maxDepth = opts.depth;
      this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type2);
      this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type2);
      this._wantsEverything = type2 === EVERYTHING_TYPE;
      this._root = sysPath.resolve(root);
      this._isDirent = "Dirent" in fs && !opts.alwaysStat;
      this._statsProp = this._isDirent ? "dirent" : "stats";
      this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
      this.parents = [this._exploreDir(root, 1)];
      this.reading = false;
      this.parent = undefined;
    }
    async _read(batch) {
      if (this.reading)
        return;
      this.reading = true;
      try {
        while (!this.destroyed && batch > 0) {
          const { path: path2, depth, files: files2 = [] } = this.parent || {};
          if (files2.length > 0) {
            const slice = files2.splice(0, batch).map((dirent) => this._formatEntry(dirent, path2));
            for (const entry of await Promise.all(slice)) {
              if (this.destroyed)
                return;
              const entryType = await this._getEntryType(entry);
              if (entryType === "directory" && this._directoryFilter(entry)) {
                if (depth <= this._maxDepth) {
                  this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                }
                if (this._wantsDir) {
                  this.push(entry);
                  batch--;
                }
              } else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
                if (this._wantsFile) {
                  this.push(entry);
                  batch--;
                }
              }
            }
          } else {
            const parent = this.parents.pop();
            if (!parent) {
              this.push(null);
              break;
            }
            this.parent = await parent;
            if (this.destroyed)
              return;
          }
        }
      } catch (error) {
        this.destroy(error);
      } finally {
        this.reading = false;
      }
    }
    async _exploreDir(path2, depth) {
      let files2;
      try {
        files2 = await readdir(path2, this._rdOptions);
      } catch (error) {
        this._onError(error);
      }
      return { files: files2, depth, path: path2 };
    }
    async _formatEntry(dirent, path2) {
      let entry;
      try {
        const basename = this._isDirent ? dirent.name : dirent;
        const fullPath = sysPath.resolve(sysPath.join(path2, basename));
        entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };
        entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
      } catch (err) {
        this._onError(err);
      }
      return entry;
    }
    _onError(err) {
      if (isNormalFlowError(err) && !this.destroyed) {
        this.emit("warn", err);
      } else {
        this.destroy(err);
      }
    }
    async _getEntryType(entry) {
      const stats = entry && entry[this._statsProp];
      if (!stats) {
        return;
      }
      if (stats.isFile()) {
        return "file";
      }
      if (stats.isDirectory()) {
        return "directory";
      }
      if (stats && stats.isSymbolicLink()) {
        const full = entry.fullPath;
        try {
          const entryRealPath = await realpath(full);
          const entryRealPathStats = await lstat(entryRealPath);
          if (entryRealPathStats.isFile()) {
            return "file";
          }
          if (entryRealPathStats.isDirectory()) {
            const len = entryRealPath.length;
            if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {
              const recursiveError = new Error(`Circular symlink detected: "${full}" points to "${entryRealPath}"`);
              recursiveError.code = RECURSIVE_ERROR_CODE;
              return this._onError(recursiveError);
            }
            return "directory";
          }
        } catch (error) {
          this._onError(error);
        }
      }
    }
    _includeAsFile(entry) {
      const stats = entry && entry[this._statsProp];
      return stats && this._wantsEverything && !stats.isDirectory();
    }
  }
  var readdirp = (root, options2 = {}) => {
    let type2 = options2.entryType || options2.type;
    if (type2 === "both")
      type2 = FILE_DIR_TYPE;
    if (type2)
      options2.type = type2;
    if (!root) {
      throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
    } else if (typeof root !== "string") {
      throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
    } else if (type2 && !ALL_TYPES.includes(type2)) {
      throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
    }
    options2.root = root;
    return new ReaddirpStream(options2);
  };
  var readdirpPromise = (root, options2 = {}) => {
    return new Promise((resolve, reject) => {
      const files2 = [];
      readdirp(root, options2).on("data", (entry) => files2.push(entry)).on("end", () => resolve(files2)).on("error", (error) => reject(error));
    });
  };
  readdirp.promise = readdirpPromise;
  readdirp.ReaddirpStream = ReaddirpStream;
  readdirp.default = readdirp;
  module2.exports = readdirp;
});

// ../../node_modules/normalize-path/index.js
var require_normalize_path = __commonJS((exports2, module2) => {
  /*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   */
  module2.exports = function(path2, stripTrailing) {
    if (typeof path2 !== "string") {
      throw new TypeError("expected path to be a string");
    }
    if (path2 === "\\" || path2 === "/")
      return "/";
    var len = path2.length;
    if (len <= 1)
      return path2;
    var prefix = "";
    if (len > 4 && path2[3] === "\\") {
      var ch = path2[2];
      if ((ch === "?" || ch === ".") && path2.slice(0, 2) === "\\\\") {
        path2 = path2.slice(2);
        prefix = "//";
      }
    }
    var segs = path2.split(/[/\\]+/);
    if (stripTrailing !== false && segs[segs.length - 1] === "") {
      segs.pop();
    }
    return prefix + segs.join("/");
  };
});

// ../../node_modules/anymatch/index.js
var require_anymatch = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var picomatch = require_picomatch();
  var normalizePath = require_normalize_path();
  var BANG = "!";
  var DEFAULT_OPTIONS = { returnIndex: false };
  var arrify = (item) => Array.isArray(item) ? item : [item];
  var createPattern = (matcher, options2) => {
    if (typeof matcher === "function") {
      return matcher;
    }
    if (typeof matcher === "string") {
      const glob = picomatch(matcher, options2);
      return (string) => matcher === string || glob(string);
    }
    if (matcher instanceof RegExp) {
      return (string) => matcher.test(string);
    }
    return (string) => false;
  };
  var matchPatterns = (patterns, negPatterns, args2, returnIndex) => {
    const isList = Array.isArray(args2);
    const _path = isList ? args2[0] : args2;
    if (!isList && typeof _path !== "string") {
      throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
    }
    const path2 = normalizePath(_path, false);
    for (let index = 0;index < negPatterns.length; index++) {
      const nglob = negPatterns[index];
      if (nglob(path2)) {
        return returnIndex ? -1 : false;
      }
    }
    const applied = isList && [path2].concat(args2.slice(1));
    for (let index = 0;index < patterns.length; index++) {
      const pattern = patterns[index];
      if (isList ? pattern(...applied) : pattern(path2)) {
        return returnIndex ? index : true;
      }
    }
    return returnIndex ? -1 : false;
  };
  var anymatch = (matchers, testString, options2 = DEFAULT_OPTIONS) => {
    if (matchers == null) {
      throw new TypeError("anymatch: specify first argument");
    }
    const opts = typeof options2 === "boolean" ? { returnIndex: options2 } : options2;
    const returnIndex = opts.returnIndex || false;
    const mtchers = arrify(matchers);
    const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
    const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG).map((matcher) => createPattern(matcher, opts));
    if (testString == null) {
      return (testString2, ri = false) => {
        const returnIndex2 = typeof ri === "boolean" ? ri : false;
        return matchPatterns(patterns, negatedGlobs, testString2, returnIndex2);
      };
    }
    return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
  };
  anymatch.default = anymatch;
  module2.exports = anymatch;
});

// ../../node_modules/is-extglob/index.js
var require_is_extglob = __commonJS((exports2, module2) => {
  /*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  module2.exports = function isExtglob(str) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    var match;
    while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
      if (match[2])
        return true;
      str = str.slice(match.index + match[0].length);
    }
    return false;
  };
});

// ../../node_modules/is-glob/index.js
var require_is_glob = __commonJS((exports2, module2) => {
  /*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  var isExtglob = require_is_extglob();
  var chars = { "{": "}", "(": ")", "[": "]" };
  var strictCheck = function(str) {
    if (str[0] === "!") {
      return true;
    }
    var index = 0;
    var pipeIndex = -2;
    var closeSquareIndex = -2;
    var closeCurlyIndex = -2;
    var closeParenIndex = -2;
    var backSlashIndex = -2;
    while (index < str.length) {
      if (str[index] === "*") {
        return true;
      }
      if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
        return true;
      }
      if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
        if (closeSquareIndex < index) {
          closeSquareIndex = str.indexOf("]", index);
        }
        if (closeSquareIndex > index) {
          if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
            return true;
          }
          backSlashIndex = str.indexOf("\\", index);
          if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
            return true;
          }
        }
      }
      if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
        closeCurlyIndex = str.indexOf("}", index);
        if (closeCurlyIndex > index) {
          backSlashIndex = str.indexOf("\\", index);
          if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
            return true;
          }
        }
      }
      if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
        closeParenIndex = str.indexOf(")", index);
        if (closeParenIndex > index) {
          backSlashIndex = str.indexOf("\\", index);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
      if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
        if (pipeIndex < index) {
          pipeIndex = str.indexOf("|", index);
        }
        if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
          closeParenIndex = str.indexOf(")", pipeIndex);
          if (closeParenIndex > pipeIndex) {
            backSlashIndex = str.indexOf("\\", pipeIndex);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
      }
      if (str[index] === "\\") {
        var open = str[index + 1];
        index += 2;
        var close = chars[open];
        if (close) {
          var n = str.indexOf(close, index);
          if (n !== -1) {
            index = n + 1;
          }
        }
        if (str[index] === "!") {
          return true;
        }
      } else {
        index++;
      }
    }
    return false;
  };
  var relaxedCheck = function(str) {
    if (str[0] === "!") {
      return true;
    }
    var index = 0;
    while (index < str.length) {
      if (/[*?{}()[\]]/.test(str[index])) {
        return true;
      }
      if (str[index] === "\\") {
        var open = str[index + 1];
        index += 2;
        var close = chars[open];
        if (close) {
          var n = str.indexOf(close, index);
          if (n !== -1) {
            index = n + 1;
          }
        }
        if (str[index] === "!") {
          return true;
        }
      } else {
        index++;
      }
    }
    return false;
  };
  module2.exports = function isGlob(str, options2) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    if (isExtglob(str)) {
      return true;
    }
    var check = strictCheck;
    if (options2 && options2.strict === false) {
      check = relaxedCheck;
    }
    return check(str);
  };
});

// ../../node_modules/chokidar/node_modules/glob-parent/index.js
var require_glob_parent = __commonJS((exports2, module2) => {
  var isGlob = require_is_glob();
  var pathPosixDirname = __require("path").posix.dirname;
  var isWin32 = __require("os").platform() === "win32";
  var slash = "/";
  var backslash = /\\/g;
  var enclosure = /[\{\[].*[\}\]]$/;
  var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
  var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
  module2.exports = function globParent(str, opts) {
    var options2 = Object.assign({ flipBackslashes: true }, opts);
    if (options2.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
      str = str.replace(backslash, slash);
    }
    if (enclosure.test(str)) {
      str += slash;
    }
    str += "a";
    do {
      str = pathPosixDirname(str);
    } while (isGlob(str) || globby.test(str));
    return str.replace(escaped, "$1");
  };
});

// ../../node_modules/braces/lib/utils.js
var require_utils3 = __commonJS((exports2) => {
  exports2.isInteger = (num) => {
    if (typeof num === "number") {
      return Number.isInteger(num);
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isInteger(Number(num));
    }
    return false;
  };
  exports2.find = (node, type2) => node.nodes.find((node2) => node2.type === type2);
  exports2.exceedsLimit = (min4, max4, step = 1, limit) => {
    if (limit === false)
      return false;
    if (!exports2.isInteger(min4) || !exports2.isInteger(max4))
      return false;
    return (Number(max4) - Number(min4)) / Number(step) >= limit;
  };
  exports2.escapeNode = (block, n = 0, type2) => {
    const node = block.nodes[n];
    if (!node)
      return;
    if (type2 && node.type === type2 || node.type === "open" || node.type === "close") {
      if (node.escaped !== true) {
        node.value = "\\" + node.value;
        node.escaped = true;
      }
    }
  };
  exports2.encloseBrace = (node) => {
    if (node.type !== "brace")
      return false;
    if (node.commas >> 0 + node.ranges >> 0 === 0) {
      node.invalid = true;
      return true;
    }
    return false;
  };
  exports2.isInvalidBrace = (block) => {
    if (block.type !== "brace")
      return false;
    if (block.invalid === true || block.dollar)
      return true;
    if (block.commas >> 0 + block.ranges >> 0 === 0) {
      block.invalid = true;
      return true;
    }
    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }
    return false;
  };
  exports2.isOpenOrClose = (node) => {
    if (node.type === "open" || node.type === "close") {
      return true;
    }
    return node.open === true || node.close === true;
  };
  exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
    if (node.type === "text")
      acc.push(node.value);
    if (node.type === "range")
      node.type = "text";
    return acc;
  }, []);
  exports2.flatten = (...args2) => {
    const result = [];
    const flat = (arr) => {
      for (let i = 0;i < arr.length; i++) {
        const ele = arr[i];
        if (Array.isArray(ele)) {
          flat(ele);
          continue;
        }
        if (ele !== undefined) {
          result.push(ele);
        }
      }
      return result;
    };
    flat(args2);
    return result;
  };
});

// ../../node_modules/braces/lib/stringify.js
var require_stringify2 = __commonJS((exports2, module2) => {
  var utils = require_utils3();
  module2.exports = (ast, options2 = {}) => {
    const stringify2 = (node, parent = {}) => {
      const invalidBlock = options2.escapeInvalid && utils.isInvalidBrace(parent);
      const invalidNode = node.invalid === true && options2.escapeInvalid === true;
      let output = "";
      if (node.value) {
        if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
          return "\\" + node.value;
        }
        return node.value;
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes) {
        for (const child of node.nodes) {
          output += stringify2(child);
        }
      }
      return output;
    };
    return stringify2(ast);
  };
});

// ../../node_modules/is-number/index.js
var require_is_number = __commonJS((exports2, module2) => {
  /*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  module2.exports = function(num) {
    if (typeof num === "number") {
      return num - num === 0;
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }
    return false;
  };
});

// ../../node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS((exports2, module2) => {
  var collatePatterns = function(neg, pos, options2) {
    let onlyNegative = filterPatterns(neg, pos, "-", false, options2) || [];
    let onlyPositive = filterPatterns(pos, neg, "", false, options2) || [];
    let intersected = filterPatterns(neg, pos, "-?", true, options2) || [];
    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join("|");
  };
  var splitToRanges = function(min4, max4) {
    let nines = 1;
    let zeros = 1;
    let stop = countNines(min4, nines);
    let stops = new Set([max4]);
    while (min4 <= stop && stop <= max4) {
      stops.add(stop);
      nines += 1;
      stop = countNines(min4, nines);
    }
    stop = countZeros(max4 + 1, zeros) - 1;
    while (min4 < stop && stop <= max4) {
      stops.add(stop);
      zeros += 1;
      stop = countZeros(max4 + 1, zeros) - 1;
    }
    stops = [...stops];
    stops.sort(compare);
    return stops;
  };
  var rangeToPattern = function(start, stop, options2) {
    if (start === stop) {
      return { pattern: start, count: [], digits: 0 };
    }
    let zipped = zip(start, stop);
    let digits = zipped.length;
    let pattern = "";
    let count = 0;
    for (let i = 0;i < digits; i++) {
      let [startDigit, stopDigit] = zipped[i];
      if (startDigit === stopDigit) {
        pattern += startDigit;
      } else if (startDigit !== "0" || stopDigit !== "9") {
        pattern += toCharacterClass(startDigit, stopDigit, options2);
      } else {
        count++;
      }
    }
    if (count) {
      pattern += options2.shorthand === true ? "\\d" : "[0-9]";
    }
    return { pattern, count: [count], digits };
  };
  var splitToPatterns = function(min4, max4, tok, options2) {
    let ranges = splitToRanges(min4, max4);
    let tokens = [];
    let start = min4;
    let prev;
    for (let i = 0;i < ranges.length; i++) {
      let max5 = ranges[i];
      let obj = rangeToPattern(String(start), String(max5), options2);
      let zeros = "";
      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        if (prev.count.length > 1) {
          prev.count.pop();
        }
        prev.count.push(obj.count[0]);
        prev.string = prev.pattern + toQuantifier(prev.count);
        start = max5 + 1;
        continue;
      }
      if (tok.isPadded) {
        zeros = padZeros(max5, tok, options2);
      }
      obj.string = zeros + obj.pattern + toQuantifier(obj.count);
      tokens.push(obj);
      start = max5 + 1;
      prev = obj;
    }
    return tokens;
  };
  var filterPatterns = function(arr, comparison, prefix, intersection, options2) {
    let result = [];
    for (let ele of arr) {
      let { string } = ele;
      if (!intersection && !contains(comparison, "string", string)) {
        result.push(prefix + string);
      }
      if (intersection && contains(comparison, "string", string)) {
        result.push(prefix + string);
      }
    }
    return result;
  };
  var zip = function(a, b) {
    let arr = [];
    for (let i = 0;i < a.length; i++)
      arr.push([a[i], b[i]]);
    return arr;
  };
  var compare = function(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  };
  var contains = function(arr, key, val) {
    return arr.some((ele) => ele[key] === val);
  };
  var countNines = function(min4, len) {
    return Number(String(min4).slice(0, -len) + "9".repeat(len));
  };
  var countZeros = function(integer, zeros) {
    return integer - integer % Math.pow(10, zeros);
  };
  var toQuantifier = function(digits) {
    let [start = 0, stop = ""] = digits;
    if (stop || start > 1) {
      return `{${start + (stop ? "," + stop : "")}}`;
    }
    return "";
  };
  var toCharacterClass = function(a, b, options2) {
    return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
  };
  var hasPadding = function(str) {
    return /^-?(0+)\d/.test(str);
  };
  var padZeros = function(value, tok, options2) {
    if (!tok.isPadded) {
      return value;
    }
    let diff = Math.abs(tok.maxLen - String(value).length);
    let relax = options2.relaxZeros !== false;
    switch (diff) {
      case 0:
        return "";
      case 1:
        return relax ? "0?" : "0";
      case 2:
        return relax ? "0{0,2}" : "00";
      default: {
        return relax ? `0{0,${diff}}` : `0{${diff}}`;
      }
    }
  };
  /*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  var isNumber = require_is_number();
  var toRegexRange = (min4, max4, options2) => {
    if (isNumber(min4) === false) {
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    }
    if (max4 === undefined || min4 === max4) {
      return String(min4);
    }
    if (isNumber(max4) === false) {
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    }
    let opts = { relaxZeros: true, ...options2 };
    if (typeof opts.strictZeros === "boolean") {
      opts.relaxZeros = opts.strictZeros === false;
    }
    let relax = String(opts.relaxZeros);
    let shorthand = String(opts.shorthand);
    let capture = String(opts.capture);
    let wrap = String(opts.wrap);
    let cacheKey = min4 + ":" + max4 + "=" + relax + shorthand + capture + wrap;
    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
      return toRegexRange.cache[cacheKey].result;
    }
    let a = Math.min(min4, max4);
    let b = Math.max(min4, max4);
    if (Math.abs(a - b) === 1) {
      let result = min4 + "|" + max4;
      if (opts.capture) {
        return `(${result})`;
      }
      if (opts.wrap === false) {
        return result;
      }
      return `(?:${result})`;
    }
    let isPadded = hasPadding(min4) || hasPadding(max4);
    let state = { min: min4, max: max4, a, b };
    let positives = [];
    let negatives = [];
    if (isPadded) {
      state.isPadded = isPadded;
      state.maxLen = String(state.max).length;
    }
    if (a < 0) {
      let newMin = b < 0 ? Math.abs(b) : 1;
      negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
      a = state.a = 0;
    }
    if (b >= 0) {
      positives = splitToPatterns(a, b, state, opts);
    }
    state.negatives = negatives;
    state.positives = positives;
    state.result = collatePatterns(negatives, positives, opts);
    if (opts.capture === true) {
      state.result = `(${state.result})`;
    } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
      state.result = `(?:${state.result})`;
    }
    toRegexRange.cache[cacheKey] = state;
    return state.result;
  };
  toRegexRange.cache = {};
  toRegexRange.clearCache = () => toRegexRange.cache = {};
  module2.exports = toRegexRange;
});

// ../../node_modules/fill-range/index.js
var require_fill_range = __commonJS((exports2, module2) => {
  /*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  var util = __require("util");
  var toRegexRange = require_to_regex_range();
  var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  var transform = (toNumber) => {
    return (value) => toNumber === true ? Number(value) : String(value);
  };
  var isValidValue = (value) => {
    return typeof value === "number" || typeof value === "string" && value !== "";
  };
  var isNumber = (num) => Number.isInteger(+num);
  var zeros = (input) => {
    let value = `${input}`;
    let index = -1;
    if (value[0] === "-")
      value = value.slice(1);
    if (value === "0")
      return false;
    while (value[++index] === "0")
      ;
    return index > 0;
  };
  var stringify2 = (start, end, options2) => {
    if (typeof start === "string" || typeof end === "string") {
      return true;
    }
    return options2.stringify === true;
  };
  var pad = (input, maxLength, toNumber) => {
    if (maxLength > 0) {
      let dash = input[0] === "-" ? "-" : "";
      if (dash)
        input = input.slice(1);
      input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
    }
    if (toNumber === false) {
      return String(input);
    }
    return input;
  };
  var toMaxLen = (input, maxLength) => {
    let negative = input[0] === "-" ? "-" : "";
    if (negative) {
      input = input.slice(1);
      maxLength--;
    }
    while (input.length < maxLength)
      input = "0" + input;
    return negative ? "-" + input : input;
  };
  var toSequence = (parts, options2, maxLen) => {
    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    let prefix = options2.capture ? "" : "?:";
    let positives = "";
    let negatives = "";
    let result;
    if (parts.positives.length) {
      positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|");
    }
    if (parts.negatives.length) {
      negatives = `-(${prefix}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`;
    }
    if (positives && negatives) {
      result = `${positives}|${negatives}`;
    } else {
      result = positives || negatives;
    }
    if (options2.wrap) {
      return `(${prefix}${result})`;
    }
    return result;
  };
  var toRange = (a, b, isNumbers, options2) => {
    if (isNumbers) {
      return toRegexRange(a, b, { wrap: false, ...options2 });
    }
    let start = String.fromCharCode(a);
    if (a === b)
      return start;
    let stop = String.fromCharCode(b);
    return `[${start}-${stop}]`;
  };
  var toRegex = (start, end, options2) => {
    if (Array.isArray(start)) {
      let wrap = options2.wrap === true;
      let prefix = options2.capture ? "" : "?:";
      return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
    }
    return toRegexRange(start, end, options2);
  };
  var rangeError = (...args2) => {
    return new RangeError("Invalid range arguments: " + util.inspect(...args2));
  };
  var invalidRange = (start, end, options2) => {
    if (options2.strictRanges === true)
      throw rangeError([start, end]);
    return [];
  };
  var invalidStep = (step, options2) => {
    if (options2.strictRanges === true) {
      throw new TypeError(`Expected step "${step}" to be a number`);
    }
    return [];
  };
  var fillNumbers = (start, end, step = 1, options2 = {}) => {
    let a = Number(start);
    let b = Number(end);
    if (!Number.isInteger(a) || !Number.isInteger(b)) {
      if (options2.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    }
    if (a === 0)
      a = 0;
    if (b === 0)
      b = 0;
    let descending = a > b;
    let startString = String(start);
    let endString = String(end);
    let stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    let padded = zeros(startString) || zeros(endString) || zeros(stepString);
    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    let toNumber = padded === false && stringify2(start, end, options2) === false;
    let format = options2.transform || transform(toNumber);
    if (options2.toRegex && step === 1) {
      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options2);
    }
    let parts = { negatives: [], positives: [] };
    let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
    let range = [];
    let index = 0;
    while (descending ? a >= b : a <= b) {
      if (options2.toRegex === true && step > 1) {
        push(a);
      } else {
        range.push(pad(format(a, index), maxLen, toNumber));
      }
      a = descending ? a - step : a + step;
      index++;
    }
    if (options2.toRegex === true) {
      return step > 1 ? toSequence(parts, options2, maxLen) : toRegex(range, null, { wrap: false, ...options2 });
    }
    return range;
  };
  var fillLetters = (start, end, step = 1, options2 = {}) => {
    if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
      return invalidRange(start, end, options2);
    }
    let format = options2.transform || ((val) => String.fromCharCode(val));
    let a = `${start}`.charCodeAt(0);
    let b = `${end}`.charCodeAt(0);
    let descending = a > b;
    let min4 = Math.min(a, b);
    let max4 = Math.max(a, b);
    if (options2.toRegex && step === 1) {
      return toRange(min4, max4, false, options2);
    }
    let range = [];
    let index = 0;
    while (descending ? a >= b : a <= b) {
      range.push(format(a, index));
      a = descending ? a - step : a + step;
      index++;
    }
    if (options2.toRegex === true) {
      return toRegex(range, null, { wrap: false, options: options2 });
    }
    return range;
  };
  var fill = (start, end, step, options2 = {}) => {
    if (end == null && isValidValue(start)) {
      return [start];
    }
    if (!isValidValue(start) || !isValidValue(end)) {
      return invalidRange(start, end, options2);
    }
    if (typeof step === "function") {
      return fill(start, end, 1, { transform: step });
    }
    if (isObject(step)) {
      return fill(start, end, 0, step);
    }
    let opts = { ...options2 };
    if (opts.capture === true)
      opts.wrap = true;
    step = step || opts.step || 1;
    if (!isNumber(step)) {
      if (step != null && !isObject(step))
        return invalidStep(step, opts);
      return fill(start, end, 1, step);
    }
    if (isNumber(start) && isNumber(end)) {
      return fillNumbers(start, end, step, opts);
    }
    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
  };
  module2.exports = fill;
});

// ../../node_modules/braces/lib/compile.js
var require_compile = __commonJS((exports2, module2) => {
  var fill = require_fill_range();
  var utils = require_utils3();
  var compile = (ast, options2 = {}) => {
    const walk = (node, parent = {}) => {
      const invalidBlock = utils.isInvalidBrace(parent);
      const invalidNode = node.invalid === true && options2.escapeInvalid === true;
      const invalid = invalidBlock === true || invalidNode === true;
      const prefix = options2.escapeInvalid === true ? "\\" : "";
      let output = "";
      if (node.isOpen === true) {
        return prefix + node.value;
      }
      if (node.isClose === true) {
        console.log("node.isClose", prefix, node.value);
        return prefix + node.value;
      }
      if (node.type === "open") {
        return invalid ? prefix + node.value : "(";
      }
      if (node.type === "close") {
        return invalid ? prefix + node.value : ")";
      }
      if (node.type === "comma") {
        return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes && node.ranges > 0) {
        const args2 = utils.reduce(node.nodes);
        const range = fill(...args2, { ...options2, wrap: false, toRegex: true, strictZeros: true });
        if (range.length !== 0) {
          return args2.length > 1 && range.length > 1 ? `(${range})` : range;
        }
      }
      if (node.nodes) {
        for (const child of node.nodes) {
          output += walk(child, node);
        }
      }
      return output;
    };
    return walk(ast);
  };
  module2.exports = compile;
});

// ../../node_modules/braces/lib/expand.js
var require_expand = __commonJS((exports2, module2) => {
  var fill = require_fill_range();
  var stringify2 = require_stringify2();
  var utils = require_utils3();
  var append = (queue = "", stash = "", enclose = false) => {
    const result = [];
    queue = [].concat(queue);
    stash = [].concat(stash);
    if (!stash.length)
      return queue;
    if (!queue.length) {
      return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
    }
    for (const item of queue) {
      if (Array.isArray(item)) {
        for (const value of item) {
          result.push(append(value, stash, enclose));
        }
      } else {
        for (let ele of stash) {
          if (enclose === true && typeof ele === "string")
            ele = `{${ele}}`;
          result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
        }
      }
    }
    return utils.flatten(result);
  };
  var expand = (ast, options2 = {}) => {
    const rangeLimit = options2.rangeLimit === undefined ? 1000 : options2.rangeLimit;
    const walk = (node, parent = {}) => {
      node.queue = [];
      let p = parent;
      let q = parent.queue;
      while (p.type !== "brace" && p.type !== "root" && p.parent) {
        p = p.parent;
        q = p.queue;
      }
      if (node.invalid || node.dollar) {
        q.push(append(q.pop(), stringify2(node, options2)));
        return;
      }
      if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
        q.push(append(q.pop(), ["{}"]));
        return;
      }
      if (node.nodes && node.ranges > 0) {
        const args2 = utils.reduce(node.nodes);
        if (utils.exceedsLimit(...args2, options2.step, rangeLimit)) {
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        }
        let range = fill(...args2, options2);
        if (range.length === 0) {
          range = stringify2(node, options2);
        }
        q.push(append(q.pop(), range));
        node.nodes = [];
        return;
      }
      const enclose = utils.encloseBrace(node);
      let queue = node.queue;
      let block = node;
      while (block.type !== "brace" && block.type !== "root" && block.parent) {
        block = block.parent;
        queue = block.queue;
      }
      for (let i = 0;i < node.nodes.length; i++) {
        const child = node.nodes[i];
        if (child.type === "comma" && node.type === "brace") {
          if (i === 1)
            queue.push("");
          queue.push("");
          continue;
        }
        if (child.type === "close") {
          q.push(append(q.pop(), queue, enclose));
          continue;
        }
        if (child.value && child.type !== "open") {
          queue.push(append(queue.pop(), child.value));
          continue;
        }
        if (child.nodes) {
          walk(child, node);
        }
      }
      return queue;
    };
    return utils.flatten(walk(ast));
  };
  module2.exports = expand;
});

// ../../node_modules/braces/lib/constants.js
var require_constants7 = __commonJS((exports2, module2) => {
  module2.exports = {
    MAX_LENGTH: 1e4,
    CHAR_0: "0",
    CHAR_9: "9",
    CHAR_UPPERCASE_A: "A",
    CHAR_LOWERCASE_A: "a",
    CHAR_UPPERCASE_Z: "Z",
    CHAR_LOWERCASE_Z: "z",
    CHAR_LEFT_PARENTHESES: "(",
    CHAR_RIGHT_PARENTHESES: ")",
    CHAR_ASTERISK: "*",
    CHAR_AMPERSAND: "&",
    CHAR_AT: "@",
    CHAR_BACKSLASH: "\\",
    CHAR_BACKTICK: "`",
    CHAR_CARRIAGE_RETURN: "\r",
    CHAR_CIRCUMFLEX_ACCENT: "^",
    CHAR_COLON: ":",
    CHAR_COMMA: ",",
    CHAR_DOLLAR: "$",
    CHAR_DOT: ".",
    CHAR_DOUBLE_QUOTE: '"',
    CHAR_EQUAL: "=",
    CHAR_EXCLAMATION_MARK: "!",
    CHAR_FORM_FEED: "\f",
    CHAR_FORWARD_SLASH: "/",
    CHAR_HASH: "#",
    CHAR_HYPHEN_MINUS: "-",
    CHAR_LEFT_ANGLE_BRACKET: "<",
    CHAR_LEFT_CURLY_BRACE: "{",
    CHAR_LEFT_SQUARE_BRACKET: "[",
    CHAR_LINE_FEED: "\n",
    CHAR_NO_BREAK_SPACE: "\xA0",
    CHAR_PERCENT: "%",
    CHAR_PLUS: "+",
    CHAR_QUESTION_MARK: "?",
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    CHAR_RIGHT_CURLY_BRACE: "}",
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    CHAR_SEMICOLON: ";",
    CHAR_SINGLE_QUOTE: "\'",
    CHAR_SPACE: " ",
    CHAR_TAB: "\t",
    CHAR_UNDERSCORE: "_",
    CHAR_VERTICAL_LINE: "|",
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
  };
});

// ../../node_modules/braces/lib/parse.js
var require_parse4 = __commonJS((exports2, module2) => {
  var stringify2 = require_stringify2();
  var {
    MAX_LENGTH,
    CHAR_BACKSLASH,
    CHAR_BACKTICK,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_LEFT_PARENTHESES,
    CHAR_RIGHT_PARENTHESES,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_RIGHT_SQUARE_BRACKET,
    CHAR_DOUBLE_QUOTE,
    CHAR_SINGLE_QUOTE,
    CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE
  } = require_constants7();
  var parse2 = (input, options2 = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    const opts = options2 || {};
    const max4 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    if (input.length > max4) {
      throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max4})`);
    }
    const ast = { type: "root", input, nodes: [] };
    const stack = [ast];
    let block = ast;
    let prev = ast;
    let brackets = 0;
    const length3 = input.length;
    let index = 0;
    let depth = 0;
    let value;
    const advance = () => input[index++];
    const push = (node) => {
      if (node.type === "text" && prev.type === "dot") {
        prev.type = "text";
      }
      if (prev && prev.type === "text" && node.type === "text") {
        prev.value += node.value;
        return;
      }
      block.nodes.push(node);
      node.parent = block;
      node.prev = prev;
      prev = node;
      return node;
    };
    push({ type: "bos" });
    while (index < length3) {
      block = stack[stack.length - 1];
      value = advance();
      if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
        continue;
      }
      if (value === CHAR_BACKSLASH) {
        push({ type: "text", value: (options2.keepEscaping ? value : "") + advance() });
        continue;
      }
      if (value === CHAR_RIGHT_SQUARE_BRACKET) {
        push({ type: "text", value: "\\" + value });
        continue;
      }
      if (value === CHAR_LEFT_SQUARE_BRACKET) {
        brackets++;
        let next;
        while (index < length3 && (next = advance())) {
          value += next;
          if (next === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            continue;
          }
          if (next === CHAR_BACKSLASH) {
            value += advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            brackets--;
            if (brackets === 0) {
              break;
            }
          }
        }
        push({ type: "text", value });
        continue;
      }
      if (value === CHAR_LEFT_PARENTHESES) {
        block = push({ type: "paren", nodes: [] });
        stack.push(block);
        push({ type: "text", value });
        continue;
      }
      if (value === CHAR_RIGHT_PARENTHESES) {
        if (block.type !== "paren") {
          push({ type: "text", value });
          continue;
        }
        block = stack.pop();
        push({ type: "text", value });
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
        const open = value;
        let next;
        if (options2.keepQuotes !== true) {
          value = "";
        }
        while (index < length3 && (next = advance())) {
          if (next === CHAR_BACKSLASH) {
            value += next + advance();
            continue;
          }
          if (next === open) {
            if (options2.keepQuotes === true)
              value += next;
            break;
          }
          value += next;
        }
        push({ type: "text", value });
        continue;
      }
      if (value === CHAR_LEFT_CURLY_BRACE) {
        depth++;
        const dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
        const brace = {
          type: "brace",
          open: true,
          close: false,
          dollar,
          depth,
          commas: 0,
          ranges: 0,
          nodes: []
        };
        block = push(brace);
        stack.push(block);
        push({ type: "open", value });
        continue;
      }
      if (value === CHAR_RIGHT_CURLY_BRACE) {
        if (block.type !== "brace") {
          push({ type: "text", value });
          continue;
        }
        const type2 = "close";
        block = stack.pop();
        block.close = true;
        push({ type: type2, value });
        depth--;
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_COMMA && depth > 0) {
        if (block.ranges > 0) {
          block.ranges = 0;
          const open = block.nodes.shift();
          block.nodes = [open, { type: "text", value: stringify2(block) }];
        }
        push({ type: "comma", value });
        block.commas++;
        continue;
      }
      if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
        const siblings = block.nodes;
        if (depth === 0 || siblings.length === 0) {
          push({ type: "text", value });
          continue;
        }
        if (prev.type === "dot") {
          block.range = [];
          prev.value += value;
          prev.type = "range";
          if (block.nodes.length !== 3 && block.nodes.length !== 5) {
            block.invalid = true;
            block.ranges = 0;
            prev.type = "text";
            continue;
          }
          block.ranges++;
          block.args = [];
          continue;
        }
        if (prev.type === "range") {
          siblings.pop();
          const before = siblings[siblings.length - 1];
          before.value += prev.value + value;
          prev = before;
          block.ranges--;
          continue;
        }
        push({ type: "dot", value });
        continue;
      }
      push({ type: "text", value });
    }
    do {
      block = stack.pop();
      if (block.type !== "root") {
        block.nodes.forEach((node) => {
          if (!node.nodes) {
            if (node.type === "open")
              node.isOpen = true;
            if (node.type === "close")
              node.isClose = true;
            if (!node.nodes)
              node.type = "text";
            node.invalid = true;
          }
        });
        const parent = stack[stack.length - 1];
        const index2 = parent.nodes.indexOf(block);
        parent.nodes.splice(index2, 1, ...block.nodes);
      }
    } while (stack.length > 0);
    push({ type: "eos" });
    return ast;
  };
  module2.exports = parse2;
});

// ../../node_modules/braces/index.js
var require_braces = __commonJS((exports2, module2) => {
  var stringify2 = require_stringify2();
  var compile = require_compile();
  var expand = require_expand();
  var parse2 = require_parse4();
  var braces = (input, options2 = {}) => {
    let output = [];
    if (Array.isArray(input)) {
      for (const pattern of input) {
        const result = braces.create(pattern, options2);
        if (Array.isArray(result)) {
          output.push(...result);
        } else {
          output.push(result);
        }
      }
    } else {
      output = [].concat(braces.create(input, options2));
    }
    if (options2 && options2.expand === true && options2.nodupes === true) {
      output = [...new Set(output)];
    }
    return output;
  };
  braces.parse = (input, options2 = {}) => parse2(input, options2);
  braces.stringify = (input, options2 = {}) => {
    if (typeof input === "string") {
      return stringify2(braces.parse(input, options2), options2);
    }
    return stringify2(input, options2);
  };
  braces.compile = (input, options2 = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options2);
    }
    return compile(input, options2);
  };
  braces.expand = (input, options2 = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options2);
    }
    let result = expand(input, options2);
    if (options2.noempty === true) {
      result = result.filter(Boolean);
    }
    if (options2.nodupes === true) {
      result = [...new Set(result)];
    }
    return result;
  };
  braces.create = (input, options2 = {}) => {
    if (input === "" || input.length < 3) {
      return [input];
    }
    return options2.expand !== true ? braces.compile(input, options2) : braces.expand(input, options2);
  };
  module2.exports = braces;
});

// ../../node_modules/binary-extensions/binary-extensions.json
var require_binary_extensions = __commonJS((exports2, module2) => {
  module2.exports = [
    "3dm",
    "3ds",
    "3g2",
    "3gp",
    "7z",
    "a",
    "aac",
    "adp",
    "afdesign",
    "afphoto",
    "afpub",
    "ai",
    "aif",
    "aiff",
    "alz",
    "ape",
    "apk",
    "appimage",
    "ar",
    "arj",
    "asf",
    "au",
    "avi",
    "bak",
    "baml",
    "bh",
    "bin",
    "bk",
    "bmp",
    "btif",
    "bz2",
    "bzip2",
    "cab",
    "caf",
    "cgm",
    "class",
    "cmx",
    "cpio",
    "cr2",
    "cur",
    "dat",
    "dcm",
    "deb",
    "dex",
    "djvu",
    "dll",
    "dmg",
    "dng",
    "doc",
    "docm",
    "docx",
    "dot",
    "dotm",
    "dra",
    "DS_Store",
    "dsk",
    "dts",
    "dtshd",
    "dvb",
    "dwg",
    "dxf",
    "ecelp4800",
    "ecelp7470",
    "ecelp9600",
    "egg",
    "eol",
    "eot",
    "epub",
    "exe",
    "f4v",
    "fbs",
    "fh",
    "fla",
    "flac",
    "flatpak",
    "fli",
    "flv",
    "fpx",
    "fst",
    "fvt",
    "g3",
    "gh",
    "gif",
    "graffle",
    "gz",
    "gzip",
    "h261",
    "h263",
    "h264",
    "icns",
    "ico",
    "ief",
    "img",
    "ipa",
    "iso",
    "jar",
    "jpeg",
    "jpg",
    "jpgv",
    "jpm",
    "jxr",
    "key",
    "ktx",
    "lha",
    "lib",
    "lvp",
    "lz",
    "lzh",
    "lzma",
    "lzo",
    "m3u",
    "m4a",
    "m4v",
    "mar",
    "mdi",
    "mht",
    "mid",
    "midi",
    "mj2",
    "mka",
    "mkv",
    "mmr",
    "mng",
    "mobi",
    "mov",
    "movie",
    "mp3",
    "mp4",
    "mp4a",
    "mpeg",
    "mpg",
    "mpga",
    "mxu",
    "nef",
    "npx",
    "numbers",
    "nupkg",
    "o",
    "odp",
    "ods",
    "odt",
    "oga",
    "ogg",
    "ogv",
    "otf",
    "ott",
    "pages",
    "pbm",
    "pcx",
    "pdb",
    "pdf",
    "pea",
    "pgm",
    "pic",
    "png",
    "pnm",
    "pot",
    "potm",
    "potx",
    "ppa",
    "ppam",
    "ppm",
    "pps",
    "ppsm",
    "ppsx",
    "ppt",
    "pptm",
    "pptx",
    "psd",
    "pya",
    "pyc",
    "pyo",
    "pyv",
    "qt",
    "rar",
    "ras",
    "raw",
    "resources",
    "rgb",
    "rip",
    "rlc",
    "rmf",
    "rmvb",
    "rpm",
    "rtf",
    "rz",
    "s3m",
    "s7z",
    "scpt",
    "sgi",
    "shar",
    "snap",
    "sil",
    "sketch",
    "slk",
    "smv",
    "snk",
    "so",
    "stl",
    "suo",
    "sub",
    "swf",
    "tar",
    "tbz",
    "tbz2",
    "tga",
    "tgz",
    "thmx",
    "tif",
    "tiff",
    "tlz",
    "ttc",
    "ttf",
    "txz",
    "udf",
    "uvh",
    "uvi",
    "uvm",
    "uvp",
    "uvs",
    "uvu",
    "viv",
    "vob",
    "war",
    "wav",
    "wax",
    "wbmp",
    "wdp",
    "weba",
    "webm",
    "webp",
    "whl",
    "wim",
    "wm",
    "wma",
    "wmv",
    "wmx",
    "woff",
    "woff2",
    "wrm",
    "wvx",
    "xbm",
    "xif",
    "xla",
    "xlam",
    "xls",
    "xlsb",
    "xlsm",
    "xlsx",
    "xlt",
    "xltm",
    "xltx",
    "xm",
    "xmind",
    "xpi",
    "xpm",
    "xwd",
    "xz",
    "z",
    "zip",
    "zipx"
  ];
});

// ../../node_modules/is-binary-path/index.js
var require_is_binary_path = __commonJS((exports2, module2) => {
  var path2 = __require("path");
  var binaryExtensions = require_binary_extensions();
  var extensions = new Set(binaryExtensions);
  module2.exports = (filePath) => extensions.has(path2.extname(filePath).slice(1).toLowerCase());
});

// ../../node_modules/chokidar/lib/constants.js
var require_constants8 = __commonJS((exports2) => {
  var { sep } = __require("path");
  var { platform } = process;
  var os = __require("os");
  exports2.EV_ALL = "all";
  exports2.EV_READY = "ready";
  exports2.EV_ADD = "add";
  exports2.EV_CHANGE = "change";
  exports2.EV_ADD_DIR = "addDir";
  exports2.EV_UNLINK = "unlink";
  exports2.EV_UNLINK_DIR = "unlinkDir";
  exports2.EV_RAW = "raw";
  exports2.EV_ERROR = "error";
  exports2.STR_DATA = "data";
  exports2.STR_END = "end";
  exports2.STR_CLOSE = "close";
  exports2.FSEVENT_CREATED = "created";
  exports2.FSEVENT_MODIFIED = "modified";
  exports2.FSEVENT_DELETED = "deleted";
  exports2.FSEVENT_MOVED = "moved";
  exports2.FSEVENT_CLONED = "cloned";
  exports2.FSEVENT_UNKNOWN = "unknown";
  exports2.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;
  exports2.FSEVENT_TYPE_FILE = "file";
  exports2.FSEVENT_TYPE_DIRECTORY = "directory";
  exports2.FSEVENT_TYPE_SYMLINK = "symlink";
  exports2.KEY_LISTENERS = "listeners";
  exports2.KEY_ERR = "errHandlers";
  exports2.KEY_RAW = "rawEmitters";
  exports2.HANDLER_KEYS = [exports2.KEY_LISTENERS, exports2.KEY_ERR, exports2.KEY_RAW];
  exports2.DOT_SLASH = `.${sep}`;
  exports2.BACK_SLASH_RE = /\\/g;
  exports2.DOUBLE_SLASH_RE = /\/\//;
  exports2.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
  exports2.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
  exports2.REPLACER_RE = /^\.[/\\]/;
  exports2.SLASH = "/";
  exports2.SLASH_SLASH = "//";
  exports2.BRACE_START = "{";
  exports2.BANG = "!";
  exports2.ONE_DOT = ".";
  exports2.TWO_DOTS = "..";
  exports2.STAR = "*";
  exports2.GLOBSTAR = "**";
  exports2.ROOT_GLOBSTAR = "/**/*";
  exports2.SLASH_GLOBSTAR = "/**";
  exports2.DIR_SUFFIX = "Dir";
  exports2.ANYMATCH_OPTS = { dot: true };
  exports2.STRING_TYPE = "string";
  exports2.FUNCTION_TYPE = "function";
  exports2.EMPTY_STR = "";
  exports2.EMPTY_FN = () => {
  };
  exports2.IDENTITY_FN = (val) => val;
  exports2.isWindows = platform === "win32";
  exports2.isMacos = platform === "darwin";
  exports2.isLinux = platform === "linux";
  exports2.isIBMi = os.type() === "OS400";
});

// ../../node_modules/chokidar/lib/nodefs-handler.js
var require_nodefs_handler = __commonJS((exports2, module2) => {
  var createFsWatchInstance = function(path2, options2, listener, errHandler, emitRaw) {
    const handleEvent = (rawEvent, evPath) => {
      listener(path2);
      emitRaw(rawEvent, evPath, { watchedPath: path2 });
      if (evPath && path2 !== evPath) {
        fsWatchBroadcast(sysPath.resolve(path2, evPath), KEY_LISTENERS, sysPath.join(path2, evPath));
      }
    };
    try {
      return fs.watch(path2, options2, handleEvent);
    } catch (error) {
      errHandler(error);
    }
  };
  var fs = __require("fs");
  var sysPath = __require("path");
  var { promisify } = __require("util");
  var isBinaryPath = require_is_binary_path();
  var {
    isWindows,
    isLinux,
    EMPTY_FN,
    EMPTY_STR,
    KEY_LISTENERS,
    KEY_ERR,
    KEY_RAW,
    HANDLER_KEYS,
    EV_CHANGE,
    EV_ADD,
    EV_ADD_DIR,
    EV_ERROR,
    STR_DATA,
    STR_END,
    BRACE_START,
    STAR
  } = require_constants8();
  var THROTTLE_MODE_WATCH = "watch";
  var open = promisify(fs.open);
  var stat = promisify(fs.stat);
  var lstat = promisify(fs.lstat);
  var close = promisify(fs.close);
  var fsrealpath = promisify(fs.realpath);
  var statMethods = { lstat, stat };
  var foreach = (val, fn) => {
    if (val instanceof Set) {
      val.forEach(fn);
    } else {
      fn(val);
    }
  };
  var addAndConvert = (main2, prop, item) => {
    let container = main2[prop];
    if (!(container instanceof Set)) {
      main2[prop] = container = new Set([container]);
    }
    container.add(item);
  };
  var clearItem = (cont) => (key) => {
    const set = cont[key];
    if (set instanceof Set) {
      set.clear();
    } else {
      delete cont[key];
    }
  };
  var delFromSet = (main2, prop, item) => {
    const container = main2[prop];
    if (container instanceof Set) {
      container.delete(item);
    } else if (container === item) {
      delete main2[prop];
    }
  };
  var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
  var FsWatchInstances = new Map;
  var fsWatchBroadcast = (fullPath, type2, val1, val2, val3) => {
    const cont = FsWatchInstances.get(fullPath);
    if (!cont)
      return;
    foreach(cont[type2], (listener) => {
      listener(val1, val2, val3);
    });
  };
  var setFsWatchListener = (path2, fullPath, options2, handlers) => {
    const { listener, errHandler, rawEmitter } = handlers;
    let cont = FsWatchInstances.get(fullPath);
    let watcher;
    if (!options2.persistent) {
      watcher = createFsWatchInstance(path2, options2, listener, errHandler, rawEmitter);
      return watcher.close.bind(watcher);
    }
    if (cont) {
      addAndConvert(cont, KEY_LISTENERS, listener);
      addAndConvert(cont, KEY_ERR, errHandler);
      addAndConvert(cont, KEY_RAW, rawEmitter);
    } else {
      watcher = createFsWatchInstance(path2, options2, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
      if (!watcher)
        return;
      watcher.on(EV_ERROR, async (error) => {
        const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
        cont.watcherUnusable = true;
        if (isWindows && error.code === "EPERM") {
          try {
            const fd = await open(path2, "r");
            await close(fd);
            broadcastErr(error);
          } catch (err) {
          }
        } else {
          broadcastErr(error);
        }
      });
      cont = {
        listeners: listener,
        errHandlers: errHandler,
        rawEmitters: rawEmitter,
        watcher
      };
      FsWatchInstances.set(fullPath, cont);
    }
    return () => {
      delFromSet(cont, KEY_LISTENERS, listener);
      delFromSet(cont, KEY_ERR, errHandler);
      delFromSet(cont, KEY_RAW, rawEmitter);
      if (isEmptySet(cont.listeners)) {
        cont.watcher.close();
        FsWatchInstances.delete(fullPath);
        HANDLER_KEYS.forEach(clearItem(cont));
        cont.watcher = undefined;
        Object.freeze(cont);
      }
    };
  };
  var FsWatchFileInstances = new Map;
  var setFsWatchFileListener = (path2, fullPath, options2, handlers) => {
    const { listener, rawEmitter } = handlers;
    let cont = FsWatchFileInstances.get(fullPath);
    let listeners = new Set;
    let rawEmitters = new Set;
    const copts = cont && cont.options;
    if (copts && (copts.persistent < options2.persistent || copts.interval > options2.interval)) {
      listeners = cont.listeners;
      rawEmitters = cont.rawEmitters;
      fs.unwatchFile(fullPath);
      cont = undefined;
    }
    if (cont) {
      addAndConvert(cont, KEY_LISTENERS, listener);
      addAndConvert(cont, KEY_RAW, rawEmitter);
    } else {
      cont = {
        listeners: listener,
        rawEmitters: rawEmitter,
        options: options2,
        watcher: fs.watchFile(fullPath, options2, (curr, prev) => {
          foreach(cont.rawEmitters, (rawEmitter2) => {
            rawEmitter2(EV_CHANGE, fullPath, { curr, prev });
          });
          const currmtime = curr.mtimeMs;
          if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
            foreach(cont.listeners, (listener2) => listener2(path2, curr));
          }
        })
      };
      FsWatchFileInstances.set(fullPath, cont);
    }
    return () => {
      delFromSet(cont, KEY_LISTENERS, listener);
      delFromSet(cont, KEY_RAW, rawEmitter);
      if (isEmptySet(cont.listeners)) {
        FsWatchFileInstances.delete(fullPath);
        fs.unwatchFile(fullPath);
        cont.options = cont.watcher = undefined;
        Object.freeze(cont);
      }
    };
  };

  class NodeFsHandler {
    constructor(fsW) {
      this.fsw = fsW;
      this._boundHandleError = (error) => fsW._handleError(error);
    }
    _watchWithNodeFs(path2, listener) {
      const opts = this.fsw.options;
      const directory = sysPath.dirname(path2);
      const basename = sysPath.basename(path2);
      const parent = this.fsw._getWatchedDir(directory);
      parent.add(basename);
      const absolutePath = sysPath.resolve(path2);
      const options2 = { persistent: opts.persistent };
      if (!listener)
        listener = EMPTY_FN;
      let closer;
      if (opts.usePolling) {
        options2.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
        closer = setFsWatchFileListener(path2, absolutePath, options2, {
          listener,
          rawEmitter: this.fsw._emitRaw
        });
      } else {
        closer = setFsWatchListener(path2, absolutePath, options2, {
          listener,
          errHandler: this._boundHandleError,
          rawEmitter: this.fsw._emitRaw
        });
      }
      return closer;
    }
    _handleFile(file, stats, initialAdd) {
      if (this.fsw.closed) {
        return;
      }
      const dirname = sysPath.dirname(file);
      const basename = sysPath.basename(file);
      const parent = this.fsw._getWatchedDir(dirname);
      let prevStats = stats;
      if (parent.has(basename))
        return;
      const listener = async (path2, newStats) => {
        if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
          return;
        if (!newStats || newStats.mtimeMs === 0) {
          try {
            const newStats2 = await stat(file);
            if (this.fsw.closed)
              return;
            const at = newStats2.atimeMs;
            const mt = newStats2.mtimeMs;
            if (!at || at <= mt || mt !== prevStats.mtimeMs) {
              this.fsw._emit(EV_CHANGE, file, newStats2);
            }
            if (isLinux && prevStats.ino !== newStats2.ino) {
              this.fsw._closeFile(path2);
              prevStats = newStats2;
              this.fsw._addPathCloser(path2, this._watchWithNodeFs(file, listener));
            } else {
              prevStats = newStats2;
            }
          } catch (error) {
            this.fsw._remove(dirname, basename);
          }
        } else if (parent.has(basename)) {
          const at = newStats.atimeMs;
          const mt = newStats.mtimeMs;
          if (!at || at <= mt || mt !== prevStats.mtimeMs) {
            this.fsw._emit(EV_CHANGE, file, newStats);
          }
          prevStats = newStats;
        }
      };
      const closer = this._watchWithNodeFs(file, listener);
      if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
        if (!this.fsw._throttle(EV_ADD, file, 0))
          return;
        this.fsw._emit(EV_ADD, file, stats);
      }
      return closer;
    }
    async _handleSymlink(entry, directory, path2, item) {
      if (this.fsw.closed) {
        return;
      }
      const full = entry.fullPath;
      const dir = this.fsw._getWatchedDir(directory);
      if (!this.fsw.options.followSymlinks) {
        this.fsw._incrReadyCount();
        let linkPath;
        try {
          linkPath = await fsrealpath(path2);
        } catch (e) {
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw.closed)
          return;
        if (dir.has(item)) {
          if (this.fsw._symlinkPaths.get(full) !== linkPath) {
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV_CHANGE, path2, entry.stats);
          }
        } else {
          dir.add(item);
          this.fsw._symlinkPaths.set(full, linkPath);
          this.fsw._emit(EV_ADD, path2, entry.stats);
        }
        this.fsw._emitReady();
        return true;
      }
      if (this.fsw._symlinkPaths.has(full)) {
        return true;
      }
      this.fsw._symlinkPaths.set(full, true);
    }
    _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
      directory = sysPath.join(directory, EMPTY_STR);
      if (!wh.hasGlob) {
        throttler = this.fsw._throttle("readdir", directory, 1000);
        if (!throttler)
          return;
      }
      const previous = this.fsw._getWatchedDir(wh.path);
      const current = new Set;
      let stream2 = this.fsw._readdirp(directory, {
        fileFilter: (entry) => wh.filterPath(entry),
        directoryFilter: (entry) => wh.filterDir(entry),
        depth: 0
      }).on(STR_DATA, async (entry) => {
        if (this.fsw.closed) {
          stream2 = undefined;
          return;
        }
        const item = entry.path;
        let path2 = sysPath.join(directory, item);
        current.add(item);
        if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path2, item)) {
          return;
        }
        if (this.fsw.closed) {
          stream2 = undefined;
          return;
        }
        if (item === target || !target && !previous.has(item)) {
          this.fsw._incrReadyCount();
          path2 = sysPath.join(dir, sysPath.relative(dir, path2));
          this._addToNodeFs(path2, initialAdd, wh, depth + 1);
        }
      }).on(EV_ERROR, this._boundHandleError);
      return new Promise((resolve) => stream2.once(STR_END, () => {
        if (this.fsw.closed) {
          stream2 = undefined;
          return;
        }
        const wasThrottled = throttler ? throttler.clear() : false;
        resolve();
        previous.getChildren().filter((item) => {
          return item !== directory && !current.has(item) && (!wh.hasGlob || wh.filterPath({
            fullPath: sysPath.resolve(directory, item)
          }));
        }).forEach((item) => {
          this.fsw._remove(directory, item);
        });
        stream2 = undefined;
        if (wasThrottled)
          this._handleRead(directory, false, wh, target, dir, depth, throttler);
      }));
    }
    async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
      const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
      const tracked = parentDir.has(sysPath.basename(dir));
      if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
        if (!wh.hasGlob || wh.globFilter(dir))
          this.fsw._emit(EV_ADD_DIR, dir, stats);
      }
      parentDir.add(sysPath.basename(dir));
      this.fsw._getWatchedDir(dir);
      let throttler;
      let closer;
      const oDepth = this.fsw.options.depth;
      if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
        if (!target) {
          await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
          if (this.fsw.closed)
            return;
        }
        closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
          if (stats2 && stats2.mtimeMs === 0)
            return;
          this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
        });
      }
      return closer;
    }
    async _addToNodeFs(path2, initialAdd, priorWh, depth, target) {
      const ready = this.fsw._emitReady;
      if (this.fsw._isIgnored(path2) || this.fsw.closed) {
        ready();
        return false;
      }
      const wh = this.fsw._getWatchHelpers(path2, depth);
      if (!wh.hasGlob && priorWh) {
        wh.hasGlob = priorWh.hasGlob;
        wh.globFilter = priorWh.globFilter;
        wh.filterPath = (entry) => priorWh.filterPath(entry);
        wh.filterDir = (entry) => priorWh.filterDir(entry);
      }
      try {
        const stats = await statMethods[wh.statMethod](wh.watchPath);
        if (this.fsw.closed)
          return;
        if (this.fsw._isIgnored(wh.watchPath, stats)) {
          ready();
          return false;
        }
        const follow = this.fsw.options.followSymlinks && !path2.includes(STAR) && !path2.includes(BRACE_START);
        let closer;
        if (stats.isDirectory()) {
          const absPath = sysPath.resolve(path2);
          const targetPath = follow ? await fsrealpath(path2) : path2;
          if (this.fsw.closed)
            return;
          closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
          if (this.fsw.closed)
            return;
          if (absPath !== targetPath && targetPath !== undefined) {
            this.fsw._symlinkPaths.set(absPath, targetPath);
          }
        } else if (stats.isSymbolicLink()) {
          const targetPath = follow ? await fsrealpath(path2) : path2;
          if (this.fsw.closed)
            return;
          const parent = sysPath.dirname(wh.watchPath);
          this.fsw._getWatchedDir(parent).add(wh.watchPath);
          this.fsw._emit(EV_ADD, wh.watchPath, stats);
          closer = await this._handleDir(parent, stats, initialAdd, depth, path2, wh, targetPath);
          if (this.fsw.closed)
            return;
          if (targetPath !== undefined) {
            this.fsw._symlinkPaths.set(sysPath.resolve(path2), targetPath);
          }
        } else {
          closer = this._handleFile(wh.watchPath, stats, initialAdd);
        }
        ready();
        this.fsw._addPathCloser(path2, closer);
        return false;
      } catch (error) {
        if (this.fsw._handleError(error)) {
          ready();
          return path2;
        }
      }
    }
  }
  module2.exports = NodeFsHandler;
});

// ../../node_modules/chokidar/lib/fsevents-handler.js
var require_fsevents_handler = __commonJS((exports2, module2) => {
  var setFSEventsListener = function(path2, realPath, listener, rawEmitter) {
    let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;
    const parentPath = sysPath.dirname(watchPath);
    let cont = FSEventsWatchers.get(watchPath);
    if (couldConsolidate(parentPath)) {
      watchPath = parentPath;
    }
    const resolvedPath = sysPath.resolve(path2);
    const hasSymlink = resolvedPath !== realPath;
    const filteredListener = (fullPath, flags, info) => {
      if (hasSymlink)
        fullPath = fullPath.replace(realPath, resolvedPath);
      if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep))
        listener(fullPath, flags, info);
    };
    let watchedParent = false;
    for (const watchedPath of FSEventsWatchers.keys()) {
      if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
        watchPath = watchedPath;
        cont = FSEventsWatchers.get(watchPath);
        watchedParent = true;
        break;
      }
    }
    if (cont || watchedParent) {
      cont.listeners.add(filteredListener);
    } else {
      cont = {
        listeners: new Set([filteredListener]),
        rawEmitter,
        watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
          if (!cont.listeners.size)
            return;
          if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS)
            return;
          const info = fsevents.getInfo(fullPath, flags);
          cont.listeners.forEach((list) => {
            list(fullPath, flags, info);
          });
          cont.rawEmitter(info.event, fullPath, info);
        })
      };
      FSEventsWatchers.set(watchPath, cont);
    }
    return () => {
      const lst = cont.listeners;
      lst.delete(filteredListener);
      if (!lst.size) {
        FSEventsWatchers.delete(watchPath);
        if (cont.watcher)
          return cont.watcher.stop().then(() => {
            cont.rawEmitter = cont.watcher = undefined;
            Object.freeze(cont);
          });
      }
    };
  };
  var fs = __require("fs");
  var sysPath = __require("path");
  var { promisify } = __require("util");
  var fsevents;
  try {
    fsevents = (()=>{throw new Error(`Cannot require module "fsevents"`);})();
  } catch (error) {
    if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
      console.error(error);
  }
  if (fsevents) {
    const mtch = process.version.match(/v(\d+)\.(\d+)/);
    if (mtch && mtch[1] && mtch[2]) {
      const maj = Number.parseInt(mtch[1], 10);
      const min4 = Number.parseInt(mtch[2], 10);
      if (maj === 8 && min4 < 16) {
        fsevents = undefined;
      }
    }
  }
  var {
    EV_ADD,
    EV_CHANGE,
    EV_ADD_DIR,
    EV_UNLINK,
    EV_ERROR,
    STR_DATA,
    STR_END,
    FSEVENT_CREATED,
    FSEVENT_MODIFIED,
    FSEVENT_DELETED,
    FSEVENT_MOVED,
    FSEVENT_UNKNOWN,
    FSEVENT_FLAG_MUST_SCAN_SUBDIRS,
    FSEVENT_TYPE_FILE,
    FSEVENT_TYPE_DIRECTORY,
    FSEVENT_TYPE_SYMLINK,
    ROOT_GLOBSTAR,
    DIR_SUFFIX,
    DOT_SLASH,
    FUNCTION_TYPE,
    EMPTY_FN,
    IDENTITY_FN
  } = require_constants8();
  var Depth = (value) => isNaN(value) ? {} : { depth: value };
  var stat = promisify(fs.stat);
  var lstat = promisify(fs.lstat);
  var realpath = promisify(fs.realpath);
  var statMethods = { stat, lstat };
  var FSEventsWatchers = new Map;
  var consolidateThreshhold = 10;
  var wrongEventFlags = new Set([
    69888,
    70400,
    71424,
    72704,
    73472,
    131328,
    131840,
    262912
  ]);
  var createFSEventsInstance = (path2, callback) => {
    const stop = fsevents.watch(path2, callback);
    return { stop };
  };
  var couldConsolidate = (path2) => {
    let count = 0;
    for (const watchPath of FSEventsWatchers.keys()) {
      if (watchPath.indexOf(path2) === 0) {
        count++;
        if (count >= consolidateThreshhold) {
          return true;
        }
      }
    }
    return false;
  };
  var canUse = () => fsevents && FSEventsWatchers.size < 128;
  var calcDepth = (path2, root) => {
    let i = 0;
    while (!path2.indexOf(root) && (path2 = sysPath.dirname(path2)) !== root)
      i++;
    return i;
  };
  var sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();

  class FsEventsHandler {
    constructor(fsw) {
      this.fsw = fsw;
    }
    checkIgnored(path2, stats) {
      const ipaths = this.fsw._ignoredPaths;
      if (this.fsw._isIgnored(path2, stats)) {
        ipaths.add(path2);
        if (stats && stats.isDirectory()) {
          ipaths.add(path2 + ROOT_GLOBSTAR);
        }
        return true;
      }
      ipaths.delete(path2);
      ipaths.delete(path2 + ROOT_GLOBSTAR);
    }
    addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
      const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
      this.handleEvent(event, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
    async checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
      try {
        const stats = await stat(path2);
        if (this.fsw.closed)
          return;
        if (sameTypes(info, stats)) {
          this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
        } else {
          this.handleEvent(EV_UNLINK, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
        }
      } catch (error) {
        if (error.code === "EACCES") {
          this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
        } else {
          this.handleEvent(EV_UNLINK, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
        }
      }
    }
    handleEvent(event, path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
      if (this.fsw.closed || this.checkIgnored(path2))
        return;
      if (event === EV_UNLINK) {
        const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;
        if (isDirectory || watchedDir.has(item)) {
          this.fsw._remove(parent, item, isDirectory);
        }
      } else {
        if (event === EV_ADD) {
          if (info.type === FSEVENT_TYPE_DIRECTORY)
            this.fsw._getWatchedDir(path2);
          if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
            const curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;
            return this._addToFsEvents(path2, false, true, curDepth);
          }
          this.fsw._getWatchedDir(parent).add(item);
        }
        const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
        this.fsw._emit(eventName, path2);
        if (eventName === EV_ADD_DIR)
          this._addToFsEvents(path2, false, true);
      }
    }
    _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
      if (this.fsw.closed || this.fsw._isIgnored(watchPath))
        return;
      const opts = this.fsw.options;
      const watchCallback = async (fullPath, flags, info) => {
        if (this.fsw.closed)
          return;
        if (opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth)
          return;
        const path2 = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));
        if (globFilter && !globFilter(path2))
          return;
        const parent = sysPath.dirname(path2);
        const item = sysPath.basename(path2);
        const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path2 : parent);
        if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
          if (typeof opts.ignored === FUNCTION_TYPE) {
            let stats;
            try {
              stats = await stat(path2);
            } catch (error) {
            }
            if (this.fsw.closed)
              return;
            if (this.checkIgnored(path2, stats))
              return;
            if (sameTypes(info, stats)) {
              this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
            } else {
              this.handleEvent(EV_UNLINK, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } else {
            this.checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        } else {
          switch (info.event) {
            case FSEVENT_CREATED:
            case FSEVENT_MODIFIED:
              return this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
            case FSEVENT_DELETED:
            case FSEVENT_MOVED:
              return this.checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        }
      };
      const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);
      this.fsw._emitReady();
      return closer;
    }
    async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
      if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
        return;
      this.fsw._symlinkPaths.set(fullPath, true);
      this.fsw._incrReadyCount();
      try {
        const linkTarget = await realpath(linkPath);
        if (this.fsw.closed)
          return;
        if (this.fsw._isIgnored(linkTarget)) {
          return this.fsw._emitReady();
        }
        this.fsw._incrReadyCount();
        this._addToFsEvents(linkTarget || linkPath, (path2) => {
          let aliasedPath = linkPath;
          if (linkTarget && linkTarget !== DOT_SLASH) {
            aliasedPath = path2.replace(linkTarget, linkPath);
          } else if (path2 !== DOT_SLASH) {
            aliasedPath = sysPath.join(linkPath, path2);
          }
          return transform(aliasedPath);
        }, false, curDepth);
      } catch (error) {
        if (this.fsw._handleError(error)) {
          return this.fsw._emitReady();
        }
      }
    }
    emitAdd(newPath, stats, processPath, opts, forceAdd) {
      const pp = processPath(newPath);
      const isDir = stats.isDirectory();
      const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));
      const base = sysPath.basename(pp);
      if (isDir)
        this.fsw._getWatchedDir(pp);
      if (dirObj.has(base))
        return;
      dirObj.add(base);
      if (!opts.ignoreInitial || forceAdd === true) {
        this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);
      }
    }
    initWatch(realPath, path2, wh, processPath) {
      if (this.fsw.closed)
        return;
      const closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);
      this.fsw._addPathCloser(path2, closer);
    }
    async _addToFsEvents(path2, transform, forceAdd, priorDepth) {
      if (this.fsw.closed) {
        return;
      }
      const opts = this.fsw.options;
      const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;
      const wh = this.fsw._getWatchHelpers(path2);
      try {
        const stats = await statMethods[wh.statMethod](wh.watchPath);
        if (this.fsw.closed)
          return;
        if (this.fsw._isIgnored(wh.watchPath, stats)) {
          throw null;
        }
        if (stats.isDirectory()) {
          if (!wh.globFilter)
            this.emitAdd(processPath(path2), stats, processPath, opts, forceAdd);
          if (priorDepth && priorDepth > opts.depth)
            return;
          this.fsw._readdirp(wh.watchPath, {
            fileFilter: (entry) => wh.filterPath(entry),
            directoryFilter: (entry) => wh.filterDir(entry),
            ...Depth(opts.depth - (priorDepth || 0))
          }).on(STR_DATA, (entry) => {
            if (this.fsw.closed) {
              return;
            }
            if (entry.stats.isDirectory() && !wh.filterPath(entry))
              return;
            const joinedPath = sysPath.join(wh.watchPath, entry.path);
            const { fullPath } = entry;
            if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
              const curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
              this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
            } else {
              this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
            }
          }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {
            this.fsw._emitReady();
          });
        } else {
          this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
          this.fsw._emitReady();
        }
      } catch (error) {
        if (!error || this.fsw._handleError(error)) {
          this.fsw._emitReady();
          this.fsw._emitReady();
        }
      }
      if (opts.persistent && forceAdd !== true) {
        if (typeof transform === FUNCTION_TYPE) {
          this.initWatch(undefined, path2, wh, processPath);
        } else {
          let realPath;
          try {
            realPath = await realpath(wh.watchPath);
          } catch (e) {
          }
          this.initWatch(realPath, path2, wh, processPath);
        }
      }
    }
  }
  module2.exports = FsEventsHandler;
  module2.exports.canUse = canUse;
});

// ../../node_modules/chokidar/index.js
var require_chokidar = __commonJS((exports2) => {
  var { EventEmitter } = __require("events");
  var fs = __require("fs");
  var sysPath = __require("path");
  var { promisify } = __require("util");
  var readdirp = require_readdirp();
  var anymatch = require_anymatch().default;
  var globParent = require_glob_parent();
  var isGlob = require_is_glob();
  var braces = require_braces();
  var normalizePath = require_normalize_path();
  var NodeFsHandler = require_nodefs_handler();
  var FsEventsHandler = require_fsevents_handler();
  var {
    EV_ALL,
    EV_READY,
    EV_ADD,
    EV_CHANGE,
    EV_UNLINK,
    EV_ADD_DIR,
    EV_UNLINK_DIR,
    EV_RAW,
    EV_ERROR,
    STR_CLOSE,
    STR_END,
    BACK_SLASH_RE,
    DOUBLE_SLASH_RE,
    SLASH_OR_BACK_SLASH_RE,
    DOT_RE,
    REPLACER_RE,
    SLASH,
    SLASH_SLASH,
    BRACE_START,
    BANG,
    ONE_DOT,
    TWO_DOTS,
    GLOBSTAR,
    SLASH_GLOBSTAR,
    ANYMATCH_OPTS,
    STRING_TYPE,
    FUNCTION_TYPE,
    EMPTY_STR,
    EMPTY_FN,
    isWindows,
    isMacos,
    isIBMi
  } = require_constants8();
  var stat = promisify(fs.stat);
  var readdir = promisify(fs.readdir);
  var arrify = (value = []) => Array.isArray(value) ? value : [value];
  var flatten = (list, result = []) => {
    list.forEach((item) => {
      if (Array.isArray(item)) {
        flatten(item, result);
      } else {
        result.push(item);
      }
    });
    return result;
  };
  var unifyPaths = (paths_) => {
    const paths = flatten(arrify(paths_));
    if (!paths.every((p) => typeof p === STRING_TYPE)) {
      throw new TypeError(`Non-string provided as watch path: ${paths}`);
    }
    return paths.map(normalizePathToUnix);
  };
  var toUnix = (string) => {
    let str = string.replace(BACK_SLASH_RE, SLASH);
    let prepend = false;
    if (str.startsWith(SLASH_SLASH)) {
      prepend = true;
    }
    while (str.match(DOUBLE_SLASH_RE)) {
      str = str.replace(DOUBLE_SLASH_RE, SLASH);
    }
    if (prepend) {
      str = SLASH + str;
    }
    return str;
  };
  var normalizePathToUnix = (path2) => toUnix(sysPath.normalize(toUnix(path2)));
  var normalizeIgnored = (cwd = EMPTY_STR) => (path2) => {
    if (typeof path2 !== STRING_TYPE)
      return path2;
    return normalizePathToUnix(sysPath.isAbsolute(path2) ? path2 : sysPath.join(cwd, path2));
  };
  var getAbsolutePath = (path2, cwd) => {
    if (sysPath.isAbsolute(path2)) {
      return path2;
    }
    if (path2.startsWith(BANG)) {
      return BANG + sysPath.join(cwd, path2.slice(1));
    }
    return sysPath.join(cwd, path2);
  };
  var undef = (opts, key) => opts[key] === undefined;

  class DirEntry {
    constructor(dir, removeWatcher) {
      this.path = dir;
      this._removeWatcher = removeWatcher;
      this.items = new Set;
    }
    add(item) {
      const { items } = this;
      if (!items)
        return;
      if (item !== ONE_DOT && item !== TWO_DOTS)
        items.add(item);
    }
    async remove(item) {
      const { items } = this;
      if (!items)
        return;
      items.delete(item);
      if (items.size > 0)
        return;
      const dir = this.path;
      try {
        await readdir(dir);
      } catch (err) {
        if (this._removeWatcher) {
          this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
        }
      }
    }
    has(item) {
      const { items } = this;
      if (!items)
        return;
      return items.has(item);
    }
    getChildren() {
      const { items } = this;
      if (!items)
        return;
      return [...items.values()];
    }
    dispose() {
      this.items.clear();
      delete this.path;
      delete this._removeWatcher;
      delete this.items;
      Object.freeze(this);
    }
  }
  var STAT_METHOD_F = "stat";
  var STAT_METHOD_L = "lstat";

  class WatchHelper {
    constructor(path2, watchPath, follow, fsw) {
      this.fsw = fsw;
      this.path = path2 = path2.replace(REPLACER_RE, EMPTY_STR);
      this.watchPath = watchPath;
      this.fullWatchPath = sysPath.resolve(watchPath);
      this.hasGlob = watchPath !== path2;
      if (path2 === EMPTY_STR)
        this.hasGlob = false;
      this.globSymlink = this.hasGlob && follow ? undefined : false;
      this.globFilter = this.hasGlob ? anymatch(path2, undefined, ANYMATCH_OPTS) : false;
      this.dirParts = this.getDirParts(path2);
      this.dirParts.forEach((parts) => {
        if (parts.length > 1)
          parts.pop();
      });
      this.followSymlinks = follow;
      this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
    }
    checkGlobSymlink(entry) {
      if (this.globSymlink === undefined) {
        this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : { realPath: entry.fullParentDir, linkPath: this.fullWatchPath };
      }
      if (this.globSymlink) {
        return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
      }
      return entry.fullPath;
    }
    entryPath(entry) {
      return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));
    }
    filterPath(entry) {
      const { stats } = entry;
      if (stats && stats.isSymbolicLink())
        return this.filterDir(entry);
      const resolvedPath = this.entryPath(entry);
      const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
      return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
    }
    getDirParts(path2) {
      if (!this.hasGlob)
        return [];
      const parts = [];
      const expandedPath = path2.includes(BRACE_START) ? braces.expand(path2) : [path2];
      expandedPath.forEach((path3) => {
        parts.push(sysPath.relative(this.watchPath, path3).split(SLASH_OR_BACK_SLASH_RE));
      });
      return parts;
    }
    filterDir(entry) {
      if (this.hasGlob) {
        const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
        let globstar = false;
        this.unmatchedGlob = !this.dirParts.some((parts) => {
          return parts.every((part, i) => {
            if (part === GLOBSTAR)
              globstar = true;
            return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
          });
        });
      }
      return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
    }
  }

  class FSWatcher extends EventEmitter {
    constructor(_opts) {
      super();
      const opts = {};
      if (_opts)
        Object.assign(opts, _opts);
      this._watched = new Map;
      this._closers = new Map;
      this._ignoredPaths = new Set;
      this._throttled = new Map;
      this._symlinkPaths = new Map;
      this._streams = new Set;
      this.closed = false;
      if (undef(opts, "persistent"))
        opts.persistent = true;
      if (undef(opts, "ignoreInitial"))
        opts.ignoreInitial = false;
      if (undef(opts, "ignorePermissionErrors"))
        opts.ignorePermissionErrors = false;
      if (undef(opts, "interval"))
        opts.interval = 100;
      if (undef(opts, "binaryInterval"))
        opts.binaryInterval = 300;
      if (undef(opts, "disableGlobbing"))
        opts.disableGlobbing = false;
      opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
      if (undef(opts, "useFsEvents"))
        opts.useFsEvents = !opts.usePolling;
      const canUseFsEvents = FsEventsHandler.canUse();
      if (!canUseFsEvents)
        opts.useFsEvents = false;
      if (undef(opts, "usePolling") && !opts.useFsEvents) {
        opts.usePolling = isMacos;
      }
      if (isIBMi) {
        opts.usePolling = true;
      }
      const envPoll = process.env.CHOKIDAR_USEPOLLING;
      if (envPoll !== undefined) {
        const envLower = envPoll.toLowerCase();
        if (envLower === "false" || envLower === "0") {
          opts.usePolling = false;
        } else if (envLower === "true" || envLower === "1") {
          opts.usePolling = true;
        } else {
          opts.usePolling = !!envLower;
        }
      }
      const envInterval = process.env.CHOKIDAR_INTERVAL;
      if (envInterval) {
        opts.interval = Number.parseInt(envInterval, 10);
      }
      if (undef(opts, "atomic"))
        opts.atomic = !opts.usePolling && !opts.useFsEvents;
      if (opts.atomic)
        this._pendingUnlinks = new Map;
      if (undef(opts, "followSymlinks"))
        opts.followSymlinks = true;
      if (undef(opts, "awaitWriteFinish"))
        opts.awaitWriteFinish = false;
      if (opts.awaitWriteFinish === true)
        opts.awaitWriteFinish = {};
      const awf = opts.awaitWriteFinish;
      if (awf) {
        if (!awf.stabilityThreshold)
          awf.stabilityThreshold = 2000;
        if (!awf.pollInterval)
          awf.pollInterval = 100;
        this._pendingWrites = new Map;
      }
      if (opts.ignored)
        opts.ignored = arrify(opts.ignored);
      let readyCalls = 0;
      this._emitReady = () => {
        readyCalls++;
        if (readyCalls >= this._readyCount) {
          this._emitReady = EMPTY_FN;
          this._readyEmitted = true;
          process.nextTick(() => this.emit(EV_READY));
        }
      };
      this._emitRaw = (...args2) => this.emit(EV_RAW, ...args2);
      this._readyEmitted = false;
      this.options = opts;
      if (opts.useFsEvents) {
        this._fsEventsHandler = new FsEventsHandler(this);
      } else {
        this._nodeFsHandler = new NodeFsHandler(this);
      }
      Object.freeze(opts);
    }
    add(paths_, _origAdd, _internal) {
      const { cwd, disableGlobbing } = this.options;
      this.closed = false;
      let paths = unifyPaths(paths_);
      if (cwd) {
        paths = paths.map((path2) => {
          const absPath = getAbsolutePath(path2, cwd);
          if (disableGlobbing || !isGlob(path2)) {
            return absPath;
          }
          return normalizePath(absPath);
        });
      }
      paths = paths.filter((path2) => {
        if (path2.startsWith(BANG)) {
          this._ignoredPaths.add(path2.slice(1));
          return false;
        }
        this._ignoredPaths.delete(path2);
        this._ignoredPaths.delete(path2 + SLASH_GLOBSTAR);
        this._userIgnored = undefined;
        return true;
      });
      if (this.options.useFsEvents && this._fsEventsHandler) {
        if (!this._readyCount)
          this._readyCount = paths.length;
        if (this.options.persistent)
          this._readyCount += paths.length;
        paths.forEach((path2) => this._fsEventsHandler._addToFsEvents(path2));
      } else {
        if (!this._readyCount)
          this._readyCount = 0;
        this._readyCount += paths.length;
        Promise.all(paths.map(async (path2) => {
          const res = await this._nodeFsHandler._addToNodeFs(path2, !_internal, 0, 0, _origAdd);
          if (res)
            this._emitReady();
          return res;
        })).then((results) => {
          if (this.closed)
            return;
          results.filter((item) => item).forEach((item) => {
            this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
          });
        });
      }
      return this;
    }
    unwatch(paths_) {
      if (this.closed)
        return this;
      const paths = unifyPaths(paths_);
      const { cwd } = this.options;
      paths.forEach((path2) => {
        if (!sysPath.isAbsolute(path2) && !this._closers.has(path2)) {
          if (cwd)
            path2 = sysPath.join(cwd, path2);
          path2 = sysPath.resolve(path2);
        }
        this._closePath(path2);
        this._ignoredPaths.add(path2);
        if (this._watched.has(path2)) {
          this._ignoredPaths.add(path2 + SLASH_GLOBSTAR);
        }
        this._userIgnored = undefined;
      });
      return this;
    }
    close() {
      if (this.closed)
        return this._closePromise;
      this.closed = true;
      this.removeAllListeners();
      const closers = [];
      this._closers.forEach((closerList) => closerList.forEach((closer) => {
        const promise = closer();
        if (promise instanceof Promise)
          closers.push(promise);
      }));
      this._streams.forEach((stream2) => stream2.destroy());
      this._userIgnored = undefined;
      this._readyCount = 0;
      this._readyEmitted = false;
      this._watched.forEach((dirent) => dirent.dispose());
      ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
        this[`_${key}`].clear();
      });
      this._closePromise = closers.length ? Promise.all(closers).then(() => {
        return;
      }) : Promise.resolve();
      return this._closePromise;
    }
    getWatched() {
      const watchList = {};
      this._watched.forEach((entry, dir) => {
        const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
        watchList[key || ONE_DOT] = entry.getChildren().sort();
      });
      return watchList;
    }
    emitWithAll(event, args2) {
      this.emit(...args2);
      if (event !== EV_ERROR)
        this.emit(EV_ALL, ...args2);
    }
    async _emit(event, path2, val1, val2, val3) {
      if (this.closed)
        return;
      const opts = this.options;
      if (isWindows)
        path2 = sysPath.normalize(path2);
      if (opts.cwd)
        path2 = sysPath.relative(opts.cwd, path2);
      const args2 = [event, path2];
      if (val3 !== undefined)
        args2.push(val1, val2, val3);
      else if (val2 !== undefined)
        args2.push(val1, val2);
      else if (val1 !== undefined)
        args2.push(val1);
      const awf = opts.awaitWriteFinish;
      let pw;
      if (awf && (pw = this._pendingWrites.get(path2))) {
        pw.lastChange = new Date;
        return this;
      }
      if (opts.atomic) {
        if (event === EV_UNLINK) {
          this._pendingUnlinks.set(path2, args2);
          setTimeout(() => {
            this._pendingUnlinks.forEach((entry, path3) => {
              this.emit(...entry);
              this.emit(EV_ALL, ...entry);
              this._pendingUnlinks.delete(path3);
            });
          }, typeof opts.atomic === "number" ? opts.atomic : 100);
          return this;
        }
        if (event === EV_ADD && this._pendingUnlinks.has(path2)) {
          event = args2[0] = EV_CHANGE;
          this._pendingUnlinks.delete(path2);
        }
      }
      if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
        const awfEmit = (err, stats) => {
          if (err) {
            event = args2[0] = EV_ERROR;
            args2[1] = err;
            this.emitWithAll(event, args2);
          } else if (stats) {
            if (args2.length > 2) {
              args2[2] = stats;
            } else {
              args2.push(stats);
            }
            this.emitWithAll(event, args2);
          }
        };
        this._awaitWriteFinish(path2, awf.stabilityThreshold, event, awfEmit);
        return this;
      }
      if (event === EV_CHANGE) {
        const isThrottled = !this._throttle(EV_CHANGE, path2, 50);
        if (isThrottled)
          return this;
      }
      if (opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
        const fullPath = opts.cwd ? sysPath.join(opts.cwd, path2) : path2;
        let stats;
        try {
          stats = await stat(fullPath);
        } catch (err) {
        }
        if (!stats || this.closed)
          return;
        args2.push(stats);
      }
      this.emitWithAll(event, args2);
      return this;
    }
    _handleError(error) {
      const code = error && error.code;
      if (error && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
        this.emit(EV_ERROR, error);
      }
      return error || this.closed;
    }
    _throttle(actionType, path2, timeout) {
      if (!this._throttled.has(actionType)) {
        this._throttled.set(actionType, new Map);
      }
      const action = this._throttled.get(actionType);
      const actionPath = action.get(path2);
      if (actionPath) {
        actionPath.count++;
        return false;
      }
      let timeoutObject;
      const clear = () => {
        const item = action.get(path2);
        const count = item ? item.count : 0;
        action.delete(path2);
        clearTimeout(timeoutObject);
        if (item)
          clearTimeout(item.timeoutObject);
        return count;
      };
      timeoutObject = setTimeout(clear, timeout);
      const thr = { timeoutObject, clear, count: 0 };
      action.set(path2, thr);
      return thr;
    }
    _incrReadyCount() {
      return this._readyCount++;
    }
    _awaitWriteFinish(path2, threshold, event, awfEmit) {
      let timeoutHandler;
      let fullPath = path2;
      if (this.options.cwd && !sysPath.isAbsolute(path2)) {
        fullPath = sysPath.join(this.options.cwd, path2);
      }
      const now = new Date;
      const awaitWriteFinish = (prevStat) => {
        fs.stat(fullPath, (err, curStat) => {
          if (err || !this._pendingWrites.has(path2)) {
            if (err && err.code !== "ENOENT")
              awfEmit(err);
            return;
          }
          const now2 = Number(new Date);
          if (prevStat && curStat.size !== prevStat.size) {
            this._pendingWrites.get(path2).lastChange = now2;
          }
          const pw = this._pendingWrites.get(path2);
          const df = now2 - pw.lastChange;
          if (df >= threshold) {
            this._pendingWrites.delete(path2);
            awfEmit(undefined, curStat);
          } else {
            timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);
          }
        });
      };
      if (!this._pendingWrites.has(path2)) {
        this._pendingWrites.set(path2, {
          lastChange: now,
          cancelWait: () => {
            this._pendingWrites.delete(path2);
            clearTimeout(timeoutHandler);
            return event;
          }
        });
        timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);
      }
    }
    _getGlobIgnored() {
      return [...this._ignoredPaths.values()];
    }
    _isIgnored(path2, stats) {
      if (this.options.atomic && DOT_RE.test(path2))
        return true;
      if (!this._userIgnored) {
        const { cwd } = this.options;
        const ign = this.options.ignored;
        const ignored = ign && ign.map(normalizeIgnored(cwd));
        const paths = arrify(ignored).filter((path3) => typeof path3 === STRING_TYPE && !isGlob(path3)).map((path3) => path3 + SLASH_GLOBSTAR);
        const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
        this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);
      }
      return this._userIgnored([path2, stats]);
    }
    _isntIgnored(path2, stat2) {
      return !this._isIgnored(path2, stat2);
    }
    _getWatchHelpers(path2, depth) {
      const watchPath = depth || this.options.disableGlobbing || !isGlob(path2) ? path2 : globParent(path2);
      const follow = this.options.followSymlinks;
      return new WatchHelper(path2, watchPath, follow, this);
    }
    _getWatchedDir(directory) {
      if (!this._boundRemove)
        this._boundRemove = this._remove.bind(this);
      const dir = sysPath.resolve(directory);
      if (!this._watched.has(dir))
        this._watched.set(dir, new DirEntry(dir, this._boundRemove));
      return this._watched.get(dir);
    }
    _hasReadPermissions(stats) {
      if (this.options.ignorePermissionErrors)
        return true;
      const md = stats && Number.parseInt(stats.mode, 10);
      const st = md & 511;
      const it = Number.parseInt(st.toString(8)[0], 10);
      return Boolean(4 & it);
    }
    _remove(directory, item, isDirectory) {
      const path2 = sysPath.join(directory, item);
      const fullPath = sysPath.resolve(path2);
      isDirectory = isDirectory != null ? isDirectory : this._watched.has(path2) || this._watched.has(fullPath);
      if (!this._throttle("remove", path2, 100))
        return;
      if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
        this.add(directory, item, true);
      }
      const wp = this._getWatchedDir(path2);
      const nestedDirectoryChildren = wp.getChildren();
      nestedDirectoryChildren.forEach((nested) => this._remove(path2, nested));
      const parent = this._getWatchedDir(directory);
      const wasTracked = parent.has(item);
      parent.remove(item);
      if (this._symlinkPaths.has(fullPath)) {
        this._symlinkPaths.delete(fullPath);
      }
      let relPath = path2;
      if (this.options.cwd)
        relPath = sysPath.relative(this.options.cwd, path2);
      if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
        const event = this._pendingWrites.get(relPath).cancelWait();
        if (event === EV_ADD)
          return;
      }
      this._watched.delete(path2);
      this._watched.delete(fullPath);
      const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
      if (wasTracked && !this._isIgnored(path2))
        this._emit(eventName, path2);
      if (!this.options.useFsEvents) {
        this._closePath(path2);
      }
    }
    _closePath(path2) {
      this._closeFile(path2);
      const dir = sysPath.dirname(path2);
      this._getWatchedDir(dir).remove(sysPath.basename(path2));
    }
    _closeFile(path2) {
      const closers = this._closers.get(path2);
      if (!closers)
        return;
      closers.forEach((closer) => closer());
      this._closers.delete(path2);
    }
    _addPathCloser(path2, closer) {
      if (!closer)
        return;
      let list = this._closers.get(path2);
      if (!list) {
        list = [];
        this._closers.set(path2, list);
      }
      list.push(closer);
    }
    _readdirp(root, opts) {
      if (this.closed)
        return;
      const options2 = { type: EV_ALL, alwaysStat: true, lstat: true, ...opts };
      let stream2 = readdirp(root, options2);
      this._streams.add(stream2);
      stream2.once(STR_CLOSE, () => {
        stream2 = undefined;
      });
      stream2.once(STR_END, () => {
        if (stream2) {
          this._streams.delete(stream2);
          stream2 = undefined;
        }
      });
      return stream2;
    }
  }
  exports2.FSWatcher = FSWatcher;
  var watch = (paths, options2) => {
    const watcher = new FSWatcher(options2);
    watcher.add(paths);
    return watcher;
  };
  exports2.watch = watch;
});

// ../../node_modules/pm2/lib/Watcher.js
var require_Watcher = __commonJS((exports2, module2) => {
  var chokidar = require_chokidar();
  var util = __require("util");
  var log = require_src()("pm2:watch");
  module2.exports = function ClusterMode(God) {
    God.watch = {};
    God.watch._watchers = {};
    God.watch.enable = function(pm2_env) {
      if (God.watch._watchers[pm2_env.pm_id]) {
        God.watch._watchers[pm2_env.pm_id].close();
        God.watch._watchers[pm2_env.pm_id] = null;
        delete God.watch._watchers[pm2_env.pm_id];
      }
      log("Initial watch ", pm2_env.watch);
      var watch = pm2_env.watch;
      if (typeof watch == "boolean" || Array.isArray(watch) && watch.length === 0)
        watch = pm2_env.pm_cwd;
      log("Watching %s", watch);
      var watch_options = {
        ignored: pm2_env.ignore_watch || /[\/\\]\.|node_modules/,
        persistent: true,
        ignoreInitial: true,
        cwd: pm2_env.pm_cwd
      };
      if (pm2_env.watch_options) {
        watch_options = Object.assign(watch_options, pm2_env.watch_options);
      }
      log("Watch opts", watch_options);
      var watcher = chokidar.watch(watch, watch_options);
      console.log("[Watch] Start watching", pm2_env.name);
      watcher.on("all", function(event, path2) {
        var self2 = this;
        if (self2.restarting === true) {
          log("Already restarting, skipping");
          return false;
        }
        self2.restarting = true;
        console.log("Change detected on path %s for app %s - restarting", path2, pm2_env.name);
        setTimeout(function() {
          God.restartProcessName(pm2_env.name, function(err, list) {
            self2.restarting = false;
            if (err) {
              log("Error while restarting", err);
              return false;
            }
            return log("Process restarted");
          });
        }, pm2_env.watch_delay || 0);
        return false;
      });
      watcher.on("error", function(e) {
        console.error(e.stack || e);
      });
      God.watch._watchers[pm2_env.pm_id] = watcher;
    }, God.watch.disableAll = function() {
      var watchers = God.watch._watchers;
      console.log("[Watch] PM2 is being killed. Watch is disabled to avoid conflicts");
      for (var i in watchers) {
        watchers[i].close && watchers[i].close();
        watchers.splice(i, 1);
      }
    }, God.watch.disable = function(pm2_env) {
      var watcher = God.watch._watchers[pm2_env.pm_id];
      if (watcher) {
        console.log("[Watch] Stop watching", pm2_env.name);
        watcher.close();
        delete God.watch._watchers[pm2_env.pm_id];
        return true;
      } else {
        return false;
      }
    };
  };
});

// ../../node_modules/@pm2/pm2-version-check/index.js
var require_pm2_version_check = __commonJS((exports2, module2) => {
  var https = __require("https");
  var debug = require_src()("pm2:version-check");
  var qs = __require("querystring");
  var VersionCheck = {};
  VersionCheck.runCheck = function(params2, cb) {
    var path2 = null;
    if (cb == null && typeof params2 == "function") {
      cb = params2;
      path2 = "/check";
    } else {
      path2 = "/check?" + qs.stringify(params2);
    }
    var options2 = {
      host: "version.pm2.io",
      path: path2,
      strictSSL: false,
      timeout: 1200,
      rejectUnauthorized: false
    };
    var req = https.get(options2, function(res) {
      if (res.statusCode != 200)
        return false;
      var bodyChunks = [];
      res.on("data", function(chunk) {
        bodyChunks.push(chunk);
      }).on("end", function() {
        var body = Buffer.concat(bodyChunks);
        try {
          var data = JSON.parse(body);
          return cb ? cb(null, data) : null;
        } catch (e) {
          return cb ? cb(new Error("Could not parse result")) : null;
        }
      });
    });
    req.on("error", function(e) {
      debug("ERROR: " + e.message);
      return cb ? cb(e) : null;
    });
  };
  module2.exports = VersionCheck;
  if (__require.main === module2) {
    VersionCheck.runCheck((err, dt) => {
      console.log(err, dt);
    });
  }
});

// ../../node_modules/pm2/lib/VersionCheck.js
var require_VersionCheck = __commonJS((exports2, module2) => {
  var hasDockerEnv = function() {
    try {
      fs.statSync("/.dockerenv");
      return true;
    } catch (_) {
      return false;
    }
  };
  var hasDockerCGroup = function() {
    try {
      return fs.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
    } catch (_) {
      return false;
    }
  };
  var vCheck = require_pm2_version_check();
  var semver = require_semver2();
  var fs = __require("fs");
  var os = __require("os");
  module2.exports = function(opts) {
    var params2 = {
      state: opts.state,
      version: opts.version
    };
    try {
      params2.os = os.type();
      params2.uptime = Math.floor(process.uptime());
      params2.nodev = process.versions.node;
      params2.docker = hasDockerEnv() || hasDockerCGroup();
    } catch (e) {
    }
    vCheck.runCheck(params2, (err, pkg) => {
      if (err)
        return false;
      if (!pkg.current_version)
        return false;
      if (opts.version && semver.lt(opts.version, pkg.current_version)) {
        console.log("[PM2] This PM2 is not UP TO DATE");
        console.log("[PM2] Upgrade to version %s", pkg.current_version);
      }
    });
  };
});

// ../../node_modules/pm2/lib/Worker.js
var require_Worker = __commonJS((exports2, module2) => {
  var vizion = require_vizion();
  var eachLimit = require_eachLimit();
  var debug = require_src()("pm2:worker");
  var domain = __require("domain");
  var Cron = require_croner();
  var pkg = require_package();
  var cst = require_constants2();
  var vCheck = require_VersionCheck();
  module2.exports = function(God) {
    var timer = null;
    God.CronJobs = new Map;
    God.Worker = {};
    God.Worker.is_running = false;
    God.getCronID = function(pm_id) {
      return `cron-${pm_id}`;
    };
    God.registerCron = function(pm2_env) {
      if (!pm2_env || pm2_env.pm_id === undefined || !pm2_env.cron_restart || pm2_env.cron_restart == "0" || God.CronJobs.has(God.getCronID(pm2_env.pm_id)))
        return;
      var pm_id = pm2_env.pm_id;
      console.log("[PM2][WORKER] Registering a cron job on:", pm_id);
      var job = Cron(pm2_env.cron_restart, function() {
        God.restartProcessId({ id: pm_id }, function(err, data) {
          if (err)
            console.error(err.stack || err);
          return;
        });
      });
      God.CronJobs.set(God.getCronID(pm_id), job);
    };
    God.deleteCron = function(id2) {
      if (typeof id2 !== "undefined" && God.CronJobs.has(God.getCronID(id2)) === false)
        return;
      console.log("[PM2] Deregistering a cron job on:", id2);
      var job = God.CronJobs.get(God.getCronID(id2));
      if (job)
        job.stop();
      God.CronJobs.delete(God.getCronID(id2));
    };
    var _getProcessById = function(pm_id) {
      var proc = God.clusters_db[pm_id];
      return proc ? proc : null;
    };
    var maxMemoryRestart = function(proc_key, cb) {
      var proc = _getProcessById(proc_key.pm2_env.pm_id);
      if (!(proc && proc.pm2_env && proc_key.monit))
        return cb();
      if (proc_key.monit.memory !== undefined && proc.pm2_env.max_memory_restart !== undefined && proc.pm2_env.max_memory_restart < proc_key.monit.memory && proc.pm2_env.axm_options && proc.pm2_env.axm_options.pid === undefined) {
        console.log("[PM2][WORKER] Process %s restarted because it exceeds --max-memory-restart value (current_memory=%s max_memory_limit=%s [octets])", proc.pm2_env.pm_id, proc_key.monit.memory, proc.pm2_env.max_memory_restart);
        God.reloadProcessId({
          id: proc.pm2_env.pm_id
        }, function(err, data) {
          if (err)
            console.error(err.stack || err);
          return cb();
        });
      } else {
        return cb();
      }
    };
    var versioningRefresh = function(proc_key, cb) {
      var proc = _getProcessById(proc_key.pm2_env.pm_id);
      if (!(proc && proc.pm2_env && (proc.pm2_env.vizion !== false && proc.pm2_env.vizion != "false") && proc.pm2_env.versioning && proc.pm2_env.versioning.repo_path)) {
        return cb();
      }
      if (proc.pm2_env.vizion_running === true) {
        debug("Vizion is already running for proc id: %d, skipping this round", proc.pm2_env.pm_id);
        return cb();
      }
      proc.pm2_env.vizion_running = true;
      var repo_path = proc.pm2_env.versioning.repo_path;
      vizion.analyze({
        folder: proc.pm2_env.versioning.repo_path
      }, function(err, meta2) {
        if (err != null)
          return cb();
        proc = _getProcessById(proc_key.pm2_env.pm_id);
        if (!(proc && proc.pm2_env && proc.pm2_env.versioning && proc.pm2_env.versioning.repo_path)) {
          console.error("Proc not defined anymore or versioning unknown");
          return cb();
        }
        proc.pm2_env.vizion_running = false;
        meta2.repo_path = repo_path;
        proc.pm2_env.versioning = meta2;
        debug("[PM2][WORKER] %s parsed for versioning", proc.pm2_env.name);
        return cb();
      });
    };
    var tasks = function() {
      if (God.Worker.is_running === true) {
        debug("[PM2][WORKER] Worker is already running, skipping this round");
        return false;
      }
      God.Worker.is_running = true;
      God.getMonitorData(null, function(err, data) {
        if (err || !data || typeof data !== "object") {
          God.Worker.is_running = false;
          return console.error(err);
        }
        eachLimit(data, 1, function(proc, next) {
          if (!proc || !proc.pm2_env || proc.pm2_env.pm_id === undefined)
            return next();
          debug("[PM2][WORKER] Processing proc id:", proc.pm2_env.pm_id);
          if (proc.pm2_env.exp_backoff_restart_delay !== undefined && proc.pm2_env.prev_restart_delay && proc.pm2_env.prev_restart_delay > 0) {
            var app_uptime = Date.now() - proc.pm2_env.pm_uptime;
            if (app_uptime > cst.EXP_BACKOFF_RESET_TIMER) {
              var ref_proc = _getProcessById(proc.pm2_env.pm_id);
              ref_proc.pm2_env.prev_restart_delay = 0;
              console.log(`[PM2][WORKER] Reset the restart delay, as app ${proc.name} has been up for more than ${cst.EXP_BACKOFF_RESET_TIMER}ms`);
            }
          }
          maxMemoryRestart(proc, function() {
            return next();
          });
        }, function(err2) {
          God.Worker.is_running = false;
          debug("[PM2][WORKER] My job here is done, next job in %d seconds", parseInt(cst.WORKER_INTERVAL / 1000));
        });
      });
    };
    var wrappedTasks = function() {
      var d = domain.create();
      d.once("error", function(err) {
        console.error("[PM2][WORKER] Error caught by domain:\n" + (err.stack || err));
        God.Worker.is_running = false;
      });
      d.run(function() {
        tasks();
      });
    };
    God.Worker.start = function() {
      timer = setInterval(wrappedTasks, cst.WORKER_INTERVAL);
      setInterval(() => {
        vCheck({
          state: "check",
          version: pkg.version
        });
      }, 1000 * 60 * 60 * 24);
    };
    God.Worker.stop = function() {
      if (timer !== null)
        clearInterval(timer);
    };
  };
});

// ../../node_modules/pm2/lib/God.js
var require_God = __commonJS((exports2, module2) => {
  var cluster = __require("cluster");
  var numCPUs = __require("os").cpus() ? __require("os").cpus().length : 1;
  var path2 = __require("path");
  var EventEmitter2 = require_eventemitter2().EventEmitter2;
  var fs = __require("fs");
  var vizion = require_vizion();
  var debug = require_src()("pm2:god");
  var Utility = require_Utility();
  var cst = require_constants2();
  var timesLimit = require_timesLimit();
  var Configuration = require_Configuration();
  cluster.setupMaster({
    windowsHide: true,
    exec: path2.resolve(path2.dirname("God.js"), "ProcessContainer.js")
  });
  var God = module2.exports = {
    next_id: 0,
    clusters_db: {},
    configuration: {},
    started_at: Date.now(),
    system_infos_proc: null,
    system_infos: null,
    bus: new EventEmitter2({
      wildcard: true,
      delimiter: ":",
      maxListeners: 1000
    })
  };
  Utility.overrideConsole(God.bus);
  require_Event()(God);
  require_Methods()(God);
  require_ForkMode()(God);
  require_ClusterMode()(God);
  require_Reload()(God);
  require_ActionMethods()(God);
  require_Watcher()(God);
  God.init = function() {
    require_Worker()(this);
    God.system_infos_proc = null;
    this.configuration = Configuration.getSync("pm2");
    setTimeout(function() {
      God.Worker.start();
    }, 500);
  };
  God.writeExitSeparator = function(pm2_env, code, signal) {
    try {
      var exit_sep = `[PM2][${new Date().toISOString()}] app exited`;
      if (code)
        exit_sep += `itself with exit code: ${code}`;
      if (signal)
        exit_sep += `by an external signal: ${signal}`;
      exit_sep += "\n";
      if (pm2_env.pm_out_log_path)
        fs.writeFileSync(pm2_env.pm_out_log_path, exit_sep);
      if (pm2_env.pm_err_log_path)
        fs.writeFileSync(pm2_env.pm_err_log_path, exit_sep);
      if (pm2_env.pm_log_path)
        fs.writeFileSync(pm2_env.pm_log_path, exit_sep);
    } catch (e) {
    }
  };
  God.prepare = function prepare(env, cb) {
    env.env.unique_id = Utility.generateUUID();
    if (typeof env.instances === "undefined") {
      env.vizion_running = false;
      if (env.env && env.env.vizion_running)
        env.env.vizion_running = false;
      if (env.status == cst.STOPPED_STATUS) {
        env.pm_id = God.getNewId();
        var clu = {
          pm2_env: env,
          process: {}
        };
        God.clusters_db[env.pm_id] = clu;
        God.registerCron(env);
        return cb(null, [God.clusters_db[env.pm_id]]);
      }
      return God.executeApp(env, function(err, clu2) {
        if (err)
          return cb(err);
        God.notify("start", clu2, true);
        return cb(null, [Utility.clone(clu2)]);
      });
    }
    env.instances = parseInt(env.instances);
    if (env.instances === 0) {
      env.instances = numCPUs;
    } else if (env.instances < 0) {
      env.instances += numCPUs;
    }
    if (env.instances <= 0) {
      env.instances = 1;
    }
    timesLimit(env.instances, 1, function(n, next) {
      env.vizion_running = false;
      if (env.env && env.env.vizion_running) {
        env.env.vizion_running = false;
      }
      God.injectVariables(env, function inject(err, _env) {
        if (err)
          return next(err);
        return God.executeApp(Utility.clone(_env), function(err2, clu2) {
          if (err2)
            return next(err2);
          God.notify("start", clu2, true);
          return next(null, Utility.clone(clu2));
        });
      });
    }, cb);
  };
  God.executeApp = function executeApp(env, cb) {
    var env_copy = Utility.clone(env);
    Utility.extend(env_copy, env_copy.env);
    env_copy["status"] = env.autostart ? cst.LAUNCHING_STATUS : cst.STOPPED_STATUS;
    env_copy["pm_uptime"] = Date.now();
    env_copy["axm_actions"] = [];
    env_copy["axm_monitor"] = {};
    env_copy["axm_options"] = {};
    env_copy["axm_dynamic"] = {};
    env_copy["vizion_running"] = env_copy["vizion_running"] !== undefined ? env_copy["vizion_running"] : false;
    if (!env_copy.created_at)
      env_copy["created_at"] = Date.now();
    if (env_copy["pm_id"] === undefined) {
      env_copy["pm_id"] = God.getNewId();
      env_copy["restart_time"] = 0;
      env_copy["unstable_restarts"] = 0;
      env_copy.pm_pid_path = env_copy.pm_pid_path.replace(/-[0-9]+\.pid$|\.pid$/g, "-" + env_copy["pm_id"] + ".pid");
      if (!env_copy["merge_logs"]) {
        ["", "_out", "_err"].forEach(function(k) {
          var key = "pm" + k + "_log_path";
          env_copy[key] && (env_copy[key] = env_copy[key].replace(/-[0-9]+\.log$|\.log$/g, "-" + env_copy["pm_id"] + ".log"));
        });
      }
      if (env_copy["watch"]) {
        God.watch.enable(env_copy);
      }
    }
    God.registerCron(env_copy);
    if (env_copy["autostart"] === false) {
      var clu = { pm2_env: env_copy, process: { pid: 0 } };
      God.clusters_db[env_copy.pm_id] = clu;
      return cb(null, clu);
    }
    var readyCb = function ready(proc) {
      if (proc.pm2_env.vizion !== false && proc.pm2_env.vizion !== "false")
        God.finalizeProcedure(proc);
      else
        God.notify("online", proc);
      if (proc.pm2_env.status !== cst.ERRORED_STATUS)
        proc.pm2_env.status = cst.ONLINE_STATUS;
      console.log(`App [${proc.pm2_env.name}:${proc.pm2_env.pm_id}] online`);
      if (cb)
        cb(null, proc);
    };
    if (env_copy.exec_mode === "cluster_mode") {
      God.nodeApp(env_copy, function nodeApp(err, clu2) {
        if (cb && err)
          return cb(err);
        if (err)
          return false;
        var old_env = God.clusters_db[clu2.pm2_env.pm_id];
        if (old_env) {
          old_env = null;
          God.clusters_db[clu2.pm2_env.pm_id] = null;
        }
        God.clusters_db[clu2.pm2_env.pm_id] = clu2;
        clu2.once("error", function(err2) {
          console.error(err2.stack || err2);
          try {
            clu2.destroy && clu2.destroy();
          } catch (e) {
            console.error(e.stack || e);
            God.handleExit(clu2, cst.ERROR_EXIT);
          }
        });
        clu2.once("disconnect", function() {
          console.log("App name:%s id:%s disconnected", clu2.pm2_env.name, clu2.pm2_env.pm_id);
        });
        clu2.once("exit", function cluExit(code, signal) {
          God.handleExit(clu2, code || 0, signal || "SIGINT");
        });
        return clu2.once("online", function() {
          if (!clu2.pm2_env.wait_ready)
            return readyCb(clu2);
          var ready_timeout = setTimeout(function() {
            God.bus.removeListener("process:msg", listener);
            return readyCb(clu2);
          }, clu2.pm2_env.listen_timeout || cst.GRACEFUL_LISTEN_TIMEOUT);
          var listener = function(packet) {
            if (packet.raw === "ready" && packet.process.name === clu2.pm2_env.name && packet.process.pm_id === clu2.pm2_env.pm_id) {
              clearTimeout(ready_timeout);
              God.bus.removeListener("process:msg", listener);
              return readyCb(clu2);
            }
          };
          God.bus.on("process:msg", listener);
        });
      });
    } else {
      God.forkMode(env_copy, function forkMode(err, clu2) {
        if (cb && err)
          return cb(err);
        if (err)
          return false;
        var old_env = God.clusters_db[clu2.pm2_env.pm_id];
        if (old_env)
          old_env = null;
        God.clusters_db[env_copy.pm_id] = clu2;
        clu2.once("error", function cluError(err2) {
          console.error(err2.stack || err2);
          try {
            clu2.kill && clu2.kill();
          } catch (e) {
            console.error(e.stack || e);
            God.handleExit(clu2, cst.ERROR_EXIT);
          }
        });
        clu2.once("exit", function cluClose(code, signal) {
          if (clu2.connected === true)
            clu2.disconnect && clu2.disconnect();
          clu2._reloadLogs = null;
          return God.handleExit(clu2, code || 0, signal);
        });
        if (!clu2.pm2_env.wait_ready)
          return readyCb(clu2);
        var ready_timeout = setTimeout(function() {
          God.bus.removeListener("process:msg", listener);
          return readyCb(clu2);
        }, clu2.pm2_env.listen_timeout || cst.GRACEFUL_LISTEN_TIMEOUT);
        var listener = function(packet) {
          if (packet.raw === "ready" && packet.process.name === clu2.pm2_env.name && packet.process.pm_id === clu2.pm2_env.pm_id) {
            clearTimeout(ready_timeout);
            God.bus.removeListener("process:msg", listener);
            return readyCb(clu2);
          }
        };
        God.bus.on("process:msg", listener);
      });
    }
    return false;
  };
  God.handleExit = function handleExit(clu, exit_code, kill_signal) {
    console.log(`App [${clu.pm2_env.name}:${clu.pm2_env.pm_id}] exited with code [${exit_code}] via signal [${kill_signal || "SIGINT"}]`);
    var proc = this.clusters_db[clu.pm2_env.pm_id];
    if (!proc) {
      console.error("Process undefined ? with process id ", clu.pm2_env.pm_id);
      return false;
    }
    var stopExitCodes = proc.pm2_env.stop_exit_codes !== undefined && proc.pm2_env.stop_exit_codes !== null ? proc.pm2_env.stop_exit_codes : [];
    if (!Array.isArray(stopExitCodes)) {
      stopExitCodes = [stopExitCodes];
    }
    var stopping = proc.pm2_env.status == cst.STOPPING_STATUS || proc.pm2_env.status == cst.STOPPED_STATUS || proc.pm2_env.status == cst.ERRORED_STATUS || (proc.pm2_env.autorestart === false || proc.pm2_env.autorestart === "false") || stopExitCodes.map((strOrNum) => typeof strOrNum === "string" ? parseInt(strOrNum, 10) : strOrNum).includes(exit_code);
    var overlimit = false;
    if (stopping)
      proc.process.pid = 0;
    if (proc.pm2_env.axm_actions)
      proc.pm2_env.axm_actions = [];
    if (proc.pm2_env.axm_monitor)
      proc.pm2_env.axm_monitor = {};
    if (proc.pm2_env.status != cst.ERRORED_STATUS && proc.pm2_env.status != cst.STOPPING_STATUS)
      proc.pm2_env.status = cst.STOPPED_STATUS;
    if (proc.pm2_env.pm_id.toString().indexOf("_old_") !== 0) {
      try {
        fs.unlinkSync(proc.pm2_env.pm_pid_path);
      } catch (e) {
        debug("Error when unlinking pid file", e);
      }
    }
    var min_uptime = typeof proc.pm2_env.min_uptime !== "undefined" ? proc.pm2_env.min_uptime : 1000;
    var max_restarts = typeof proc.pm2_env.max_restarts !== "undefined" ? proc.pm2_env.max_restarts : 16;
    if (Date.now() - proc.pm2_env.created_at < min_uptime * max_restarts) {
      if (Date.now() - proc.pm2_env.pm_uptime < min_uptime) {
        proc.pm2_env.unstable_restarts += 1;
      }
    }
    if (proc.pm2_env.unstable_restarts >= max_restarts) {
      proc.pm2_env.status = cst.ERRORED_STATUS;
      proc.process.pid = 0;
      console.log("Script %s had too many unstable restarts (%d). Stopped. %j", proc.pm2_env.pm_exec_path, proc.pm2_env.unstable_restarts, proc.pm2_env.status);
      God.notify("restart overlimit", proc);
      proc.pm2_env.unstable_restarts = 0;
      proc.pm2_env.created_at = null;
      overlimit = true;
    }
    if (typeof exit_code !== "undefined")
      proc.pm2_env.exit_code = exit_code;
    God.notify("exit", proc);
    if (God.pm2_being_killed) {
      return false;
    }
    var restart_delay = 0;
    if (proc.pm2_env.restart_delay !== undefined && !isNaN(parseInt(proc.pm2_env.restart_delay))) {
      proc.pm2_env.status = cst.WAITING_RESTART;
      restart_delay = parseInt(proc.pm2_env.restart_delay);
    }
    if (proc.pm2_env.exp_backoff_restart_delay !== undefined && !isNaN(parseInt(proc.pm2_env.exp_backoff_restart_delay))) {
      proc.pm2_env.status = cst.WAITING_RESTART;
      if (!proc.pm2_env.prev_restart_delay) {
        proc.pm2_env.prev_restart_delay = proc.pm2_env.exp_backoff_restart_delay;
        restart_delay = proc.pm2_env.exp_backoff_restart_delay;
      } else {
        proc.pm2_env.prev_restart_delay = Math.floor(Math.min(15000, proc.pm2_env.prev_restart_delay * 1.5));
        restart_delay = proc.pm2_env.prev_restart_delay;
      }
      console.log(`App [${clu.pm2_env.name}:${clu.pm2_env.pm_id}] will restart in ${restart_delay}ms`);
    }
    if (!stopping && !overlimit) {
      Object.defineProperty(proc.pm2_env, "restart_task", { configurable: true, writable: true });
      proc.pm2_env.restart_task = setTimeout(function() {
        proc.pm2_env.restart_time += 1;
        God.executeApp(proc.pm2_env);
      }, restart_delay);
    }
    return false;
  };
  God.finalizeProcedure = function finalizeProcedure(proc) {
    var last_path = "";
    var current_path = proc.pm2_env.cwd || path2.dirname(proc.pm2_env.pm_exec_path);
    var proc_id = proc.pm2_env.pm_id;
    proc.pm2_env.version = Utility.findPackageVersion(proc.pm2_env.pm_exec_path || proc.pm2_env.cwd);
    if (proc.pm2_env.vizion_running === true) {
      debug("Vizion is already running for proc id: %d, skipping this round", proc_id);
      return God.notify("online", proc);
    }
    proc.pm2_env.vizion_running = true;
    vizion.analyze({ folder: current_path }, function recur_path(err, meta2) {
      var proc2 = God.clusters_db[proc_id];
      if (err)
        debug(err.stack || err);
      if (!proc2 || !proc2.pm2_env || proc2.pm2_env.status == cst.STOPPED_STATUS || proc2.pm2_env.status == cst.STOPPING_STATUS || proc2.pm2_env.status == cst.ERRORED_STATUS) {
        return console.error("Cancelling versioning data parsing");
      }
      proc2.pm2_env.vizion_running = false;
      if (!err) {
        proc2.pm2_env.versioning = meta2;
        proc2.pm2_env.versioning.repo_path = current_path;
        God.notify("online", proc2);
      } else if (err && current_path === last_path) {
        proc2.pm2_env.versioning = null;
        God.notify("online", proc2);
      } else {
        last_path = current_path;
        current_path = path2.dirname(current_path);
        proc2.pm2_env.vizion_running = true;
        vizion.analyze({ folder: current_path }, recur_path);
      }
      return false;
    });
  };
  God.injectVariables = function injectVariables(env, cb) {
    var instanceKey = process.env.PM2_PROCESS_INSTANCE_VAR || env.instance_var;
    var instances = Object.keys(God.clusters_db).map(function(procId) {
      return God.clusters_db[procId];
    }).filter(function(proc) {
      return proc.pm2_env.name === env.name && typeof proc.pm2_env[instanceKey] !== "undefined";
    }).map(function(proc) {
      return proc.pm2_env[instanceKey];
    }).sort(function(a, b) {
      return b - a;
    });
    var instanceNumber = typeof instances[0] === "undefined" ? 0 : instances[0] + 1;
    for (var i = 0;i < instances.length; i++) {
      if (instances.indexOf(i) === -1) {
        instanceNumber = i;
        break;
      }
    }
    env[instanceKey] = instanceNumber;
    if (env.increment_var) {
      var lastIncrement = Object.keys(God.clusters_db).map(function(procId) {
        return God.clusters_db[procId];
      }).filter(function(proc) {
        return proc.pm2_env.name === env.name && typeof proc.pm2_env[env.increment_var] !== "undefined";
      }).map(function(proc) {
        return Number(proc.pm2_env[env.increment_var]);
      }).sort(function(a, b) {
        return b - a;
      })[0];
      var defaut = Number(env.env[env.increment_var]) || 0;
      env[env.increment_var] = typeof lastIncrement === "undefined" ? defaut : lastIncrement + 1;
      env.env[env.increment_var] = env[env.increment_var];
    }
    return cb(null, env);
  };
  God.init();
});

// ../../node_modules/pm2/lib/tools/fmt.js
var require_fmt = __commonJS((exports2, module2) => {
  var util = __require("util");
  var sep = "===============================================================================";
  var line = "-------------------------------------------------------------------------------";
  var field = "                    ";
  exports2.separator = function() {
    console.log(sep);
  };
  exports2.sep = exports2.separator;
  exports2.line = function() {
    console.log(line);
  };
  exports2.title = function(title) {
    var out = "--- " + title + " ";
    out += line.substr(out.length);
    console.log(out);
  };
  exports2.field = function(key, value) {
    console.log("" + key + field.substr(key.length) + " : " + value);
  };
  exports2.subfield = function(key, value) {
    console.log("- " + key + field.substr(key.length + 2) + " : " + value);
  };
  exports2.li = function(msg) {
    console.log("* " + msg);
  };
  exports2.dump = function(data, name2) {
    if (name2) {
      console.log(name2 + " :", util.inspect(data, false, null, true));
    } else {
      console.log(util.inspect(data, false, null, true));
    }
  };
  exports2.msg = function(msg) {
    console.log(msg);
  };
});

// ../../node_modules/pm2/lib/Daemon.js
var require_Daemon = __commonJS((exports2, module2) => {
  var __dirname = "C:\\Users\\balle\\Documents\\GitHub\\echoesmd\\node_modules\\pm2\\lib";
  var debug = require_src()("pm2:daemon");
  var pkg = require_package();
  var cst = require_constants2();
  var rpc = require_pm2_axon_rpc();
  var axon = require_lib2();
  var domain = __require("domain");
  var Utility = require_Utility();
  var util = __require("util");
  var fs = __require("fs");
  var God = require_God();
  var eachLimit = require_eachLimit();
  var fmt = require_fmt();
  var semver = require_semver2();
  var Daemon = module2.exports = function(opts) {
    if (!opts)
      opts = {};
    this.ignore_signals = opts.ignore_signals || false;
    this.rpc_socket_ready = false;
    this.pub_socket_ready = false;
    this.pub_socket_file = opts.pub_socket_file || cst.DAEMON_PUB_PORT;
    this.rpc_socket_file = opts.rpc_socket_file || cst.DAEMON_RPC_PORT;
    this.pid_path = opts.pid_file || cst.PM2_PID_FILE_PATH;
  };
  Daemon.prototype.start = function() {
    var that = this;
    var d = domain.create();
    d.once("error", function(err) {
      fmt.sep();
      fmt.title("PM2 global error caught");
      fmt.field("Time", new Date);
      console.error(err.message);
      console.error(err.stack);
      fmt.sep();
      console.error("[PM2] Resurrecting PM2");
      var path2 = cst.IS_WINDOWS ? __dirname + "/../bin/pm2" : process.env["_"];
      var fork_new_pm2 = __require("child_process").spawn("node", [path2, "update"], {
        detached: true,
        windowsHide: true,
        stdio: "inherit"
      });
      fork_new_pm2.on("close", function() {
        console.log("PM2 successfully forked");
        process.exit(0);
      });
    });
    d.run(function() {
      that.innerStart();
    });
  };
  Daemon.prototype.innerStart = function(cb) {
    var that = this;
    if (!cb)
      cb = function() {
        fmt.sep();
        fmt.title("New PM2 Daemon started");
        fmt.field("Time", new Date);
        fmt.field("PM2 version", pkg.version);
        fmt.field("Node.js version", process.versions.node);
        fmt.field("Current arch", process.arch);
        fmt.field("PM2 home", cst.PM2_HOME);
        fmt.field("PM2 PID file", that.pid_path);
        fmt.field("RPC socket file", that.rpc_socket_file);
        fmt.field("BUS socket file", that.pub_socket_file);
        fmt.field("Application log path", cst.DEFAULT_LOG_PATH);
        fmt.field("Worker Interval", cst.WORKER_INTERVAL);
        fmt.field("Process dump file", cst.DUMP_FILE_PATH);
        fmt.field("Concurrent actions", cst.CONCURRENT_ACTIONS);
        fmt.field("SIGTERM timeout", cst.KILL_TIMEOUT);
        fmt.sep();
      };
    try {
      fs.writeFileSync(that.pid_path, process.pid.toString());
    } catch (e) {
      console.error(e.stack || e);
    }
    if (this.ignore_signals != true)
      this.handleSignals();
    this.pub = axon.socket("pub-emitter");
    this.pub_socket = this.pub.bind(this.pub_socket_file);
    this.pub_socket.once("bind", function() {
      fs.chmod(that.pub_socket_file, "775", function(e) {
        if (e)
          console.error(e);
        try {
          if (process.env.PM2_SOCKET_USER && process.env.PM2_SOCKET_GROUP)
            fs.chown(that.pub_socket_file, parseInt(process.env.PM2_SOCKET_USER), parseInt(process.env.PM2_SOCKET_GROUP), function(e2) {
              if (e2)
                console.error(e2);
            });
        } catch (e2) {
          console.error(e2);
        }
      });
      that.pub_socket_ready = true;
      that.sendReady(cb);
    });
    this.rep = axon.socket("rep");
    var server2 = new rpc.Server(this.rep);
    this.rpc_socket = this.rep.bind(this.rpc_socket_file);
    this.rpc_socket.once("bind", function() {
      fs.chmod(that.rpc_socket_file, "775", function(e) {
        if (e)
          console.error(e);
        try {
          if (process.env.PM2_SOCKET_USER && process.env.PM2_SOCKET_GROUP)
            fs.chown(that.rpc_socket_file, parseInt(process.env.PM2_SOCKET_USER), parseInt(process.env.PM2_SOCKET_GROUP), function(e2) {
              if (e2)
                console.error(e2);
            });
        } catch (e2) {
          console.error(e2);
        }
      });
      that.rpc_socket_ready = true;
      that.sendReady(cb);
    });
    function profile(type2, msg, cb2) {
      if (semver.satisfies(process.version, "< 8"))
        return cb2(null, { error: "Node.js is not on right version" });
      var cmd;
      if (type2 === "cpu") {
        cmd = {
          enable: "Profiler.enable",
          start: "Profiler.start",
          stop: "Profiler.stop",
          disable: "Profiler.disable"
        };
      }
      if (type2 == "mem") {
        cmd = {
          enable: "HeapProfiler.enable",
          start: "HeapProfiler.startSampling",
          stop: "HeapProfiler.stopSampling",
          disable: "HeapProfiler.disable"
        };
      }
      const inspector = __require("inspector");
      var session = new inspector.Session;
      session.connect();
      var timeout = msg.timeout || 5000;
      session.post(cmd.enable, (err, data) => {
        if (err)
          return cb2(null, { error: err.message || err });
        console.log(`Starting ${cmd.start}`);
        session.post(cmd.start, (err2, data2) => {
          if (err2)
            return cb2(null, { error: err2.message || err2 });
          setTimeout(() => {
            session.post(cmd.stop, (err3, data3) => {
              if (err3)
                return cb2(null, { error: err3.message || err3 });
              const profile2 = data3.profile;
              console.log(`Stopping ${cmd.stop}`);
              session.post(cmd.disable);
              fs.writeFile(msg.pwd, JSON.stringify(profile2), (err4) => {
                if (err4)
                  return cb2(null, { error: err4.message || err4 });
                return cb2(null, { file: msg.pwd });
              });
            });
          }, timeout);
        });
      });
    }
    server2.expose({
      killMe: that.close.bind(this),
      profileCPU: profile.bind(this, "cpu"),
      profileMEM: profile.bind(this, "mem"),
      prepare: God.prepare,
      getMonitorData: God.getMonitorData,
      startProcessId: God.startProcessId,
      stopProcessId: God.stopProcessId,
      restartProcessId: God.restartProcessId,
      deleteProcessId: God.deleteProcessId,
      sendLineToStdin: God.sendLineToStdin,
      softReloadProcessId: God.softReloadProcessId,
      reloadProcessId: God.reloadProcessId,
      duplicateProcessId: God.duplicateProcessId,
      resetMetaProcessId: God.resetMetaProcessId,
      stopWatch: God.stopWatch,
      startWatch: God.startWatch,
      toggleWatch: God.toggleWatch,
      notifyByProcessId: God.notifyByProcessId,
      notifyKillPM2: God.notifyKillPM2,
      monitor: God.monitor,
      unmonitor: God.unmonitor,
      msgProcess: God.msgProcess,
      sendDataToProcessId: God.sendDataToProcessId,
      sendSignalToProcessId: God.sendSignalToProcessId,
      sendSignalToProcessName: God.sendSignalToProcessName,
      ping: God.ping,
      getVersion: God.getVersion,
      getReport: God.getReport,
      reloadLogs: God.reloadLogs
    });
    this.startLogic();
  };
  Daemon.prototype.close = function(opts, cb) {
    var that = this;
    God.bus.emit("pm2:kill", {
      status: "killed",
      msg: "pm2 has been killed via CLI"
    });
    if (God.system_infos_proc !== null)
      God.system_infos_proc.kill();
    that.rpc_socket.close(function() {
      that.pub_socket.close(function() {
        if (cst.IS_WINDOWS === false) {
          try {
            process.kill(parseInt(opts.pid), "SIGQUIT");
          } catch (e) {
            console.error("Could not send SIGQUIT to CLI");
          }
        }
        try {
          fs.unlinkSync(that.pid_path);
        } catch (e) {
        }
        console.log("PM2 successfully stopped");
        setTimeout(function() {
          process.exit(cst.SUCCESS_EXIT);
        }, 2);
      });
    });
  };
  Daemon.prototype.handleSignals = function() {
    var that = this;
    process.on("SIGTERM", that.gracefullExit.bind(this));
    process.on("SIGINT", that.gracefullExit.bind(this));
    process.on("SIGHUP", function() {
    });
    process.on("SIGQUIT", that.gracefullExit.bind(this));
    process.on("SIGUSR2", function() {
      God.reloadLogs({}, function() {
      });
    });
  };
  Daemon.prototype.sendReady = function(cb) {
    if (this.rpc_socket_ready == true && this.pub_socket_ready == true) {
      cb(null, {
        pid: process.pid,
        pm2_version: pkg.version
      });
      if (typeof process.send != "function")
        return false;
      process.send({
        online: true,
        success: true,
        pid: process.pid,
        pm2_version: pkg.version
      });
    }
  };
  Daemon.prototype.gracefullExit = function() {
    var that = this;
    if (this.isExiting)
      return;
    this.isExiting = true;
    God.bus.emit("pm2:kill", {
      status: "killed",
      msg: "pm2 has been killed by SIGNAL"
    });
    console.log("pm2 has been killed by signal, dumping process list before exit...");
    if (God.system_infos_proc !== null)
      God.system_infos_proc.kill();
    God.dumpProcessList(function() {
      var processes = God.getFormatedProcesses();
      eachLimit(processes, 1, function(proc, next) {
        console.log("Deleting process %s", proc.pm2_env.pm_id);
        God.deleteProcessId(proc.pm2_env.pm_id, function() {
          return next();
        });
      }, function(err) {
        try {
          fs.unlinkSync(that.pid_path);
        } catch (e) {
        }
        setTimeout(function() {
          that.isExiting = false;
          console.log("Exited peacefully");
          process.exit(cst.SUCCESS_EXIT);
        }, 2);
      });
    });
  };
  Daemon.prototype.startLogic = function() {
    var that = this;
    God.bus.on("axm:action", function axmActions(msg) {
      var pm2_env = msg.process;
      var exists = false;
      var axm_action = msg.data;
      if (!pm2_env || !God.clusters_db[pm2_env.pm_id])
        return console.error("AXM ACTION Unknown id %s", pm2_env.pm_id);
      if (!God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions)
        God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions = [];
      God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions.forEach(function(actions) {
        if (actions.action_name == axm_action.action_name)
          exists = true;
      });
      if (exists === false) {
        debug("Adding action", axm_action);
        God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions.push(axm_action);
      }
      msg = null;
    });
    God.bus.on("axm:option:configuration", function axmMonitor(msg) {
      if (!msg.process)
        return console.error("[axm:option:configuration] no process defined");
      if (!God.clusters_db[msg.process.pm_id])
        return console.error("[axm:option:configuration] Unknown id %s", msg.process.pm_id);
      try {
        if (msg.data.name)
          God.clusters_db[msg.process.pm_id].pm2_env.name = msg.data.name;
        Object.keys(msg.data).forEach(function(conf_key) {
          God.clusters_db[msg.process.pm_id].pm2_env.axm_options[conf_key] = Utility.clone(msg.data[conf_key]);
        });
      } catch (e) {
        console.error(e.stack || e);
      }
      msg = null;
    });
    God.bus.on("axm:monitor", function axmMonitor(msg) {
      if (!msg.process)
        return console.error("[axm:monitor] no process defined");
      if (!msg.process || !God.clusters_db[msg.process.pm_id])
        return console.error("AXM MONITOR Unknown id %s", msg.process.pm_id);
      Object.assign(God.clusters_db[msg.process.pm_id].pm2_env.axm_monitor, Utility.clone(msg.data));
      msg = null;
    });
    God.bus.onAny(function(event, data_v) {
      if ([
        "axm:action",
        "axm:monitor",
        "axm:option:setPID",
        "axm:option:configuration"
      ].indexOf(event) > -1) {
        data_v = null;
        return false;
      }
      that.pub.emit(event, Utility.clone(data_v));
      data_v = null;
    });
  };
  if (__require.main === module2) {
    process.title = process.env.PM2_DAEMON_TITLE || "PM2 v" + pkg.version + ": God Daemon (" + process.env.PM2_HOME + ")";
    daemon = new Daemon;
    daemon.start();
  }
  var daemon;
});

// ../../node_modules/pm2/lib/Client.js
var require_Client = __commonJS((exports2, module2) => {
  var noop = function() {
  };
  var __dirname = "C:\\Users\\balle\\Documents\\GitHub\\echoesmd\\node_modules\\pm2\\lib";
  var debug = require_src()("pm2:client");
  var Common = require_Common();
  var KMDaemon = require_InteractorClient();
  var rpc = require_pm2_axon_rpc();
  var forEach2 = require_forEach();
  var axon = require_lib2();
  var util = __require("util");
  var fs = __require("fs");
  var path2 = __require("path");
  var pkg = require_package();
  var which = require_which();
  var Client = module2.exports = function(opts) {
    if (!opts)
      opts = {};
    if (!opts.conf)
      this.conf = require_constants2();
    else {
      this.conf = opts.conf;
    }
    this.daemon_mode = typeof opts.daemon_mode === "undefined" ? true : opts.daemon_mode;
    this.pm2_home = this.conf.PM2_ROOT_PATH;
    this.secret_key = opts.secret_key;
    this.public_key = opts.public_key;
    this.machine_name = opts.machine_name;
    this.initFileStructure(this.conf);
    debug("Using RPC file %s", this.conf.DAEMON_RPC_PORT);
    debug("Using PUB file %s", this.conf.DAEMON_PUB_PORT);
    this.rpc_socket_file = this.conf.DAEMON_RPC_PORT;
    this.pub_socket_file = this.conf.DAEMON_PUB_PORT;
  };
  Client.prototype.start = function(cb) {
    var that = this;
    this.pingDaemon(function(daemonAlive) {
      if (daemonAlive === true)
        return that.launchRPC(function(err, meta2) {
          return cb(null, {
            daemon_mode: that.conf.daemon_mode,
            new_pm2_instance: false,
            rpc_socket_file: that.rpc_socket_file,
            pub_socket_file: that.pub_socket_file,
            pm2_home: that.pm2_home
          });
        });
      if (that.daemon_mode === false) {
        var Daemon = require_Daemon();
        var daemon = new Daemon({
          pub_socket_file: that.conf.DAEMON_PUB_PORT,
          rpc_socket_file: that.conf.DAEMON_RPC_PORT,
          pid_file: that.conf.PM2_PID_FILE_PATH,
          ignore_signals: true
        });
        console.log("Launching in no daemon mode");
        daemon.innerStart(function() {
          KMDaemon.launchAndInteract(that.conf, {
            machine_name: that.machine_name,
            public_key: that.public_key,
            secret_key: that.secret_key,
            pm2_version: pkg.version
          }, function(err, data, interactor_proc) {
            that.interactor_process = interactor_proc;
          });
          that.launchRPC(function(err, meta2) {
            return cb(null, {
              daemon_mode: that.conf.daemon_mode,
              new_pm2_instance: true,
              rpc_socket_file: that.rpc_socket_file,
              pub_socket_file: that.pub_socket_file,
              pm2_home: that.pm2_home
            });
          });
        });
        return false;
      }
      that.launchDaemon(function(err, child) {
        if (err) {
          Common.printError(err);
          return cb ? cb(err) : process.exit(that.conf.ERROR_EXIT);
        }
        if (!process.env.PM2_DISCRETE_MODE)
          Common.printOut(that.conf.PREFIX_MSG + "PM2 Successfully daemonized");
        that.launchRPC(function(err2, meta2) {
          return cb(null, {
            daemon_mode: that.conf.daemon_mode,
            new_pm2_instance: true,
            rpc_socket_file: that.rpc_socket_file,
            pub_socket_file: that.pub_socket_file,
            pm2_home: that.pm2_home
          });
        });
      });
    });
  };
  Client.prototype.initFileStructure = function(opts) {
    if (!fs.existsSync(opts.DEFAULT_LOG_PATH)) {
      try {
        require_mkdirp().sync(opts.DEFAULT_LOG_PATH);
      } catch (e) {
        console.error(e.stack || e);
      }
    }
    if (!fs.existsSync(opts.DEFAULT_PID_PATH)) {
      try {
        require_mkdirp().sync(opts.DEFAULT_PID_PATH);
      } catch (e) {
        console.error(e.stack || e);
      }
    }
    if (!fs.existsSync(opts.PM2_MODULE_CONF_FILE)) {
      try {
        fs.writeFileSync(opts.PM2_MODULE_CONF_FILE, "{}");
      } catch (e) {
        console.error(e.stack || e);
      }
    }
    if (!fs.existsSync(opts.DEFAULT_MODULE_PATH)) {
      try {
        require_mkdirp().sync(opts.DEFAULT_MODULE_PATH);
      } catch (e) {
        console.error(e.stack || e);
      }
    }
    if (process.env.PM2_DISCRETE_MODE) {
      try {
        fs.writeFileSync(path2.join(opts.PM2_HOME, "touch"), Date.now().toString());
      } catch (e) {
        debug(e.stack || e);
      }
    }
    if (!process.env.PM2_PROGRAMMATIC && !fs.existsSync(path2.join(opts.PM2_HOME, "touch"))) {
      var vCheck = require_VersionCheck();
      vCheck({
        state: "install",
        version: pkg.version
      });
      var dt = fs.readFileSync(path2.join(__dirname, opts.PM2_BANNER));
      console.log(dt.toString());
      try {
        fs.writeFileSync(path2.join(opts.PM2_HOME, "touch"), Date.now().toString());
      } catch (e) {
        debug(e.stack || e);
      }
    }
  };
  Client.prototype.close = function(cb) {
    var that = this;
    forEach2([
      that.disconnectRPC.bind(that),
      that.disconnectBus.bind(that)
    ], function(fn, next) {
      fn(next);
    }, cb);
  };
  Client.prototype.launchDaemon = function(opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {
        interactor: true
      };
    }
    var that = this;
    var ClientJS = path2.resolve(path2.dirname("Client.js"), "Daemon.js");
    var node_args = [];
    var out, err;
    out = fs.openSync(that.conf.PM2_LOG_FILE_PATH, "a"), err = fs.openSync(that.conf.PM2_LOG_FILE_PATH, "a");
    if (this.conf.LOW_MEMORY_ENVIRONMENT) {
      var os = __require("os");
      node_args.push("--gc-global");
      node_args.push("--max-old-space-size=" + Math.floor(os.totalmem() / 1024 / 1024));
    }
    if (process.env.PM2_NODE_OPTIONS)
      node_args = node_args.concat(process.env.PM2_NODE_OPTIONS.split(" "));
    node_args.push(ClientJS);
    if (!process.env.PM2_DISCRETE_MODE)
      Common.printOut(that.conf.PREFIX_MSG + "Spawning PM2 daemon with pm2_home=" + this.pm2_home);
    var interpreter = "node";
    if (which("node") == null)
      interpreter = process.execPath;
    var child = __require("child_process").spawn(interpreter, node_args, {
      detached: true,
      cwd: that.conf.cwd || process.cwd(),
      windowsHide: true,
      env: Object.assign({
        SILENT: that.conf.DEBUG ? !that.conf.DEBUG : true,
        PM2_HOME: that.pm2_home
      }, process.env),
      stdio: ["ipc", out, err]
    });
    function onError(e) {
      console.error(e.message || e);
      return cb ? cb(e.message || e) : false;
    }
    child.once("error", onError);
    child.unref();
    child.once("message", function(msg) {
      debug("PM2 daemon launched with return message: ", msg);
      child.removeListener("error", onError);
      child.disconnect();
      if (opts && opts.interactor == false)
        return cb(null, child);
      if (process.env.PM2_NO_INTERACTION == "true")
        return cb(null, child);
      KMDaemon.launchAndInteract(that.conf, {
        machine_name: that.machine_name,
        public_key: that.public_key,
        secret_key: that.secret_key,
        pm2_version: pkg.version
      }, function(err2, data, interactor_proc) {
        that.interactor_process = interactor_proc;
        return cb(null, child);
      });
    });
  };
  Client.prototype.pingDaemon = function pingDaemon(cb) {
    var req = axon.socket("req");
    var client = new rpc.Client(req);
    var that = this;
    debug("[PING PM2] Trying to connect to server");
    client.sock.once("reconnect attempt", function() {
      client.sock.close();
      debug("Daemon not launched");
      process.nextTick(function() {
        return cb(false);
      });
    });
    client.sock.once("error", function(e) {
      if (e.code === "EACCES") {
        fs.stat(that.conf.DAEMON_RPC_PORT, function(e2, stats) {
          if (stats.uid === 0) {
            console.error(that.conf.PREFIX_MSG_ERR + "Permission denied, to give access to current user:");
            console.log("$ sudo chown " + process.env.USER + ":" + process.env.USER + " " + that.conf.DAEMON_RPC_PORT + " " + that.conf.DAEMON_PUB_PORT);
          } else
            console.error(that.conf.PREFIX_MSG_ERR + "Permission denied, check permissions on " + that.conf.DAEMON_RPC_PORT);
          process.exit(1);
        });
      } else
        console.error(e.message || e);
    });
    client.sock.once("connect", function() {
      client.sock.once("close", function() {
        return cb(true);
      });
      client.sock.close();
      debug("Daemon alive");
    });
    req.connect(this.rpc_socket_file);
  };
  Client.prototype.launchRPC = function launchRPC(cb) {
    var self2 = this;
    debug("Launching RPC client on socket file %s", this.rpc_socket_file);
    var req = axon.socket("req");
    this.client = new rpc.Client(req);
    var connectHandler = function() {
      self2.client.sock.removeListener("error", errorHandler);
      debug("RPC Connected to Daemon");
      if (cb) {
        setTimeout(function() {
          cb(null);
        }, 4);
      }
    };
    var errorHandler = function(e) {
      self2.client.sock.removeListener("connect", connectHandler);
      if (cb) {
        return cb(e);
      }
    };
    this.client.sock.once("connect", connectHandler);
    this.client.sock.once("error", errorHandler);
    this.client_sock = req.connect(this.rpc_socket_file);
  };
  Client.prototype.disconnectRPC = function disconnectRPC(cb) {
    var that = this;
    if (!cb)
      cb = noop;
    if (!this.client_sock || !this.client_sock.close) {
      this.client = null;
      return process.nextTick(function() {
        cb(new Error("SUB connection to PM2 is not launched"));
      });
    }
    if (this.client_sock.connected === false || this.client_sock.closing === true) {
      this.client = null;
      return process.nextTick(function() {
        cb(new Error("RPC already being closed"));
      });
    }
    try {
      var timer;
      that.client_sock.once("close", function() {
        clearTimeout(timer);
        that.client = null;
        debug("PM2 RPC cleanly closed");
        return cb(null, { msg: "RPC Successfully closed" });
      });
      timer = setTimeout(function() {
        if (that.client_sock.destroy)
          that.client_sock.destroy();
        that.client = null;
        return cb(null, { msg: "RPC Successfully closed via timeout" });
      }, 200);
      that.client_sock.close();
    } catch (e) {
      debug("Error while disconnecting RPC PM2", e.stack || e);
      return cb(e);
    }
    return false;
  };
  Client.prototype.launchBus = function launchEventSystem(cb) {
    var self2 = this;
    this.sub = axon.socket("sub-emitter");
    this.sub_sock = this.sub.connect(this.pub_socket_file);
    this.sub_sock.once("connect", function() {
      return cb(null, self2.sub, self2.sub_sock);
    });
  };
  Client.prototype.disconnectBus = function disconnectBus(cb) {
    if (!cb)
      cb = noop;
    var that = this;
    if (!this.sub_sock || !this.sub_sock.close) {
      that.sub = null;
      return process.nextTick(function() {
        cb(null, { msg: "bus was not connected" });
      });
    }
    if (this.sub_sock.connected === false || this.sub_sock.closing === true) {
      that.sub = null;
      return process.nextTick(function() {
        cb(new Error("SUB connection is already being closed"));
      });
    }
    try {
      var timer;
      that.sub_sock.once("close", function() {
        that.sub = null;
        clearTimeout(timer);
        debug("PM2 PUB cleanly closed");
        return cb();
      });
      timer = setTimeout(function() {
        if (Client.sub_sock.destroy)
          that.sub_sock.destroy();
        return cb();
      }, 200);
      this.sub_sock.close();
    } catch (e) {
      return cb(e);
    }
  };
  Client.prototype.getExposedMethods = function getExposedMethods(cb) {
    this.client.methods(cb);
  };
  Client.prototype.executeRemote = function executeRemote(method, app_conf, fn) {
    var self2 = this;
    if (method.indexOf("stop") !== -1) {
      this.stopWatch(method, app_conf);
    } else if (method.indexOf("delete") !== -1) {
      this.stopWatch(method, app_conf);
    } else if (method.indexOf("kill") !== -1) {
      this.stopWatch("deleteAll", app_conf);
    } else if (method.indexOf("restartProcessId") !== -1 && process.argv.indexOf("--watch") > -1) {
      delete app_conf.env.current_conf.watch;
      this.toggleWatch(method, app_conf);
    }
    if (!this.client || !this.client.call) {
      this.start(function(error) {
        if (error) {
          if (fn)
            return fn(error);
          console.error(error);
          return process.exit(0);
        }
        if (self2.client) {
          return self2.client.call(method, app_conf, fn);
        }
      });
      return false;
    }
    debug("Calling daemon method pm2:%s on rpc socket:%s", method, this.rpc_socket_file);
    return this.client.call(method, app_conf, fn);
  };
  Client.prototype.notifyGod = function(action_name, id2, cb) {
    this.executeRemote("notifyByProcessId", {
      id: id2,
      action_name,
      manually: true
    }, function() {
      debug("God notified");
      return cb ? cb() : false;
    });
  };
  Client.prototype.killDaemon = function killDaemon(fn) {
    var timeout;
    var that = this;
    function quit() {
      that.close(function() {
        return fn ? fn(null, { success: true }) : false;
      });
    }
    if (process.platform !== "win32" && process.platform !== "win64") {
      process.once("SIGQUIT", function() {
        debug("Received SIGQUIT from pm2 daemon");
        clearTimeout(timeout);
        quit();
      });
    } else {
      setTimeout(function() {
        that.pingDaemon(function(alive) {
          if (!alive) {
            clearTimeout(timeout);
            return quit();
          }
        });
      }, 250);
    }
    timeout = setTimeout(function() {
      quit();
    }, 3000);
    this.executeRemote("killMe", { pid: process.pid });
  };
  Client.prototype.toggleWatch = function toggleWatch(method, env, fn) {
    debug("Calling toggleWatch");
    this.client.call("toggleWatch", method, env, function() {
      return fn ? fn() : false;
    });
  };
  Client.prototype.startWatch = function restartWatch(method, env, fn) {
    debug("Calling startWatch");
    this.client.call("startWatch", method, env, function() {
      return fn ? fn() : false;
    });
  };
  Client.prototype.stopWatch = function stopWatch(method, env, fn) {
    debug("Calling stopWatch");
    this.client.call("stopWatch", method, env, function() {
      return fn ? fn() : false;
    });
  };
  Client.prototype.getAllProcess = function(cb) {
    var found_proc = [];
    this.executeRemote("getMonitorData", {}, function(err, procs) {
      if (err) {
        Common.printError("Error retrieving process list: " + err);
        return cb(err);
      }
      return cb(null, procs);
    });
  };
  Client.prototype.getAllProcessId = function(cb) {
    var found_proc = [];
    this.executeRemote("getMonitorData", {}, function(err, procs) {
      if (err) {
        Common.printError("Error retrieving process list: " + err);
        return cb(err);
      }
      return cb(null, procs.map((proc) => proc.pm_id));
    });
  };
  Client.prototype.getAllProcessIdWithoutModules = function(cb) {
    var found_proc = [];
    this.executeRemote("getMonitorData", {}, function(err, procs) {
      if (err) {
        Common.printError("Error retrieving process list: " + err);
        return cb(err);
      }
      var proc_ids = procs.filter((proc) => !proc.pm2_env.pmx_module).map((proc) => proc.pm_id);
      return cb(null, proc_ids);
    });
  };
  Client.prototype.getProcessIdByName = function(name2, force_all, cb) {
    var found_proc = [];
    var full_details = {};
    if (typeof cb === "undefined") {
      cb = force_all;
      force_all = false;
    }
    if (typeof name2 == "number")
      name2 = name2.toString();
    this.executeRemote("getMonitorData", {}, function(err, list) {
      if (err) {
        Common.printError("Error retrieving process list: " + err);
        return cb(err);
      }
      list.forEach(function(proc) {
        if (proc.pm2_env.name == name2 || proc.pm2_env.pm_exec_path == path2.resolve(name2)) {
          found_proc.push(proc.pm_id);
          full_details[proc.pm_id] = proc;
        }
      });
      return cb(null, found_proc, full_details);
    });
  };
  Client.prototype.getProcessIdsByNamespace = function(namespace, force_all, cb) {
    var found_proc = [];
    var full_details = {};
    if (typeof cb === "undefined") {
      cb = force_all;
      force_all = false;
    }
    if (typeof namespace == "number")
      namespace = namespace.toString();
    this.executeRemote("getMonitorData", {}, function(err, list) {
      if (err) {
        Common.printError("Error retrieving process list: " + err);
        return cb(err);
      }
      list.forEach(function(proc) {
        if (proc.pm2_env.namespace == namespace) {
          found_proc.push(proc.pm_id);
          full_details[proc.pm_id] = proc;
        }
      });
      return cb(null, found_proc, full_details);
    });
  };
  Client.prototype.getProcessByName = function(name2, cb) {
    var found_proc = [];
    this.executeRemote("getMonitorData", {}, function(err, list) {
      if (err) {
        Common.printError("Error retrieving process list: " + err);
        return cb(err);
      }
      list.forEach(function(proc) {
        if (proc.pm2_env.name == name2 || proc.pm2_env.pm_exec_path == path2.resolve(name2)) {
          found_proc.push(proc);
        }
      });
      return cb(null, found_proc);
    });
  };
  Client.prototype.getProcessByNameOrId = function(nameOrId, cb) {
    var foundProc = [];
    this.executeRemote("getMonitorData", {}, function(err, list) {
      if (err) {
        Common.printError("Error retrieving process list: " + err);
        return cb(err);
      }
      list.forEach(function(proc) {
        if (proc.pm2_env.name === nameOrId || proc.pm2_env.pm_exec_path === path2.resolve(nameOrId) || proc.pid === parseInt(nameOrId) || proc.pm2_env.pm_id === parseInt(nameOrId)) {
          foundProc.push(proc);
        }
      });
      return cb(null, foundProc);
    });
  };
});

// ../../node_modules/async/forEachLimit.js
var require_forEachLimit = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachLimit = function(coll, limit, iteratee, callback) {
    return (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _eachOfLimit = require_eachOfLimit();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _withoutIndex = require_withoutIndex();
  var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports2.default = (0, _awaitify2.default)(eachLimit, 4);
  module2.exports = exports2.default;
});

// ../../node_modules/pm2/lib/tools/sexec.js
var require_sexec = __commonJS((exports2, module2) => {
  var _exec = function(command, options2, callback) {
    options2 = options2 || {};
    if (typeof options2 === "function") {
      callback = options2;
    }
    if (typeof options2 === "object" && typeof callback === "function") {
      options2.async = true;
    }
    if (!command) {
      try {
        console.error("[sexec] must specify command");
      } catch (e) {
        return;
      }
    }
    options2 = Object.assign({
      silent: false,
      cwd: path2.resolve(process.cwd()).toString(),
      env: process.env,
      maxBuffer: DEFAULT_MAXBUFFER_SIZE,
      encoding: "utf8"
    }, options2);
    var c = child.exec(command, options2, function(err, stdout, stderr) {
      if (callback) {
        if (!err) {
          callback(0, stdout, stderr);
        } else if (err.code === undefined) {
          callback(1, stdout, stderr);
        } else {
          callback(err.code, stdout, stderr);
        }
      }
    });
    if (!options2.silent) {
      c.stdout.pipe(process.stdout);
      c.stderr.pipe(process.stderr);
    }
  };
  var path2 = __require("path");
  var fs = __require("fs");
  var child = __require("child_process");
  var DEFAULT_MAXBUFFER_SIZE = 20 * 1024 * 1024;
  module2.exports = _exec;
});

// ../../node_modules/pm2/lib/tools/copydirSync.js
var require_copydirSync = __commonJS((exports2, module2) => {
  var copydirSync = function(from3, to, options2) {
    if (typeof options2 === "function") {
      options2 = {
        filter: options2
      };
    }
    if (typeof options2 === "undefined")
      options2 = {};
    if (typeof options2.cover === "undefined") {
      options2.cover = true;
    }
    options2.filter = typeof options2.filter === "function" ? options2.filter : function(state, filepath, filename) {
      return options2.filter;
    };
    var stats = fs.lstatSync(from3);
    var statsname = stats.isDirectory() ? "directory" : stats.isFile() ? "file" : stats.isSymbolicLink() ? "symbolicLink" : "";
    var valid = options2.filter(statsname, from3, path2.dirname(from3), path2.basename(from3));
    if (statsname === "directory" || statsname === "symbolicLink") {
      if (valid) {
        try {
          fs.statSync(to);
        } catch (err) {
          if (err.code === "ENOENT") {
            fs.mkdirSync(to);
            options2.debug && console.log(">> " + to);
          } else {
            throw err;
          }
        }
        rewriteSync(to, options2, stats);
        if (statsname != "symbolicLink")
          listDirectorySync(from3, to, options2);
      }
    } else if (stats.isFile()) {
      if (valid) {
        if (options2.cover) {
          writeFileSync(from3, to, options2, stats);
        } else {
          try {
            fs.statSync(to);
          } catch (err) {
            if (err.code === "ENOENT") {
              writeFileSync(from3, to, options2, stats);
            } else {
              throw err;
            }
          }
        }
      }
    } else {
      throw new Error("stats invalid: " + from3);
    }
  };
  var listDirectorySync = function(from3, to, options2) {
    var files2 = fs.readdirSync(from3);
    copyFromArraySync(files2, from3, to, options2);
  };
  var copyFromArraySync = function(files2, from3, to, options2) {
    if (files2.length === 0)
      return true;
    var f = files2.shift();
    copydirSync(path2.join(from3, f), path2.join(to, f), options2);
    copyFromArraySync(files2, from3, to, options2);
  };
  var writeFileSync = function(from3, to, options2, stats) {
    fs.writeFileSync(to, fs.readFileSync(from3, "binary"), "binary");
    options2.debug && console.log(">> " + to);
    rewriteSync(to, options2, stats);
  };
  var rewriteSync = function(f, options2, stats, callback) {
    if (options2.cover) {
      var mode = options2.mode === true ? stats.mode : options2.mode;
      var utimes = options2.utimes === true ? {
        atime: stats.atime,
        mtime: stats.mtime
      } : options2.utimes;
      mode && fs.chmodSync(f, mode);
      utimes && fs.utimesSync(f, utimes.atime, utimes.mtime);
    }
    return true;
  };
  var fs = __require("fs");
  var path2 = __require("path");
  module2.exports = copydirSync;
});

// ../../node_modules/pm2/lib/tools/deleteFolderRecursive.js
var require_deleteFolderRecursive = __commonJS((exports2, module2) => {
  var fs = __require("fs");
  var Path = __require("path");
  var deleteFolderRecursive = function(path2) {
    if (fs.existsSync(path2)) {
      fs.readdirSync(path2).forEach((file, index) => {
        const curPath = Path.join(path2, file);
        if (fs.lstatSync(curPath).isDirectory()) {
          deleteFolderRecursive(curPath);
        } else {
          fs.unlinkSync(curPath);
        }
      });
      fs.rmdirSync(path2);
    }
  };
  module2.exports = deleteFolderRecursive;
});

// ../../node_modules/pm2/lib/API/Modules/NPM.js
var require_NPM = __commonJS((exports2, module2) => {
  var localStart = function(PM2, opts, cb) {
    var proc_path = "", cmd = "", conf2 = {};
    Common.printOut(cst.PREFIX_MSG_MOD + "Installing local module in DEVELOPMENT MODE with WATCH auto restart");
    proc_path = process.cwd();
    cmd = path2.join(proc_path, cst.DEFAULT_MODULE_JSON);
    Common.extend(opts, {
      cmd,
      development_mode: true,
      proc_path
    });
    return StartModule(PM2, opts, function(err, dt) {
      if (err)
        return cb(err);
      Common.printOut(cst.PREFIX_MSG_MOD + "Module successfully installed and launched");
      return cb(null, dt);
    });
  };
  var generateSample = function(app_name, cb) {
    var rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    function samplize(module_name) {
      var cmd1 = "git clone https://github.com/pm2-hive/sample-module.git " + module_name + "; cd " + module_name + "; rm -rf .git";
      var cmd2 = "cd " + module_name + ' ; sed -i "s:sample-module:' + module_name + ':g" package.json';
      var cmd3 = "cd " + module_name + " ; npm install";
      Common.printOut(cst.PREFIX_MSG_MOD + "Getting sample app");
      sexec(cmd1, function(err) {
        if (err)
          Common.printError(cst.PREFIX_MSG_MOD_ERR + err.message);
        sexec(cmd2, function(err2) {
          console.log("");
          sexec(cmd3, function(err3) {
            console.log("");
            Common.printOut(cst.PREFIX_MSG_MOD + "Module sample created in folder: ", path2.join(process.cwd(), module_name));
            console.log("");
            Common.printOut("Start module in development mode:");
            Common.printOut("$ cd " + module_name + "/");
            Common.printOut("$ pm2 install . ");
            console.log("");
            Common.printOut("Module Log: ");
            Common.printOut("$ pm2 logs " + module_name);
            console.log("");
            Common.printOut("Uninstall module: ");
            Common.printOut("$ pm2 uninstall " + module_name);
            console.log("");
            Common.printOut("Force restart: ");
            Common.printOut("$ pm2 restart " + module_name);
            return cb ? cb() : false;
          });
        });
      });
    }
    if (app_name)
      return samplize(app_name);
    rl.question(cst.PREFIX_MSG_MOD + "Module name: ", function(module_name) {
      samplize(module_name);
    });
  };
  var publish = function(opts, cb) {
    var rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    var semver = require_semver2();
    var package_file = path2.join(process.cwd(), "package.json");
    var package_json = __require(package_file);
    package_json.version = semver.inc(package_json.version, "minor");
    Common.printOut(cst.PREFIX_MSG_MOD + "Incrementing module to: %s@%s", package_json.name, package_json.version);
    rl.question("Write & Publish? [Y/N]", function(answer) {
      if (answer != "Y")
        return cb();
      fs.writeFile(package_file, JSON.stringify(package_json, null, 2), function(err, data) {
        if (err)
          return cb(err);
        Common.printOut(cst.PREFIX_MSG_MOD + "Publishing module - %s@%s", package_json.name, package_json.version);
        sexec("npm publish", function(code) {
          Common.printOut(cst.PREFIX_MSG_MOD + "Module - %s@%s successfully published", package_json.name, package_json.version);
          Common.printOut(cst.PREFIX_MSG_MOD + "Pushing module on Git");
          sexec('git add . ; git commit -m "' + package_json.version + '"; git push origin master', function(code2) {
            Common.printOut(cst.PREFIX_MSG_MOD + "Installable with pm2 install %s", package_json.name);
            return cb(null, package_json);
          });
        });
      });
    });
  };
  var moduleExistInLocalDB = function(CLI, module_name, cb) {
    var modules = Configuration.getSync(cst.MODULE_CONF_PREFIX);
    if (!modules)
      return cb(false);
    var module_name_only = Utility.getCanonicModuleName(module_name);
    modules = Object.keys(modules);
    return cb(modules.indexOf(module_name_only) > -1 ? true : false);
  };
  var install = function(CLI, module_name, opts, cb) {
    moduleExistInLocalDB(CLI, module_name, function(exists) {
      if (exists) {
        Common.logMod("Module already installed. Updating.");
        Rollback.backup(module_name);
        return uninstall(CLI, module_name, function() {
          return continueInstall(CLI, module_name, opts, cb);
        });
      }
      return continueInstall(CLI, module_name, opts, cb);
    });
  };
  var getNPMCommandLine = function(module_name, install_path) {
    if (which("npm")) {
      return spawn.bind(this, cst.IS_WINDOWS ? "npm.cmd" : "npm", ["install", module_name, "--loglevel=error", "--prefix", `"${install_path}"`], {
        stdio: "inherit",
        env: process.env,
        windowsHide: true,
        shell: true
      });
    } else {
      return spawn.bind(this, cst.BUILTIN_NODE_PATH, [cst.BUILTIN_NPM_PATH, "install", module_name, "--loglevel=error", "--prefix", `"${install_path}"`], {
        stdio: "inherit",
        env: process.env,
        windowsHide: true,
        shell: true
      });
    }
  };
  var continueInstall = function(CLI, module_name, opts, cb) {
    Common.printOut(cst.PREFIX_MSG_MOD + "Calling " + chalk.bold.red("[NPM]") + " to install " + module_name + " ...");
    var canonic_module_name = Utility.getCanonicModuleName(module_name);
    var install_path = path2.join(cst.DEFAULT_MODULE_PATH, canonic_module_name);
    require_mkdirp()(install_path).then(function() {
      process.chdir(os.homedir());
      var install_instance = getNPMCommandLine(module_name, install_path)();
      install_instance.on("close", finalizeInstall);
      install_instance.on("error", function(err) {
        console.error(err.stack || err);
      });
    });
    function finalizeInstall(code) {
      if (code != 0) {
        return Rollback.revert(CLI, module_name, function() {
          return cb(new Error("Installation failed via NPM, module has been restored to prev version"));
        });
      }
      Common.printOut(cst.PREFIX_MSG_MOD + "Module downloaded");
      var proc_path = path2.join(install_path, "node_modules", canonic_module_name);
      var package_json_path = path2.join(proc_path, "package.json");
      try {
        var conf2 = JSON.parse(fs.readFileSync(package_json_path).toString()).config;
        if (conf2) {
          Object.keys(conf2).forEach(function(key) {
            Configuration.setSyncIfNotExist(canonic_module_name + ":" + key, conf2[key]);
          });
        }
      } catch (e) {
        Common.printError(e);
      }
      opts = Common.extend(opts, {
        cmd: package_json_path,
        development_mode: false,
        proc_path
      });
      Configuration.set(cst.MODULE_CONF_PREFIX + ":" + canonic_module_name, {
        uid: opts.uid,
        gid: opts.gid
      }, function(err, data) {
        if (err)
          return cb(err);
        StartModule(CLI, opts, function(err2, dt) {
          if (err2)
            return cb(err2);
          if (process.env.PM2_PROGRAMMATIC === "true")
            return cb(null, dt);
          CLI.conf(canonic_module_name, function() {
            Common.printOut(cst.PREFIX_MSG_MOD + "Module successfully installed and launched");
            Common.printOut(cst.PREFIX_MSG_MOD + "Checkout module options: `$ pm2 conf`");
            return cb(null, dt);
          });
        });
      });
    }
  };
  var start = function(PM2, modules, module_name, cb) {
    Common.printOut(cst.PREFIX_MSG_MOD + "Starting NPM module " + module_name);
    var install_path = path2.join(cst.DEFAULT_MODULE_PATH, module_name);
    var proc_path = path2.join(install_path, "node_modules", module_name);
    var package_json_path = path2.join(proc_path, "package.json");
    var opts = {};
    Common.extend(opts, modules[module_name]);
    Common.extend(opts, {
      cmd: package_json_path,
      development_mode: false,
      proc_path
    });
    StartModule(PM2, opts, function(err, dt) {
      if (err)
        console.error(err);
      return cb();
    });
  };
  var uninstall = function(CLI, module_name, cb) {
    var module_name_only = Utility.getCanonicModuleName(module_name);
    var proc_path = path2.join(cst.DEFAULT_MODULE_PATH, module_name_only);
    Configuration.unsetSync(cst.MODULE_CONF_PREFIX + ":" + module_name_only);
    CLI.deleteModule(module_name_only, function(err, data) {
      console.log("Deleting", proc_path);
      if (module_name != "." && proc_path.includes("modules") === true) {
        deleteFolderRecursive(proc_path);
      }
      if (err) {
        Common.printError(err);
        return cb(err);
      }
      return cb(null, data);
    });
  };
  var getModuleConf = function(app_name) {
    if (!app_name)
      throw new Error("No app_name defined");
    var module_conf = Configuration.getAllSync();
    var additional_env = {};
    if (!module_conf[app_name]) {
      additional_env = {};
      additional_env[app_name] = {};
    } else {
      additional_env = Common.clone(module_conf[app_name]);
      additional_env[app_name] = JSON.stringify(module_conf[app_name]);
    }
    return additional_env;
  };
  var StartModule = function(CLI, opts, cb) {
    if (!opts.cmd && !opts.package)
      throw new Error("module package.json not defined");
    if (!opts.development_mode)
      opts.development_mode = false;
    var package_json = __require(opts.cmd || opts.package);
    if (!package_json.apps && !package_json.pm2) {
      package_json.apps = {};
      if (package_json.bin) {
        var bin = Object.keys(package_json.bin)[0];
        package_json.apps.script = package_json.bin[bin];
      } else if (package_json.main) {
        package_json.apps.script = package_json.main;
      }
    }
    Common.extend(opts, {
      cwd: opts.proc_path,
      watch: opts.development_mode,
      force_name: package_json.name,
      started_as_module: true
    });
    CLI.start(package_json, opts, function(err, data) {
      if (err)
        return cb(err);
      if (opts.safe) {
        Common.printOut(cst.PREFIX_MSG_MOD + "Monitoring module behavior for potential issue (5secs...)");
        var time = typeof opts.safe == "boolean" ? 3000 : parseInt(opts.safe);
        return setTimeout(function() {
          CLI.describe(package_json.name, function(err2, apps) {
            if (err2 || apps[0].pm2_env.restart_time > 2) {
              return Rollback.revert(CLI, package_json.name, function() {
                return cb(new Error("New Module is instable, restored to previous version"));
              });
            }
            return cb(null, data);
          });
        }, time);
      }
      return cb(null, data);
    });
  };
  var path2 = __require("path");
  var fs = __require("fs");
  var os = __require("os");
  var spawn = __require("child_process").spawn;
  var chalk = require_source();
  var readline = __require("readline");
  var which = require_which();
  var sexec = require_sexec();
  var copydirSync = require_copydirSync();
  var deleteFolderRecursive = require_deleteFolderRecursive();
  var Configuration = require_Configuration();
  var cst = require_constants2();
  var Common = require_Common();
  var Utility = require_Utility();
  module2.exports = {
    install,
    uninstall,
    start,
    publish,
    generateSample,
    localStart,
    getModuleConf
  };
  var Rollback = {
    revert: function(CLI, module_name, cb) {
      var canonic_module_name = Utility.getCanonicModuleName(module_name);
      var backup_path = path2.join(__require("os").tmpdir(), canonic_module_name);
      var module_path = path2.join(cst.DEFAULT_MODULE_PATH, canonic_module_name);
      try {
        fs.statSync(backup_path);
      } catch (e) {
        return cb(new Error("no backup found"));
      }
      Common.printOut(cst.PREFIX_MSG_MOD + chalk.bold.red("[[[[[ Module installation failure! ]]]]]"));
      Common.printOut(cst.PREFIX_MSG_MOD + chalk.bold.red("[RESTORING TO PREVIOUS VERSION]"));
      CLI.deleteModule(canonic_module_name, function() {
        if (module_name.includes("modules") === true)
          deleteFolderRecursive(module_path);
        copydirSync(backup_path, path2.join(cst.DEFAULT_MODULE_PATH, canonic_module_name));
        var proc_path = path2.join(module_path, "node_modules", canonic_module_name);
        var package_json_path = path2.join(proc_path, "package.json");
        StartModule(CLI, {
          cmd: package_json_path,
          development_mode: false,
          proc_path
        }, cb);
      });
    },
    backup: function(module_name) {
      var tmpdir = __require("os").tmpdir();
      var canonic_module_name = Utility.getCanonicModuleName(module_name);
      var module_path = path2.join(cst.DEFAULT_MODULE_PATH, canonic_module_name);
      copydirSync(module_path, path2.join(tmpdir, canonic_module_name));
    }
  };
});

// ../../node_modules/needle/node_modules/debug/node_modules/ms/index.js
var require_ms2 = __commonJS((exports2, module2) => {
  var parse2 = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n, name2) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
  };
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options2) {
    options2 = options2 || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// ../../node_modules/needle/node_modules/debug/src/common.js
var require_common4 = __commonJS((exports2, module2) => {
  var setup = function(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms2();
    Object.keys(env).forEach(function(key) {
      createDebug[key] = env[key];
    });
    createDebug.instances = [];
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      var hash = 0;
      for (var i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      var prevTime;
      function debug() {
        if (!debug.enabled) {
          return;
        }
        for (var _len = arguments.length, args2 = new Array(_len), _key = 0;_key < _len; _key++) {
          args2[_key] = arguments[_key];
        }
        var self2 = debug;
        var curr = Number(new Date);
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args2[0] = createDebug.coerce(args2[0]);
        if (typeof args2[0] !== "string") {
          args2.unshift("%O");
        }
        var index = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%") {
            return match;
          }
          index++;
          var formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            var val = args2[index];
            match = formatter.call(self2, val);
            args2.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args2);
        var logFn = self2.log || createDebug.log;
        logFn.apply(self2, args2);
      }
      debug.namespace = namespace;
      debug.enabled = createDebug.enabled(namespace);
      debug.useColors = createDebug.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      debug.extend = extend;
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      createDebug.instances.push(debug);
      return debug;
    }
    function destroy() {
      var index = createDebug.instances.indexOf(this);
      if (index !== -1) {
        createDebug.instances.splice(index, 1);
        return true;
      }
      return false;
    }
    function extend(namespace, delimiter) {
      return createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      var i;
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (i = 0;i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
      for (i = 0;i < createDebug.instances.length; i++) {
        var instance = createDebug.instances[i];
        instance.enabled = createDebug.enabled(instance.namespace);
      }
    }
    function disable() {
      createDebug.enable("");
    }
    function enabled(name2) {
      if (name2[name2.length - 1] === "*") {
        return true;
      }
      var i;
      var len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name2)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  };
  module2.exports = setup;
});

// ../../node_modules/needle/node_modules/debug/src/browser.js
var require_browser2 = __commonJS((exports2, module2) => {
  var _typeof = function(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  };
  var useColors = function() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  };
  var formatArgs = function(args2) {
    args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + exports2.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    var c = "color: " + this.color;
    args2.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args2[0].replace(/%[a-zA-Z%]/g, function(match) {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args2.splice(lastC, 0, c);
  };
  var log = function() {
    var _console;
    return (typeof console === "undefined" ? "undefined" : _typeof(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
  };
  var save = function(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  };
  var load = function() {
    var r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  };
  var localstorage = function() {
    try {
      return localStorage;
    } catch (error) {
    }
  };
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
  module2.exports = require_common4()(exports2);
  var formatters = module2.exports.formatters;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// ../../node_modules/needle/node_modules/debug/src/node.js
var require_node2 = __commonJS((exports2, module2) => {
  var useColors = function() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  };
  var formatArgs = function(args2) {
    var name2 = this.namespace, useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      var prefix = "  ".concat(colorCode, ";1m").concat(name2, " \x1B[0m");
      args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
      args2.push(colorCode + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
    } else {
      args2[0] = getDate() + name2 + " " + args2[0];
    }
  };
  var getDate = function() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  };
  var log = function() {
    return process.stderr.write(util.format.apply(util, arguments) + "\n");
  };
  var save = function(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  };
  var load = function() {
    return process.env.DEBUG;
  };
  var init2 = function(debug) {
    debug.inspectOpts = {};
    var keys3 = Object.keys(exports2.inspectOpts);
    for (var i = 0;i < keys3.length; i++) {
      debug.inspectOpts[keys3[i]] = exports2.inspectOpts[keys3[i]];
    }
  };
  var tty = __require("tty");
  var util = __require("util");
  exports2.init = init2;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    supportsColor2 = require_supports_color();
    if (supportsColor2 && (supportsColor2.stderr || supportsColor2).level >= 2) {
      exports2.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
    }
  } catch (error) {
  }
  var supportsColor2;
  exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
      return k.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  module2.exports = require_common4()(exports2);
  var formatters = module2.exports.formatters;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
      return str.trim();
    }).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// ../../node_modules/needle/node_modules/debug/src/index.js
var require_src2 = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module2.exports = require_browser2();
  } else {
    module2.exports = require_node2();
  }
});

// ../../node_modules/needle/lib/querystring.js
var require_querystring = __commonJS((exports2) => {
  var stringify2 = function(obj, prefix) {
    if (prefix && (obj === null || typeof obj == "undefined")) {
      return prefix + "=";
    } else if (toString.call(obj) == "[object Array]") {
      return stringifyArray(obj, prefix);
    } else if (toString.call(obj) == "[object Object]") {
      return stringifyObject(obj, prefix);
    } else if (toString.call(obj) == "[object Date]") {
      return obj.toISOString();
    } else if (prefix) {
      return prefix + "=" + encodeURIComponent(String(obj));
    } else if (String(obj).indexOf("=") !== -1) {
      return String(obj);
    } else {
      throw new TypeError("Cannot build a querystring out of: " + obj);
    }
  };
  var stringifyArray = function(arr, prefix) {
    var ret = [];
    for (var i = 0, len = arr.length;i < len; i++) {
      if (prefix)
        ret.push(stringify2(arr[i], prefix + "[]"));
      else
        ret.push(stringify2(arr[i]));
    }
    return ret.join("&");
  };
  var stringifyObject = function(obj, prefix) {
    var ret = [];
    Object.keys(obj).forEach(function(key) {
      ret.push(stringify2(obj[key], prefix ? prefix + "[" + encodeURIComponent(key) + "]" : encodeURIComponent(key)));
    });
    return ret.join("&");
  };
  var toString = Object.prototype.toString;
  exports2.build = stringify2;
});

// ../../node_modules/needle/lib/multipart.js
var require_multipart = __commonJS((exports2) => {
  var generate_part = function(name2, part, boundary, callback) {
    var return_part = "--" + boundary + "\r\n";
    return_part += 'Content-Disposition: form-data; name="' + name2 + '"';
    function append(data, filename2) {
      if (data) {
        var binary = part.content_type.indexOf("text") == -1;
        return_part += '; filename="' + encodeURIComponent(filename2) + '"\r\n';
        if (binary)
          return_part += "Content-Transfer-Encoding: binary\r\n";
        return_part += "Content-Type: " + part.content_type + "\r\n\r\n";
        return_part += binary ? data.toString("binary") : data.toString("utf8");
      }
      callback(null, return_part + "\r\n");
    }
    if ((part.file || part.buffer) && part.content_type) {
      var filename = part.filename ? part.filename : part.file ? basename(part.file) : name2;
      if (part.buffer)
        return append(part.buffer, filename);
      readFile(part.file, function(err, data) {
        if (err)
          return callback(err);
        append(data, filename);
      });
    } else {
      if (typeof part.value == "object")
        return callback(new Error("Object received for " + name2 + ", expected string."));
      if (part.content_type) {
        return_part += "\r\n";
        return_part += "Content-Type: " + part.content_type;
      }
      return_part += "\r\n\r\n";
      return_part += Buffer.from(String(part.value), "utf8").toString("binary");
      append();
    }
  };
  var flatten = function(object, into, prefix) {
    into = into || {};
    for (var key in object) {
      var prefix_key = prefix ? prefix + "[" + key + "]" : key;
      var prop = object[key];
      if (prop && typeof prop === "object" && !(prop.buffer || prop.file || prop.content_type))
        flatten(prop, into, prefix_key);
      else
        into[prefix_key] = prop;
    }
    return into;
  };
  var readFile = __require("fs").readFile;
  var basename = __require("path").basename;
  exports2.build = function(data, boundary, callback) {
    if (typeof data != "object" || typeof data.pipe == "function")
      return callback(new Error("Multipart builder expects data as key/val object."));
    var body = "", object = flatten(data), count = Object.keys(object).length;
    if (count === 0)
      return callback(new Error("Empty multipart body. Invalid data."));
    function done(err, section) {
      if (err)
        return callback(err);
      if (section)
        body += section;
      --count || callback(null, body + "--" + boundary + "--");
    }
    for (var key in object) {
      var value = object[key];
      if (value === null || typeof value == "undefined") {
        done();
      } else if (Buffer.isBuffer(value)) {
        var part = { buffer: value, content_type: "application/octet-stream" };
        generate_part(key, part, boundary, done);
      } else {
        var part = value.buffer || value.file || value.content_type ? value : { value };
        generate_part(key, part, boundary, done);
      }
    }
  };
});

// ../../node_modules/needle/lib/auth.js
var require_auth = __commonJS((exports2, module2) => {
  var get_header = function(header, credentials, opts) {
    var type2 = header.split(" ")[0], user = credentials[0], pass = credentials[1];
    if (type2 == "Digest") {
      return digest.generate(header, user, pass, opts.method, opts.path);
    } else if (type2 == "Basic") {
      return basic(user, pass);
    }
  };
  var md5 = function(string) {
    return createHash("md5").update(string).digest("hex");
  };
  var basic = function(user, pass) {
    var str = typeof pass == "undefined" ? user : [user, pass].join(":");
    return "Basic " + Buffer.from(str).toString("base64");
  };
  var createHash = __require("crypto").createHash;
  var digest = {};
  digest.parse_header = function(header) {
    var challenge = {}, matches = header.match(/([a-z0-9_-]+)="?([a-z0-9=\/\.@\s-]+)"?/gi);
    for (var i = 0, l = matches.length;i < l; i++) {
      var parts = matches[i].split("="), key = parts.shift(), val = parts.join("=").replace(/^"/, "").replace(/"$/, "");
      challenge[key] = val;
    }
    return challenge;
  };
  digest.update_nc = function(nc) {
    var max4 = 99999999;
    nc++;
    if (nc > max4)
      nc = 1;
    var padding = new Array(8).join("0") + "";
    nc = nc + "";
    return padding.substr(0, 8 - nc.length) + nc;
  };
  digest.generate = function(header, user, pass, method, path2) {
    var nc = 1, cnonce = null, challenge = digest.parse_header(header);
    var ha1 = md5(user + ":" + challenge.realm + ":" + pass), ha2 = md5(method.toUpperCase() + ":" + path2), resp = [ha1, challenge.nonce];
    if (typeof challenge.qop === "string") {
      cnonce = md5(Math.random().toString(36)).substr(0, 8);
      nc = digest.update_nc(nc);
      resp = resp.concat(nc, cnonce);
    }
    resp = resp.concat(challenge.qop, ha2);
    var params2 = {
      uri: path2,
      realm: challenge.realm,
      nonce: challenge.nonce,
      username: user,
      response: md5(resp.join(":"))
    };
    if (challenge.qop) {
      params2.qop = challenge.qop;
    }
    if (challenge.opaque) {
      params2.opaque = challenge.opaque;
    }
    if (cnonce) {
      params2.nc = nc;
      params2.cnonce = cnonce;
    }
    header = [];
    for (var k in params2)
      header.push(k + '="' + params2[k] + '"');
    return "Digest " + header.join(", ");
  };
  module2.exports = {
    header: get_header,
    basic,
    digest: digest.generate
  };
});

// ../../node_modules/needle/lib/cookies.js
var require_cookies = __commonJS((exports2) => {
  var cleanCookieString = function(str) {
    return str.trim().replace(/\x3B+$/, "");
  };
  var getFirstPair = function(str) {
    var index = str.indexOf(";");
    return index === -1 ? str : str.substr(0, index);
  };
  var encodeCookieComponent = function(str) {
    return str.toString().replace(EXCLUDED_CHARS, encodeURIComponent);
  };
  var parseSetCookieString = function(str) {
    str = cleanCookieString(str);
    str = getFirstPair(str);
    var res = COOKIE_PAIR.exec(str);
    if (!res || !res[VALUE_INDEX])
      return null;
    return {
      name: unescape2(res[KEY_INDEX]),
      value: unescape2(res[VALUE_INDEX])
    };
  };
  var parseSetCookieHeader = function(header) {
    if (!header)
      return {};
    header = Array.isArray(header) ? header : [header];
    return header.reduce(function(res, str) {
      var cookie = parseSetCookieString(str);
      if (cookie)
        res[cookie.name] = cookie.value;
      return res;
    }, {});
  };
  var writeCookieString = function(obj) {
    return Object.keys(obj).reduce(function(str, name2) {
      var encodedName = encodeCookieComponent(name2);
      var encodedValue = encodeCookieComponent(obj[name2]);
      str += (str ? "; " : "") + encodedName + "=" + encodedValue;
      return str;
    }, "");
  };
  var unescape2 = __require("querystring").unescape;
  var COOKIE_PAIR = /^([^=\s]+)\s*=\s*("?)\s*(.*)\s*\2\s*$/;
  var EXCLUDED_CHARS = /[\x00-\x1F\x7F\x3B\x3B\s\"\,\\"%]/g;
  var KEY_INDEX = 1;
  var VALUE_INDEX = 3;
  exports2.read = parseSetCookieHeader;
  exports2.write = writeCookieString;
});

// ../../node_modules/sax/lib/sax.js
var require_sax = __commonJS((exports2) => {
  (function(sax) {
    sax.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream;
    sax.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      if (parser.opt.unquotedAttributeValues === undefined) {
        parser.opt.unquotedAttributeValues = !strict;
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit(parser, "onready");
    }
    if (!Object.create) {
      Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F;
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o) {
        var a = [];
        for (var i in o)
          if (o.hasOwnProperty(i))
            a.push(i);
        return a;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i = 0, l = buffers.length;i < l; i++) {
        var len = parser[buffers[i]].length;
        if (len > maxAllowed) {
          switch (buffers[i]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error(parser, "Max buffer length exceeded: " + buffers[i]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m = sax.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
      for (var i = 0, l = buffers.length;i < l; i++) {
        parser[buffers[i]] = "";
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
    }
    SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write: write4,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var Stream;
    try {
      Stream = __require("stream").Stream;
    } catch (ex) {
      Stream = function() {
      };
    }
    if (!Stream)
      Stream = function() {
      };
    var streamWraps = sax.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }
      Stream.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      };
      this._parser.onerror = function(er) {
        me.emit("error", er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h) {
            if (!h) {
              me.removeAllListeners(ev);
              me._parser["on" + ev] = h;
              return h;
            }
            me.on(ev, h);
          },
          enumerable: true,
          configurable: false
        });
      });
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
      constructor: {
        value: SAXStream
      }
    });
    SAXStream.prototype.write = function(data) {
      if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = __require("string_decoder").StringDecoder;
          this._decoder = new SD("utf8");
        }
        data = this._decoder.write(data);
      }
      this._parser.write(data.toString());
      this.emit("data", data);
      return true;
    };
    SAXStream.prototype.end = function(chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on" + ev] = function() {
          var args2 = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args2.splice(0, 0, ev);
          me.emit.apply(me, args2);
        };
      }
      return Stream.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
      return c === " " || c === "\n" || c === "\r" || c === "\t";
    }
    function isQuote(c) {
      return c === '"' || c === "\'";
    }
    function isAttribEnd(c) {
      return c === ">" || isWhitespace(c);
    }
    function isMatch(regex, c) {
      return regex.test(c);
    }
    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }
    var S = 0;
    sax.STATE = {
      BEGIN: S++,
      BEGIN_WHITESPACE: S++,
      TEXT: S++,
      TEXT_ENTITY: S++,
      OPEN_WAKA: S++,
      SGML_DECL: S++,
      SGML_DECL_QUOTED: S++,
      DOCTYPE: S++,
      DOCTYPE_QUOTED: S++,
      DOCTYPE_DTD: S++,
      DOCTYPE_DTD_QUOTED: S++,
      COMMENT_STARTING: S++,
      COMMENT: S++,
      COMMENT_ENDING: S++,
      COMMENT_ENDED: S++,
      CDATA: S++,
      CDATA_ENDING: S++,
      CDATA_ENDING_2: S++,
      PROC_INST: S++,
      PROC_INST_BODY: S++,
      PROC_INST_ENDING: S++,
      OPEN_TAG: S++,
      OPEN_TAG_SLASH: S++,
      ATTRIB: S++,
      ATTRIB_NAME: S++,
      ATTRIB_NAME_SAW_WHITE: S++,
      ATTRIB_VALUE: S++,
      ATTRIB_VALUE_QUOTED: S++,
      ATTRIB_VALUE_CLOSED: S++,
      ATTRIB_VALUE_UNQUOTED: S++,
      ATTRIB_VALUE_ENTITY_Q: S++,
      ATTRIB_VALUE_ENTITY_U: S++,
      CLOSE_TAG: S++,
      CLOSE_TAG_SAW_WHITE: S++,
      SCRIPT: S++,
      SCRIPT_ENDING: S++
    };
    sax.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    };
    sax.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    };
    Object.keys(sax.ENTITIES).forEach(function(key) {
      var e = sax.ENTITIES[key];
      var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
      sax.ENTITIES[key] = s2;
    });
    for (var s in sax.STATE) {
      sax.STATE[sax.STATE[s]] = s;
    }
    S = sax.STATE;
    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode)
        closeText(parser);
      emit(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode)
        emit(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim)
        text = text.trim();
      if (opt.normalize)
        text = text.replace(/\s+/g, " ");
      return text;
    }
    function error(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit(parser, "onerror", er);
      return parser;
    }
    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot)
        strictFail(parser, "Unclosed root tag");
      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict)
        parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = { name: parser.tagName, attributes: {} };
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name2, attribute) {
      var i = name2.indexOf(":");
      var qualName = i < 0 ? ["", name2] : name2.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name2 === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\n" + "Actual: " + parser.attribValue);
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n" + "Actual: " + parser.attribValue);
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      }
      parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
        }
        for (var i = 0, l = parser.attribList.length;i < l; i++) {
          var nv = parser.attribList[i];
          var name2 = nv[0];
          var value = nv[1];
          var qualName = qname(name2, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === "" ? "" : tag.ns[prefix] || "";
          var a = {
            name: name2,
            value,
            prefix,
            local,
            uri
          };
          if (prefix && prefix !== "xmlns" && !uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a.uri = prefix;
          }
          parser.tag.attributes[name2] = a;
          emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
      var t = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t--) {
        var close = parser.tags[t];
        if (close.name !== closeTo) {
          strictFail(parser, "Unexpected close tag");
        } else {
          break;
        }
      }
      if (t < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s2 = parser.tags.length;
      while (s2-- > t) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x = {};
        for (var i in tag.ns) {
          x[i] = tag.ns[i];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
          });
        }
      }
      if (t === 0)
        parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
      if (c === "<") {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace(c)) {
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c;
        parser.state = S.TEXT;
      }
    }
    function charAt(chunk, i) {
      var result = "";
      if (i < chunk.length) {
        result = chunk.charAt(i);
      }
      return result;
    }
    function write4(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error(parser, "Cannot write after close. Assign an onready handler.");
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i = 0;
      var c = "";
      while (true) {
        c = charAt(chunk, i++);
        parser.c = c;
        if (!c) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c === "\n") {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i - 1;
              while (c && c !== "<" && c !== "&") {
                c = charAt(chunk, i++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i - 1);
            }
            if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c === "&") {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c;
              }
            }
            continue;
          case S.SCRIPT:
            if (c === "<") {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c;
            }
            continue;
          case S.SCRIPT_ENDING:
            if (c === "/") {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += "<" + c;
              parser.state = S.SCRIPT;
            }
            continue;
          case S.OPEN_WAKA:
            if (c === "!") {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace(c)) {
            } else if (isMatch(nameStart, c)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c;
            } else if (c === "/") {
              parser.state = S.CLOSE_TAG;
              parser.tagName = "";
            } else if (c === "?") {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c = new Array(pad).join(" ") + c;
              }
              parser.textNode += "<" + c;
              parser.state = S.TEXT;
            }
            continue;
          case S.SGML_DECL:
            if (parser.sgmlDecl + c === "--") {
              parser.state = S.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
              continue;
            }
            if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
              parser.state = S.DOCTYPE_DTD;
              parser.doctype += "<!" + parser.sgmlDecl + c;
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(parser, "Inappropriately located doctype declaration");
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S.TEXT;
            } else if (isQuote(c)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c;
            } else {
              parser.sgmlDecl += c;
            }
            continue;
          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c;
            continue;
          case S.DOCTYPE:
            if (c === ">") {
              parser.state = S.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c;
              if (c === "[") {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c;
              }
            }
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.q = "";
              parser.state = S.DOCTYPE;
            }
            continue;
          case S.DOCTYPE_DTD:
            if (c === "]") {
              parser.doctype += c;
              parser.state = S.DOCTYPE;
            } else if (c === "<") {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else if (isQuote(c)) {
              parser.doctype += c;
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c;
            } else {
              parser.doctype += c;
            }
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;
          case S.COMMENT:
            if (c === "-") {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c;
            }
            continue;
          case S.COMMENT_ENDING:
            if (c === "-") {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c;
              parser.state = S.COMMENT;
            }
            continue;
          case S.COMMENT_ENDED:
            if (c !== ">") {
              strictFail(parser, "Malformed comment");
              parser.comment += "--" + c;
              parser.state = S.COMMENT;
            } else if (parser.doctype && parser.doctype !== true) {
              parser.state = S.DOCTYPE_DTD;
            } else {
              parser.state = S.TEXT;
            }
            continue;
          case S.CDATA:
            if (c === "]") {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c;
            }
            continue;
          case S.CDATA_ENDING:
            if (c === "]") {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.CDATA_ENDING_2:
            if (c === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S.TEXT;
            } else if (c === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.PROC_INST:
            if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace(c)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c;
            }
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace(c)) {
              continue;
            } else if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c;
            }
            continue;
          case S.PROC_INST_ENDING:
            if (c === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += "?" + c;
              parser.state = S.PROC_INST_BODY;
            }
            continue;
          case S.OPEN_TAG:
            if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else {
              newTag(parser);
              if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.OPEN_TAG_SLASH:
            if (c === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >");
              parser.state = S.ATTRIB;
            }
            continue;
          case S.ATTRIB:
            if (isWhitespace(c)) {
              continue;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (c === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace(c)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c)) {
              parser.attribName += c;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace(c)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              });
              parser.attribName = "";
              if (c === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace(c)) {
              continue;
            } else if (isQuote(c)) {
              parser.q = c;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              if (!parser.opt.unquotedAttributeValues) {
                error(parser, "Unquoted attribute value");
              }
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c;
            }
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace(c)) {
              parser.state = S.ATTRIB;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            if (c === ">") {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace(c)) {
                continue;
              } else if (notMatch(nameStart, c)) {
                if (parser.script) {
                  parser.script += "</" + c;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c;
              }
            } else if (c === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace(c)) {
              continue;
            }
            if (c === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer = "attribValue";
                break;
            }
            if (c === ";") {
              var parsedEntity = parseEntity(parser);
              if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
                parser.entity = "";
                parser.state = returnState;
                parser.write(parsedEntity);
              } else {
                parser[buffer] += parsedEntity;
                parser.entity = "";
                parser.state = returnState;
              }
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
              parser.entity += c;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer] += "&" + parser.entity + c;
              parser.entity = "";
              parser.state = returnState;
            }
            continue;
          default: {
            throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor4 = Math.floor;
        var fromCodePoint2 = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length3 = arguments.length;
          if (!length3) {
            return "";
          }
          var result = "";
          while (++index < length3) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor4(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length3 || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint2,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint2;
        }
      })();
    }
  })(typeof exports2 === "undefined" ? exports2.sax = {} : exports2);
});

// ../../node_modules/needle/lib/parsers.js
var require_parsers = __commonJS((exports2, module2) => {
  var parseXML = function(str, cb) {
    var obj, current, parser = sax.parser(true, { trim: true, lowercase: true });
    parser.onerror = parser.onend = done;
    function done(err) {
      parser.onerror = parser.onend = function() {
      };
      cb(err, obj);
    }
    function newElement(name2, attributes) {
      return {
        name: name2 || "",
        value: "",
        attributes: attributes || {},
        children: []
      };
    }
    parser.ontext = function(t) {
      if (current)
        current.value += t;
    };
    parser.onopentag = function(node) {
      var element = newElement(node.name, node.attributes);
      if (current) {
        element.parent = current;
        current.children.push(element);
      } else {
        obj = element;
      }
      current = element;
    };
    parser.onclosetag = function() {
      if (typeof current.parent !== "undefined") {
        var just_closed = current;
        current = current.parent;
        delete just_closed.parent;
      }
    };
    parser.write(str).close();
  };
  var parserFactory = function(name2, fn) {
    function parser() {
      var chunks = [], stream2 = new Transform({ objectMode: true });
      stream2._transform = function(chunk, encoding, done) {
        chunks.push(chunk);
        done();
      };
      stream2._flush = function(done) {
        var self2 = this, data = Buffer.concat(chunks);
        try {
          fn(data, function(err, result) {
            if (err)
              throw err;
            self2.push(result);
          });
        } catch (err) {
          self2.push(data);
        } finally {
          done();
        }
      };
      return stream2;
    }
    return { fn: parser, name: name2 };
  };
  var buildParser = function(name2, types2, fn) {
    var parser = parserFactory(name2, fn);
    types2.forEach(function(type2) {
      parsers[type2] = parser;
    });
  };
  var Transform = __require("stream").Transform;
  var sax = require_sax();
  var parsers = {};
  buildParser("json", [
    "application/json",
    "text/javascript"
  ], function(buffer, cb) {
    var err, data;
    try {
      data = JSON.parse(buffer);
    } catch (e) {
      err = e;
    }
    cb(err, data);
  });
  buildParser("xml", [
    "text/xml",
    "application/xml",
    "application/rdf+xml",
    "application/rss+xml",
    "application/atom+xml"
  ], function(buffer, cb) {
    parseXML(buffer.toString(), function(err, obj) {
      cb(err, obj);
    });
  });
  module2.exports = parsers;
  module2.exports.use = buildParser;
});

// ../../node_modules/safer-buffer/safer.js
var require_safer = __commonJS((exports2, module2) => {
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key))
      continue;
    if (key === "SlowBuffer" || key === "Buffer")
      continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key))
      continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow")
      continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length3) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length3);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size2, fill, encoding) {
      if (typeof size2 !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size2);
      }
      if (size2 < 0 || size2 >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
      }
      var buf = Buffer2(size2);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  module2.exports = safer;
});

// ../../node_modules/needle/node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS((exports2) => {
  var PrependBOMWrapper = function(encoder, options2) {
    this.encoder = encoder;
    this.addBOM = true;
  };
  var StripBOMWrapper = function(decoder, options2) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options2 || {};
  };
  var BOMChar = "\uFEFF";
  exports2.PrependBOM = PrependBOMWrapper;
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  exports2.StripBOM = StripBOMWrapper;
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS((exports2, module2) => {
  var InternalCodec = function(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "\uD83D\uDCA9") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  };
  var InternalDecoder = function(options2, codec) {
    StringDecoder2.call(this, codec.enc);
  };
  var InternalEncoder = function(options2, codec) {
    this.enc = codec.enc;
  };
  var InternalEncoderBase64 = function(options2, codec) {
    this.prevStr = "";
  };
  var InternalEncoderCesu8 = function(options2, codec) {
  };
  var InternalDecoderCesu8 = function(options2, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  };
  var Buffer2 = require_safer().Buffer;
  module2.exports = {
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    _internal: InternalCodec
  };
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder2 = __require("string_decoder").StringDecoder;
  if (!StringDecoder2.prototype.end)
    StringDecoder2.prototype.end = function() {
    };
  InternalDecoder.prototype = StringDecoder2.prototype;
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0;i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0;i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS((exports2) => {
  var Utf16BECodec = function() {
  };
  var Utf16BEEncoder = function() {
  };
  var Utf16BEDecoder = function() {
    this.overflowByte = -1;
  };
  var Utf16Codec = function(codecOptions, iconv) {
    this.iconv = iconv;
  };
  var Utf16Encoder = function(options2, codec) {
    options2 = options2 || {};
    if (options2.addBOM === undefined)
      options2.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options2);
  };
  var Utf16Decoder = function(options2, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options2 || {};
    this.iconv = codec.iconv;
  };
  var detectEncoding = function(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-16le";
    if (buf.length >= 2) {
      if (buf[0] == 254 && buf[1] == 255)
        enc = "utf-16be";
      else if (buf[0] == 255 && buf[1] == 254)
        enc = "utf-16le";
      else {
        var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
        for (var i = 0;i < _len; i += 2) {
          if (buf[i] === 0 && buf[i + 1] !== 0)
            asciiCharsBE++;
          if (buf[i] !== 0 && buf[i + 1] === 0)
            asciiCharsLE++;
        }
        if (asciiCharsBE > asciiCharsLE)
          enc = "utf-16be";
        else if (asciiCharsBE < asciiCharsLE)
          enc = "utf-16le";
      }
    }
    return enc;
  };
  var Buffer2 = require_safer().Buffer;
  exports2.utf16be = Utf16BECodec;
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0;i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (;i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
  };
  exports2.utf16 = Utf16Codec;
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBytes.push(buf);
      this.initialBytesLen += buf.length;
      if (this.initialBytesLen < 16)
        return "";
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var res = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res + trail : res;
    }
    return this.decoder.end();
  };
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS((exports2) => {
  var Utf7Codec = function(codecOptions, iconv) {
    this.iconv = iconv;
  };
  var Utf7Encoder = function(options2, codec) {
    this.iconv = codec.iconv;
  };
  var Utf7Decoder = function(options2, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  };
  var Utf7IMAPCodec = function(codecOptions, iconv) {
    this.iconv = iconv;
  };
  var Utf7IMAPEncoder = function(options2, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  };
  var Utf7IMAPDecoder = function(options2, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  };
  var Buffer2 = require_safer().Buffer;
  exports2.utf7 = Utf7Codec;
  exports2.unicode11utf7 = "utf7";
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (i = 0;i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var i;
  var plusChar = "+".charCodeAt(0);
  var minusChar = "-".charCodeAt(0);
  var andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0;i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString();
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString();
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  exports2.utf7imap = Utf7IMAPCodec;
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0;i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0;i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS((exports2) => {
  var SBCSCodec = function(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0;i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0;i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  };
  var SBCSEncoder = function(options2, codec) {
    this.encodeBuf = codec.encodeBuf;
  };
  var SBCSDecoder = function(options2, codec) {
    this.decodeBuf = codec.decodeBuf;
  };
  var Buffer2 = require_safer().Buffer;
  exports2._sbcs = SBCSCodec;
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0;i < str.length; i++)
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0;i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS((exports2, module2) => {
  module2.exports = {
    "10029": "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7"
    },
    "808": "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\u20AC\u25A0\xA0"
    },
    mik: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2514\u2534\u252C\u251C\u2500\u253C\u2563\u2551\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2510\u2591\u2592\u2593\u2502\u2524\u2116\xA7\u2557\u255D\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    "20866": "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    "21866": "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  };
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS((exports2, module2) => {
  module2.exports = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    windows874: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\uFFFD\uFFFD\uFFFD\u2026\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\u0160\u2039\u015A\u0164\u017D\u0179\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0161\u203A\u015B\u0165\u017E\u017A\xA0\u02C7\u02D8\u0141\xA4\u0104\xA6\xA7\xA8\xA9\u015E\xAB\xAC\xAD\xAE\u017B\xB0\xB1\u02DB\u0142\xB4\xB5\xB6\xB7\xB8\u0105\u015F\xBB\u013D\u02DD\u013E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u040C\u040B\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u045C\u045B\u045F\xA0\u040E\u045E\u0408\xA4\u0490\xA6\xA7\u0401\xA9\u0404\xAB\xAC\xAD\xAE\u0407\xB0\xB1\u0406\u0456\u0491\xB5\xB6\xB7\u0451\u2116\u0454\xBB\u0458\u0405\u0455\u0457\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\u017D\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\u017E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0385\u0386\xA3\xA4\xA5\xA6\xA7\xA8\xA9\uFFFD\xAB\xAC\xAD\xAE\u2015\xB0\xB1\xB2\xB3\u0384\xB5\xB6\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\xA1\xA2\xA3\u20AA\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\xBF\u05B0\u05B1\u05B2\u05B3\u05B4\u05B5\u05B6\u05B7\u05B8\u05B9\u05BA\u05BB\u05BC\u05BD\u05BE\u05BF\u05C0\u05C1\u05C2\u05C3\u05F0\u05F1\u05F2\u05F3\u05F4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: "\u20AC\u067E\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0679\u2039\u0152\u0686\u0698\u0688\u06AF\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u06A9\u2122\u0691\u203A\u0153\u200C\u200D\u06BA\xA0\u060C\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\u06BE\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\u061B\xBB\xBC\xBD\xBE\u061F\u06C1\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\xD7\u0637\u0638\u0639\u063A\u0640\u0641\u0642\u0643\xE0\u0644\xE2\u0645\u0646\u0647\u0648\xE7\xE8\xE9\xEA\xEB\u0649\u064A\xEE\xEF\u064B\u064C\u064D\u064E\xF4\u064F\u0650\xF7\u0651\xF9\u0652\xFB\xFC\u200E\u200F\u06D2"
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\xA8\u02C7\xB8\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\xAF\u02DB\uFFFD\xA0\uFFFD\xA2\xA3\xA4\uFFFD\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u02D9"
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u02D8\u0141\xA4\u013D\u015A\xA7\xA8\u0160\u015E\u0164\u0179\xAD\u017D\u017B\xB0\u0105\u02DB\u0142\xB4\u013E\u015B\u02C7\xB8\u0161\u015F\u0165\u017A\u02DD\u017E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0126\u02D8\xA3\xA4\uFFFD\u0124\xA7\xA8\u0130\u015E\u011E\u0134\xAD\uFFFD\u017B\xB0\u0127\xB2\xB3\xB4\xB5\u0125\xB7\xB8\u0131\u015F\u011F\u0135\xBD\uFFFD\u017C\xC0\xC1\xC2\uFFFD\xC4\u010A\u0108\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\uFFFD\xD1\xD2\xD3\xD4\u0120\xD6\xD7\u011C\xD9\xDA\xDB\xDC\u016C\u015C\xDF\xE0\xE1\xE2\uFFFD\xE4\u010B\u0109\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\uFFFD\xF1\xF2\xF3\xF4\u0121\xF6\xF7\u011D\xF9\xFA\xFB\xFC\u016D\u015D\u02D9"
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0138\u0156\xA4\u0128\u013B\xA7\xA8\u0160\u0112\u0122\u0166\xAD\u017D\xAF\xB0\u0105\u02DB\u0157\xB4\u0129\u013C\u02C7\xB8\u0161\u0113\u0123\u0167\u014A\u017E\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\u012A\u0110\u0145\u014C\u0136\xD4\xD5\xD6\xD7\xD8\u0172\xDA\xDB\xDC\u0168\u016A\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\u012B\u0111\u0146\u014D\u0137\xF4\xF5\xF6\xF7\xF8\u0173\xFA\xFB\xFC\u0169\u016B\u02D9"
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0403\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0453\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\uFFFD\uFFFD\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u060C\xAD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u061B\uFFFD\uFFFD\uFFFD\u061F\uFFFD\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u2018\u2019\xA3\u20AC\u20AF\xA6\xA7\xA8\xA9\u037A\xAB\xAC\xAD\uFFFD\u2015\xB0\xB1\xB2\xB3\u0384\u0385\u0386\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2017\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0112\u0122\u012A\u0128\u0136\xA7\u013B\u0110\u0160\u0166\u017D\xAD\u016A\u014A\xB0\u0105\u0113\u0123\u012B\u0129\u0137\xB7\u013C\u0111\u0161\u0167\u017E\u2015\u016B\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\xCF\xD0\u0145\u014C\xD3\xD4\xD5\xD6\u0168\xD8\u0172\xDA\xDB\xDC\xDD\xDE\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\xEF\xF0\u0146\u014D\xF3\xF4\xF5\xF6\u0169\xF8\u0173\xFA\xFB\xFC\xFD\xFE\u0138"
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u201D\xA2\xA3\xA4\u201E\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\u201C\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u2019"
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u1E02\u1E03\xA3\u010A\u010B\u1E0A\xA7\u1E80\xA9\u1E82\u1E0B\u1EF2\xAD\xAE\u0178\u1E1E\u1E1F\u0120\u0121\u1E40\u1E41\xB6\u1E56\u1E81\u1E57\u1E83\u1E60\u1EF3\u1E84\u1E85\u1E61\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0174\xD1\xD2\xD3\xD4\xD5\xD6\u1E6A\xD8\xD9\xDA\xDB\xDC\xDD\u0176\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0175\xF1\xF2\xF3\xF4\xF5\xF6\u1E6B\xF8\xF9\xFA\xFB\xFC\xFD\u0177\xFF"
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\u0160\xA7\u0161\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u017D\xB5\xB6\xB7\u017E\xB9\xBA\xBB\u0152\u0153\u0178\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0105\u0141\u20AC\u201E\u0160\xA7\u0161\xA9\u0218\xAB\u0179\xAD\u017A\u017B\xB0\xB1\u010C\u0142\u017D\u201D\xB6\xB7\u017E\u010D\u0219\xBB\u0152\u0153\u0178\u017C\xC0\xC1\xC2\u0102\xC4\u0106\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0110\u0143\xD2\xD3\xD4\u0150\xD6\u015A\u0170\xD9\xDA\xDB\xDC\u0118\u021A\xDF\xE0\xE1\xE2\u0103\xE4\u0107\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0111\u0144\xF2\xF3\xF4\u0151\xF6\u015B\u0171\xF9\xFA\xFB\xFC\u0119\u021B\xFF"
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: "\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u03C5\u03C6\u03C7\u03C8\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03C9\u03AC\u03AD\u03AE\u03CA\u03AF\u03CC\u03CD\u03CB\u03CE\u0386\u0388\u0389\u038A\u038C\u038E\u038F\xB1\u2265\u2264\u03AA\u03AB\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: "\u0106\xFC\xE9\u0101\xE4\u0123\xE5\u0107\u0142\u0113\u0156\u0157\u012B\u0179\xC4\xC5\xC9\xE6\xC6\u014D\xF6\u0122\xA2\u015A\u015B\xD6\xDC\xF8\xA3\xD8\xD7\xA4\u0100\u012A\xF3\u017B\u017C\u017A\u201D\xA6\xA9\xAE\xAC\xBD\xBC\u0141\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0104\u010C\u0118\u0116\u2563\u2551\u2557\u255D\u012E\u0160\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0172\u016A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u017D\u0105\u010D\u0119\u0117\u012F\u0161\u0173\u016B\u017E\u2518\u250C\u2588\u2584\u258C\u2590\u2580\xD3\xDF\u014C\u0143\xF5\xD5\xB5\u0144\u0136\u0137\u013B\u013C\u0146\u0112\u0145\u2019\xAD\xB1\u201C\xBE\xB6\xA7\xF7\u201E\xB0\u2219\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u0131\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\u016F\u0107\xE7\u0142\xEB\u0150\u0151\xEE\u0179\xC4\u0106\xC9\u0139\u013A\xF4\xF6\u013D\u013E\u015A\u015B\xD6\xDC\u0164\u0165\u0141\xD7\u010D\xE1\xED\xF3\xFA\u0104\u0105\u017D\u017E\u0118\u0119\xAC\u017A\u010C\u015F\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\u011A\u015E\u2563\u2551\u2557\u255D\u017B\u017C\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0102\u0103\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u0111\u0110\u010E\xCB\u010F\u0147\xCD\xCE\u011B\u2518\u250C\u2588\u2584\u0162\u016E\u2580\xD3\xDF\xD4\u0143\u0144\u0148\u0160\u0161\u0154\xDA\u0155\u0170\xFD\xDD\u0163\xB4\xAD\u02DD\u02DB\u02C7\u02D8\xA7\xF7\xB8\xB0\xA8\u02D9\u0171\u0158\u0159\u25A0\xA0"
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: "\u0452\u0402\u0453\u0403\u0451\u0401\u0454\u0404\u0455\u0405\u0456\u0406\u0457\u0407\u0458\u0408\u0459\u0409\u045A\u040A\u045B\u040B\u045C\u040C\u045E\u040E\u045F\u040F\u044E\u042E\u044A\u042A\u0430\u0410\u0431\u0411\u0446\u0426\u0434\u0414\u0435\u0415\u0444\u0424\u0433\u0413\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0445\u0425\u0438\u0418\u2563\u2551\u2557\u255D\u0439\u0419\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u043A\u041A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u043B\u041B\u043C\u041C\u043D\u041D\u043E\u041E\u043F\u2518\u250C\u2588\u2584\u041F\u044F\u2580\u042F\u0440\u0420\u0441\u0421\u0442\u0422\u0443\u0423\u0436\u0416\u0432\u0412\u044C\u042C\u2116\xAD\u044B\u042B\u0437\u0417\u0448\u0428\u044D\u042D\u0449\u0429\u0447\u0427\xA7\u25A0\xA0"
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\xA3\uFFFD\xD7\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAE\xAC\xBD\xBC\uFFFD\xAB\xBB\u2591\u2592\u2593\u2502\u2524\uFFFD\uFFFD\uFFFD\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\uFFFD\uFFFD\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2518\u250C\u2588\u2584\xA6\uFFFD\u2580\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xB5\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\u0131\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\u0130\xD6\xDC\xF8\xA3\xD8\u015E\u015F\xE1\xED\xF3\xFA\xF1\xD1\u011E\u011F\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xBA\xAA\xCA\xCB\xC8\uFFFD\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\uFFFD\xD7\xDA\xDB\xD9\xEC\xFF\xAF\xB4\xAD\xB1\uFFFD\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u20AC\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE3\xE0\xC1\xE7\xEA\xCA\xE8\xCD\xD4\xEC\xC3\xC2\xC9\xC0\xC8\xF4\xF5\xF2\xDA\xF9\xCC\xD5\xDC\xA2\xA3\xD9\u20A7\xD3\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xD2\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xD0\xF0\xDE\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xFE\xFB\xDD\xFD\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xC1\xCD\xD3\xDA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xC2\xE0\xB6\xE7\xEA\xEB\xE8\xEF\xEE\u2017\xC0\xA7\xC9\xC8\xCA\xF4\xCB\xCF\xFB\xF9\xA4\xD4\xDC\xA2\xA3\xD9\xDB\u0192\xA6\xB4\xF3\xFA\xA8\xB8\xB3\xAF\xCE\u2310\xAC\xBD\xBC\xBE\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: `\0\x01\x02\x03\x04\x05\x06\x07	
\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$\u066A&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xB0\xB7\u2219\u221A\u2592\u2500\u2502\u253C\u2524\u252C\u251C\u2534\u2510\u250C\u2514\u2518\u03B2\u221E\u03C6\xB1\xBD\xBC\u2248\xAB\xBB\uFEF7\uFEF8\uFFFD\uFFFD\uFEFB\uFEFC\uFFFD\xA0\xAD\uFE82\xA3\xA4\uFE84\uFFFD\uFFFD\uFE8E\uFE8F\uFE95\uFE99\u060C\uFE9D\uFEA1\uFEA5\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFED1\u061B\uFEB1\uFEB5\uFEB9\u061F\xA2\uFE80\uFE81\uFE83\uFE85\uFECA\uFE8B\uFE8D\uFE91\uFE93\uFE97\uFE9B\uFE9F\uFEA3\uFEA7\uFEA9\uFEAB\uFEAD\uFEAF\uFEB3\uFEB7\uFEBB\uFEBF\uFEC1\uFEC5\uFECB\uFECF\xA6\xAC\xF7\xD7\uFEC9\u0640\uFED3\uFED7\uFEDB\uFEDF\uFEE3\uFEE7\uFEEB\uFEED\uFEEF\uFEF3\uFEBD\uFECC\uFECE\uFECD\uFEE1\uFE7D\u0651\uFEE5\uFEE9\uFEEC\uFEF0\uFEF2\uFED0\uFED5\uFEF5\uFEF6\uFEDD\uFED9\uFEF1\u25A0\uFFFD`
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xA4\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\xA4\u25A0\xA0"
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0386\uFFFD\xB7\xAC\xA6\u2018\u2019\u0388\u2015\u0389\u038A\u03AA\u038C\uFFFD\uFFFD\u038E\u03AB\xA9\u038F\xB2\xB3\u03AC\xA3\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03CD\u0391\u0392\u0393\u0394\u0395\u0396\u0397\xBD\u0398\u0399\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u039A\u039B\u039C\u039D\u2563\u2551\u2557\u255D\u039E\u039F\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u03A0\u03A1\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u2518\u250C\u2588\u2584\u03B4\u03B5\u2580\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u0384\xAD\xB1\u03C5\u03C6\u03C7\xA7\u03C8\u0385\xB0\xA8\u03C9\u03CB\u03B0\u03CE\u25A0\xA0"
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\u203E\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0160\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\u017D\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0161\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\u017E\xFF"
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: "\uFE88\xD7\xF7\uF8F6\uF8F5\uF8F4\uF8F7\uFE71\x88\u25A0\u2502\u2500\u2510\u250C\u2514\u2518\uFE79\uFE7B\uFE7D\uFE7F\uFE77\uFE8A\uFEF0\uFEF3\uFEF2\uFECE\uFECF\uFED0\uFEF6\uFEF8\uFEFA\uFEFC\xA0\uF8FA\uF8F9\uF8F8\xA4\uF8FB\uFE8B\uFE91\uFE97\uFE9B\uFE9F\uFEA3\u060C\xAD\uFEA7\uFEB3\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFEB7\u061B\uFEBB\uFEBF\uFECA\u061F\uFECB\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\uFEC7\u0639\u063A\uFECC\uFE82\uFE84\uFE8E\uFED3\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFED7\uFEDB\uFEDF\uF8FC\uFEF5\uFEF7\uFEF9\uFEFB\uFEE3\uFEE7\uFEEC\uFEE9\uFFFD"
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0490\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0491\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0490\u0491\u0404\u0454\u0406\u0456\u0407\u0457\xB7\u221A\u2116\xA4\u25A0\xA0"
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E81\u0E82\u0E84\u0E87\u0E88\u0EAA\u0E8A\u0E8D\u0E94\u0E95\u0E96\u0E97\u0E99\u0E9A\u0E9B\u0E9C\u0E9D\u0E9E\u0E9F\u0EA1\u0EA2\u0EA3\u0EA5\u0EA7\u0EAB\u0EAD\u0EAE\uFFFD\uFFFD\uFFFD\u0EAF\u0EB0\u0EB2\u0EB3\u0EB4\u0EB5\u0EB6\u0EB7\u0EB8\u0EB9\u0EBC\u0EB1\u0EBB\u0EBD\uFFFD\uFFFD\uFFFD\u0EC0\u0EC1\u0EC2\u0EC3\u0EC4\u0EC8\u0EC9\u0ECA\u0ECB\u0ECC\u0ECD\u0EC6\uFFFD\u0EDC\u0EDD\u20AD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0ED0\u0ED1\u0ED2\u0ED3\u0ED4\u0ED5\u0ED6\u0ED7\u0ED8\u0ED9\uFFFD\uFFFD\xA2\xAC\xA6\uFFFD"
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E48\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\u0E49\u0E4A\u0E4B\u20AC\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\xA2\xAC\xA6\xA0"
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: "\u20AC\x81\x82\x83\x84\u2026\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u2126\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uFFFD\xA9\u2044\xA4\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7"
    },
    maccyrillic: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\xA2\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u2202\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
    },
    macgreek: {
      type: "_sbcs",
      chars: "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\xAD\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\u0387\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\uFFFD"
    },
    maciceland: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macroman: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macromania: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u015E\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\u0103\u015F\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\u0162\u0163\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macthai: {
      type: "_sbcs",
      chars: "\xAB\xBB\u2026\uF88C\uF88F\uF892\uF895\uF898\uF88B\uF88E\uF891\uF894\uF897\u201C\u201D\uF899\uFFFD\u2022\uF884\uF889\uF885\uF886\uF887\uF888\uF88A\uF88D\uF890\uF893\uF896\u2018\u2019\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFEFF\u200B\u2013\u2014\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u2122\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\xAE\xA9\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    macturkish: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\uFFFD\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macukraine: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
    },
    koi8r: {
      type: "_sbcs",
      chars: "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u2553\u2554\u2555\u2556\u2557\u2558\u2559\u255A\u255B\u255C\u255D\u255E\u255F\u2560\u2561\u0401\u2562\u2563\u2564\u2565\u2566\u2567\u2568\u2569\u256A\u256B\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    koi8u: {
      type: "_sbcs",
      chars: "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u255D\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    koi8ru: {
      type: "_sbcs",
      chars: "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u045E\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u040E\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    koi8t: {
      type: "_sbcs",
      chars: "\u049B\u0493\u201A\u0492\u201E\u2026\u2020\u2021\uFFFD\u2030\u04B3\u2039\u04B2\u04B7\u04B6\uFFFD\u049A\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u04EF\u04EE\u0451\xA4\u04E3\xA6\xA7\uFFFD\uFFFD\uFFFD\xAB\xAC\xAD\xAE\uFFFD\xB0\xB1\xB2\u0401\uFFFD\u04E2\xB6\xB7\uFFFD\u2116\uFFFD\xBB\uFFFD\uFFFD\uFFFD\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    armscii8: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\u0587\u0589)(\xBB\xAB\u2014.\u055D,-\u058A\u2026\u055C\u055B\u055E\u0531\u0561\u0532\u0562\u0533\u0563\u0534\u0564\u0535\u0565\u0536\u0566\u0537\u0567\u0538\u0568\u0539\u0569\u053A\u056A\u053B\u056B\u053C\u056C\u053D\u056D\u053E\u056E\u053F\u056F\u0540\u0570\u0541\u0571\u0542\u0572\u0543\u0573\u0544\u0574\u0545\u0575\u0546\u0576\u0547\u0577\u0548\u0578\u0549\u0579\u054A\u057A\u054B\u057B\u054C\u057C\u054D\u057D\u054E\u057E\u054F\u057F\u0550\u0580\u0551\u0581\u0552\u0582\u0553\u0583\u0554\u0584\u0555\u0585\u0556\u0586\u055A\uFFFD"
    },
    rk1048: {
      type: "_sbcs",
      chars: "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u049A\u04BA\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u049B\u04BB\u045F\xA0\u04B0\u04B1\u04D8\xA4\u04E8\xA6\xA7\u0401\xA9\u0492\xAB\xAC\xAD\xAE\u04AE\xB0\xB1\u0406\u0456\u04E9\xB5\xB6\xB7\u0451\u2116\u0493\xBB\u04D9\u04A2\u04A3\u04AF\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
    },
    tcvn: {
      type: "_sbcs",
      chars: `\0\xDA\u1EE4\x03\u1EEA\u1EEC\u1EEE\x07	
\r\x0E\x0F\x10\u1EE8\u1EF0\u1EF2\u1EF6\u1EF8\xDD\u1EF4\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xC0\u1EA2\xC3\xC1\u1EA0\u1EB6\u1EAC\xC8\u1EBA\u1EBC\xC9\u1EB8\u1EC6\xCC\u1EC8\u0128\xCD\u1ECA\xD2\u1ECE\xD5\xD3\u1ECC\u1ED8\u1EDC\u1EDE\u1EE0\u1EDA\u1EE2\xD9\u1EE6\u0168\xA0\u0102\xC2\xCA\xD4\u01A0\u01AF\u0110\u0103\xE2\xEA\xF4\u01A1\u01B0\u0111\u1EB0\u0300\u0309\u0303\u0301\u0323\xE0\u1EA3\xE3\xE1\u1EA1\u1EB2\u1EB1\u1EB3\u1EB5\u1EAF\u1EB4\u1EAE\u1EA6\u1EA8\u1EAA\u1EA4\u1EC0\u1EB7\u1EA7\u1EA9\u1EAB\u1EA5\u1EAD\xE8\u1EC2\u1EBB\u1EBD\xE9\u1EB9\u1EC1\u1EC3\u1EC5\u1EBF\u1EC7\xEC\u1EC9\u1EC4\u1EBE\u1ED2\u0129\xED\u1ECB\xF2\u1ED4\u1ECF\xF5\xF3\u1ECD\u1ED3\u1ED5\u1ED7\u1ED1\u1ED9\u1EDD\u1EDF\u1EE1\u1EDB\u1EE3\xF9\u1ED6\u1EE7\u0169\xFA\u1EE5\u1EEB\u1EED\u1EEF\u1EE9\u1EF1\u1EF3\u1EF7\u1EF9\xFD\u1EF5\u1ED0`
    },
    georgianacademy: {
      type: "_sbcs",
      chars: "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10EF\u10F0\u10F1\u10F2\u10F3\u10F4\u10F5\u10F6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    georgianps: {
      type: "_sbcs",
      chars: "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10F1\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10F2\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10F3\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10F4\u10EF\u10F0\u10F5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    pt154: {
      type: "_sbcs",
      chars: "\u0496\u0492\u04EE\u0493\u201E\u2026\u04B6\u04AE\u04B2\u04AF\u04A0\u04E2\u04A2\u049A\u04BA\u04B8\u0497\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u04B3\u04B7\u04A1\u04E3\u04A3\u049B\u04BB\u04B9\xA0\u040E\u045E\u0408\u04E8\u0498\u04B0\xA7\u0401\xA9\u04D8\xAB\xAC\u04EF\xAE\u049C\xB0\u04B1\u0406\u0456\u0499\u04E9\xB6\xB7\u0451\u2116\u04D9\xBB\u0458\u04AA\u04AB\u049D\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
    },
    viscii: {
      type: "_sbcs",
      chars: `\0\x01\u1EB2\x03\x04\u1EB4\u1EAA\x07	
\r\x0E\x0F\x10\x11\x12\x13\u1EF6\x15\x16\x17\x18\u1EF8\x1A\x1B\x1C\x1D\u1EF4\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~\x7F\u1EA0\u1EAE\u1EB0\u1EB6\u1EA4\u1EA6\u1EA8\u1EAC\u1EBC\u1EB8\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EE2\u1EDA\u1EDC\u1EDE\u1ECA\u1ECE\u1ECC\u1EC8\u1EE6\u0168\u1EE4\u1EF2\xD5\u1EAF\u1EB1\u1EB7\u1EA5\u1EA7\u1EA9\u1EAD\u1EBD\u1EB9\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1ED1\u1ED3\u1ED5\u1ED7\u1EE0\u01A0\u1ED9\u1EDD\u1EDF\u1ECB\u1EF0\u1EE8\u1EEA\u1EEC\u01A1\u1EDB\u01AF\xC0\xC1\xC2\xC3\u1EA2\u0102\u1EB3\u1EB5\xC8\xC9\xCA\u1EBA\xCC\xCD\u0128\u1EF3\u0110\u1EE9\xD2\xD3\xD4\u1EA1\u1EF7\u1EEB\u1EED\xD9\xDA\u1EF9\u1EF5\xDD\u1EE1\u01B0\xE0\xE1\xE2\xE3\u1EA3\u0103\u1EEF\u1EAB\xE8\xE9\xEA\u1EBB\xEC\xED\u0129\u1EC9\u0111\u1EF1\xF2\xF3\xF4\xF5\u1ECF\u1ECD\u1EE5\xF9\xFA\u0169\u1EE7\xFD\u1EE3\u1EEE`
    },
    iso646cn: {
      type: "_sbcs",
      chars: `\0\x01\x02\x03\x04\x05\x06\x07	
\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#\xA5%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD`
    },
    iso646jp: {
      type: "_sbcs",
      chars: `\0\x01\x02\x03\x04\x05\x06\x07	
\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\xA5]^_\`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD`
    },
    hproman8: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xC0\xC2\xC8\xCA\xCB\xCE\xCF\xB4\u02CB\u02C6\xA8\u02DC\xD9\xDB\u20A4\xAF\xDD\xFD\xB0\xC7\xE7\xD1\xF1\xA1\xBF\xA4\xA3\xA5\xA7\u0192\xA2\xE2\xEA\xF4\xFB\xE1\xE9\xF3\xFA\xE0\xE8\xF2\xF9\xE4\xEB\xF6\xFC\xC5\xEE\xD8\xC6\xE5\xED\xF8\xE6\xC4\xEC\xD6\xDC\xC9\xEF\xDF\xD4\xC1\xC3\xE3\xD0\xF0\xCD\xCC\xD3\xD2\xD5\xF5\u0160\u0161\xDA\u0178\xFF\xDE\xFE\xB7\xB5\xB6\xBE\u2014\xBC\xBD\xAA\xBA\xAB\u25A0\xBB\xB1\uFFFD"
    },
    macintosh: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    ascii: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    tis620: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    }
  };
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS((exports2) => {
  var DBCSCodec = function(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0;i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0;i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from;j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = "?".charCodeAt(0);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var thirdByteNodeIdx = this.decodeTables.length;
      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      var fourthByteNodeIdx = this.decodeTables.length;
      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      for (var i2 = 129;i2 <= 254; i2++) {
        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
        var secondByteNode = this.decodeTables[secondByteNodeIdx];
        for (var j = 48;j <= 57; j++)
          secondByteNode[j] = NODE_START - thirdByteNodeIdx;
      }
      for (var i2 = 129;i2 <= 254; i2++)
        thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
      for (var i2 = 48;i2 <= 57; i2++)
        fourthByteNode[i2] = GB18030_CODE;
    }
  };
  var DBCSEncoder = function(options2, codec) {
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  };
  var DBCSDecoder = function(options2, codec) {
    this.nodeIdx = 0;
    this.prevBuf = Buffer2.alloc(0);
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  };
  var findIdx = function(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + Math.floor((r - l + 1) / 2);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  };
  var Buffer2 = require_safer().Buffer;
  exports2._dbcs = DBCSCodec;
  var UNASSIGNED = -1;
  var GB18030_CODE = -2;
  var SEQ_START = -10;
  var NODE_START = -1000;
  var UNASSIGNED_NODE = new Array(256);
  var DEF_CHAR = -1;
  for (i = 0;i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  var i;
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (;addr > 0; addr >>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node = this.decodeTables[0];
    for (var i2 = bytes.length - 1;i2 > 0; i2--) {
      var val = node[bytes[i2]];
      if (val == UNASSIGNED) {
        node[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1;k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0;l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m = 0;m < len; m++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0;l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === undefined)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED)
        node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j = 1;j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object")
        node = oldVal;
      else {
        node = node[uCode] = {};
        if (oldVal !== undefined)
          node[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i2 = 0;i2 < 256; i2++) {
      var uCode = node[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0)
        this._setEncodeChar(uCode, mbCode);
      else if (uCode <= NODE_START)
        this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
      else if (uCode <= SEQ_START)
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
  };
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length)
          break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== undefined && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == undefined) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== undefined) {
            dbcsCode = resCode;
            nextChar = uCode;
          } else {
          }
        }
        seqObj = undefined;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== undefined)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== undefined) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      } else {
      }
      this.seqObj = undefined;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
    if (prevBufOffset > 0)
      prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
    for (var i2 = 0, j = 0;i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) {
      } else if (uCode === UNASSIGNED) {
        i2 = seqStart;
        uCode = this.defaultCharUnicode.charCodeAt(0);
      } else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset);
        var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0;k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode > 65535) {
        uCode -= 65536;
        var uCodeLead = 55296 + Math.floor(uCode / 1024);
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 + uCode % 1024;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBuf.length > 0) {
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);
      this.prevBuf = Buffer2.alloc(0);
      this.nodeIdx = 0;
      if (buf.length > 0)
        ret += this.write(buf);
    }
    this.nodeIdx = 0;
    return ret;
  };
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS((exports2, module2) => {
  module2.exports = [
    ["0", " ", 128],
    ["a1", "", 62],
    ["8140", "", 9, ""],
    ["8180", ""],
    ["81b8", ""],
    ["81c8", ""],
    ["81da", ""],
    ["81f0", ""],
    ["81fc", ""],
    ["824f", "", 9],
    ["8260", "", 25],
    ["8281", "", 25],
    ["829f", "", 82],
    ["8340", "", 62],
    ["8380", "", 22],
    ["839f", "", 16, "", 6],
    ["83bf", "", 16, "", 6],
    ["8440", "", 5, "", 25],
    ["8470", "", 5, "", 7],
    ["8480", "", 17],
    ["849f", ""],
    ["8740", "", 19, "", 9],
    ["875f", ""],
    ["877e", ""],
    ["8780", "", 4, ""],
    ["889f", ""],
    ["8940", ""],
    ["8980", ""],
    ["8a40", ""],
    ["8a80", ""],
    ["8b40", ""],
    ["8b80", ""],
    ["8c40", ""],
    ["8c80", ""],
    ["8d40", ""],
    ["8d80", ""],
    ["8e40", ""],
    ["8e80", ""],
    ["8f40", ""],
    ["8f80", ""],
    ["9040", ""],
    ["9080", ""],
    ["9140", ""],
    ["9180", ""],
    ["9240", ""],
    ["9280", ""],
    ["9340", ""],
    ["9380", ""],
    ["9440", ""],
    ["9480", ""],
    ["9540", ""],
    ["9580", ""],
    ["9640", ""],
    ["9680", ""],
    ["9740", ""],
    ["9780", ""],
    ["9840", ""],
    ["989f", ""],
    ["9940", ""],
    ["9980", ""],
    ["9a40", ""],
    ["9a80", ""],
    ["9b40", ""],
    ["9b80", ""],
    ["9c40", ""],
    ["9c80", ""],
    ["9d40", ""],
    ["9d80", ""],
    ["9e40", ""],
    ["9e80", ""],
    ["9f40", ""],
    ["9f80", ""],
    ["e040", ""],
    ["e080", ""],
    ["e140", ""],
    ["e180", ""],
    ["e240", ""],
    ["e280", ""],
    ["e340", ""],
    ["e380", ""],
    ["e440", ""],
    ["e480", ""],
    ["e540", ""],
    ["e580", ""],
    ["e640", ""],
    ["e680", ""],
    ["e740", ""],
    ["e780", ""],
    ["e840", ""],
    ["e880", ""],
    ["e940", ""],
    ["e980", ""],
    ["ea40", ""],
    ["ea80", ""],
    ["ed40", ""],
    ["ed80", ""],
    ["ee40", ""],
    ["ee80", ""],
    ["eeef", "", 9, ""],
    ["f040", "", 62],
    ["f080", "", 124],
    ["f140", "", 62],
    ["f180", "", 124],
    ["f240", "", 62],
    ["f280", "", 124],
    ["f340", "", 62],
    ["f380", "", 124],
    ["f440", "", 62],
    ["f480", "", 124],
    ["f540", "", 62],
    ["f580", "", 124],
    ["f640", "", 62],
    ["f680", "", 124],
    ["f740", "", 62],
    ["f780", "", 124],
    ["f840", "", 62],
    ["f880", "", 124],
    ["f940", ""],
    ["fa40", "", 9, "", 9, ""],
    ["fa80", ""],
    ["fb40", ""],
    ["fb80", ""],
    ["fc40", ""]
  ];
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS((exports2, module2) => {
  module2.exports = [
    ["0", " ", 127],
    ["8ea1", "", 62],
    ["a1a1", "", 9, ""],
    ["a2a1", ""],
    ["a2ba", ""],
    ["a2ca", ""],
    ["a2dc", ""],
    ["a2f2", ""],
    ["a2fe", ""],
    ["a3b0", "", 9],
    ["a3c1", "", 25],
    ["a3e1", "", 25],
    ["a4a1", "", 82],
    ["a5a1", "", 85],
    ["a6a1", "", 16, "", 6],
    ["a6c1", "", 16, "", 6],
    ["a7a1", "", 5, "", 25],
    ["a7d1", "", 5, "", 25],
    ["a8a1", ""],
    ["ada1", "", 19, "", 9],
    ["adc0", ""],
    ["addf", "", 4, ""],
    ["b0a1", ""],
    ["b1a1", ""],
    ["b2a1", ""],
    ["b3a1", ""],
    ["b4a1", ""],
    ["b5a1", ""],
    ["b6a1", ""],
    ["b7a1", ""],
    ["b8a1", ""],
    ["b9a1", ""],
    ["baa1", ""],
    ["bba1", ""],
    ["bca1", ""],
    ["bda1", ""],
    ["bea1", ""],
    ["bfa1", ""],
    ["c0a1", ""],
    ["c1a1", ""],
    ["c2a1", ""],
    ["c3a1", ""],
    ["c4a1", ""],
    ["c5a1", ""],
    ["c6a1", ""],
    ["c7a1", ""],
    ["c8a1", ""],
    ["c9a1", ""],
    ["caa1", ""],
    ["cba1", ""],
    ["cca1", ""],
    ["cda1", ""],
    ["cea1", ""],
    ["cfa1", ""],
    ["d0a1", ""],
    ["d1a1", ""],
    ["d2a1", ""],
    ["d3a1", ""],
    ["d4a1", ""],
    ["d5a1", ""],
    ["d6a1", ""],
    ["d7a1", ""],
    ["d8a1", ""],
    ["d9a1", ""],
    ["daa1", ""],
    ["dba1", ""],
    ["dca1", ""],
    ["dda1", ""],
    ["dea1", ""],
    ["dfa1", ""],
    ["e0a1", ""],
    ["e1a1", ""],
    ["e2a1", ""],
    ["e3a1", ""],
    ["e4a1", ""],
    ["e5a1", ""],
    ["e6a1", ""],
    ["e7a1", ""],
    ["e8a1", ""],
    ["e9a1", ""],
    ["eaa1", ""],
    ["eba1", ""],
    ["eca1", ""],
    ["eda1", ""],
    ["eea1", ""],
    ["efa1", ""],
    ["f0a1", ""],
    ["f1a1", ""],
    ["f2a1", ""],
    ["f3a1", ""],
    ["f4a1", ""],
    ["f9a1", ""],
    ["faa1", ""],
    ["fba1", ""],
    ["fca1", ""],
    ["fcf1", "", 9, ""],
    ["8fa2af", ""],
    ["8fa2c2", ""],
    ["8fa2eb", ""],
    ["8fa6e1", ""],
    ["8fa6e7", ""],
    ["8fa6e9", ""],
    ["8fa6ec", ""],
    ["8fa6f1", ""],
    ["8fa7c2", "", 10, ""],
    ["8fa7f2", "", 10, ""],
    ["8fa9a1", ""],
    ["8fa9a4", ""],
    ["8fa9a6", ""],
    ["8fa9a8", ""],
    ["8fa9ab", ""],
    ["8fa9af", ""],
    ["8fa9c1", ""],
    ["8faaa1", ""],
    ["8faaba", ""],
    ["8faba1", ""],
    ["8fabbd", ""],
    ["8fabc5", ""],
    ["8fb0a1", ""],
    ["8fb1a1", ""],
    ["8fb2a1", "", 4, ""],
    ["8fb3a1", ""],
    ["8fb4a1", ""],
    ["8fb5a1", ""],
    ["8fb6a1", "", 5, "", 4, ""],
    ["8fb7a1", "", 4, ""],
    ["8fb8a1", ""],
    ["8fb9a1", ""],
    ["8fbaa1", "", 4, ""],
    ["8fbba1", ""],
    ["8fbca1", "", 4, ""],
    ["8fbda1", "", 4, ""],
    ["8fbea1", "", 4, ""],
    ["8fbfa1", ""],
    ["8fc0a1", ""],
    ["8fc1a1", ""],
    ["8fc2a1", ""],
    ["8fc3a1", "", 4, ""],
    ["8fc4a1", ""],
    ["8fc5a1", ""],
    ["8fc6a1", ""],
    ["8fc7a1", ""],
    ["8fc8a1", ""],
    ["8fc9a1", "", 4, "", 4, ""],
    ["8fcaa1", ""],
    ["8fcba1", ""],
    ["8fcca1", "", 9, ""],
    ["8fcda1", "", 5, ""],
    ["8fcea1", "", 6, ""],
    ["8fcfa1", ""],
    ["8fd0a1", ""],
    ["8fd1a1", ""],
    ["8fd2a1", "", 5],
    ["8fd3a1", ""],
    ["8fd4a1", "", 4, ""],
    ["8fd5a1", ""],
    ["8fd6a1", ""],
    ["8fd7a1", ""],
    ["8fd8a1", ""],
    ["8fd9a1", "", 4, "", 6, ""],
    ["8fdaa1", "", 4, ""],
    ["8fdba1", "", 6, ""],
    ["8fdca1", "", 4, ""],
    ["8fdda1", "", 4, ""],
    ["8fdea1", "", 4, ""],
    ["8fdfa1", ""],
    ["8fe0a1", ""],
    ["8fe1a1", "", 4, ""],
    ["8fe2a1", ""],
    ["8fe3a1", "", 5, "", 4, ""],
    ["8fe4a1", "", 4, ""],
    ["8fe5a1", "", 4, ""],
    ["8fe6a1", ""],
    ["8fe7a1", ""],
    ["8fe8a1", "", 4, ""],
    ["8fe9a1", "", 4],
    ["8feaa1", "", 4, ""],
    ["8feba1", "", 4, ""],
    ["8feca1", ""],
    ["8feda1", "", 4, "", 4, ""]
  ];
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS((exports2, module2) => {
  module2.exports = [
    ["0", " ", 127, ""],
    ["8140", "", 5, "", 9, "", 6, ""],
    ["8180", "", 6, "", 4, "", 4, "", 5, ""],
    ["8240", "", 4, "", 8, "", 4, "", 11],
    ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""],
    ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""],
    ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5],
    ["8440", "", 5, "", 5, ""],
    ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""],
    ["8540", "", 9, ""],
    ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""],
    ["8640", "", 4, "", 5, "", 4, "", 5, ""],
    ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""],
    ["8740", "", 7, "", 11, "", 4, "", 4],
    ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6],
    ["8840", "", 9, "", 4, "", 4, ""],
    ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7],
    ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""],
    ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""],
    ["8a40", "", 4, "", 12, ""],
    ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5],
    ["8b40", "", 8, "", 17, "", 6, "", 13, ""],
    ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6],
    ["8c40", "", 7, ""],
    ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4],
    ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4],
    ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""],
    ["8e40", "", 21, "", 12, "", 6, "", 12, ""],
    ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6],
    ["8f40", "", 5, "", 11, "", 8, ""],
    ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""],
    ["9040", "", 4, "", 4, "", 6, ""],
    ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6],
    ["9140", "", 6, "", 6, "", 18, "", 4, ""],
    ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""],
    ["9240", "", 6, "", 5, ""],
    ["9280", "", 5, "", 7, "", 6, ""],
    ["9340", "", 6, "", 4, "", 4, "", 5, ""],
    ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""],
    ["9440", "", 24, "", 7, "", 7, "", 4, "", 8],
    ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""],
    ["9540", "", 4, "", 4, "", 6, ""],
    ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""],
    ["9640", "", 5, "", 4, ""],
    ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5],
    ["9740", "", 7, "", 8, "", 7, "", 9, ""],
    ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""],
    ["9840", "", 4, "", 5, "", 9, ""],
    ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""],
    ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5],
    ["9980", "", 114, "", 6],
    ["9a40", "", 11, "", 7, "", 13, ""],
    ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""],
    ["9b40", "", 4, ""],
    ["9b80", "", 5, "", 4, "", 4, "", 5, ""],
    ["9c40", "", 7, ""],
    ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5],
    ["9d40", "", 7, "", 4, "", 9, "", 6, ""],
    ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""],
    ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6],
    ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""],
    ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""],
    ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4],
    ["a040", "", 9, "", 5, "", 9, "", 11, "", 19],
    ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""],
    ["a1a1", "", 7, ""],
    ["a2a1", "", 9],
    ["a2b1", "", 19, "", 19, "", 9],
    ["a2e5", "", 9],
    ["a2f1", "", 11],
    ["a3a1", "", 88, ""],
    ["a4a1", "", 82],
    ["a5a1", "", 85],
    ["a6a1", "", 16, "", 6],
    ["a6c1", "", 16, "", 6],
    ["a6e0", ""],
    ["a6ee", ""],
    ["a6f4", ""],
    ["a7a1", "", 5, "", 25],
    ["a7d1", "", 5, "", 25],
    ["a840", "", 35, "", 6],
    ["a880", "", 7, ""],
    ["a8a1", ""],
    ["a8bd", ""],
    ["a8c0", ""],
    ["a8c5", "", 36],
    ["a940", "", 8, ""],
    ["a959", ""],
    ["a95c", ""],
    ["a960", "", 9, "", 8],
    ["a980", "", 4, ""],
    ["a996", ""],
    ["a9a4", "", 75],
    ["aa40", "", 5, "", 5, "", 8],
    ["aa80", "", 7, "", 10, ""],
    ["ab40", "", 11, "", 4, "", 5, "", 4],
    ["ab80", "", 6, "", 4],
    ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11],
    ["ac80", "", 6, "", 12, "", 4, ""],
    ["ad40", "", 10, "", 7, "", 15, "", 12],
    ["ad80", "", 9, "", 8, "", 6, ""],
    ["ae40", "", 6, "", 7, "", 4, ""],
    ["ae80", "", 7, "", 6, "", 4, ""],
    ["af40", "", 4, ""],
    ["af80", ""],
    ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""],
    ["b080", "", 7, "", 8, "", 9, ""],
    ["b140", "", 4, "", 7, "", 10, ""],
    ["b180", "", 4, "", 7, "", 7, ""],
    ["b240", "", 11, "", 5, "", 11, "", 4],
    ["b280", "", 12, "", 8, "", 4, ""],
    ["b340", "", 5, ""],
    ["b380", "", 11, "", 7, "", 6, ""],
    ["b440", "", 7, "", 9],
    ["b480", "", 4, "", 5, "", 6, ""],
    ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""],
    ["b580", "", 6, "", 4, ""],
    ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""],
    ["b680", "", 6, "", 4, ""],
    ["b740", "", 14, "", 5, "", 9, "", 4, "", 16],
    ["b780", "", 6, ""],
    ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""],
    ["b880", "", 4, ""],
    ["b940", "", 5, "", 10, "", 6, ""],
    ["b980", "", 7, ""],
    ["ba40", "", 4, "", 4, "", 7, "", 5, ""],
    ["ba80", "", 4, "", 5, "", 12, "", 5, ""],
    ["bb40", "", 9, "", 36, "", 5, "", 9],
    ["bb80", "", 6, "", 4, ""],
    ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5],
    ["bc80", "", 14, "", 6, ""],
    ["bd40", "", 54, "", 7],
    ["bd80", "", 32, ""],
    ["be40", "", 12, "", 6, "", 42],
    ["be80", "", 32, ""],
    ["bf40", "", 62],
    ["bf80", "", 4, "", 4, "", 21, ""],
    ["c040", "", 35, "", 23, ""],
    ["c080", "", 6, "", 9, ""],
    ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""],
    ["c180", "", 4, "", 4, "", 5, ""],
    ["c240", "", 6, "", 5, ""],
    ["c280", "", 13, "", 5, "", 11, ""],
    ["c340", "", 5, "", 4, "", 6, ""],
    ["c380", "", 12, "", 4, ""],
    ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""],
    ["c480", "", 7, "", 5, "", 6, ""],
    ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""],
    ["c580", "", 7, "", 7, ""],
    ["c640", ""],
    ["c680", "", 4, "", 9, ""],
    ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""],
    ["c780", ""],
    ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""],
    ["c880", "", 6, "", 4, "", 4, ""],
    ["c940", "", 4, "", 7, "", 12, ""],
    ["c980", "", 4, "", 4, "", 10, ""],
    ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10],
    ["ca80", "", 4, "", 8, ""],
    ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""],
    ["cb80", "", 5, "", 6, "", 14, ""],
    ["cc40", "", 4, "", 10, "", 15, "", 13, ""],
    ["cc80", "", 11, "", 4, "", 7, ""],
    ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""],
    ["cd80", ""],
    ["ce40", "", 6, "", 5, "", 7, ""],
    ["ce80", "", 4, "", 6, "", 4, ""],
    ["cf40", "", 4, "", 4, "", 6, "", 9],
    ["cf80", "", 5, "", 7, "", 4, ""],
    ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""],
    ["d080", "", 4, "", 4, "", 5, ""],
    ["d140", "", 4, "", 4, "", 6, "", 5],
    ["d180", "", 4, "", 4, "", 4, ""],
    ["d240", "", 8, "", 24, "", 5, "", 19, ""],
    ["d280", "", 26, ""],
    ["d340", "", 30, "", 6],
    ["d380", "", 4, "", 5, "", 21, ""],
    ["d440", "", 31, "", 8, "", 21],
    ["d480", "", 25, "", 6, ""],
    ["d540", "", 7, "", 7, "", 46],
    ["d580", "", 32, ""],
    ["d640", "", 34, "", 27],
    ["d680", "", 30, ""],
    ["d740", "", 31, "", 4, "", 25],
    ["d780", "", 24, ""],
    ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""],
    ["d880", "", 6, "", 20, ""],
    ["d940", "", 62],
    ["d980", "", 32, ""],
    ["da40", "", 14, "", 8, "", 4, "", 9, ""],
    ["da80", "", 12, ""],
    ["db40", "", 6, "", 7, "", 4, ""],
    ["db80", "", 4, "", 5, "", 11, ""],
    ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7],
    ["dc80", "", 10, "", 21, ""],
    ["dd40", "", 62],
    ["dd80", "", 32, ""],
    ["de40", "", 32, ""],
    ["de80", "", 4, ""],
    ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""],
    ["df80", "", 4, ""],
    ["e040", "", 19, ""],
    ["e080", "", 10, "", 6, "", 8, ""],
    ["e140", "", 4, "", 6, "", 5, "", 5, ""],
    ["e180", "", 10, "", 9, "", 8, ""],
    ["e240", "", 62],
    ["e280", "", 32, "", 5, ""],
    ["e340", "", 45, "", 16],
    ["e380", "", 7, "", 24, ""],
    ["e440", "", 5, "", 24, "", 31],
    ["e480", "", 32, ""],
    ["e540", "", 51, "", 10],
    ["e580", "", 31, ""],
    ["e640", "", 34, "", 27],
    ["e680", "", 29, ""],
    ["e740", "", 7, "", 54],
    ["e780", "", 32, "", 6, "", 4, ""],
    ["e840", "", 14, "", 43, ""],
    ["e880", "", 20, ""],
    ["e940", "", 7, "", 42],
    ["e980", "", 32, ""],
    ["ea40", "", 27, "", 6, ""],
    ["ea80", "", 4, "", 12, ""],
    ["eb40", "", 9, "", 7, "", 9, "", 6, ""],
    ["eb80", "", 4, ""],
    ["ec40", "", 8, "", 4, "", 18, "", 7],
    ["ec80", "", 4, "", 7, "", 4, "", 4, ""],
    ["ed40", "", 6, "", 46],
    ["ed80", "", 4, "", 23, ""],
    ["ee40", "", 62],
    ["ee80", "", 32, "", 4, "", 6, ""],
    ["ef40", "", 5, "", 37, "", 4],
    ["ef80", "", 30, "", 4, "", 8, ""],
    ["f040", "", 4, "", 28, "", 26],
    ["f080", "", 9, "", 12, "", 4, "", 6, ""],
    ["f140", "", 10, "", 47],
    ["f180", "", 32, ""],
    ["f240", "", 62],
    ["f280", "", 32, ""],
    ["f340", "", 17, "", 6, "", 4, ""],
    ["f380", "", 8, "", 6, ""],
    ["f440", "", 5, "", 10, "", 10, "", 7, "", 5],
    ["f480", "", 32, ""],
    ["f540", "", 62],
    ["f580", "", 32, ""],
    ["f640", "", 62],
    ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""],
    ["f740", "", 62],
    ["f780", "", 4, "", 4, ""],
    ["f840", "", 62],
    ["f880", "", 32],
    ["f940", "", 62],
    ["f980", "", 32],
    ["fa40", "", 62],
    ["fa80", "", 32],
    ["fb40", "", 27, "", 9, ""],
    ["fb80", "", 5, "", 8, "", 5, ""],
    ["fc40", "", 8, "", 4, "", 8, "", 6],
    ["fc80", "", 4, "", 5, "", 8, ""],
    ["fd40", "", 4, "", 4, "", 10, "", 38],
    ["fd80", "", 5, "", 11, "", 4, ""],
    ["fe40", ""]
  ];
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS((exports2, module2) => {
  module2.exports = [
    ["a140", "", 62],
    ["a180", "", 32],
    ["a240", "", 62],
    ["a280", "", 32],
    ["a2ab", "", 5],
    ["a2e3", ""],
    ["a2ef", ""],
    ["a2fd", ""],
    ["a340", "", 62],
    ["a380", "", 31, ""],
    ["a440", "", 62],
    ["a480", "", 32],
    ["a4f4", "", 10],
    ["a540", "", 62],
    ["a580", "", 32],
    ["a5f7", "", 7],
    ["a640", "", 62],
    ["a680", "", 32],
    ["a6b9", "", 7],
    ["a6d9", "", 6],
    ["a6ec", ""],
    ["a6f3", ""],
    ["a6f6", "", 8],
    ["a740", "", 62],
    ["a780", "", 32],
    ["a7c2", "", 14],
    ["a7f2", "", 12],
    ["a896", "", 10],
    ["a8bc", ""],
    ["a8bf", ""],
    ["a8c1", ""],
    ["a8ea", "", 20],
    ["a958", ""],
    ["a95b", ""],
    ["a95d", ""],
    ["a989", "", 11],
    ["a997", "", 12],
    ["a9f0", "", 14],
    ["aaa1", "", 93],
    ["aba1", "", 93],
    ["aca1", "", 93],
    ["ada1", "", 93],
    ["aea1", "", 93],
    ["afa1", "", 93],
    ["d7fa", "", 4],
    ["f8a1", "", 93],
    ["f9a1", "", 93],
    ["faa1", "", 93],
    ["fba1", "", 93],
    ["fca1", "", 93],
    ["fda1", "", 93],
    ["fe50", ""],
    ["fe80", "", 6, "", 93]
  ];
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS((exports2, module2) => {
  module2.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189000] };
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS((exports2, module2) => {
  module2.exports = [
    ["0", " ", 127],
    ["8141", "", 4, "", 6, ""],
    ["8161", "", 9, "", 5, ""],
    ["8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, ""],
    ["8241", "", 7, "", 5],
    ["8261", "", 6, "", 5, ""],
    ["8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18],
    ["8341", "", 5, "", 5, "", 7],
    ["8361", "", 18, ""],
    ["8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8],
    ["8441", "", 5, "", 8],
    ["8461", "", 18],
    ["8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, ""],
    ["8541", "", 5, "", 4, "", 6, "", 4],
    ["8561", "", 5, "", 5, "", 6, ""],
    ["8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, ""],
    ["8641", "", 6, "", 5, ""],
    ["8661", "", 6, "", 10],
    ["8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, ""],
    ["8741", "", 9, "", 15],
    ["8761", "", 18, ""],
    ["8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4],
    ["8841", "", 4, "", 5, "", 6, "", 4],
    ["8861", "", 4, ""],
    ["8881", "", 15, "", 4, "", 6, "", 5, "", 54, ""],
    ["8941", "", 6, "", 5, ""],
    ["8961", "", 10, "", 5, ""],
    ["8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15],
    ["8a41", "", 10, "", 6, ""],
    ["8a61", "", 4, "", 18, ""],
    ["8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, ""],
    ["8b41", "", 5, "", 4, "", 6, ""],
    ["8b61", "", 6, "", 8],
    ["8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18],
    ["8c41", "", 15, "", 4],
    ["8c61", "", 6, "", 5, "", 6, "", 5],
    ["8c81", "", 12, "", 26, "", 50, "", 5, "", 16],
    ["8d41", "", 16, "", 8],
    ["8d61", "", 17, ""],
    ["8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, ""],
    ["8e41", "", 6, "", 5, "", 8],
    ["8e61", "", 4, "", 19],
    ["8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7],
    ["8f41", "", 7, "", 17],
    ["8f61", "", 7, "", 6, "", 4],
    ["8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5],
    ["9041", "", 6, "", 5, ""],
    ["9061", "", 5, "", 15],
    ["9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, ""],
    ["9141", "", 6, "", 5],
    ["9161", "", 9, "", 5],
    ["9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6],
    ["9241", "", 7, "", 4, ""],
    ["9261", "", 7, "", 7, "", 4],
    ["9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, ""],
    ["9341", "", 4, ""],
    ["9361", "", 6, "", 8],
    ["9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, ""],
    ["9441", "", 5, "", 5, "", 8],
    ["9461", "", 5, "", 6, "", 12],
    ["9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24],
    ["9541", "", 11, "", 5, ""],
    ["9561", "", 6, "", 5, ""],
    ["9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14],
    ["9641", "", 23, ""],
    ["9661", "", 6, "", 5, "", 8],
    ["9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44],
    ["9741", "", 16, "", 8],
    ["9761", "", 17, "", 7],
    ["9781", "", 11, "", 5, "", 6, "", 89, ""],
    ["9841", "", 16, "", 5, ""],
    ["9861", "", 6, "", 15],
    ["9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, ""],
    ["9941", "", 6, "", 5, ""],
    ["9961", "", 6, "", 5, ""],
    ["9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, ""],
    ["9a41", "", 16],
    ["9a61", "", 6, "", 6, ""],
    ["9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, ""],
    ["9b41", "", 6, "", 8],
    ["9b61", "", 17, "", 7],
    ["9b81", "", 25, "", 4, "", 5, "", 50, "", 22, ""],
    ["9c41", "", 4, "", 5, "", 5],
    ["9c61", "", 8, "", 6, "", 9],
    ["9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12],
    ["9d41", "", 13, "", 8],
    ["9d61", "", 25],
    ["9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, ""],
    ["9e41", "", 7, "", 9, ""],
    ["9e61", "", 4, "", 6, ""],
    ["9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, ""],
    ["9f41", "", 5, "", 4, "", 5, ""],
    ["9f61", "", 6, "", 5, ""],
    ["9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, ""],
    ["a041", "", 5, "", 6, ""],
    ["a061", "", 5, "", 13],
    ["a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, ""],
    ["a141", "", 18, ""],
    ["a161", "", 6, "", 5, ""],
    ["a181", "", 14, "", 5, "", 4, "", 9, ""],
    ["a241", "", 5, "", 18],
    ["a261", "", 6, "", 18],
    ["a281", "", 7, "", 6, "", 7, ""],
    ["a341", "", 6, "", 10, ""],
    ["a361", "", 6, "", 16],
    ["a381", "", 16, "", 4, "", 58, "", 32, ""],
    ["a441", "", 5, ""],
    ["a461", "", 5, "", 12],
    ["a481", "", 28, "", 93],
    ["a541", "", 4, "", 6, "", 5, ""],
    ["a561", "", 17, "", 5, ""],
    ["a581", "", 16, "", 14, "", 9],
    ["a5b0", "", 9],
    ["a5c1", "", 16, "", 6],
    ["a5e1", "", 16, "", 6],
    ["a641", "", 19, ""],
    ["a661", "", 5, "", 5, "", 6],
    ["a681", "", 6, "", 18, "", 7],
    ["a741", "", 4, "", 6, "", 7],
    ["a761", "", 22, ""],
    ["a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, ""],
    ["a841", "", 10, "", 14],
    ["a861", "", 18, "", 6],
    ["a881", "", 19, "", 11, ""],
    ["a8a6", ""],
    ["a8a8", ""],
    ["a8b1", "", 27, "", 25, "", 14, ""],
    ["a941", "", 14, "", 10],
    ["a961", "", 18],
    ["a981", "", 14, "", 6, "", 27, "", 25, "", 14, ""],
    ["aa41", "", 6, "", 4, ""],
    ["aa61", "", 4, "", 5, "", 6, ""],
    ["aa81", "", 29, "", 82],
    ["ab41", "", 6, "", 5, ""],
    ["ab61", "", 6, "", 5, "", 5],
    ["ab81", "", 8, "", 6, "", 12, "", 85],
    ["ac41", "", 5, "", 6, ""],
    ["ac61", "", 11, "", 4],
    ["ac81", "", 28, "", 5, "", 25],
    ["acd1", "", 5, "", 25],
    ["ad41", "", 6, "", 5, "", 7],
    ["ad61", "", 6, "", 10, ""],
    ["ad81", "", 5, "", 18, ""],
    ["ae41", "", 5, "", 16],
    ["ae61", "", 5, "", 6, "", 4],
    ["ae81", "", 6, "", 5, ""],
    ["af41", "", 19],
    ["af61", "", 13, "", 5, ""],
    ["af81", "", 5, "", 6, "", 5, ""],
    ["b041", "", 5, "", 5, "", 12],
    ["b061", "", 5, "", 19],
    ["b081", "", 13, "", 6, "", 5, "", 7, "", 4, ""],
    ["b141", "", 6, "", 5, ""],
    ["b161", "", 6, "", 5, "", 11],
    ["b181", "", 14, "", 6, ""],
    ["b241", "", 6, "", 5, ""],
    ["b261", "", 18, "", 5, ""],
    ["b281", "", 5, "", 18, "", 6, ""],
    ["b341", "", 19, ""],
    ["b361", "", 5, "", 5, "", 5],
    ["b381", "", 5, "", 5, "", 19, "", 4, ""],
    ["b441", "", 5, "", 6, "", 5],
    ["b461", "", 6, "", 10, ""],
    ["b481", "", 6, "", 18, "", 4, "", 4, ""],
    ["b541", "", 14, "", 5],
    ["b561", "", 5, "", 5, "", 4],
    ["b581", "", 6, "", 5, "", 11, ""],
    ["b641", "", 7, "", 17],
    ["b661", "", 15, ""],
    ["b681", "", 5, "", 6, "", 5, ""],
    ["b741", "", 13, "", 6, ""],
    ["b761", "", 20, ""],
    ["b781", "", 6, "", 14, ""],
    ["b841", "", 7, "", 17],
    ["b861", "", 8, "", 13],
    ["b881", "", 5, "", 24, "", 4, ""],
    ["b941", "", 6, "", 5, ""],
    ["b961", "", 14, "", 6, ""],
    ["b981", "", 22, "", 4, "", 4, ""],
    ["ba41", "", 5, "", 6, ""],
    ["ba61", "", 5, "", 4, "", 5],
    ["ba81", "", 6, "", 9, ""],
    ["bb41", "", 4, "", 5, "", 4, ""],
    ["bb61", "", 6, "", 5, ""],
    ["bb81", "", 31, ""],
    ["bc41", "", 17, ""],
    ["bc61", "", 5, "", 6, ""],
    ["bc81", "", 4, "", 6, "", 5, "", 5, "", 4, ""],
    ["bd41", "", 7, "", 7, ""],
    ["bd61", "", 5, "", 13],
    ["bd81", "", 5, "", 25, ""],
    ["be41", "", 7, "", 14],
    ["be61", "", 7, "", 7, ""],
    ["be81", "", 4, "", 4, "", 5, "", 8, "", 6, ""],
    ["bf41", "", 10, "", 14],
    ["bf61", "", 18, ""],
    ["bf81", "", 5, "", 7, "", 6, "", 5, ""],
    ["c041", "", 5, "", 6, "", 5],
    ["c061", "", 25],
    ["c081", "", 6, "", 5, "", 7, ""],
    ["c141", "", 5, "", 6, ""],
    ["c161", "", 19, ""],
    ["c181", "", 31, ""],
    ["c241", "", 4, "", 5, ""],
    ["c261", "", 4, "", 5, "", 6, ""],
    ["c281", "", 5, "", 7, "", 9, ""],
    ["c341", "", 4],
    ["c361", "", 4, "", 5, "", 11],
    ["c381", "", 5, "", 7, "", 5, ""],
    ["c441", "", 7, "", 7, ""],
    ["c461", "", 5, "", 4],
    ["c481", "", 5, "", 11, ""],
    ["c541", "", 6, "", 5, ""],
    ["c561", "", 6, "", 5, "", 4],
    ["c581", "", 6, "", 5, ""],
    ["c641", "", 6, "", 5],
    ["c6a1", ""],
    ["c7a1", ""],
    ["c8a1", ""],
    ["caa1", ""],
    ["cba1", ""],
    ["cca1", ""],
    ["cda1", ""],
    ["cea1", ""],
    ["cfa1", ""],
    ["d0a1", ""],
    ["d1a1", "", 5, "", 4, ""],
    ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""],
    ["d3a1", ""],
    ["d4a1", ""],
    ["d5a1", ""],
    ["d6a1", ""],
    ["d7a1", ""],
    ["d8a1", ""],
    ["d9a1", ""],
    ["daa1", ""],
    ["dba1", ""],
    ["dca1", ""],
    ["dda1", ""],
    ["dea1", ""],
    ["dfa1", ""],
    ["e0a1", ""],
    ["e1a1", ""],
    ["e2a1", ""],
    ["e3a1", ""],
    ["e4a1", ""],
    ["e5a1", ""],
    ["e6a1", ""],
    ["e7a1", ""],
    ["e8a1", ""],
    ["e9a1", ""],
    ["eaa1", ""],
    ["eba1", ""],
    ["eca1", ""],
    ["eda1", ""],
    ["eea1", ""],
    ["efa1", ""],
    ["f0a1", ""],
    ["f1a1", ""],
    ["f2a1", ""],
    ["f3a1", ""],
    ["f4a1", ""],
    ["f5a1", ""],
    ["f6a1", ""],
    ["f7a1", ""],
    ["f8a1", ""],
    ["f9a1", ""],
    ["faa1", ""],
    ["fba1", ""],
    ["fca1", ""],
    ["fda1", ""]
  ];
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS((exports2, module2) => {
  module2.exports = [
    ["0", " ", 127],
    ["a140", ""],
    ["a1a1", "", 4, ""],
    ["a240", "", 7, ""],
    ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21],
    ["a340", "", 16, "", 6, "", 16, "", 6, "", 10],
    ["a3a1", "", 25, ""],
    ["a3e1", ""],
    ["a440", ""],
    ["a4a1", ""],
    ["a540", ""],
    ["a5a1", ""],
    ["a640", ""],
    ["a6a1", ""],
    ["a740", ""],
    ["a7a1", ""],
    ["a840", ""],
    ["a8a1", ""],
    ["a940", ""],
    ["a9a1", ""],
    ["aa40", ""],
    ["aaa1", ""],
    ["ab40", ""],
    ["aba1", ""],
    ["ac40", ""],
    ["aca1", ""],
    ["ad40", ""],
    ["ada1", ""],
    ["ae40", ""],
    ["aea1", ""],
    ["af40", ""],
    ["afa1", ""],
    ["b040", ""],
    ["b0a1", ""],
    ["b140", ""],
    ["b1a1", ""],
    ["b240", ""],
    ["b2a1", ""],
    ["b340", ""],
    ["b3a1", ""],
    ["b440", ""],
    ["b4a1", ""],
    ["b540", ""],
    ["b5a1", ""],
    ["b640", ""],
    ["b6a1", ""],
    ["b740", ""],
    ["b7a1", ""],
    ["b840", ""],
    ["b8a1", ""],
    ["b940", ""],
    ["b9a1", ""],
    ["ba40", ""],
    ["baa1", ""],
    ["bb40", ""],
    ["bba1", ""],
    ["bc40", ""],
    ["bca1", ""],
    ["bd40", ""],
    ["bda1", ""],
    ["be40", ""],
    ["bea1", ""],
    ["bf40", ""],
    ["bfa1", ""],
    ["c040", ""],
    ["c0a1", ""],
    ["c140", ""],
    ["c1a1", ""],
    ["c240", ""],
    ["c2a1", ""],
    ["c340", ""],
    ["c3a1", ""],
    ["c440", ""],
    ["c4a1", ""],
    ["c540", ""],
    ["c5a1", ""],
    ["c640", ""],
    ["c940", ""],
    ["c9a1", ""],
    ["ca40", ""],
    ["caa1", ""],
    ["cb40", ""],
    ["cba1", ""],
    ["cc40", ""],
    ["cca1", ""],
    ["cd40", ""],
    ["cda1", ""],
    ["ce40", ""],
    ["cea1", ""],
    ["cf40", ""],
    ["cfa1", ""],
    ["d040", ""],
    ["d0a1", ""],
    ["d140", ""],
    ["d1a1", ""],
    ["d240", ""],
    ["d2a1", ""],
    ["d340", ""],
    ["d3a1", ""],
    ["d440", ""],
    ["d4a1", ""],
    ["d540", ""],
    ["d5a1", ""],
    ["d640", ""],
    ["d6a1", ""],
    ["d740", ""],
    ["d7a1", ""],
    ["d840", ""],
    ["d8a1", ""],
    ["d940", ""],
    ["d9a1", ""],
    ["da40", ""],
    ["daa1", ""],
    ["db40", ""],
    ["dba1", ""],
    ["dc40", ""],
    ["dca1", ""],
    ["dd40", ""],
    ["dda1", ""],
    ["de40", ""],
    ["dea1", ""],
    ["df40", ""],
    ["dfa1", ""],
    ["e040", ""],
    ["e0a1", ""],
    ["e140", ""],
    ["e1a1", ""],
    ["e240", ""],
    ["e2a1", ""],
    ["e340", ""],
    ["e3a1", ""],
    ["e440", ""],
    ["e4a1", ""],
    ["e540", ""],
    ["e5a1", ""],
    ["e640", ""],
    ["e6a1", ""],
    ["e740", ""],
    ["e7a1", ""],
    ["e840", ""],
    ["e8a1", ""],
    ["e940", ""],
    ["e9a1", ""],
    ["ea40", ""],
    ["eaa1", ""],
    ["eb40", ""],
    ["eba1", ""],
    ["ec40", ""],
    ["eca1", ""],
    ["ed40", ""],
    ["eda1", ""],
    ["ee40", ""],
    ["eea1", ""],
    ["ef40", ""],
    ["efa1", ""],
    ["f040", ""],
    ["f0a1", ""],
    ["f140", ""],
    ["f1a1", ""],
    ["f240", ""],
    ["f2a1", ""],
    ["f340", ""],
    ["f3a1", ""],
    ["f440", ""],
    ["f4a1", ""],
    ["f540", ""],
    ["f5a1", ""],
    ["f640", ""],
    ["f6a1", ""],
    ["f740", ""],
    ["f7a1", ""],
    ["f840", ""],
    ["f8a1", ""],
    ["f940", ""],
    ["f9a1", ""]
  ];
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS((exports2, module2) => {
  module2.exports = [
    ["8740", ""],
    ["8767", ""],
    ["87a1", ""],
    ["8840", "", 4, ""],
    ["88a1", ""],
    ["8940", ""],
    ["8943", ""],
    ["8946", ""],
    ["894c", ""],
    ["89a1", ""],
    ["89ab", ""],
    ["89b0", ""],
    ["89b5", ""],
    ["89c1", ""],
    ["89c5", ""],
    ["8a40", ""],
    ["8a43", ""],
    ["8a64", ""],
    ["8a76", ""],
    ["8aa1", ""],
    ["8aac", ""],
    ["8ab2", ""],
    ["8abb", ""],
    ["8ac9", ""],
    ["8ace", ""],
    ["8adf", ""],
    ["8af6", ""],
    ["8b40", ""],
    ["8b55", ""],
    ["8ba1", ""],
    ["8bde", ""],
    ["8c40", ""],
    ["8ca1", ""],
    ["8ca7", ""],
    ["8cc9", ""],
    ["8cce", ""],
    ["8ce6", ""],
    ["8d40", ""],
    ["8d42", ""],
    ["8da1", ""],
    ["8e40", ""],
    ["8ea1", ""],
    ["8f40", ""],
    ["8fa1", ""],
    ["9040", ""],
    ["90a1", ""],
    ["9140", ""],
    ["91a1", ""],
    ["9240", ""],
    ["92a1", ""],
    ["9340", ""],
    ["93a1", ""],
    ["9440", ""],
    ["94a1", ""],
    ["9540", ""],
    ["95a1", ""],
    ["9640", ""],
    ["96a1", ""],
    ["9740", ""],
    ["97a1", ""],
    ["9840", ""],
    ["98a1", ""],
    ["9940", ""],
    ["99a1", ""],
    ["9a40", ""],
    ["9aa1", ""],
    ["9b40", ""],
    ["9b62", ""],
    ["9ba1", ""],
    ["9c40", ""],
    ["9ca1", ""],
    ["9d40", ""],
    ["9da1", ""],
    ["9e40", ""],
    ["9ea1", ""],
    ["9ead", ""],
    ["9ec5", ""],
    ["9ef5", ""],
    ["9f40", ""],
    ["9f4f", ""],
    ["9fa1", ""],
    ["9fae", ""],
    ["9fb2", ""],
    ["9fc1", ""],
    ["9fc9", ""],
    ["9fdb", ""],
    ["9fe7", ""],
    ["9feb", ""],
    ["9ff0", ""],
    ["a040", ""],
    ["a055", ""],
    ["a058", ""],
    ["a05b", ""],
    ["a063", ""],
    ["a073", ""],
    ["a0a1", ""],
    ["a0a6", ""],
    ["a0ae", ""],
    ["a0b0", ""],
    ["a0d4", ""],
    ["a0e2", ""],
    ["a3c0", "", 31, ""],
    ["c6a1", "", 9, "", 9, "", 9, "", 23],
    ["c740", "", 58, ""],
    ["c7a1", "", 81, "", 5, "", 4],
    ["c840", "", 26, "", 25, ""],
    ["c8a1", ""],
    ["c8cd", ""],
    ["c8f5", ""],
    ["f9fe", ""],
    ["fa40", ""],
    ["faa1", ""],
    ["fb40", ""],
    ["fba1", ""],
    ["fc40", ""],
    ["fca1", ""],
    ["fd40", ""],
    ["fda1", ""],
    ["fe40", ""],
    ["fea1", ""]
  ];
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS((exports2, module2) => {
  module2.exports = {
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return require_shiftjis();
      },
      encodeAdd: { "\xA5": 92, "\u203E": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    "932": "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return require_eucjp();
      },
      encodeAdd: { "\xA5": 92, "\u203E": 126 }
    },
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    windows936: "cp936",
    ms936: "cp936",
    "936": "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return require_cp936();
      }
    },
    gbk: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    gb18030: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      },
      gb18030: function() {
        return require_gb18030_ranges();
      },
      encodeSkipVals: [128],
      encodeAdd: { "\u20AC": 41699 }
    },
    chinese: "gb18030",
    windows949: "cp949",
    ms949: "cp949",
    "949": "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return require_cp949();
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    windows950: "cp950",
    ms950: "cp950",
    "950": "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return require_cp950();
      }
    },
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return require_cp950().concat(require_big5_added());
      },
      encodeSkipVals: [41676]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  };
});

// ../../node_modules/needle/node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS((exports2, module2) => {
  var modules = [
    require_internal(),
    require_utf16(),
    require_utf7(),
    require_sbcs_codec(),
    require_sbcs_data(),
    require_sbcs_data_generated(),
    require_dbcs_codec(),
    require_dbcs_data()
  ];
  for (i = 0;i < modules.length; i++) {
    module2 = modules[i];
    for (enc in module2)
      if (Object.prototype.hasOwnProperty.call(module2, enc))
        exports2[enc] = module2[enc];
  }
  var module2;
  var enc;
  var i;
});

// ../../node_modules/needle/node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS((exports2, module2) => {
  var IconvLiteEncoderStream = function(conv, options2) {
    this.conv = conv;
    options2 = options2 || {};
    options2.decodeStrings = false;
    Transform.call(this, options2);
  };
  var IconvLiteDecoderStream = function(conv, options2) {
    this.conv = conv;
    options2 = options2 || {};
    options2.encoding = this.encoding = "utf8";
    Transform.call(this, options2);
  };
  var Buffer2 = __require("buffer").Buffer;
  var Transform = __require("stream").Transform;
  module2.exports = function(iconv) {
    iconv.encodeStream = function encodeStream(encoding, options2) {
      return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options2), options2);
    };
    iconv.decodeStream = function decodeStream(encoding, options2) {
      return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options2), options2);
    };
    iconv.supportsStreams = true;
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
  };
  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
  });
  IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
    if (typeof chunk != "string")
      return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length)
        this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      if (res && res.length)
        this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on("error", cb);
    this.on("data", function(chunk) {
      chunks.push(chunk);
    });
    this.on("end", function() {
      cb(null, Buffer2.concat(chunks));
    });
    return this;
  };
  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
  });
  IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
    if (!Buffer2.isBuffer(chunk))
      return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length)
        this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      if (res && res.length)
        this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res = "";
    this.on("error", cb);
    this.on("data", function(chunk) {
      res += chunk;
    });
    this.on("end", function() {
      cb(null, res);
    });
    return this;
  };
});

// ../../node_modules/needle/node_modules/iconv-lite/lib/extend-node.js
var require_extend_node = __commonJS((exports2, module2) => {
  var Buffer2 = __require("buffer").Buffer;
  module2.exports = function(iconv) {
    var original = undefined;
    iconv.supportsNodeEncodingsExtension = !(Buffer2.from || new Buffer2(0) instanceof Uint8Array);
    iconv.extendNodeEncodings = function extendNodeEncodings() {
      if (original)
        return;
      original = {};
      if (!iconv.supportsNodeEncodingsExtension) {
        console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
        console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
        return;
      }
      var nodeNativeEncodings = {
        hex: true,
        utf8: true,
        "utf-8": true,
        ascii: true,
        binary: true,
        base64: true,
        ucs2: true,
        "ucs-2": true,
        utf16le: true,
        "utf-16le": true
      };
      Buffer2.isNativeEncoding = function(enc) {
        return enc && nodeNativeEncodings[enc.toLowerCase()];
      };
      var SlowBuffer = __require("buffer").SlowBuffer;
      original.SlowBufferToString = SlowBuffer.prototype.toString;
      SlowBuffer.prototype.toString = function(encoding, start, end) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.SlowBufferToString.call(this, encoding, start, end);
        if (typeof start == "undefined")
          start = 0;
        if (typeof end == "undefined")
          end = this.length;
        return iconv.decode(this.slice(start, end), encoding);
      };
      original.SlowBufferWrite = SlowBuffer.prototype.write;
      SlowBuffer.prototype.write = function(string, offset, length3, encoding) {
        if (isFinite(offset)) {
          if (!isFinite(length3)) {
            encoding = length3;
            length3 = undefined;
          }
        } else {
          var swap = encoding;
          encoding = offset;
          offset = length3;
          length3 = swap;
        }
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length3) {
          length3 = remaining;
        } else {
          length3 = +length3;
          if (length3 > remaining) {
            length3 = remaining;
          }
        }
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.SlowBufferWrite.call(this, string, offset, length3, encoding);
        if (string.length > 0 && (length3 < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string, encoding);
        if (buf.length < length3)
          length3 = buf.length;
        buf.copy(this, offset, 0, length3);
        return length3;
      };
      original.BufferIsEncoding = Buffer2.isEncoding;
      Buffer2.isEncoding = function(encoding) {
        return Buffer2.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
      };
      original.BufferByteLength = Buffer2.byteLength;
      Buffer2.byteLength = SlowBuffer.byteLength = function(str, encoding) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferByteLength.call(this, str, encoding);
        return iconv.encode(str, encoding).length;
      };
      original.BufferToString = Buffer2.prototype.toString;
      Buffer2.prototype.toString = function(encoding, start, end) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferToString.call(this, encoding, start, end);
        if (typeof start == "undefined")
          start = 0;
        if (typeof end == "undefined")
          end = this.length;
        return iconv.decode(this.slice(start, end), encoding);
      };
      original.BufferWrite = Buffer2.prototype.write;
      Buffer2.prototype.write = function(string, offset, length3, encoding) {
        var _offset = offset, _length = length3, _encoding = encoding;
        if (isFinite(offset)) {
          if (!isFinite(length3)) {
            encoding = length3;
            length3 = undefined;
          }
        } else {
          var swap = encoding;
          encoding = offset;
          offset = length3;
          length3 = swap;
        }
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferWrite.call(this, string, _offset, _length, _encoding);
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length3) {
          length3 = remaining;
        } else {
          length3 = +length3;
          if (length3 > remaining) {
            length3 = remaining;
          }
        }
        if (string.length > 0 && (length3 < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string, encoding);
        if (buf.length < length3)
          length3 = buf.length;
        buf.copy(this, offset, 0, length3);
        return length3;
      };
      if (iconv.supportsStreams) {
        var Readable = __require("stream").Readable;
        original.ReadableSetEncoding = Readable.prototype.setEncoding;
        Readable.prototype.setEncoding = function setEncoding(enc, options2) {
          this._readableState.decoder = iconv.getDecoder(enc, options2);
          this._readableState.encoding = enc;
        };
        Readable.prototype.collect = iconv._collect;
      }
    };
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
      if (!iconv.supportsNodeEncodingsExtension)
        return;
      if (!original)
        throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
      delete Buffer2.isNativeEncoding;
      var SlowBuffer = __require("buffer").SlowBuffer;
      SlowBuffer.prototype.toString = original.SlowBufferToString;
      SlowBuffer.prototype.write = original.SlowBufferWrite;
      Buffer2.isEncoding = original.BufferIsEncoding;
      Buffer2.byteLength = original.BufferByteLength;
      Buffer2.prototype.toString = original.BufferToString;
      Buffer2.prototype.write = original.BufferWrite;
      if (iconv.supportsStreams) {
        var Readable = __require("stream").Readable;
        Readable.prototype.setEncoding = original.ReadableSetEncoding;
        delete Readable.prototype.collect;
      }
      original = undefined;
    };
  };
});

// ../../node_modules/needle/node_modules/iconv-lite/lib/index.js
var require_lib3 = __commonJS((exports2, module2) => {
  var Buffer2 = require_safer().Buffer;
  var bomHandling = require_bom_handling();
  var iconv = exports2;
  iconv.encodings = null;
  iconv.defaultCharUnicode = "\uFFFD";
  iconv.defaultCharSingleByte = "?";
  iconv.encode = function encode(str, encoding, options2) {
    str = "" + (str || "");
    var encoder = iconv.getEncoder(encoding, options2);
    var res = encoder.write(str);
    var trail = encoder.end();
    return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
  };
  iconv.decode = function decode(buf, encoding, options2) {
    if (typeof buf === "string") {
      if (!iconv.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        iconv.skipDecodeWarning = true;
      }
      buf = Buffer2.from("" + (buf || ""), "binary");
    }
    var decoder = iconv.getDecoder(encoding, options2);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
  };
  iconv.encodingExists = function encodingExists(enc) {
    try {
      iconv.getCodec(enc);
      return true;
    } catch (e) {
      return false;
    }
  };
  iconv.toEncoding = iconv.encode;
  iconv.fromEncoding = iconv.decode;
  iconv._codecDataCache = {};
  iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
      iconv.encodings = require_encodings();
    var enc = iconv._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = iconv._codecDataCache[enc];
      if (codec)
        return codec;
      var codecDef = iconv.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key in codecDef)
            codecOptions[key] = codecDef[key];
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          codec = new codecDef(codecOptions, iconv);
          iconv._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  iconv._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  iconv.getEncoder = function getEncoder(encoding, options2) {
    var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options2, codec);
    if (codec.bomAware && options2 && options2.addBOM)
      encoder = new bomHandling.PrependBOM(encoder, options2);
    return encoder;
  };
  iconv.getDecoder = function getDecoder(encoding, options2) {
    var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options2, codec);
    if (codec.bomAware && !(options2 && options2.stripBOM === false))
      decoder = new bomHandling.StripBOM(decoder, options2);
    return decoder;
  };
  var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
  if (nodeVer) {
    nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
      require_streams()(iconv);
    }
    require_extend_node()(iconv);
  }
  var nodeVerArr;
  if (false) {
  }
});

// ../../node_modules/needle/lib/decoder.js
var require_decoder = __commonJS((exports2, module2) => {
  var StreamDecoder = function(charset) {
    if (!(this instanceof StreamDecoder))
      return new StreamDecoder(charset);
    stream2.Transform.call(this, charset);
    this.charset = charset;
    this.parsed_chunk = false;
  };
  var iconv;
  var inherits = __require("util").inherits;
  var stream2 = __require("stream");
  var regex = /(?:charset|encoding)\s*=\s*['"]? *([\w\-]+)/i;
  inherits(StreamDecoder, stream2.Transform);
  StreamDecoder.prototype._transform = function(chunk, encoding, done) {
    var res, found;
    if (this.charset == "iso-8859-1" && !this.parsed_chunk) {
      this.parsed_chunk = true;
      var matches = regex.exec(chunk.toString());
      if (matches) {
        found = matches[1].toLowerCase();
        this.charset = found == "utf-8" ? "utf8" : found;
      }
    }
    try {
      res = iconv.decode(chunk, this.charset);
    } catch (e) {
      res = chunk;
    }
    this.push(res);
    done();
  };
  module2.exports = function(charset) {
    try {
      if (!iconv)
        iconv = require_lib3();
    } catch (e) {
    }
    if (iconv)
      return new StreamDecoder(charset);
    else
      return new stream2.PassThrough;
  };
});

// ../../node_modules/needle/package.json
var require_package2 = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "needle",
    version: "2.4.0",
    description: "The leanest and most handsome HTTP client in the Nodelands.",
    keywords: [
      "http",
      "https",
      "simple",
      "request",
      "client",
      "multipart",
      "upload",
      "proxy",
      "deflate",
      "timeout",
      "charset",
      "iconv",
      "cookie",
      "redirect"
    ],
    tags: [
      "http",
      "https",
      "simple",
      "request",
      "client",
      "multipart",
      "upload",
      "proxy",
      "deflate",
      "timeout",
      "charset",
      "iconv",
      "cookie",
      "redirect"
    ],
    author: "Toms Pollak <tomas@forkhq.com>",
    repository: {
      type: "git",
      url: "https://github.com/tomas/needle.git"
    },
    dependencies: {
      debug: "^3.2.6",
      "iconv-lite": "^0.4.4",
      sax: "^1.2.4"
    },
    devDependencies: {
      JSONStream: "^1.3.5",
      jschardet: "^1.6.0",
      mocha: "^5.2.0",
      q: "^1.5.1",
      should: "^13.2.3",
      sinon: "^2.3.0",
      xml2js: "^0.4.19"
    },
    scripts: {
      test: "mocha test"
    },
    directories: {
      lib: "./lib"
    },
    main: "./lib/needle",
    bin: {
      needle: "./bin/needle"
    },
    license: "MIT",
    engines: {
      node: ">= 4.4.x"
    }
  };
});

// ../../node_modules/needle/lib/needle.js
var require_needle = __commonJS((exports2, module2) => {
  var keys_by_type = function(type2) {
    return Object.keys(defaults).map(function(el) {
      if (defaults[el] !== null && defaults[el].constructor == type2)
        return el;
    }).filter(function(el) {
      return el;
    });
  };
  var parse_content_type = function(header) {
    if (!header || header === "")
      return {};
    var found, charset = "iso-8859-1", arr = header.split(";");
    if (arr.length > 1 && (found = arr[1].match(/charset=(.+)/)))
      charset = found[1];
    return { type: arr[0], charset };
  };
  var is_stream = function(obj) {
    return typeof obj.pipe === "function";
  };
  var get_stream_length = function(stream3, given_length, cb) {
    if (given_length > 0)
      return cb(given_length);
    if (stream3.end !== undefined && stream3.end !== Infinity && stream3.start !== undefined)
      return cb(stream3.end + 1 - (stream3.start || 0));
    fs.stat(stream3.path, function(err, stat) {
      cb(stat ? stat.size - (stream3.start || 0) : null);
    });
  };
  var Needle = function(method, uri, data, options2, callback) {
    if (typeof uri !== "string")
      throw new TypeError("URL must be a string, not " + uri);
    this.method = method;
    this.uri = uri;
    this.data = data;
    if (typeof options2 == "function") {
      this.callback = options2;
      this.options = {};
    } else {
      this.callback = callback;
      this.options = options2;
    }
  };
  var fs = __require("fs");
  var http = __require("http");
  var https = __require("https");
  var url = __require("url");
  var stream2 = __require("stream");
  var debug = require_src2()("needle");
  var stringify2 = require_querystring().build;
  var multipart = require_multipart();
  var auth = require_auth();
  var cookies = require_cookies();
  var parsers = require_parsers();
  var decoder = require_decoder();
  var version3 = require_package2().version;
  var user_agent = "Needle/" + version3;
  user_agent += " (Node.js " + process.version + "; " + process.platform + " " + process.arch + ")";
  var tls_options = "agent pfx key passphrase cert ca ciphers rejectUnauthorized secureProtocol checkServerIdentity";
  var close_by_default = !http.Agent || http.Agent.defaultMaxSockets != Infinity;
  var extend = Object.assign ? Object.assign : __require("util")._extend;
  var redirect_codes = [301, 302, 303, 307];
  var decompressors = {};
  try {
    zlib = __require("zlib");
    decompressors["x-deflate"] = zlib.Inflate;
    decompressors["deflate"] = zlib.Inflate;
    decompressors["x-gzip"] = zlib.Gunzip;
    decompressors["gzip"] = zlib.Gunzip;
    zlib_options = {
      flush: zlib.Z_SYNC_FLUSH,
      finishFlush: zlib.Z_SYNC_FLUSH
    };
  } catch (e) {
  }
  var zlib;
  var zlib_options;
  var defaults = {
    boundary: "--------------------NODENEEDLEHTTPCLIENT",
    encoding: "utf8",
    parse_response: "all",
    proxy: null,
    accept: "*/*",
    user_agent,
    open_timeout: 1e4,
    response_timeout: 0,
    read_timeout: 0,
    follow_max: 0,
    stream_length: -1,
    decode_response: true,
    parse_cookies: true,
    follow_set_cookies: false,
    follow_set_referer: false,
    follow_keep_method: false,
    follow_if_same_host: false,
    follow_if_same_protocol: false
  };
  var aliased = {
    options: {
      decode: "decode_response",
      parse: "parse_response",
      timeout: "open_timeout",
      follow: "follow_max"
    },
    inverted: {}
  };
  Object.keys(aliased.options).map(function(k) {
    var value = aliased.options[k];
    aliased.inverted[value] = k;
  });
  Needle.prototype.setup = function(uri, options2) {
    function get_option(key, fallback) {
      if (typeof options2[key] != "undefined")
        return options2[key];
      return typeof options2[aliased.inverted[key]] != "undefined" ? options2[aliased.inverted[key]] : fallback;
    }
    function check_value(expected, key) {
      var value = get_option(key), type2 = typeof value;
      if (type2 != "undefined" && type2 != expected)
        throw new TypeError(type2 + " received for " + key + ", but expected a " + expected);
      return type2 == expected ? value : defaults[key];
    }
    var config = {
      http_opts: {
        localAddress: get_option("localAddress", undefined)
      },
      output: options2.output,
      proxy: get_option("proxy", defaults.proxy),
      parser: get_option("parse_response", defaults.parse_response),
      encoding: options2.encoding || (options2.multipart ? "binary" : defaults.encoding)
    };
    keys_by_type(Boolean).forEach(function(key) {
      config[key] = check_value("boolean", key);
    });
    keys_by_type(Number).forEach(function(key) {
      config[key] = check_value("number", key);
    });
    tls_options.split(" ").forEach(function(key) {
      if (typeof options2[key] != "undefined") {
        config.http_opts[key] = options2[key];
        if (typeof options2.agent == "undefined")
          config.http_opts.agent = false;
      }
    });
    config.headers = {
      accept: options2.accept || defaults.accept,
      "user-agent": options2.user_agent || defaults.user_agent
    };
    if (options2.content_type)
      config.headers["content-type"] = options2.content_type;
    if (options2.connection || close_by_default)
      config.headers["connection"] = options2.connection || "close";
    if ((options2.compressed || defaults.compressed) && typeof zlib != "undefined")
      config.headers["accept-encoding"] = "gzip,deflate";
    if (options2.cookies)
      config.headers["cookie"] = cookies.write(options2.cookies);
    if (uri.match(/[^\/]@/)) {
      var parts = (url.parse(uri).auth || "").split(":");
      options2.username = parts[0];
      options2.password = parts[1];
    }
    if (options2.username) {
      if (options2.auth && (options2.auth == "auto" || options2.auth == "digest")) {
        config.credentials = [options2.username, options2.password];
      } else {
        config.headers["authorization"] = auth.basic(options2.username, options2.password);
      }
    }
    if (config.proxy) {
      if (config.proxy.indexOf("http") === -1)
        config.proxy = "http://" + config.proxy;
      if (config.proxy.indexOf("@") !== -1) {
        var proxy = (url.parse(config.proxy).auth || "").split(":");
        options2.proxy_user = proxy[0];
        options2.proxy_pass = proxy[1];
      }
      if (options2.proxy_user)
        config.headers["proxy-authorization"] = auth.basic(options2.proxy_user, options2.proxy_pass);
    }
    for (var h in options2.headers)
      config.headers[h.toLowerCase()] = options2.headers[h];
    return config;
  };
  Needle.prototype.start = function() {
    var out = new stream2.PassThrough({ objectMode: false }), uri = this.uri, data = this.data, method = this.method, callback = typeof this.options == "function" ? this.options : this.callback, options2 = this.options || {};
    if (uri.indexOf("http") === -1)
      uri = uri.replace(/^(\/\/)?/, "http://");
    var self2 = this, body, waiting = false, config = this.setup(uri, options2);
    var json = options2.json || options2.json !== false && config.headers["content-type"] == "application/json";
    if (data) {
      if (options2.multipart) {
        var boundary = options2.boundary || defaults.boundary;
        waiting = true;
        multipart.build(data, boundary, function(err, parts) {
          if (err)
            throw err;
          config.headers["content-type"] = "multipart/form-data; boundary=" + boundary;
          next(parts);
        });
      } else if (is_stream(data)) {
        if (method.toUpperCase() == "GET")
          throw new Error("Refusing to pipe() a stream via GET. Did you mean .post?");
        if (config.stream_length > 0 || config.stream_length === 0 && data.path) {
          waiting = true;
          get_stream_length(data, config.stream_length, function(length3) {
            data.length = length3;
            next(data);
          });
        } else {
          body = data;
        }
      } else if (Buffer.isBuffer(data)) {
        body = data;
      } else if (method.toUpperCase() == "GET" && !json) {
        uri = uri.replace(/\?.*|$/, "?" + stringify2(data));
      } else {
        body = typeof data === "string" ? data : json ? JSON.stringify(data) : stringify2(data);
        body = Buffer.from(body, config.encoding);
      }
    }
    function next(body2) {
      if (body2) {
        if (body2.length)
          config.headers["content-length"] = body2.length;
        if (!config.headers["content-type"]) {
          config.headers["content-type"] = json ? "application/json; charset=utf-8" : "application/x-www-form-urlencoded";
        }
      }
      if (options2.json && (!options2.accept && !(options2.headers || {}).accept))
        config.headers["accept"] = "application/json";
      self2.send_request(1, method, uri, config, body2, out, callback);
    }
    if (!waiting)
      next(body);
    return out;
  };
  Needle.prototype.get_request_opts = function(method, uri, config) {
    var { http_opts: opts, proxy } = config, remote = proxy ? url.parse(proxy) : url.parse(uri);
    opts.protocol = remote.protocol;
    opts.host = remote.hostname;
    opts.port = remote.port || (remote.protocol == "https:" ? 443 : 80);
    opts.path = proxy ? uri : remote.pathname + (remote.search || "");
    opts.method = method;
    opts.headers = config.headers;
    if (!opts.headers["host"]) {
      var target = proxy ? url.parse(uri) : remote;
      opts.headers["host"] = target.hostname;
      if (target.port && [80, 443].indexOf(target.port) === -1) {
        opts.headers["host"] += ":" + target.port;
      }
    }
    return opts;
  };
  Needle.prototype.should_follow = function(location2, config, original) {
    if (!location2)
      return false;
    function matches(property) {
      var property = original[property];
      return location2.indexOf(property) !== -1;
    }
    if (location2 === original)
      return false;
    if (config.follow_if_same_host && !matches("host"))
      return false;
    if (config.follow_if_same_protocol && !matches("protocol"))
      return false;
    return true;
  };
  Needle.prototype.send_request = function(count, method, uri, config, post_data, out, callback) {
    var timer, returned = 0, self2 = this, request_opts = this.get_request_opts(method, uri, config), protocol = request_opts.protocol == "https:" ? https : http;
    function done(err, resp) {
      if (returned++ > 0)
        return debug("Already finished, stopping here.");
      if (timer)
        clearTimeout(timer);
      request.removeListener("error", had_error);
      if (callback)
        return callback(err, resp, resp ? resp.body : undefined);
      out.emit("done", err);
    }
    function had_error(err) {
      debug("Request error", err);
      out.emit("err", err);
      done(err || new Error("Unknown error when making request."));
    }
    function set_timeout(type2, milisecs) {
      if (timer)
        clearTimeout(timer);
      if (milisecs <= 0)
        return;
      timer = setTimeout(function() {
        out.emit("timeout", type2);
        request.abort();
        if (type2 == "read")
          done(new Error(type2 + " timeout"));
      }, milisecs);
    }
    function on_socket_end() {
      if (!this.writable && this.destroyed === false) {
        this.destroy();
        had_error(new Error("Remote end closed socket abruptly."));
      }
    }
    debug("Making request #" + count, request_opts);
    var request = protocol.request(request_opts, function(resp) {
      var headers = resp.headers;
      debug("Got response", resp.statusCode, headers);
      out.emit("response", resp);
      set_timeout("read", config.read_timeout);
      if (config.parse_cookies && (headers["set-cookie"] || config.stored_cookies)) {
        resp.cookies = extend(config.stored_cookies || {}, cookies.read(headers["set-cookie"]));
        debug("Got cookies", resp.cookies);
      }
      if (redirect_codes.indexOf(resp.statusCode) !== -1 && self2.should_follow(headers.location, config, uri)) {
        clearTimeout(timer);
        if (count <= config.follow_max) {
          out.emit("redirect", headers.location);
          if (!config.follow_keep_method) {
            method = "GET";
            post_data = null;
            delete config.headers["content-length"];
          }
          if (config.follow_set_cookies && resp.cookies) {
            config.stored_cookies = resp.cookies;
            config.headers["cookie"] = cookies.write(resp.cookies);
          }
          if (config.follow_set_referer)
            config.headers["referer"] = encodeURI(uri);
          config.headers["host"] = null;
          debug("Redirecting to " + url.resolve(uri, headers.location));
          return self2.send_request(++count, method, url.resolve(uri, headers.location), config, post_data, out, callback);
        } else if (config.follow_max > 0) {
          return done(new Error("Max redirects reached. Possible loop in: " + headers.location));
        }
      }
      if (resp.statusCode == 401 && headers["www-authenticate"] && config.credentials) {
        if (!config.headers["authorization"]) {
          var auth_header = auth.header(headers["www-authenticate"], config.credentials, request_opts);
          if (auth_header) {
            config.headers["authorization"] = auth_header;
            return self2.send_request(count, method, uri, config, post_data, out, callback);
          }
        }
      }
      out.emit("header", resp.statusCode, headers);
      out.emit("headers", headers);
      var pipeline = [], mime = parse_content_type(headers["content-type"]), text_response = mime.type && mime.type.indexOf("text/") != -1;
      if (headers["content-encoding"] && decompressors[headers["content-encoding"]]) {
        var decompressor = decompressors[headers["content-encoding"]](zlib_options);
        decompressor.on("error", had_error);
        pipeline.push(decompressor);
      }
      if (config.parser && parsers[mime.type]) {
        var parser_name = config.parser.toString().toLowerCase();
        if (["xml", "json"].indexOf(parser_name) == -1 || parsers[mime.type].name == parser_name) {
          out.parser = parsers[mime.type].name;
          pipeline.push(parsers[mime.type].fn());
          out._writableState.objectMode = true;
          out._readableState.objectMode = true;
        }
      } else if (text_response && config.decode_response && mime.charset && !mime.charset.match(/utf-?8$/i)) {
        pipeline.push(decoder(mime.charset));
      }
      pipeline.push(out);
      var tmp = resp;
      while (pipeline.length) {
        tmp = tmp.pipe(pipeline.shift());
      }
      if (config.output && resp.statusCode == 200) {
        var file = fs.createWriteStream(config.output);
        file.on("error", had_error);
        out.on("end", function() {
          if (file.writable)
            file.end();
        });
        file.on("close", function() {
          delete out.file;
        });
        out.on("readable", function() {
          var chunk;
          while ((chunk = this.read()) !== null) {
            if (file.writable)
              file.write(chunk);
            if (resp.body)
              resp.body.push(chunk);
          }
        });
        out.file = file;
      }
      if (callback) {
        resp.raw = [];
        resp.body = [];
        resp.bytes = 0;
        var clean_pipe = new stream2.PassThrough;
        resp.pipe(clean_pipe);
        clean_pipe.on("readable", function() {
          var chunk;
          while ((chunk = this.read()) != null) {
            resp.bytes += chunk.length;
            resp.raw.push(chunk);
          }
        });
        if (!config.output || resp.statusCode != 200) {
          out.on("readable", function() {
            var chunk;
            while ((chunk = this.read()) !== null) {
              if (typeof chunk == "string")
                chunk = Buffer.from(chunk);
              resp.body.push(chunk);
            }
          });
        }
      }
      out.on("end", function() {
        if (resp.body) {
          resp.raw = Buffer.concat(resp.raw);
          if (resp.body[0] !== undefined && !Buffer.isBuffer(resp.body[0])) {
            resp.body = resp.body[0];
            if (out.parser)
              resp.parser = out.parser;
          } else {
            resp.body = Buffer.concat(resp.body);
            if (text_response || out.parser) {
              resp.body = resp.body.toString();
            }
          }
        }
        if (out.file) {
          out.file.on("close", function() {
            done(null, resp, resp.body);
          });
        } else {
          done(null, resp, resp.body);
        }
      });
    });
    set_timeout("open", config.open_timeout);
    request.on("error", had_error);
    request.once("abort", function() {
      if (timer)
        clearTimeout(timer);
    });
    request.once("socket", function(socket) {
      if (socket.connecting) {
        socket.once("connect", function() {
          set_timeout("response", config.response_timeout);
        });
      } else {
        set_timeout("response", config.response_timeout);
      }
      if (!socket.on_socket_end) {
        socket.on_socket_end = on_socket_end;
        socket.once("end", function() {
          process.nextTick(on_socket_end.bind(socket));
        });
      }
    });
    if (post_data) {
      if (is_stream(post_data)) {
        post_data.pipe(request);
      } else {
        request.write(post_data, config.encoding);
        request.end();
      }
    } else {
      request.end();
    }
    out.request = request;
    return out;
  };
  if (typeof Promise !== "undefined") {
    module2.exports = function() {
      var verb, args2 = [].slice.call(arguments);
      if (args2[0].match(/\.|\//))
        verb = args2.length > 2 ? "post" : "get";
      else
        verb = args2.shift();
      if (verb.match(/get|head/) && args2.length == 2)
        args2.splice(1, 0, null);
      return new Promise(function(resolve, reject) {
        module2.exports.request(verb, args2[0], args2[1], args2[2], function(err, resp) {
          return err ? reject(err) : resolve(resp);
        });
      });
    };
  }
  module2.exports.version = version3;
  module2.exports.defaults = function(obj) {
    for (var key in obj) {
      var target_key = aliased.options[key] || key;
      if (defaults.hasOwnProperty(target_key) && typeof obj[key] != "undefined") {
        if (target_key != "parse_response" && target_key != "proxy") {
          var valid_type = defaults[target_key].constructor.name;
          if (obj[key].constructor.name != valid_type)
            throw new TypeError("Invalid type for " + key + ", should be " + valid_type);
        }
        defaults[target_key] = obj[key];
      } else {
        throw new Error("Invalid property for defaults:" + target_key);
      }
    }
    return defaults;
  };
  "head get".split(" ").forEach(function(method) {
    module2.exports[method] = function(uri, options2, callback) {
      return new Needle(method, uri, null, options2, callback).start();
    };
  });
  "post put patch delete".split(" ").forEach(function(method) {
    module2.exports[method] = function(uri, data, options2, callback) {
      return new Needle(method, uri, data, options2, callback).start();
    };
  });
  module2.exports.request = function(method, uri, data, opts, callback) {
    return new Needle(method, uri, data, opts, callback).start();
  };
});

// ../../node_modules/pm2/lib/API/Modules/TAR.js
var require_TAR = __commonJS((exports2, module2) => {
  var install = function(PM2, module_filepath, opts, cb) {
    if (module_filepath.includes("http") === true) {
      var target_file = module_filepath.split("/").pop();
      var target_filepath = path2.join(os.tmpdir(), target_file);
      opts.install_url = module_filepath;
      return retrieveRemote(module_filepath, target_filepath, (err) => {
        if (err) {
          Common.errMod(err);
          process.exit(1);
        }
        installLocal(PM2, target_filepath, opts, cb);
      });
    }
    installLocal(PM2, module_filepath, opts, cb);
  };
  var retrieveRemote = function(url, dest, cb) {
    Common.logMod(`Retrieving remote package ${url}...`);
    var wget = spawn("wget", [url, "-O", dest, "-q"], {
      stdio: "inherit",
      env: process.env,
      windowsHide: true,
      shell: true
    });
    wget.on("error", (err) => {
      console.error(err.stack || err);
    });
    wget.on("close", (code) => {
      if (code !== 0)
        return cb(new Error("Could not download"));
      return cb(null);
    });
  };
  var installLocal = function(PM2, module_filepath, opts, cb) {
    Common.logMod(`Installing package ${module_filepath}`);
    getModuleName(module_filepath, function(err, module_name) {
      if (err)
        return cb(err);
      Common.logMod(`Module name is ${module_name}`);
      Common.logMod(`Depackaging module...`);
      var install_path = path2.join(cst.DEFAULT_MODULE_PATH, module_name);
      require_mkdirp().sync(install_path);
      var install_instance = spawn("tar", ["zxf", module_filepath, "-C", install_path, "--strip-components 1"], {
        stdio: "inherit",
        env: process.env,
        shell: true
      });
      install_instance.on("close", function(code) {
        Common.logMod(`Module depackaged in ${install_path}`);
        if (code == 0)
          return runInstall(PM2, install_path, module_name, opts, cb);
        return PM2.exitCli(1);
      });
      install_instance.on("error", function(err2) {
        console.error(err2.stack || err2);
      });
    });
  };
  var deleteModulePath = function(module_name) {
    var sanitized = module_name.replace(/\./g, "");
    deleteFolderRecursive(path2.join(cst.DEFAULT_MODULE_PATH, module_name));
  };
  var runInstall = function(PM2, target_path, module_name, opts, cb) {
    var config_file = path2.join(target_path, "package.json");
    var conf2;
    try {
      conf2 = __require(config_file);
      module_name = conf2.name;
    } catch (e) {
      Common.errMod(new Error("Cannot find package.json file with name attribute at least"));
    }
    opts.started_as_module = true;
    opts.cwd = target_path;
    if (needPrefix(conf2))
      opts.name_prefix = module_name;
    if (opts.install) {
      Common.logMod(`Running YARN install...`);
      sexec(`cd ${target_path} ; yarn install`, { silent: false }, function(code) {
        Common.logMod(`Starting ${target_path}`);
        PM2.start(conf2, opts, function(err, data) {
          if (err)
            return cb(err);
          Configuration.setSync(`${cst.MODULE_CONF_PREFIX_TAR}:${module_name}`, {
            source: "tarball",
            install_url: opts.install_url,
            installed_at: Date.now()
          });
          Common.logMod(`Module INSTALLED and STARTED`);
          return cb(null, "Module installed & Started");
        });
      });
    } else {
      PM2.start(conf2, opts, function(err, data) {
        if (err)
          return cb(err);
        Configuration.setSync(`${cst.MODULE_CONF_PREFIX_TAR}:${module_name}`, {
          source: "tarball",
          install_url: opts.install_url,
          installed_at: Date.now()
        });
        Common.logMod(`Module INSTALLED and STARTED`);
        return cb(null, "Module installed & Started");
      });
    }
  };
  var start = function(PM2, module_name, cb) {
    var module_path = path2.join(cst.DEFAULT_MODULE_PATH, module_name);
    Common.printOut(cst.PREFIX_MSG_MOD + "Starting TAR module " + module_name);
    var package_json_path = path2.join(module_path, "package.json");
    var module_conf = Configuration.getSync(`${cst.MODULE_CONF_PREFIX_TAR}:${module_name}`);
    try {
      var conf2 = __require(package_json_path);
    } catch (e) {
      Common.printError(`Could not find package.json as ${package_json_path}`);
      return cb();
    }
    var opts = {};
    opts.started_as_module = true;
    opts.cwd = module_path;
    if (module_conf.install_url)
      opts.install_url = module_conf.install_url;
    if (needPrefix(conf2))
      opts.name_prefix = module_name;
    PM2.start(conf2, opts, function(err, data) {
      if (err) {
        Common.printError(`Could not start ${module_name} ${module_path}`);
        return cb();
      }
      Common.printOut(`${cst.PREFIX_MSG_MOD} Module ${module_name} STARTED`);
      return cb();
    });
  };
  var uninstall = function(PM2, module_name, cb) {
    var module_path = path2.join(cst.DEFAULT_MODULE_PATH, module_name);
    Common.logMod(`Removing ${module_name} from auto startup`);
    try {
      var pkg = __require(path2.join(module_path, "package.json"));
    } catch (e) {
      Common.errMod("Could not retrieve module package.json");
      return cb(e);
    }
    var apps = pkg.apps || pkg.pm2;
    apps = [].concat(apps);
    forEachLimit(apps, 1, (app, next) => {
      var app_name;
      if (!app.name) {
        Common.renderApplicationName(app);
      }
      if (apps.length > 1)
        app_name = `${module_name}:${app.name}`;
      else if (apps.length == 1 && pkg.name != apps[0].name)
        app_name = `${module_name}:${app.name}`;
      else
        app_name = app.name;
      PM2._operate("deleteProcessId", app_name, () => {
        deleteModulePath(module_name);
        next();
      });
    }, () => {
      Configuration.unsetSync(`${cst.MODULE_CONF_PREFIX_TAR}:${module_name}`);
      cb(null);
    });
  };
  var getModuleName = function(module_filepath, cb) {
    var tmp_folder = path2.join(os.tmpdir(), cst.MODULE_BASEFOLDER);
    var install_instance = spawn("tar", ["zxf", module_filepath, "-C", os.tmpdir(), `${cst.MODULE_BASEFOLDER}/package.json`], {
      stdio: "inherit",
      env: process.env,
      shell: true
    });
    install_instance.on("close", function(code) {
      try {
        var pkg = JSON.parse(fs.readFileSync(path2.join(tmp_folder, `package.json`)));
        return cb(null, pkg.name);
      } catch (e) {
        return cb(e);
      }
    });
  };
  var packager = function(module_path, target_path, cb) {
    var base_folder = path2.dirname(module_path);
    var module_folder_name = path2.basename(module_path);
    var pkg = __require(path2.join(module_path, "package.json"));
    var pkg_name = `${module_folder_name}-v${pkg.version.replace(/\./g, "-")}.tar.gz`;
    var target_fullpath = path2.join(target_path, pkg_name);
    var cmd = `tar zcf ${target_fullpath} -C ${base_folder} --transform 's,${module_folder_name},module,' ${module_folder_name}`;
    Common.logMod(`Gziping ${module_path} to ${target_fullpath}`);
    var tar = exec(cmd, (err, sto, ste) => {
      if (err) {
        console.log(sto.toString().trim());
        console.log(ste.toString().trim());
      }
    });
    tar.on("close", function(code) {
      cb(code == 0 ? null : code, {
        package_name: pkg_name,
        path: target_fullpath
      });
    });
  };
  var publish = function(PM2, folder, cb) {
    var target_folder = folder ? path2.resolve(folder) : process.cwd();
    try {
      var pkg = JSON.parse(fs.readFileSync(path2.join(target_folder, "package.json")).toString());
    } catch (e) {
      Common.errMod(`${process.cwd()} module does not contain any package.json`);
      process.exit(1);
    }
    if (!pkg.name)
      throw new Error("Attribute name should be present");
    if (!pkg.version)
      throw new Error("Attribute version should be present");
    if (!pkg.pm2 && !pkg.apps)
      throw new Error("Attribute apps should be present");
    var current_path = target_folder;
    var module_name = path2.basename(current_path);
    var target_path = os.tmpdir();
    Common.logMod(`Starting publishing procedure for ${module_name}@${pkg.version}`);
    packager(current_path, target_path, (err, res) => {
      if (err) {
        Common.errMod("Can\'t package, exiting");
        process.exit(1);
      }
      Common.logMod(`Package [${pkg.name}] created in path ${res.path}`);
      var data = {
        module_data: {
          file: res.path,
          content_type: "content/gzip"
        },
        id: pkg.name,
        name: pkg.name,
        version: pkg.version
      };
      var uri = `${PM2.pm2_configuration.registry}/api/v1/modules`;
      Common.logMod(`Sending Package to remote ${pkg.name} ${uri}`);
      require_needle().post(uri, data, { multipart: true }, function(err2, res2, body) {
        if (err2) {
          Common.errMod(err2);
          process.exit(1);
        }
        if (res2.statusCode !== 200) {
          Common.errMod(`${pkg.name}-${pkg.version}: ${res2.body.msg}`);
          process.exit(1);
        }
        Common.logMod(`Module ${module_name} published under version ${pkg.version}`);
        process.exit(0);
      });
    });
  };
  var needPrefix = function(conf2) {
    if (conf2.apps && conf2.apps.length > 1 || conf2.pm2 && conf2.pm2.length > 1 || conf2.apps.length == 1 && conf2.name != conf2.apps[0].name)
      return true;
    return false;
  };
  var Configuration = require_Configuration();
  var cst = require_constants2();
  var Common = require_Common();
  var forEachLimit = require_forEachLimit();
  var sexec = require_sexec();
  var deleteFolderRecursive = require_deleteFolderRecursive();
  var path2 = __require("path");
  var fs = __require("fs");
  var os = __require("os");
  var spawn = __require("child_process").spawn;
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  module2.exports = {
    install,
    uninstall,
    start,
    publish,
    packager
  };
});

// ../../node_modules/async/parallel.js
var require_parallel3 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var parallel = function(tasks, callback) {
    return (0, _parallel3.default)(_eachOf2.default, tasks, callback);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = parallel;
  var _eachOf = require_eachOf();
  var _eachOf2 = _interopRequireDefault(_eachOf);
  var _parallel2 = require_parallel();
  var _parallel3 = _interopRequireDefault(_parallel2);
  module2.exports = exports2.default;
});

// ../../node_modules/pm2/lib/API/Modules/LOCAL.js
var require_LOCAL = __commonJS((exports2, module2) => {
  var install = function(module3, cb, verbose) {
    if (!module3 || !module3.name || module3.name.length === 0) {
      return cb(new Error("No module name !"));
    }
    if (typeof verbose === "undefined") {
      verbose = true;
    }
    installLangModule(module3.name, function(err) {
      var display = module3.message || module3.name;
      if (err) {
        if (verbose) {
          Common.printError(cst.PREFIX_MSG_MOD_ERR + chalk.bold.green(display + " installation has FAILED (checkout previous logs)"));
        }
        return cb(err);
      }
      if (verbose) {
        Common.printOut(cst.PREFIX_MSG + chalk.bold.green(display + " ENABLED"));
      }
      return cb();
    });
  };
  var installMultipleModules = function(modules, cb, post_install) {
    var functionList = [];
    for (var i = 0;i < modules.length; i++) {
      functionList.push(function(index) {
        return function(callback) {
          var module3 = modules[index];
          if (typeof modules[index] === "string") {
            module3 = { name: modules[index] };
          }
          install(module3, function($post_install, err, $index, $modules) {
            try {
              var install_instance = spawn(post_install[modules[index]], {
                stdio: "inherit",
                windowsHide: true,
                env: process.env,
                shell: true,
                cwd: process.cwd()
              });
              Common.printOut(cst.PREFIX_MSG_MOD + "Running configuraton script.");
            } catch (e) {
              Common.printOut(cst.PREFIX_MSG_MOD + "No configuraton script found.");
            }
            callback(null, { module: module3, err });
          }, false);
        };
      }(i));
    }
    parallel(functionList, function(err, results) {
      for (var i2 = 0;i2 < results.length; i2++) {
        var display = results[i2].module.message || results[i2].module.name;
        if (results[i2].err) {
          err = results[i2].err;
          Common.printError(cst.PREFIX_MSG_MOD_ERR + chalk.bold.green(display + " installation has FAILED (checkout previous logs)"));
        } else {
          Common.printOut(cst.PREFIX_MSG + chalk.bold.green(display + " ENABLED"));
        }
      }
      if (cb)
        cb(err);
    });
  };
  var installLangModule = function(module_name, cb) {
    var node_module_path = path2.resolve(path2.join(__dirname, "../../../"));
    Common.printOut(cst.PREFIX_MSG_MOD + "Calling " + chalk.bold.red("[NPM]") + " to install " + module_name + " ...");
    var install_instance = spawn(cst.IS_WINDOWS ? "npm.cmd" : "npm", ["install", module_name, "--loglevel=error"], {
      stdio: "inherit",
      env: process.env,
      shell: true,
      cwd: node_module_path
    });
    install_instance.on("close", function(code) {
      if (code > 0)
        return cb(new Error("Module install failed"));
      return cb(null);
    });
    install_instance.on("error", function(err) {
      console.error(err.stack || err);
    });
  };
  var __dirname = "C:\\Users\\balle\\Documents\\GitHub\\echoesmd\\node_modules\\pm2\\lib\\API\\Modules";
  var path2 = __require("path");
  var fs = __require("fs");
  var os = __require("os");
  var spawn = __require("child_process").spawn;
  var chalk = require_source();
  var parallel = require_parallel3();
  var Configuration = require_Configuration();
  var cst = require_constants2();
  var Common = require_Common();
  var Utility = require_Utility();
  var readline = __require("readline");
  var INTERNAL_MODULES = {
    "deep-monitoring": {
      dependencies: [{ name: "v8-profiler-node8" }, { name: "gc-stats" }, { name: "event-loop-inspector" }]
    },
    "gc-stats": { name: "gc-stats" },
    "event-loop-inspector": { name: "event-loop-inspector" },
    "v8-profiler": { name: "v8-profiler-node8" },
    profiler: { name: "v8-profiler-node8" },
    typescript: { dependencies: [{ name: "typescript" }, { name: "ts-node@latest" }] },
    livescript: { name: "livescript" },
    "coffee-script": { name: "coffee-script", message: "Coffeescript v1 support" },
    coffeescript: { name: "coffeescript", message: "Coffeescript v2 support" }
  };
  module2.exports = {
    install,
    INTERNAL_MODULES,
    installMultipleModules
  };
});

// ../../node_modules/pm2/lib/API/Modules/Modularizer.js
var require_Modularizer = __commonJS((exports2, module2) => {
  var path2 = __require("path");
  var eachLimit = require_eachLimit();
  var forEachLimit = require_forEachLimit();
  var Configuration = require_Configuration();
  var cst = require_constants2();
  var Common = require_Common();
  var NPM = require_NPM();
  var TAR = require_TAR();
  var LOCAL = require_LOCAL();
  var Modularizer = module2.exports = {};
  Modularizer.install = function(CLI, module_name, opts, cb) {
    module_name = module_name.replace(/[;`|]/g, "");
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    if (LOCAL.INTERNAL_MODULES.hasOwnProperty(module_name)) {
      Common.logMod(`Adding dependency ${module_name} to PM2 Runtime`);
      var currentModule = LOCAL.INTERNAL_MODULES[module_name];
      if (currentModule && currentModule.hasOwnProperty("dependencies")) {
        LOCAL.installMultipleModules(currentModule.dependencies, cb);
      } else {
        LOCAL.install(currentModule, cb);
      }
    } else if (module_name == ".") {
      Common.logMod(`Installing local NPM module`);
      return NPM.localStart(CLI, opts, cb);
    } else if (opts.tarball || /\.tar\.gz$/i.test(module_name)) {
      Common.logMod(`Installing TAR module`);
      TAR.install(CLI, module_name, opts, cb);
    } else {
      Common.logMod(`Installing NPM ${module_name} module`);
      NPM.install(CLI, module_name, opts, cb);
    }
  };
  Modularizer.launchModules = function(CLI, cb) {
    var modules = Modularizer.listModules();
    if (!modules)
      return cb();
    function launchNPMModules(cb2) {
      if (!modules.npm_modules)
        return launchTARModules(cb2);
      eachLimit(Object.keys(modules.npm_modules), 1, function(module_name, next) {
        NPM.start(CLI, modules, module_name, next);
      }, function() {
        launchTARModules(cb2);
      });
    }
    function launchTARModules(cb2) {
      if (!modules.tar_modules)
        return cb2();
      eachLimit(Object.keys(modules.tar_modules), 1, function(module_name, next) {
        TAR.start(CLI, module_name, next);
      }, function() {
        return cb2 ? cb2(null) : false;
      });
    }
    launchNPMModules(cb);
  };
  Modularizer.package = function(CLI, module_path, cb) {
    var fullpath = process.cwd();
    if (module_path)
      fullpath = __require("path").resolve(module_path);
    TAR.package(fullpath, process.cwd(), cb);
  };
  Modularizer.uninstall = function(CLI, module_name, cb) {
    Common.printOut(cst.PREFIX_MSG_MOD + "Uninstalling module " + module_name);
    var modules_list = Modularizer.listModules();
    if (module_name == "all") {
      if (!modules_list)
        return cb();
      return forEachLimit(Object.keys(modules_list.npm_modules), 1, function(module_name2, next) {
        NPM.uninstall(CLI, module_name2, next);
      }, () => {
        forEachLimit(Object.keys(modules_list.tar_modules), 1, function(module_name2, next) {
          TAR.uninstall(CLI, module_name2, next);
        }, cb);
      });
    }
    if (modules_list.npm_modules[module_name]) {
      NPM.uninstall(CLI, module_name, cb);
    } else if (modules_list.tar_modules[module_name]) {
      TAR.uninstall(CLI, module_name, cb);
    } else {
      Common.errMod("Unknown module");
      CLI.exitCli(1);
    }
  };
  Modularizer.listModules = function() {
    return {
      npm_modules: Configuration.getSync(cst.MODULE_CONF_PREFIX) || {},
      tar_modules: Configuration.getSync(cst.MODULE_CONF_PREFIX_TAR) || {}
    };
  };
  Modularizer.getAdditionalConf = function(app_name) {
    return NPM.getModuleConf(app_name);
  };
  Modularizer.publish = function(PM2, folder, opts, cb) {
    if (opts.npm == true) {
      NPM.publish(opts, cb);
    } else {
      TAR.publish(PM2, folder, cb);
    }
  };
  Modularizer.generateSample = function(app_name, cb) {
    NPM.generateSample(app_name, cb);
  };
});

// ../../node_modules/pm2/lib/API/UX/helpers.js
var require_helpers = __commonJS((exports2, module2) => {
  var chalk = require_source();
  var Helpers = {};
  Helpers.bytesToSize = function(bytes, precision) {
    var kilobyte = 1024;
    var megabyte = kilobyte * 1024;
    var gigabyte = megabyte * 1024;
    var terabyte = gigabyte * 1024;
    if (bytes >= 0 && bytes < kilobyte) {
      return bytes + "b ";
    } else if (bytes >= kilobyte && bytes < megabyte) {
      return (bytes / kilobyte).toFixed(precision) + "kb ";
    } else if (bytes >= megabyte && bytes < gigabyte) {
      return (bytes / megabyte).toFixed(precision) + "mb ";
    } else if (bytes >= gigabyte && bytes < terabyte) {
      return (bytes / gigabyte).toFixed(precision) + "gb ";
    } else if (bytes >= terabyte) {
      return (bytes / terabyte).toFixed(precision) + "tb ";
    } else {
      return bytes + "b ";
    }
  };
  Helpers.colorStatus = function(status) {
    switch (status) {
      case "online":
        return chalk.green.bold("online");
        break;
      case "running":
        return chalk.green.bold("online");
        break;
      case "restarting":
        return chalk.yellow.bold("restart");
        break;
      case "created":
        return chalk.yellow.bold("created");
        break;
      case "launching":
        return chalk.blue.bold("launching");
        break;
      default:
        return chalk.red.bold(status);
    }
  };
  Helpers.safe_push = function() {
    var argv = arguments;
    var table = argv[0];
    for (var i = 1;i < argv.length; ++i) {
      var elem = argv[i];
      if (elem[Object.keys(elem)[0]] === undefined || elem[Object.keys(elem)[0]] === null) {
        elem[Object.keys(elem)[0]] = "N/A";
      } else if (Array.isArray(elem[Object.keys(elem)[0]])) {
        elem[Object.keys(elem)[0]].forEach(function(curr, j) {
          if (curr === undefined || curr === null)
            elem[Object.keys(elem)[0]][j] = "N/A";
        });
      }
      table.push(elem);
    }
  };
  Helpers.timeSince = function(date) {
    var seconds = Math.floor((new Date - date) / 1000);
    var interval = Math.floor(seconds / 31536000);
    if (interval > 1) {
      return interval + "Y";
    }
    interval = Math.floor(seconds / 2592000);
    if (interval > 1) {
      return interval + "M";
    }
    interval = Math.floor(seconds / 86400);
    if (interval > 1) {
      return interval + "D";
    }
    interval = Math.floor(seconds / 3600);
    if (interval > 1) {
      return interval + "h";
    }
    interval = Math.floor(seconds / 60);
    if (interval > 1) {
      return interval + "m";
    }
    return Math.floor(seconds) + "s";
  };
  Helpers.colorizedMetric = function(value, warn2, alert, prefix) {
    var inverted = false;
    if (alert < warn2)
      inverted = true;
    if (!prefix)
      prefix = "";
    if (isNaN(value) === true)
      return "N/A";
    if (value == 0)
      return 0 + prefix;
    if (inverted == true) {
      if (value > warn2)
        return chalk.green(value + prefix);
      if (value <= warn2 && value >= alert)
        return chalk.bold.yellow(value + prefix);
      return chalk.bold.red(value + prefix);
    }
    if (value < warn2)
      return chalk.green(value + prefix);
    if (value >= warn2 && value <= alert)
      return chalk.bold.yellow(value + prefix);
    return chalk.bold.red(value + prefix);
  };
  Helpers.getNestedProperty = function(propertyName, obj) {
    var parts = propertyName.split("."), length3 = parts.length, property = obj || {};
    for (var i = 0;i < length3; i++) {
      property = property[parts[i]];
    }
    return property;
  };
  Helpers.openEditor = function(file, opts, cb) {
    var spawn = __require("child_process").spawn;
    if (typeof opts === "function") {
      cb = opts;
      opts = {};
    }
    if (!opts)
      opts = {};
    var ed = /^win/.test(process.platform) ? "notepad" : "vim";
    var editor = opts.editor || process.env.VISUAL || process.env.EDITOR || ed;
    var args2 = editor.split(/\s+/);
    var bin = args2.shift();
    var ps = spawn(bin, args2.concat([file]), {
      windowsHide: true,
      stdio: "inherit"
    });
    ps.on("exit", function(code, sig) {
      if (typeof cb === "function")
        cb(code, sig);
    });
  };
  Helpers.dispKeys = function(kv, target_module) {
    Object.keys(kv).forEach(function(key) {
      if (target_module != null && target_module != key)
        return false;
      if (typeof kv[key] == "object") {
        var obj = {};
        console.log(chalk.bold("Module: ") + chalk.bold.blue(key));
        Object.keys(kv[key]).forEach(function(sub_key) {
          console.log(`\$ pm2 set ${key}:${sub_key} ${kv[key][sub_key]}`);
        });
      }
    });
  };
  module2.exports = Helpers;
});

// ../../node_modules/cli-tableau/node_modules/chalk/source/util.js
var require_util3 = __commonJS((exports2, module2) => {
  var stringReplaceAll = (string, substring, replacer) => {
    let index = string.indexOf(substring);
    if (index === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
      endIndex = index + substringLength;
      index = string.indexOf(substring, endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index - 1] === "\r";
      returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index + 1;
      index = string.indexOf("\n", endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  module2.exports = {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  };
});

// ../../node_modules/cli-tableau/node_modules/chalk/source/templates.js
var require_templates3 = __commonJS((exports2, module2) => {
  var unescape2 = function(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES.get(c) || c;
  };
  var parseArguments = function(name2, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number)) {
        results.push(number);
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, character) => escape2 ? unescape2(escape2) : character));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
      }
    }
    return results;
  };
  var parseStyle = function(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name2 = matches[1];
      if (matches[2]) {
        const args2 = parseArguments(name2, matches[2]);
        results.push([name2].concat(args2));
      } else {
        results.push([name2]);
      }
    }
    return results;
  };
  var buildStyle = function(chalk, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk;
    for (const [styleName, styles2] of Object.entries(enabled)) {
      if (!Array.isArray(styles2)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
    }
    return current;
  };
  var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "\t"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  module2.exports = (chalk, temporary) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter) {
        chunk.push(unescape2(escapeCharacter));
      } else if (style) {
        const string = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
        styles.push({ inverse, styles: parseStyle(style) });
      } else if (close) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMsg);
    }
    return chunks.join("");
  };
});

// ../../node_modules/cli-tableau/node_modules/chalk/source/index.js
var require_source3 = __commonJS((exports2, module2) => {
  var Chalk = function(options2) {
    return chalkFactory(options2);
  };
  var ansiStyles = require_ansi_styles();
  var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
  var {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  } = require_util3();
  var levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  var styles = Object.create(null);
  var applyOptions = (object, options2 = {}) => {
    if (options2.level > 3 || options2.level < 0) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options2.level === undefined ? colorLevel : options2.level;
  };

  class ChalkClass {
    constructor(options2) {
      return chalkFactory(options2);
    }
  }
  var chalkFactory = (options2) => {
    const chalk2 = {};
    applyOptions(chalk2, options2);
    chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
    Object.setPrototypeOf(chalk2, Chalk.prototype);
    Object.setPrototypeOf(chalk2.template, chalk2);
    chalk2.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    };
    chalk2.template.Instance = ChalkClass;
    return chalk2.template;
  };
  for (const [styleName, style] of Object.entries(ansiStyles)) {
    styles[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
        Object.defineProperty(this, styleName, { value: builder });
        return builder;
      }
    };
  }
  styles.visible = {
    get() {
      const builder = createBuilder(this, this._styler, true);
      Object.defineProperty(this, "visible", { value: builder });
      return builder;
    }
  };
  var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const model of usedModels) {
    styles[model] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  for (const model of usedModels) {
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, {
    ...styles,
    level: {
      enumerable: true,
      get() {
        return this._generator.level;
      },
      set(level) {
        this._generator.level = level;
      }
    }
  });
  var createStyler = (open, close, parent) => {
    let openAll;
    let closeAll;
    if (parent === undefined) {
      openAll = open;
      closeAll = close;
    } else {
      openAll = parent.openAll + open;
      closeAll = close + parent.closeAll;
    }
    return {
      open,
      close,
      openAll,
      closeAll,
      parent
    };
  };
  var createBuilder = (self2, _styler, _isEmpty) => {
    const builder = (...arguments_) => {
      return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    };
    builder.__proto__ = proto;
    builder._generator = self2;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
  };
  var applyStyle = (self2, string) => {
    if (self2.level <= 0 || !string) {
      return self2._isEmpty ? "" : string;
    }
    let styler = self2._styler;
    if (styler === undefined) {
      return string;
    }
    const { openAll, closeAll } = styler;
    if (string.indexOf("\x1B") !== -1) {
      while (styler !== undefined) {
        string = stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  };
  var template;
  var chalkTag = (chalk2, ...strings) => {
    const [firstString] = strings;
    if (!Array.isArray(firstString)) {
      return strings.join(" ");
    }
    const arguments_ = strings.slice(1);
    const parts = [firstString.raw[0]];
    for (let i = 1;i < firstString.length; i++) {
      parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
    }
    if (template === undefined) {
      template = require_templates3();
    }
    return template(chalk2, parts.join(""));
  };
  Object.defineProperties(Chalk.prototype, styles);
  var chalk = Chalk();
  chalk.supportsColor = stdoutColor;
  chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
  chalk.stderr.supportsColor = stderrColor;
  chalk.Level = {
    None: 0,
    Basic: 1,
    Ansi256: 2,
    TrueColor: 3,
    0: "None",
    1: "Basic",
    2: "Ansi256",
    3: "TrueColor"
  };
  module2.exports = chalk;
});

// ../../node_modules/cli-tableau/lib/utils.js
var require_utils4 = __commonJS((exports2) => {
  var options2 = function(defaults, opts) {
    for (var p in opts) {
      if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {
        defaults[p] = defaults[p] || {};
        options2(defaults[p], opts[p]);
      } else {
        defaults[p] = opts[p];
      }
    }
    return defaults;
  };
  exports2.repeat = function(str, times) {
    return Array(times + 1).join(str);
  };
  exports2.truncate = function(str, length3, chr) {
    chr = chr || "\u2026";
    return str.length >= length3 ? str.substr(0, length3 - chr.length) + chr : str;
  };
  exports2.options = options2;
  exports2.strlen = function(str) {
    var code = /\u001b\[(?:\d*;){0,5}\d*m/g;
    var stripped = ("" + (str != null ? str : "")).replace(code, "");
    var split = stripped.split("\n");
    return split.reduce(function(memo, s) {
      return s.length > memo ? s.length : memo;
    }, 0);
  };
});

// ../../node_modules/cli-tableau/lib/index.js
var require_lib4 = __commonJS((exports2, module2) => {
  var Table = function(options2) {
    this.options = utils.options({
      chars: {
        top: "\u2500",
        "top-mid": "\u252C",
        "top-left": "\u250C",
        "top-right": "\u2510",
        bottom: "\u2500",
        "bottom-mid": "\u2534",
        "bottom-left": "\u2514",
        "bottom-right": "\u2518",
        left: "\u2502",
        "left-mid": "\u251C",
        mid: "\u2500",
        "mid-mid": "\u253C",
        right: "\u2502",
        "right-mid": "\u2524",
        middle: "\u2502"
      },
      truncate: "\u2026",
      colWidths: [],
      colAligns: [],
      style: {
        "padding-left": 1,
        "padding-right": 1,
        head: ["red"],
        border: ["grey"],
        compact: false
      },
      head: []
    }, options2);
    if (options2.borders == false) {
      this.options.chars = {
        top: "",
        "top-mid": "",
        "top-left": "",
        "top-right": "",
        bottom: "",
        "bottom-mid": "",
        "bottom-left": "",
        "bottom-right": "",
        left: "",
        "left-mid": "",
        mid: "",
        "mid-mid": "",
        right: "",
        "right-mid": "",
        middle: ""
      };
    }
  };
  var colors = require_source3();
  var utils = require_utils4();
  var repeat = utils.repeat;
  var truncate = utils.truncate;
  Table.prototype = new Array;
  Table.prototype.__defineGetter__("width", function() {
    var str = this.toString().split("\n");
    if (str.length)
      return str[0].length;
    return 0;
  });
  Table.prototype.render = Table.prototype.toString = function() {
    var ret = "";
    var options2 = this.options;
    var style = options2.style;
    var head = options2.head;
    var chars = options2.chars;
    var truncater = options2.truncate;
    var colWidths = options2.colWidths || new Array(this.head.length);
    var totalWidth = 0;
    if (!head.length && !this.length)
      return "";
    if (!colWidths.length) {
      var everyRows = this.slice(0);
      if (head.length) {
        everyRows = everyRows.concat([head]);
      }
      everyRows.forEach(function(cells) {
        if (Array.isArray(cells) && cells.length) {
          extractColumnWidths(cells);
        } else {
          var headerCell = Object.keys(cells)[0];
          var valueCell = cells[headerCell];
          colWidths[0] = Math.max(colWidths[0] || 0, getWidth(headerCell) || 0);
          if (Array.isArray(valueCell) && valueCell.length) {
            extractColumnWidths(valueCell, 1);
          } else {
            colWidths[1] = Math.max(colWidths[1] || 0, getWidth(valueCell) || 0);
          }
        }
      });
    }
    totalWidth = (colWidths.length === 1 ? colWidths[0] : colWidths.reduce(function(a, b) {
      return a + b;
    })) + colWidths.length + 1;
    function extractColumnWidths(arr, offset) {
      offset = offset || 0;
      arr.forEach(function(cell, i) {
        colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, getWidth(cell) || 0);
      });
    }
    function getWidth(obj) {
      return typeof obj === "object" && obj && obj.width !== undefined ? obj.width : (typeof obj === "object" && obj !== null ? utils.strlen(obj.text) : utils.strlen(obj)) + (style["padding-left"] || 0) + (style["padding-right"] || 0);
    }
    function line(line2, left, right, intersection) {
      var width = 0;
      line2 = left + repeat(line2, totalWidth - 2) + right;
      colWidths.forEach(function(w, i) {
        if (i === colWidths.length - 1)
          return;
        width += w + 1;
        line2 = line2.substr(0, width) + intersection + line2.substr(width + 1);
      });
      return applyStyles(options2.style.border, line2);
    }
    function lineTop() {
      var l2 = line(chars.top, chars["top-left"] || chars.top, chars["top-right"] || chars.top, chars["top-mid"]);
      if (l2) {
        ret += l2 + "\n";
      }
    }
    function generateRow(items, style2) {
      var cells = [];
      var maxHeight = 0;
      if (!Array.isArray(items) && typeof items === "object") {
        var key = Object.keys(items)[0];
        var value = items[key];
        var firstCellHead = true;
        if (Array.isArray(value)) {
          items = value;
          items.unshift(key);
        } else {
          items = [key, value];
        }
      }
      items.forEach(function(item, i) {
        var contents = (item === null || item === undefined ? "" : item).toString().split("\n").reduce(function(memo, l2) {
          memo.push(string(l2, i));
          return memo;
        }, []);
        var height = contents.length;
        if (height > maxHeight) {
          maxHeight = height;
        }
        cells.push({ contents, height });
      });
      var lines = new Array(maxHeight);
      cells.forEach(function(cell, i) {
        cell.contents.forEach(function(line2, j2) {
          if (!lines[j2]) {
            lines[j2] = [];
          }
          if (style2 || firstCellHead && i === 0 && options2.style.head) {
            line2 = applyStyles(options2.style.head, line2);
          }
          lines[j2].push(line2);
        });
        for (var j = cell.height, l2 = maxHeight;j < l2; j++) {
          if (!lines[j]) {
            lines[j] = [];
          }
          lines[j].push(string("", i));
        }
      });
      var ret2 = "";
      lines.forEach(function(line2, index) {
        if (ret2.length > 0) {
          ret2 += "\n" + applyStyles(options2.style.border, chars.left);
        }
        ret2 += line2.join(applyStyles(options2.style.border, chars.middle)) + applyStyles(options2.style.border, chars.right);
      });
      return applyStyles(options2.style.border, chars.left) + ret2;
    }
    function applyStyles(styles, subject) {
      if (!subject) {
        return "";
      }
      styles.forEach(function(style2) {
        subject = colors[style2](subject);
      });
      return subject;
    }
    function string(str, index) {
      str = String(typeof str === "object" && str.text ? str.text : str);
      var length3 = utils.strlen(str);
      var width = colWidths[index] - (style["padding-left"] || 0) - (style["padding-right"] || 0);
      var align = options2.colAligns[index] || "left";
      return repeat(" ", style["padding-left"] || 0) + (length3 === width ? str : length3 < width ? str.padEnd(width + (str.length - length3), " ", align === "left" ? "right" : align === "middle" ? "both" : "left") : truncater ? truncate(str, width, truncater) : str) + repeat(" ", style["padding-right"] || 0);
    }
    if (head.length) {
      lineTop();
      ret += generateRow(head, style.head) + "\n";
    }
    if (this.length) {
      this.forEach(function(cells, i) {
        if (!head.length && i === 0) {
          lineTop();
        } else {
          if (!style.compact || i < !!head.length ? 1 : cells.length === 0) {
            var l2 = line(chars.mid, chars["left-mid"], chars["right-mid"], chars["mid-mid"]);
            if (l2) {
              ret += l2 + "\n";
            }
          }
        }
        if (Array.isArray(cells) && !cells.length) {
          return;
        } else {
          ret += generateRow(cells) + "\n";
        }
      });
    }
    var l = line(chars.bottom, chars["bottom-left"] || chars.bottom, chars["bottom-right"] || chars.bottom, chars["bottom-mid"]);
    if (l) {
      ret += l;
    } else {
      ret = ret.slice(0, -1);
    }
    return ret;
  };
  module2.exports = Table;
  module2.exports.version = "2.0.0";
});

// ../../node_modules/pm2/lib/API/UX/pm2-describe.js
var require_pm2_describe = __commonJS((exports2, module2) => {
  var Table = require_lib4();
  var chalk = require_source();
  var UxHelpers = require_helpers();
  var Common = require_Common();
  var postModuleInfos = function(module_name, human_info) {
    var table = new Table({
      style: { "padding-left": 1, head: ["cyan", "bold"], compact: true }
    });
    var disp = {};
    human_info.unshift(["Module name", module_name]);
    human_info.forEach(function(info) {
      var obj = {};
      obj[chalk.bold.cyan(info[0])] = info[1];
      table.push(obj);
    });
    console.log();
    console.log(chalk.bold.inverse(" Module %s infos "), module_name);
    console.log(table.toString());
  };
  module2.exports = function(proc) {
    var table = new Table({
      style: { "padding-left": 1, head: ["cyan", "bold"], compact: true }
    });
    var pm2_env = proc.pm2_env;
    var created_at = "N/A";
    if (pm2_env.axm_options && pm2_env.axm_options.human_info) {
      postModuleInfos(pm2_env.name, pm2_env.axm_options.human_info);
    }
    try {
      if (pm2_env.created_at != null)
        created_at = new Date(pm2_env.created_at).toISOString();
    } catch (e) {
    }
    console.log(chalk.bold.inverse(" Describing process with id %d - name %s "), pm2_env.pm_id, pm2_env.name);
    UxHelpers.safe_push(table, { status: UxHelpers.colorStatus(pm2_env.status) }, { name: pm2_env.name }, { namespace: pm2_env.namespace }, { version: pm2_env.version }, { restarts: pm2_env.restart_time }, { uptime: pm2_env.pm_uptime && pm2_env.status == "online" ? UxHelpers.timeSince(pm2_env.pm_uptime) : 0 }, { "script path": pm2_env.pm_exec_path }, { "script args": pm2_env.args ? (typeof pm2_env.args == "string" ? JSON.parse(pm2_env.args.replace(/'/g, '"')) : pm2_env.args).join(" ") : null }, { "error log path": pm2_env.pm_err_log_path }, { "out log path": pm2_env.pm_out_log_path }, { "pid path": pm2_env.pm_pid_path }, { interpreter: pm2_env.exec_interpreter }, { "interpreter args": pm2_env.node_args.length != 0 ? pm2_env.node_args : null }, { "script id": pm2_env.pm_id }, { "exec cwd": pm2_env.pm_cwd }, { "exec mode": pm2_env.exec_mode }, { "node.js version": pm2_env.node_version }, { "node env": pm2_env.env.NODE_ENV }, { "watch & reload": pm2_env.watch ? chalk.green.bold("\u2714") : "\u2718" }, { "unstable restarts": pm2_env.unstable_restarts }, { "created at": created_at });
    if ("pm_log_path" in pm2_env) {
      table.splice(6, 0, { "entire log path": pm2_env.pm_log_path });
    }
    if ("cron_restart" in pm2_env) {
      table.splice(5, 0, { "cron restart": pm2_env.cron_restart });
    }
    console.log(table.toString());
    if (pm2_env.axm_options && pm2_env.axm_options.module_conf && Object.keys(pm2_env.axm_options.module_conf).length > 0) {
      var table_conf = new Table({
        style: { "padding-left": 1, head: ["cyan", "bold"], compact: true }
      });
      console.log("Process configuration");
      Object.keys(pm2_env.axm_options.module_conf).forEach(function(key) {
        var tmp = {};
        tmp[key] = pm2_env.axm_options.module_conf[key];
        UxHelpers.safe_push(table_conf, tmp);
      });
      console.log(table_conf.toString());
    }
    if (pm2_env.versioning) {
      var table2 = new Table({
        style: { "padding-left": 1, head: ["cyan", "bold"], compact: true }
      });
      console.log(chalk.inverse.bold(" Revision control metadata "));
      UxHelpers.safe_push(table2, { "revision control": pm2_env.versioning.type }, { "remote url": pm2_env.versioning.url }, { "repository root": pm2_env.versioning.repo_path }, { "last update": pm2_env.versioning.update_time }, { revision: pm2_env.versioning.revision }, { comment: pm2_env.versioning.comment ? pm2_env.versioning.comment.trim().slice(0, 60) : "" }, { branch: pm2_env.versioning.branch });
      console.log(table2.toString());
    }
    if (pm2_env.axm_actions && Object.keys(pm2_env.axm_actions).length > 0) {
      var table_actions = new Table({
        style: { "padding-left": 1, head: ["cyan", "bold"], compact: true }
      });
      console.log(chalk.inverse.bold(" Actions available "));
      pm2_env.axm_actions.forEach(function(action_set) {
        UxHelpers.safe_push(table_actions, [action_set.action_name]);
      });
      console.log(table_actions.toString());
      Common.printOut(chalk.white.italic(" Trigger via: pm2 trigger %s <action_name>\n"), pm2_env.name);
    }
    if (pm2_env.axm_monitor && Object.keys(pm2_env.axm_monitor).length > 0) {
      var table_probes = new Table({
        style: { "padding-left": 1, head: ["cyan", "bold"], compact: true }
      });
      console.log(chalk.inverse.bold(" Code metrics value "));
      Object.keys(pm2_env.axm_monitor).forEach(function(key) {
        var obj = {};
        var metric_name = pm2_env.axm_monitor[key].hasOwnProperty("value") ? pm2_env.axm_monitor[key].value : pm2_env.axm_monitor[key];
        var metric_unit = pm2_env.axm_monitor[key].hasOwnProperty("unit") ? pm2_env.axm_monitor[key].unit : "";
        var value = `${metric_name} ${metric_unit}`;
        obj[key] = value;
        UxHelpers.safe_push(table_probes, obj);
      });
      console.log(table_probes.toString());
    }
    var table_env = new Table({
      style: { "padding-left": 1, head: ["cyan", "bold"], compact: true }
    });
    console.log(chalk.inverse.bold(" Divergent env variables from local env "));
    var _env = Common.safeExtend({}, pm2_env);
    var diff_env = {};
    Object.keys(process.env).forEach((k) => {
      if (!_env[k] || _env[k] != process.env[k]) {
        diff_env[k] = process.env[k];
      }
    });
    Object.keys(diff_env).forEach(function(key) {
      var obj = {};
      if (_env[key]) {
        obj[key] = _env[key].slice(0, process.stdout.columns - 60);
        UxHelpers.safe_push(table_env, obj);
      }
    });
    console.log(table_env.toString());
    console.log();
    Common.printOut(chalk.white.italic(" Add your own code metrics: http://bit.ly/code-metrics"));
    Common.printOut(chalk.white.italic(" Use `pm2 logs %s [--lines 1000]` to display logs"), pm2_env.name);
    Common.printOut(chalk.white.italic(" Use `pm2 env %s` to display environment variables"), pm2_env.pm_id);
    Common.printOut(chalk.white.italic(" Use `pm2 monit` to monitor CPU and Memory usage"), pm2_env.name);
  };
});

// ../../node_modules/pm2/lib/API/UX/pm2-ls.js
var require_pm2_ls = __commonJS((exports2, module2) => {
  var checkIfProcessAreDumped = function(list) {
    try {
      var dump_raw = __require("fs").readFileSync(cst.DUMP_FILE_PATH);
      var dump = JSON.parse(dump_raw);
      var apps_dumped = dump.map((proc) => proc.name);
      var apps_running = list.filter((proc) => proc.pm2_env.pmx_module != true).map((proc) => proc.name);
      var diff = apps_dumped.filter((a) => !apps_running.includes(a));
      if (diff.length > 0) {
        Common.warn(`Current process list is not synchronized with saved list. App ${chalk.bold(diff.join(" "))} differs. Type 'pm2 save' to synchronize.`);
      } else if (apps_dumped.length != apps_running.length) {
        Common.warn(`Current process list is not synchronized with saved list. Type 'pm2 save' to synchronize.`);
      }
    } catch (e) {
    }
  };
  var listModulesAndAppsManaged = function(list, commander) {
    var name_col_size = 11;
    if (list && list.length > 0)
      name_col_size = list.reduce((p, c) => p.name.length > c.name.length ? p : c).name.length + 5;
    var id_width = Math.max(2 + (Math.max(...list.map((l) => String(l.pm2_env.pm_id || 0).length)) || 0), 4);
    var app_head = {
      id: id_width,
      name: name_col_size,
      namespace: 13,
      version: 9,
      mode: 9,
      pid: 10,
      uptime: 8,
      "\u21BA": 6,
      status: 11,
      cpu: 10,
      mem: 10,
      user: 10,
      watching: 10
    };
    var mod_head = {
      id: id_width,
      module: 30,
      version: 15,
      pid: 10,
      status: 10,
      "\u21BA": 6,
      cpu: 10,
      mem: 10,
      user: 10
    };
    if (CONDENSED_MODE) {
      app_head = {
        id: id_width,
        name: 20,
        mode: 10,
        "\u21BA": 6,
        status: 11,
        cpu: 10,
        memory: 10
      };
      mod_head = {
        id: id_width,
        name: 20,
        status: 10,
        cpu: 10,
        mem: 10
      };
    }
    var app_table = new Table({
      head: Object.keys(app_head),
      colWidths: Object.keys(app_head).map((k) => app_head[k]),
      colAligns: ["left"],
      style: { "padding-left": 1, head: ["cyan", "bold"], compact: true }
    });
    var module_table = new Table({
      head: Object.keys(mod_head),
      colWidths: Object.keys(mod_head).map((k) => mod_head[k]),
      colAligns: ["left"],
      style: { "padding-left": 1, head: ["cyan", "bold"], compact: true }
    });
    var sortField = "name", sortOrder = "asc", sort, fields = {
      name: "pm2_env.name",
      namespace: "pm2_env.namespace",
      pid: "pid",
      id: "pm_id",
      cpu: "monit.cpu",
      memory: "monit.memory",
      uptime: "pm2_env.pm_uptime",
      status: "pm2_env.status"
    };
    if (commander && commander.sort) {
      sort = commander.sort.split(":");
      if (fields[sort[0].toLowerCase()]) {
        sortField = sort[0].toLowerCase();
        sortOrder = sort.length === 2 ? sort[1] : "asc";
      }
    }
    list.sort(function(a, b) {
      var fieldA = UxHelpers.getNestedProperty(fields[sortField], a);
      var fieldB = UxHelpers.getNestedProperty(fields[sortField], b);
      if (sortOrder === "desc") {
        if (fieldA > fieldB)
          return -1;
        if (fieldA < fieldB)
          return 1;
      } else {
        if (fieldA < fieldB)
          return -1;
        if (fieldA > fieldB)
          return 1;
      }
      return 0;
    });
    list.forEach(function(l) {
      var obj = {};
      if (l.pm2_env.pm_id > proc_id) {
        proc_id = l.pm2_env.pm_id;
      }
      var mode = l.pm2_env.exec_mode;
      var status = l.pm2_env.status;
      var key = l.pm2_env.pm_id;
      key = chalk.bold.cyan(key);
      if (l.pm2_env.axm_options) {
        var is_tracing_enabled = false;
        if (l.pm2_env.axm_options.tracing && typeof l.pm2_env.axm_options.tracing == "boolean" && l.pm2_env.axm_options.tracing == true)
          is_tracing_enabled = true;
        if (l.pm2_env.axm_options.tracing && l.pm2_env.axm_options.tracing.enabled && typeof l.pm2_env.axm_options.tracing.enabled == "boolean" && l.pm2_env.axm_options.tracing.enabled == true)
          is_tracing_enabled = true;
        if (is_tracing_enabled == true)
          l.pm2_env.name = chalk.green("\u2635") + " " + l.pm2_env.name;
        if (l.pm2_env._km_monitored)
          l.pm2_env.name = chalk.bold.green("\u25C9") + " " + l.pm2_env.name;
      }
      if (l.pm2_env.pmx_module == true) {
        if (l.pm2_env.name == "pm2-sysmonit")
          return;
        obj[key] = [];
        obj[key].push(l.name);
        if (!CONDENSED_MODE) {
          var pid = l.pm2_env.axm_options.pid ? l.pm2_env.axm_options.pid : l.pid;
          obj[key].push(l.pm2_env.version || "N/A", pid);
        }
        obj[key].push(UxHelpers.colorStatus(status));
        if (!CONDENSED_MODE)
          obj[key].push(l.pm2_env.restart_time ? l.pm2_env.restart_time : 0);
        obj[key].push(l.monit ? l.monit.cpu + "%" : "N/A", l.monit ? UxHelpers.bytesToSize(l.monit.memory, 1) : "N/A");
        if (!CONDENSED_MODE) {
          if (l.pm2_env.uid && typeof l.pm2_env.uid == "number") {
            let users = Passwd.getUsers();
            Object.keys(users).forEach(function(username) {
              var user = users[username];
              if (user.userId == l.pm2_env.uid) {
                l.pm2_env.uid = user.username;
              }
            });
          }
          obj[key].push(chalk.bold(l.pm2_env.uid || l.pm2_env.username));
        }
        UxHelpers.safe_push(module_table, obj);
      } else {
        obj[key] = [];
        obj[key].push(l.pm2_env.name);
        if (!CONDENSED_MODE)
          obj[key].push(l.pm2_env.namespace);
        if (!CONDENSED_MODE)
          obj[key].push(l.pm2_env.version);
        obj[key].push(mode == "fork_mode" ? chalk.inverse.bold("fork") : chalk.blue.bold("cluster"));
        if (!CONDENSED_MODE)
          obj[key].push(l.pid);
        if (!CONDENSED_MODE)
          obj[key].push(l.pm2_env.pm_uptime && status == "online" ? UxHelpers.timeSince(l.pm2_env.pm_uptime) : 0);
        obj[key].push(l.pm2_env.restart_time ? l.pm2_env.restart_time : 0);
        obj[key].push(UxHelpers.colorStatus(status));
        obj[key].push(l.monit ? l.monit.cpu + "%" : "N/A");
        obj[key].push(l.monit ? UxHelpers.bytesToSize(l.monit.memory, 1) : "N/A");
        if (!CONDENSED_MODE) {
          if (l.pm2_env.uid && typeof l.pm2_env.uid == "number") {
            let users = Passwd.getUsers();
            Object.keys(users).forEach(function(username) {
              var user = users[username];
              if (user.userId == l.pm2_env.uid) {
                l.pm2_env.uid = user.username;
              }
            });
          }
          obj[key].push(chalk.bold(l.pm2_env.uid || l.pm2_env.username));
        }
        if (!CONDENSED_MODE)
          obj[key].push(l.pm2_env.watch ? chalk.green.bold("enabled") : chalk.grey("disabled"));
        UxHelpers.safe_push(app_table, obj);
      }
    });
    console.log(app_table.toString());
    if (module_table.length > 0) {
      console.log(chalk.bold(`Module${module_table.length > 1 ? "s" : ""}`));
      console.log(module_table.toString());
    }
    proc_id++;
  };
  var miniMonitBar = function(sys_infos) {
    let sys_metrics = sys_infos.pm2_env.axm_monitor;
    let cpu = sys_metrics["CPU Usage"];
    if (typeof cpu == "undefined")
      return;
    var sys_summary_line = `${chalk.bold.cyan("host metrics")} `;
    sys_summary_line += `| ${chalk.bold("cpu")}: ${UxHelpers.colorizedMetric(cpu.value, 40, 70, "%")}`;
    let temp = sys_metrics["CPU Temperature"].value;
    if (temp && temp != "-1") {
      sys_summary_line += ` ${UxHelpers.colorizedMetric(temp, 50, 70, "\xBA")}`;
    }
    let mem_total = sys_metrics["RAM Total"].value;
    let mem_available = sys_metrics["RAM Available"].value;
    if (mem_total) {
      var perc_mem_usage = (mem_available / mem_total * 100).toFixed(1);
      sys_summary_line += ` | ${chalk.bold("mem free")}: ${UxHelpers.colorizedMetric(perc_mem_usage, 30, 10, "%")} `;
    }
    let interfaces = Object.keys(sys_metrics).filter((m) => m.includes("net") && m != "net:default").map((i) => i.split(":")[2]).filter((iface, i, self2) => self2.indexOf(iface) === i);
    interfaces.forEach((iface) => {
      if (!sys_metrics[`net:rx_5:${iface}`])
        return;
      sys_summary_line += `| ${chalk.bold(iface)}: `;
      sys_summary_line += `\u21D3 ${UxHelpers.colorizedMetric(sys_metrics[`net:rx_5:${iface}`].value, 10, 20, "mb/s")} `;
      sys_summary_line += `\u21D1 ${UxHelpers.colorizedMetric(sys_metrics[`net:tx_5:${iface}`].value, 10, 20, "mb/s")} `;
    });
    if (CONDENSED_MODE == false) {
      let read = sys_metrics["Disk Reads"].value;
      let write4 = sys_metrics["Disk Writes"].value;
      sys_summary_line += `| ${chalk.bold("disk")}: \u21D3 ${UxHelpers.colorizedMetric(read, 10, 20, "mb/s")}`;
      sys_summary_line += ` \u21D1 ${UxHelpers.colorizedMetric(write4, 10, 20, "mb/s")} `;
      let disks = Object.keys(sys_metrics).filter((m) => m.includes("fs:")).map((i) => i.split(":")[2]).filter((iface, i, self2) => self2.indexOf(iface) === i);
      var disk_nb = 0;
      disks.forEach((fs) => {
        let use = sys_metrics[`fs:use:${fs}`].value;
        if (use > 60)
          sys_summary_line += `${chalk.grey(fs)} ${UxHelpers.colorizedMetric(use, 80, 90, "%")} `;
      });
    }
    sys_summary_line += "|";
    console.log(sys_summary_line);
  };
  var cst = require_constants2();
  var Common = require_Common();
  var Configuration = require_Configuration();
  var UxHelpers = require_helpers();
  var chalk = require_source();
  var Table = require_lib4();
  var Passwd = require_passwd();
  var CONDENSED_MODE = (process.stdout.columns || 300) < 134;
  var proc_id = 0;
  module2.exports = function(list, commander) {
    var pm2_conf = Configuration.getSync("pm2");
    if (!list)
      return console.log("list empty");
    listModulesAndAppsManaged(list, commander);
    let sysmonit = list.filter((proc) => proc.name == "pm2-sysmonit");
    if (sysmonit && sysmonit[0])
      miniMonitBar(sysmonit[0]);
    checkIfProcessAreDumped(list);
  };
});

// ../../node_modules/pm2/lib/API/UX/pm2-ls-minimal.js
var require_pm2_ls_minimal = __commonJS((exports2, module2) => {
  var UxHelpers = require_helpers();
  var p = __require("path");
  module2.exports = function(list) {
    list.forEach(function(l) {
      var mode = l.pm2_env.exec_mode.split("_mode")[0];
      var status = l.pm2_env.status;
      var key = l.pm2_env.name || p.basename(l.pm2_env.pm_exec_path.script);
      console.log("+--- %s", key);
      console.log("namespace : %s", l.pm2_env.namespace);
      console.log("version : %s", l.pm2_env.version);
      console.log("pid : %s", l.pid);
      console.log("pm2 id : %s", l.pm2_env.pm_id);
      console.log("status : %s", status);
      console.log("mode : %s", mode);
      console.log("restarted : %d", l.pm2_env.restart_time ? l.pm2_env.restart_time : 0);
      console.log("uptime : %s", l.pm2_env.pm_uptime && status == "online" ? UxHelpers.timeSince(l.pm2_env.pm_uptime) : 0);
      console.log("memory usage : %s", l.monit ? UxHelpers.bytesToSize(l.monit.memory, 1) : "");
      console.log("error log : %s", l.pm2_env.pm_err_log_path);
      console.log("watching : %s", l.pm2_env.watch ? "yes" : "no");
      console.log("PID file : %s\n", l.pm2_env.pm_pid_path);
    });
  };
});

// ../../node_modules/pm2/lib/API/UX/index.js
var require_UX = __commonJS((exports2, module2) => {
  var UX = {
    helpers: require_helpers(),
    describe: require_pm2_describe(),
    list: require_pm2_ls(),
    list_min: require_pm2_ls_minimal()
  };
  module2.exports = UX;
});

// ../../node_modules/pm2/lib/API/Modules/flagExt.js
var require_flagExt = __commonJS((exports2, module2) => {
  var find_extensions = function(folder, ext, ret) {
    try {
      fs.accessSync(folder, fs.constants.R_OK);
    } catch (err) {
      return;
    }
    if (fs.statSync(folder).isDirectory() && folder.indexOf("node_modules") == -1 && fs.statSync(folder)["mode"] & 4) {
      fs.readdirSync(folder).forEach((file) => {
        var tmp;
        if (Number.parseInt(folder.lastIndexOf("/") + 1) === folder.length)
          tmp = folder + file;
        else
          tmp = folder + "/" + file;
        if (fs.statSync(tmp).isDirectory())
          find_extensions(tmp, ext, ret);
        else {
          var p = true;
          for (var i = 0;i < ext.length; i++)
            if (ext[i].test(file))
              p = false;
          if (p)
            ret.push(folder + "/" + file);
        }
      });
    }
  };
  var fs = __require("fs");
  var conf2 = require_constants2();
  exports2.make_available_extension = function make_available_extension(opts, ret) {
    if (typeof opts == "object" && typeof ret == "object") {
      var mas = opts.ext.split(",");
      for (var i = 0;i < mas.length; i++)
        mas[i] = "." + mas[i];
      var res = [];
      for (var i = 0;i < mas.length; i++)
        res[i] = new RegExp(mas[i] + "$");
      find_extensions(process.cwd(), res, ret);
    }
  };
});

// ../../node_modules/pm2/lib/tools/json5.js
var require_json5 = __commonJS((exports2) => {
  var JSON5 = typeof exports2 === "object" ? exports2 : {};
  JSON5.parse = function() {
    var at, ch, escapee = {
      "'": "'",
      '"': '"',
      "\\": "\\",
      "/": "/",
      "\n": "",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "\t"
    }, ws = [
      " ",
      "\t",
      "\r",
      "\n",
      "\v",
      "\f",
      "\xA0",
      "\uFEFF"
    ], text, error = function(m) {
      var error2 = new SyntaxError;
      error2.message = m;
      error2.at = at;
      error2.text = text;
      throw error2;
    }, next = function(c) {
      if (c && c !== ch) {
        error("Expected '" + c + "' instead of '" + ch + "'");
      }
      ch = text.charAt(at);
      at += 1;
      return ch;
    }, peek = function() {
      return text.charAt(at);
    }, identifier = function() {
      var key = ch;
      if (ch !== "_" && ch !== "$" && (ch < "a" || ch > "z") && (ch < "A" || ch > "Z")) {
        error("Bad identifier");
      }
      while (next() && (ch === "_" || ch === "$" || ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch >= "0" && ch <= "9")) {
        key += ch;
      }
      return key;
    }, number = function() {
      var number2, sign = "", string2 = "", base = 10;
      if (ch === "-" || ch === "+") {
        sign = ch;
        next(ch);
      }
      if (ch === "I") {
        number2 = word();
        if (typeof number2 !== "number" || isNaN(number2)) {
          error("Unexpected word for number");
        }
        return sign === "-" ? -number2 : number2;
      }
      if (ch === "N") {
        number2 = word();
        if (!isNaN(number2)) {
          error("expected word to be NaN");
        }
        return number2;
      }
      if (ch === "0") {
        string2 += ch;
        next();
        if (ch === "x" || ch === "X") {
          string2 += ch;
          next();
          base = 16;
        } else if (ch >= "0" && ch <= "9") {
          error("Octal literal");
        }
      }
      switch (base) {
        case 10:
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
          if (ch === ".") {
            string2 += ".";
            while (next() && ch >= "0" && ch <= "9") {
              string2 += ch;
            }
          }
          if (ch === "e" || ch === "E") {
            string2 += ch;
            next();
            if (ch === "-" || ch === "+") {
              string2 += ch;
              next();
            }
            while (ch >= "0" && ch <= "9") {
              string2 += ch;
              next();
            }
          }
          break;
        case 16:
          while (ch >= "0" && ch <= "9" || ch >= "A" && ch <= "F" || ch >= "a" && ch <= "f") {
            string2 += ch;
            next();
          }
          break;
      }
      if (sign === "-") {
        number2 = -string2;
      } else {
        number2 = +string2;
      }
      if (!isFinite(number2)) {
        error("Bad number");
      } else {
        return number2;
      }
    }, string = function() {
      var hex, i, string2 = "", delim, uffff;
      if (ch === '"' || ch === "'") {
        delim = ch;
        while (next()) {
          if (ch === delim) {
            next();
            return string2;
          } else if (ch === "\\") {
            next();
            if (ch === "u") {
              uffff = 0;
              for (i = 0;i < 4; i += 1) {
                hex = parseInt(next(), 16);
                if (!isFinite(hex)) {
                  break;
                }
                uffff = uffff * 16 + hex;
              }
              string2 += String.fromCharCode(uffff);
            } else if (ch === "\r") {
              if (peek() === "\n") {
                next();
              }
            } else if (typeof escapee[ch] === "string") {
              string2 += escapee[ch];
            } else {
              break;
            }
          } else if (ch === "\n") {
            break;
          } else {
            string2 += ch;
          }
        }
      }
      error("Bad string");
    }, inlineComment = function() {
      if (ch !== "/") {
        error("Not an inline comment");
      }
      do {
        next();
        if (ch === "\n" || ch === "\r") {
          next();
          return;
        }
      } while (ch);
    }, blockComment = function() {
      if (ch !== "*") {
        error("Not a block comment");
      }
      do {
        next();
        while (ch === "*") {
          next("*");
          if (ch === "/") {
            next("/");
            return;
          }
        }
      } while (ch);
      error("Unterminated block comment");
    }, comment = function() {
      if (ch !== "/") {
        error("Not a comment");
      }
      next("/");
      if (ch === "/") {
        inlineComment();
      } else if (ch === "*") {
        blockComment();
      } else {
        error("Unrecognized comment");
      }
    }, white = function() {
      while (ch) {
        if (ch === "/") {
          comment();
        } else if (ws.indexOf(ch) >= 0) {
          next();
        } else {
          return;
        }
      }
    }, word = function() {
      switch (ch) {
        case "t":
          next("t");
          next("r");
          next("u");
          next("e");
          return true;
        case "f":
          next("f");
          next("a");
          next("l");
          next("s");
          next("e");
          return false;
        case "n":
          next("n");
          next("u");
          next("l");
          next("l");
          return null;
        case "I":
          next("I");
          next("n");
          next("f");
          next("i");
          next("n");
          next("i");
          next("t");
          next("y");
          return Infinity;
        case "N":
          next("N");
          next("a");
          next("N");
          return NaN;
      }
      error("Unexpected '" + ch + "'");
    }, value, array = function() {
      var array2 = [];
      if (ch === "[") {
        next("[");
        white();
        while (ch) {
          if (ch === "]") {
            next("]");
            return array2;
          }
          if (ch === ",") {
            error("Missing array element");
          } else {
            array2.push(value());
          }
          white();
          if (ch !== ",") {
            next("]");
            return array2;
          }
          next(",");
          white();
        }
      }
      error("Bad array");
    }, object = function() {
      var key, object2 = {};
      if (ch === "{") {
        next("{");
        white();
        while (ch) {
          if (ch === "}") {
            next("}");
            return object2;
          }
          if (ch === '"' || ch === "'") {
            key = string();
          } else {
            key = identifier();
          }
          white();
          next(":");
          object2[key] = value();
          white();
          if (ch !== ",") {
            next("}");
            return object2;
          }
          next(",");
          white();
        }
      }
      error("Bad object");
    };
    value = function() {
      white();
      switch (ch) {
        case "{":
          return object();
        case "[":
          return array();
        case '"':
        case "'":
          return string();
        case "-":
        case "+":
        case ".":
          return number();
        default:
          return ch >= "0" && ch <= "9" ? number() : word();
      }
    };
    return function(source, reviver) {
      var result;
      text = String(source);
      at = 0;
      ch = " ";
      result = value();
      white();
      if (ch) {
        error("Syntax error");
      }
      return typeof reviver === "function" ? function walk(holder, key) {
        var k, v, value2 = holder[key];
        if (value2 && typeof value2 === "object") {
          for (k in value2) {
            if (Object.prototype.hasOwnProperty.call(value2, k)) {
              v = walk(value2, k);
              if (v !== undefined) {
                value2[k] = v;
              } else {
                delete value2[k];
              }
            }
          }
        }
        return reviver.call(holder, key, value2);
      }({ "": result }, "") : result;
    };
  }();
  JSON5.stringify = function(obj, replacer, space) {
    if (replacer && (typeof replacer !== "function" && !isArray2(replacer))) {
      throw new Error("Replacer must be a function or an array");
    }
    var getReplacedValueOrUndefined = function(holder, key, isTopLevel) {
      var value = holder[key];
      if (value && value.toJSON && typeof value.toJSON === "function") {
        value = value.toJSON();
      }
      if (typeof replacer === "function") {
        return replacer.call(holder, key, value);
      } else if (replacer) {
        if (isTopLevel || isArray2(holder) || replacer.indexOf(key) >= 0) {
          return value;
        } else {
          return;
        }
      } else {
        return value;
      }
    };
    function isWordChar(char) {
      return char >= "a" && char <= "z" || char >= "A" && char <= "Z" || char >= "0" && char <= "9" || char === "_" || char === "$";
    }
    function isWordStart(char) {
      return char >= "a" && char <= "z" || char >= "A" && char <= "Z" || char === "_" || char === "$";
    }
    function isWord(key) {
      if (typeof key !== "string") {
        return false;
      }
      if (!isWordStart(key[0])) {
        return false;
      }
      var i = 1, length3 = key.length;
      while (i < length3) {
        if (!isWordChar(key[i])) {
          return false;
        }
        i++;
      }
      return true;
    }
    JSON5.isWord = isWord;
    function isArray2(obj2) {
      if (Array.isArray) {
        return Array.isArray(obj2);
      } else {
        return Object.prototype.toString.call(obj2) === "[object Array]";
      }
    }
    function isDate(obj2) {
      return Object.prototype.toString.call(obj2) === "[object Date]";
    }
    isNaN = isNaN || function(val) {
      return typeof val === "number" && val !== val;
    };
    var objStack = [];
    function checkForCircular(obj2) {
      for (var i = 0;i < objStack.length; i++) {
        if (objStack[i] === obj2) {
          throw new TypeError("Converting circular structure to JSON");
        }
      }
    }
    function makeIndent(str, num, noNewLine) {
      if (!str) {
        return "";
      }
      if (str.length > 10) {
        str = str.substring(0, 10);
      }
      var indent = noNewLine ? "" : "\n";
      for (var i = 0;i < num; i++) {
        indent += str;
      }
      return indent;
    }
    var indentStr;
    if (space) {
      if (typeof space === "string") {
        indentStr = space;
      } else if (typeof space === "number" && space >= 0) {
        indentStr = makeIndent(" ", space, true);
      } else {
      }
    }
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, meta2 = {
      "\b": "\\b",
      "\t": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    function escapeString(string) {
      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
        var c = meta2[a];
        return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
    }
    function internalStringify(holder, key, isTopLevel) {
      var buffer, res;
      var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);
      if (obj_part && !isDate(obj_part)) {
        obj_part = obj_part.valueOf();
      }
      switch (typeof obj_part) {
        case "boolean":
          return obj_part.toString();
        case "number":
          if (isNaN(obj_part) || !isFinite(obj_part)) {
            return "null";
          }
          return obj_part.toString();
        case "string":
          return escapeString(obj_part.toString());
        case "object":
          if (obj_part === null) {
            return "null";
          } else if (isArray2(obj_part)) {
            checkForCircular(obj_part);
            buffer = "[";
            objStack.push(obj_part);
            for (var i = 0;i < obj_part.length; i++) {
              res = internalStringify(obj_part, i, false);
              buffer += makeIndent(indentStr, objStack.length);
              if (res === null || typeof res === "undefined") {
                buffer += "null";
              } else {
                buffer += res;
              }
              if (i < obj_part.length - 1) {
                buffer += ",";
              } else if (indentStr) {
                buffer += "\n";
              }
            }
            objStack.pop();
            buffer += makeIndent(indentStr, objStack.length, true) + "]";
          } else {
            checkForCircular(obj_part);
            buffer = "{";
            var nonEmpty = false;
            objStack.push(obj_part);
            for (var prop in obj_part) {
              if (obj_part.hasOwnProperty(prop)) {
                var value = internalStringify(obj_part, prop, false);
                isTopLevel = false;
                if (typeof value !== "undefined" && value !== null) {
                  buffer += makeIndent(indentStr, objStack.length);
                  nonEmpty = true;
                  var key = isWord(prop) ? prop : escapeString(prop);
                  buffer += key + ":" + (indentStr ? " " : "") + value + ",";
                }
              }
            }
            objStack.pop();
            if (nonEmpty) {
              buffer = buffer.substring(0, buffer.length - 1) + makeIndent(indentStr, objStack.length) + "}";
            } else {
              buffer = "{}";
            }
          }
          return buffer;
        default:
          return;
      }
    }
    var topLevelHolder = { "": obj };
    if (obj === undefined) {
      return getReplacedValueOrUndefined(topLevelHolder, "", true);
    }
    return internalStringify(topLevelHolder, "", true);
  };
});

// ../../node_modules/pm2/lib/tools/treeify.js
var require_treeify = __commonJS((exports2, module2) => {
  (function(root, factory) {
    if (typeof exports2 === "object") {
      module2.exports = factory();
    } else if (typeof define === "function" && define.amd) {
      define(factory);
    } else {
      root.treeify = factory();
    }
  })(exports2, function() {
    function makePrefix(key, last2) {
      var str = last2 ? "\u2514" : "\u251C";
      if (key) {
        str += "\u2500 ";
      } else {
        str += "\u2500\u2500\u2510";
      }
      return str;
    }
    function filterKeys(obj, hideFunctions) {
      var keys3 = [];
      for (var branch in obj) {
        if (!obj.hasOwnProperty(branch)) {
          continue;
        }
        if (hideFunctions && typeof obj[branch] === "function") {
          continue;
        }
        keys3.push(branch);
      }
      return keys3;
    }
    function growBranch(key, root, last2, lastStates, showValues, hideFunctions, callback) {
      var line = "", index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);
      if (lastStatesCopy.push([root, last2]) && lastStates.length > 0) {
        lastStates.forEach(function(lastState, idx) {
          if (idx > 0) {
            line += (lastState[1] ? " " : "\u2502") + "  ";
          }
          if (!circular && lastState[0] === root) {
            circular = true;
          }
        });
        line += makePrefix(key, last2) + key;
        showValues && (typeof root !== "object" || root instanceof Date) && (line += ": " + root);
        circular && (line += " (circular ref.)");
        callback(line);
      }
      if (!circular && typeof root === "object") {
        var keys3 = filterKeys(root, hideFunctions);
        keys3.forEach(function(branch) {
          lastKey = ++index === keys3.length;
          growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);
        });
      }
    }
    var Treeify = {};
    Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {
      var hideFunctionsArg = typeof hideFunctions !== "function" ? hideFunctions : false;
      growBranch(".", obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);
    };
    Treeify.asTree = function(obj, showValues, hideFunctions) {
      var tree = "";
      growBranch(".", obj, false, [], showValues, hideFunctions, function(line) {
        tree += line + "\n";
      });
      return tree;
    };
    return Treeify;
  });
});

// ../../node_modules/json-stringify-safe/stringify.js
var require_stringify3 = __commonJS((exports2, module2) => {
  var stringify2 = function(obj, replacer, spaces, cycleReplacer) {
    return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
  };
  var serializer = function(replacer, cycleReplacer) {
    var stack = [], keys3 = [];
    if (cycleReplacer == null)
      cycleReplacer = function(key, value) {
        if (stack[0] === value)
          return "[Circular ~]";
        return "[Circular ~." + keys3.slice(0, stack.indexOf(value)).join(".") + "]";
      };
    return function(key, value) {
      if (stack.length > 0) {
        var thisPos = stack.indexOf(this);
        ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
        ~thisPos ? keys3.splice(thisPos, Infinity, key) : keys3.push(key);
        if (~stack.indexOf(value))
          value = cycleReplacer.call(this, key, value);
      } else
        stack.push(value);
      return replacer == null ? value : replacer.call(this, key, value);
    };
  };
  exports2 = module2.exports = stringify2;
  exports2.getSerialize = serializer;
});

// ../../node_modules/tx2/src/events.js
var require_events = __commonJS((exports2, module2) => {
  var stringify2 = require_stringify3();
  module2.exports = {
    event(name2, data) {
      if (!name2)
        return console.error("[AXM] emit.name is missing");
      let inflight_obj = {};
      if (typeof data == "object")
        inflight_obj = JSON.parse(stringify2(data));
      else {
        inflight_obj.data = data || null;
      }
      inflight_obj.__name = name2;
      this.send({
        type: "human:event",
        data: inflight_obj
      });
    }
  };
});

// ../../node_modules/tx2/src/actions.js
var require_actions = __commonJS((exports2, module2) => {
  module2.exports = {
    action(action_name, opts, fn) {
      if (!fn) {
        fn = opts;
        opts = null;
      }
      if (!action_name)
        return console.error("[PMX] action.action_name is missing");
      if (!fn)
        return console.error("[PMX] emit.data is mission");
      this.send({
        type: "axm:action",
        data: {
          action_name,
          opts,
          arity: fn.length
        }
      });
      let reply = (data) => {
        if (data.length) {
          data._length = data.length;
          delete data.length;
        }
        this.send({
          type: "axm:reply",
          data: {
            return: data,
            action_name
          }
        });
      };
      process.on("message", (data) => {
        if (!data)
          return false;
        if (data && (data == action_name || data.msg == action_name))
          this.event("action triggered", { action_name, opts });
        if (fn.length === 2 && typeof data === "string" && data === action_name)
          return fn({}, reply);
        if (fn.length === 1 && typeof data === "object" && data.msg === action_name)
          return fn(reply);
        if (typeof data === "string" && data === action_name)
          return fn(reply);
        if (typeof data === "object" && data.msg === action_name)
          return fn(data.opts, reply);
      });
    }
  };
});

// ../../node_modules/tx2/src/utils/probes/Counter.js
var require_Counter = __commonJS((exports2, module2) => {
  var Counter = function(opts) {
    opts = opts || {};
    this._count = opts.count || 0;
  };
  module2.exports = Counter;
  Counter.prototype.val = function() {
    return this._count;
  };
  Counter.prototype.inc = function(n) {
    const incBy = n == null ? 1 : n;
    this._count += incBy;
  };
  Counter.prototype.dec = function(n) {
    const decBy = n == null ? 1 : n;
    this._count -= decBy;
  };
  Counter.prototype.reset = function(count) {
    this._count = count || 0;
  };
});

// ../../node_modules/tx2/src/utils/probes/BinaryHeap.js
var require_BinaryHeap = __commonJS((exports2, module2) => {
  var BinaryHeap = function(options2) {
    options2 = options2 || {};
    this._elements = options2.elements || [];
    this._score = options2.score || this._score;
  };
  module2.exports = BinaryHeap;
  BinaryHeap.prototype.add = function() {
    for (var i = 0;i < arguments.length; i++) {
      var element = arguments[i];
      this._elements.push(element);
      this._bubble(this._elements.length - 1);
    }
  };
  BinaryHeap.prototype.first = function() {
    return this._elements[0];
  };
  BinaryHeap.prototype.removeFirst = function() {
    var root = this._elements[0];
    var last2 = this._elements.pop();
    if (this._elements.length > 0) {
      this._elements[0] = last2;
      this._sink(0);
    }
    return root;
  };
  BinaryHeap.prototype.clone = function() {
    return new BinaryHeap({
      elements: this.toArray(),
      score: this._score
    });
  };
  BinaryHeap.prototype.toSortedArray = function() {
    var array = [];
    var clone = this.clone();
    while (true) {
      var element = clone.removeFirst();
      if (element === undefined)
        break;
      array.push(element);
    }
    return array;
  };
  BinaryHeap.prototype.toArray = function() {
    return [].concat(this._elements);
  };
  BinaryHeap.prototype.size = function() {
    return this._elements.length;
  };
  BinaryHeap.prototype._bubble = function(bubbleIndex) {
    var bubbleElement = this._elements[bubbleIndex];
    var bubbleScore = this._score(bubbleElement);
    while (bubbleIndex > 0) {
      var parentIndex = this._parentIndex(bubbleIndex);
      var parentElement = this._elements[parentIndex];
      var parentScore = this._score(parentElement);
      if (bubbleScore <= parentScore)
        break;
      this._elements[parentIndex] = bubbleElement;
      this._elements[bubbleIndex] = parentElement;
      bubbleIndex = parentIndex;
    }
  };
  BinaryHeap.prototype._sink = function(sinkIndex) {
    var sinkElement = this._elements[sinkIndex];
    var sinkScore = this._score(sinkElement);
    var length3 = this._elements.length;
    while (true) {
      var swapIndex = null;
      var swapScore = null;
      var swapElement = null;
      var childIndexes = this._childIndexes(sinkIndex);
      for (var i = 0;i < childIndexes.length; i++) {
        var childIndex = childIndexes[i];
        if (childIndex >= length3)
          break;
        var childElement = this._elements[childIndex];
        var childScore = this._score(childElement);
        if (childScore > sinkScore) {
          if (swapScore === null || swapScore < childScore) {
            swapIndex = childIndex;
            swapScore = childScore;
            swapElement = childElement;
          }
        }
      }
      if (swapIndex === null)
        break;
      this._elements[swapIndex] = sinkElement;
      this._elements[sinkIndex] = swapElement;
      sinkIndex = swapIndex;
    }
  };
  BinaryHeap.prototype._parentIndex = function(index) {
    return Math.floor((index - 1) / 2);
  };
  BinaryHeap.prototype._childIndexes = function(index) {
    return [
      2 * index + 1,
      2 * index + 2
    ];
    return;
  };
  BinaryHeap.prototype._score = function(element) {
    return element.valueOf();
  };
});

// ../../node_modules/tx2/src/utils/probes/units.js
var require_units = __commonJS((exports2) => {
  exports2.NANOSECONDS = 1 / (1000 * 1000);
  exports2.MICROSECONDS = 1 / 1000;
  exports2.MILLISECONDS = 1;
  exports2.SECONDS = 1000 * exports2.MILLISECONDS;
  exports2.MINUTES = 60 * exports2.SECONDS;
  exports2.HOURS = 60 * exports2.MINUTES;
  exports2.DAYS = 24 * exports2.HOURS;
});

// ../../node_modules/tx2/src/utils/probes/EDS.js
var require_EDS = __commonJS((exports2, module2) => {
  var ExponentiallyDecayingSample = function(options2) {
    options2 = options2 || {};
    this._elements = new BinaryHeap({
      score: function(element) {
        return -element.priority;
      }
    });
    this._rescaleInterval = options2.rescaleInterval || ExponentiallyDecayingSample.RESCALE_INTERVAL;
    this._alpha = options2.alpha || ExponentiallyDecayingSample.ALPHA;
    this._size = options2.size || ExponentiallyDecayingSample.SIZE;
    this._random = options2.random || this._random;
    this._landmark = null;
    this._nextRescale = null;
    this._mean = null;
  };
  var BinaryHeap = require_BinaryHeap();
  var units = require_units();
  module2.exports = ExponentiallyDecayingSample;
  ExponentiallyDecayingSample.RESCALE_INTERVAL = 1 * units.HOURS;
  ExponentiallyDecayingSample.ALPHA = 0.015;
  ExponentiallyDecayingSample.SIZE = 1028;
  ExponentiallyDecayingSample.prototype.update = function(value, timestamp) {
    var now = Date.now();
    if (!this._landmark) {
      this._landmark = now;
      this._nextRescale = this._landmark + this._rescaleInterval;
    }
    timestamp = timestamp || now;
    var newSize = this._elements.size() + 1;
    var element = {
      priority: this._priority(timestamp - this._landmark),
      value
    };
    if (newSize <= this._size) {
      this._elements.add(element);
    } else if (element.priority > this._elements.first().priority) {
      this._elements.removeFirst();
      this._elements.add(element);
    }
    if (now >= this._nextRescale)
      this._rescale(now);
  };
  ExponentiallyDecayingSample.prototype.toSortedArray = function() {
    return this._elements.toSortedArray().map(function(element) {
      return element.value;
    });
  };
  ExponentiallyDecayingSample.prototype.toArray = function() {
    return this._elements.toArray().map(function(element) {
      return element.value;
    });
  };
  ExponentiallyDecayingSample.prototype._weight = function(age) {
    return Math.exp(this._alpha * (age / 1000));
  };
  ExponentiallyDecayingSample.prototype._priority = function(age) {
    return this._weight(age) / this._random();
  };
  ExponentiallyDecayingSample.prototype._random = function() {
    return Math.random();
  };
  ExponentiallyDecayingSample.prototype._rescale = function(now) {
    now = now || Date.now();
    var self2 = this;
    var oldLandmark = this._landmark;
    this._landmark = now || Date.now();
    this._nextRescale = now + this._rescaleInterval;
    var factor = self2._priority(-(self2._landmark - oldLandmark));
    this._elements.toArray().forEach(function(element) {
      element.priority *= factor;
    });
  };
  ExponentiallyDecayingSample.prototype.avg = function(now) {
    var sum = 0;
    this._elements.toArray().forEach(function(element) {
      sum += element.value;
    });
    return sum / this._elements.size();
  };
});

// ../../node_modules/tx2/src/utils/probes/Histogram.js
var require_Histogram = __commonJS((exports2, module2) => {
  var Histogram = function(opts) {
    var self2 = this;
    opts = opts || {};
    this._measurement = opts.measurement;
    this._call_fn = null;
    var methods = {
      min: this.getMin,
      max: this.getMax,
      sum: this.getSum,
      count: this.getCount,
      variance: this._calculateVariance,
      mean: this._calculateMean,
      stddev: this._calculateStddev,
      ema: this.getEma()
    };
    if (methods[this._measurement])
      this._call_fn = methods[this._measurement];
    else {
      this._call_fn = function() {
        var percentiles = this.percentiles([0.5, 0.75, 0.95, 0.99, 0.999]);
        var medians = {
          median: percentiles[0.5],
          p75: percentiles[0.75],
          p95: percentiles[0.95],
          p99: percentiles[0.99],
          p999: percentiles[0.999]
        };
        return medians[this._measurement];
      };
    }
    this._sample = new EDS;
    this._min = null;
    this._max = null;
    this._count = 0;
    this._sum = 0;
    this._varianceM = 0;
    this._varianceS = 0;
    this._ema = 0;
  };
  var EDS = require_EDS();
  Histogram.prototype.update = function(value) {
    this._count++;
    this._sum += value;
    this._sample.update(value);
    this._updateMin(value);
    this._updateMax(value);
    this._updateVariance(value);
    this._updateEma(value);
  };
  Histogram.prototype.percentiles = function(percentiles) {
    var values = this._sample.toArray().sort(function(a, b) {
      return a === b ? 0 : a - b;
    });
    var results = {};
    for (var i = 0;i < percentiles.length; i++) {
      var percentile = percentiles[i];
      if (!values.length) {
        results[percentile] = null;
        continue;
      }
      var pos = percentile * (values.length + 1);
      if (pos < 1) {
        results[percentile] = values[0];
      } else if (pos >= values.length) {
        results[percentile] = values[values.length - 1];
      } else {
        var lower = values[Math.floor(pos) - 1];
        var upper = values[Math.ceil(pos) - 1];
        results[percentile] = lower + (pos - Math.floor(pos)) * (upper - lower);
      }
    }
    return results;
  };
  Histogram.prototype.reset = function() {
    this.constructor.call(this);
  };
  Histogram.prototype.val = function() {
    if (typeof this._call_fn === "function")
      return this._call_fn();
    else
      return this._call_fn;
  };
  Histogram.prototype.getMin = function() {
    return this._min;
  };
  Histogram.prototype.getMax = function() {
    return this._max;
  };
  Histogram.prototype.getSum = function() {
    return this._sum;
  };
  Histogram.prototype.getCount = function() {
    return this._count;
  };
  Histogram.prototype.getEma = function() {
    return this._ema;
  };
  Histogram.prototype.fullResults = function() {
    var percentiles = this.percentiles([0.5, 0.75, 0.95, 0.99, 0.999]);
    return {
      min: this._min,
      max: this._max,
      sum: this._sum,
      variance: this._calculateVariance(),
      mean: this._calculateMean(),
      stddev: this._calculateStddev(),
      count: this._count,
      median: percentiles[0.5],
      p75: percentiles[0.75],
      p95: percentiles[0.95],
      p99: percentiles[0.99],
      p999: percentiles[0.999],
      ema: this._ema
    };
  };
  Histogram.prototype._updateMin = function(value) {
    if (this._min === null || value < this._min) {
      this._min = value;
    }
  };
  Histogram.prototype._updateMax = function(value) {
    if (this._max === null || value > this._max) {
      this._max = value;
    }
  };
  Histogram.prototype._updateVariance = function(value) {
    if (this._count === 1)
      return this._varianceM = value;
    var oldM = this._varianceM;
    this._varianceM += (value - oldM) / this._count;
    this._varianceS += (value - oldM) * (value - this._varianceM);
  };
  Histogram.prototype._updateEma = function(value) {
    if (this._count <= 1)
      return this._ema = this._calculateMean();
    var alpha = 2 / (1 + this._count);
    this._ema = value * alpha + this._ema * (1 - alpha);
  };
  Histogram.prototype._calculateMean = function() {
    return this._count === 0 ? 0 : this._sum / this._count;
  };
  Histogram.prototype._calculateVariance = function() {
    return this._count <= 1 ? null : this._varianceS / (this._count - 1);
  };
  Histogram.prototype._calculateStddev = function() {
    return this._count < 1 ? null : Math.sqrt(this._calculateVariance());
  };
  module2.exports = Histogram;
});

// ../../node_modules/tx2/src/utils/probes/EWMA.js
var require_EWMA = __commonJS((exports2, module2) => {
  var ExponentiallyWeightedMovingAverage = function(timePeriod, tickInterval) {
    this._timePeriod = timePeriod || 1 * units.MINUTE;
    this._tickInterval = tickInterval || ExponentiallyWeightedMovingAverage.TICK_INTERVAL;
    this._alpha = 1 - Math.exp(-this._tickInterval / this._timePeriod);
    this._count = 0;
    this._rate = 0;
  };
  var units = require_units();
  module2.exports = ExponentiallyWeightedMovingAverage;
  ExponentiallyWeightedMovingAverage.TICK_INTERVAL = 5 * units.SECONDS;
  ExponentiallyWeightedMovingAverage.prototype.update = function(n) {
    this._count += n;
  };
  ExponentiallyWeightedMovingAverage.prototype.tick = function() {
    var instantRate = this._count / this._tickInterval;
    this._count = 0;
    this._rate += this._alpha * (instantRate - this._rate);
  };
  ExponentiallyWeightedMovingAverage.prototype.rate = function(timeUnit) {
    return (this._rate || 0) * timeUnit;
  };
});

// ../../node_modules/tx2/src/utils/probes/Meter.js
var require_Meter = __commonJS((exports2, module2) => {
  var Meter = function(opts) {
    var self2 = this;
    this._tickInterval = units.SECONDS;
    this._samples = opts.seconds || 1;
    this._timeframe = opts.timeframe || 60;
    this._rate = new EWMA(units.SECONDS, this._tickInterval);
    this._interval = setInterval(function() {
      self2._rate.tick();
    }, this._tickInterval);
    this._interval.unref();
  };
  var units = require_units();
  var EWMA = require_EWMA();
  Meter.RATE_UNIT = units.SECONDS;
  Meter.prototype.mark = function(n) {
    n = n || 1;
    this._rate.update(n);
  };
  Meter.prototype.val = function() {
    return Math.round(this._rate.rate(Meter.RATE_UNIT) * 100) / 100;
  };
  module2.exports = Meter;
});

// ../../node_modules/tx2/src/metrics.js
var require_metrics = __commonJS((exports2, module2) => {
  var getValue = function(value) {
    if (typeof value == "function")
      return value();
    return value;
  };
  var Counter = require_Counter();
  var Histogram = require_Histogram();
  var Meter = require_Meter();
  var DEFAULT_AGGREGATION = "avg";
  var AVAILABLE_MEASUREMENTS = ["min", "max", "sum", "count", "variance", "mean", "stddev", "median", "p75", "p95", "p99", "p999"];
  module2.exports = {
    _metrics: {},
    prepareData: function() {
      var cooked_data = {};
      Object.keys(this._metrics).forEach((probe_name) => {
        if (typeof this._metrics[probe_name].value == "undefined")
          return false;
        cooked_data[probe_name] = {
          value: getValue(this._metrics[probe_name].value)
        };
        if (this._metrics[probe_name].unit)
          cooked_data[probe_name].unit = this._metrics[probe_name].unit;
        if (this._metrics[probe_name].agg_type && this._metrics[probe_name].agg_type != "none")
          cooked_data[probe_name].agg_type = this._metrics[probe_name].agg_type;
        if (this._metrics[probe_name].unit)
          cooked_data[probe_name].unit = this._metrics[probe_name].unit;
      });
      return cooked_data;
    },
    transpose: function(variable_name, reporter) {
      if (typeof variable_name === "object") {
        reporter = variable_name.data;
        variable_name = variable_name.name;
      }
      if (typeof reporter !== "function") {
        return console.error("[PMX] reporter is not a function");
      }
      this._metrics[variable_name] = {
        value: reporter
      };
    },
    metricExists: function(metric_name) {
      return !!this._metrics[metric_name];
    },
    metric: function(opts, unit, val) {
      let name2, value;
      if (typeof opts == "string" && typeof unit == "string") {
        name2 = opts;
        unit = unit;
        value = val;
      } else if (typeof opts == "string" && typeof unit == "function") {
        name2 = opts;
        value = unit;
      } else if (typeof opts == "string" && typeof unit == "number") {
        name2 = opts;
        value = unit;
      } else if (typeof opts === "object") {
        name2 = opts.name;
        value = opts.val || opts.value;
        unit = opts.unit || null;
      }
      if (!name2)
        return console.error("[PX2][Metric] Name not defined");
      this._metrics[name2] = {
        value,
        unit
      };
      return {
        val: () => {
          var value2 = this._metrics[name2].value;
          if (typeof value2 == "function")
            value2 = value2();
          return value2;
        },
        set: (dt) => {
          this._metrics[name2].value = dt;
        }
      };
    },
    histogram: function(opts) {
      if (!opts.name)
        return console.error("[Metric][Histogram] Name not defined");
      opts.measurement = opts.measurement || "mean";
      opts.unit = opts.unit || "";
      if (AVAILABLE_MEASUREMENTS.indexOf(opts.measurement) == -1)
        return console.error("[Metric][Histogram] Measure type %s does not exists", opts.measurement);
      var histogram = new Histogram(opts);
      this._metrics[opts.name] = {
        value: () => {
          if (opts.val || opts.value) {
            var value = opts.val || opts.value;
            if (typeof value == "function")
              value = value();
            histogram.update(value);
          }
          return Math.round(histogram.val() * 100) / 100;
        },
        unit: opts.unit
      };
      return histogram;
    },
    meter: function(opts) {
      if (!opts.name)
        return console.error("[Metric][Meter] Name not defined");
      opts.unit = opts.unit || "";
      var meter = new Meter(opts);
      this._metrics[opts.name] = {
        value: function() {
          return meter.val() + "" + opts.unit;
        },
        unit: opts.unit
      };
      return meter;
    },
    counter: function(opts) {
      let name2, unit, agg_type = DEFAULT_AGGREGATION;
      if (typeof opts == "string")
        name2 = opts;
      else {
        name2 = opts.name;
        unit = opts.unit;
      }
      if (!name2)
        return console.error("[Metric][Counter] Name not defined");
      var counter = new Counter;
      this._metrics[name2] = {
        value: function() {
          return counter.val();
        },
        agg_type,
        unit: unit || null
      };
      return counter;
    }
  };
});

// ../../node_modules/tx2/src/issues.js
var require_issues = __commonJS((exports2, module2) => {
  var jsonize = function(err, filter, space) {
    if (typeof err != "object")
      return err;
    var plainObject = {};
    Object.getOwnPropertyNames(err).forEach(function(key) {
      plainObject[key] = err[key];
    });
    return plainObject;
  };
  module2.exports = {
    _interpretError: function(err) {
      var s_err = {};
      if (typeof err === "string") {
        s_err.message = err;
        s_err.stack = err;
      } else if (!(err instanceof Error) && typeof err === "object") {
        s_err.message = err;
        s_err.stack = err;
      } else if (err instanceof Error) {
        err.stack;
        if (err.__error_callsites) {
          var stackFrames = [];
          err.__error_callsites.forEach(function(callSite) {
            stackFrames.push({ file_name: callSite.getFileName(), line_number: callSite.getLineNumber() });
          });
          err.stackframes = stackFrames;
          delete err.__error_callsites;
        }
        s_err = err;
      }
      return jsonize(s_err);
    },
    issue: function(err) {
      var ret_err = this._interpretError(err);
      this.send({
        type: "process:exception",
        data: ret_err
      });
      return ret_err;
    }
  };
});

// ../../node_modules/tx2/src/index.js
var require_src3 = __commonJS((exports2, module2) => {
  var Events = require_events();
  var Actions = require_actions();
  var Metrics = require_metrics();
  var Issues = require_issues();
  var EventEmitter = __require("events");
  var stringify2 = require_stringify3();

  class TX2 extends EventEmitter {
    constructor() {
      super();
      Object.assign(this, Events);
      Object.assign(this, Actions);
      Object.assign(this, Metrics);
      Object.assign(this, Issues);
      var p_interval = setInterval(() => {
        this.send({
          type: "axm:monitor",
          data: Metrics.prepareData()
        });
      }, 990);
      p_interval.unref();
    }
    send(args2) {
      this.emit("data", args2);
      if (!process.send) {
        var output = args2.data;
        delete output.__name;
        return false;
      }
      try {
        process.send(JSON.parse(stringify2(args2)));
      } catch (e) {
        console.error("Process disconnected from parent !");
        console.error(e.stack || e);
        process.exit(1);
      }
    }
  }
  module2.exports = TX2;
});

// ../../node_modules/tx2/index.js
var require_tx2 = __commonJS((exports2, module2) => {
  var PX2 = require_src3();
  module2.exports = new PX2;
});

// ../../node_modules/systeminformation/package.json
var require_package3 = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "systeminformation",
    version: "5.22.11",
    description: "Advanced, lightweight system and OS information library",
    license: "MIT",
    author: "Sebastian Hildebrandt <hildebrandt@plus-innovations.com> (https://plus-innovations.com)",
    homepage: "https://systeminformation.io",
    main: "./lib/index.js",
    bin: {
      systeminformation: "lib/cli.js"
    },
    types: "./lib/index.d.ts",
    scripts: {
      test: "node ./test/test.js"
    },
    files: [
      "lib/"
    ],
    keywords: [
      "system information",
      "sysinfo",
      "monitor",
      "monitoring",
      "os",
      "linux",
      "osx",
      "windows",
      "freebsd",
      "openbsd",
      "netbsd",
      "cpu",
      "cpuload",
      "physical cores",
      "logical cores",
      "processor",
      "cores",
      "threads",
      "socket type",
      "memory",
      "file system",
      "fsstats",
      "diskio",
      "block devices",
      "netstats",
      "network",
      "network interfaces",
      "network connections",
      "network stats",
      "iface",
      "printer",
      "processes",
      "users",
      "internet",
      "battery",
      "docker",
      "docker stats",
      "docker processes",
      "graphics",
      "graphic card",
      "graphic controller",
      "gpu",
      "display",
      "smart",
      "disk layout",
      "usb",
      "audio",
      "bluetooth",
      "wifi",
      "wifinetworks",
      "virtual box",
      "virtualbox",
      "vm",
      "backend",
      "hardware",
      "BIOS",
      "chassis"
    ],
    repository: {
      type: "git",
      url: "https://github.com/sebhildebrandt/systeminformation.git"
    },
    funding: {
      type: "Buy me a coffee",
      url: "https://www.buymeacoffee.com/systeminfo"
    },
    os: [
      "darwin",
      "linux",
      "win32",
      "freebsd",
      "openbsd",
      "netbsd",
      "sunos",
      "android"
    ],
    engines: {
      node: ">=8.0.0"
    }
  };
});

// ../../node_modules/systeminformation/lib/util.js
var require_util4 = __commonJS((exports2) => {
  var toInt = function(value) {
    let result = parseInt(value, 10);
    if (isNaN(result)) {
      result = 0;
    }
    return result;
  };
  var splitByNumber = function(str) {
    let numberStarted = false;
    let num = "";
    let cpart = "";
    for (const c of str) {
      if (c >= "0" && c <= "9" || numberStarted) {
        numberStarted = true;
        num += c;
      } else {
        cpart += c;
      }
    }
    return [cpart, num];
  };
  var isFunction = function(functionToCheck) {
    let getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
  };
  var unique = function(obj) {
    let uniques = [];
    let stringify2 = {};
    for (let i = 0;i < obj.length; i++) {
      let keys3 = Object.keys(obj[i]);
      keys3.sort(function(a, b) {
        return a - b;
      });
      let str = "";
      for (let j = 0;j < keys3.length; j++) {
        str += JSON.stringify(keys3[j]);
        str += JSON.stringify(obj[i][keys3[j]]);
      }
      if (!{}.hasOwnProperty.call(stringify2, str)) {
        uniques.push(obj[i]);
        stringify2[str] = true;
      }
    }
    return uniques;
  };
  var sortByKey = function(array, keys3) {
    return array.sort(function(a, b) {
      let x = "";
      let y = "";
      keys3.forEach(function(key) {
        x = x + a[key];
        y = y + b[key];
      });
      return x < y ? -1 : x > y ? 1 : 0;
    });
  };
  var cores = function() {
    if (_cores === 0) {
      _cores = os.cpus().length;
    }
    return _cores;
  };
  var getValue = function(lines, property, separator, trimmed, lineMatch) {
    separator = separator || ":";
    property = property.toLowerCase();
    trimmed = trimmed || false;
    lineMatch = lineMatch || false;
    let result = "";
    lines.some((line) => {
      let lineLower = line.toLowerCase().replace(/\t/g, "");
      if (trimmed) {
        lineLower = lineLower.trim();
      }
      if (lineLower.startsWith(property) && (lineMatch ? lineLower.match(property + separator) || lineLower.match(property + " " + separator) : true)) {
        const parts = trimmed ? line.trim().split(separator) : line.split(separator);
        if (parts.length >= 2) {
          parts.shift();
          result = parts.join(separator).trim();
          return true;
        }
      }
    });
    return result;
  };
  var decodeEscapeSequence = function(str, base) {
    base = base || 16;
    return str.replace(/\\x([0-9A-Fa-f]{2})/g, function() {
      return String.fromCharCode(parseInt(arguments[1], base));
    });
  };
  var detectSplit = function(str) {
    let seperator = "";
    let part = 0;
    str.split("").forEach((element) => {
      if (element >= "0" && element <= "9") {
        if (part === 1) {
          part++;
        }
      } else {
        if (part === 0) {
          part++;
        }
        if (part === 1) {
          seperator += element;
        }
      }
    });
    return seperator;
  };
  var parseTime = function(t, pmDesignator) {
    pmDesignator = pmDesignator || "";
    t = t.toUpperCase();
    let hour = 0;
    let min4 = 0;
    let splitter = detectSplit(t);
    let parts = t.split(splitter);
    if (parts.length >= 2) {
      if (parts[2]) {
        parts[1] += parts[2];
      }
      let isPM = parts[1] && parts[1].toLowerCase().indexOf("pm") > -1 || parts[1].toLowerCase().indexOf("p.m.") > -1 || parts[1].toLowerCase().indexOf("p. m.") > -1 || parts[1].toLowerCase().indexOf("n") > -1 || parts[1].toLowerCase().indexOf("ch") > -1 || parts[1].toLowerCase().indexOf("\xF6s") > -1 || pmDesignator && parts[1].toLowerCase().indexOf(pmDesignator) > -1;
      hour = parseInt(parts[0], 10);
      min4 = parseInt(parts[1], 10);
      hour = isPM && hour < 12 ? hour + 12 : hour;
      return ("0" + hour).substr(-2) + ":" + ("0" + min4).substr(-2);
    }
  };
  var parseDateTime = function(dt, culture) {
    const result = {
      date: "",
      time: ""
    };
    culture = culture || {};
    let dateFormat = (culture.dateFormat || "").toLowerCase();
    let pmDesignator = culture.pmDesignator || "";
    const parts = dt.split(" ");
    if (parts[0]) {
      if (parts[0].indexOf("/") >= 0) {
        const dtparts = parts[0].split("/");
        if (dtparts.length === 3) {
          if (dtparts[0].length === 4) {
            result.date = dtparts[0] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[2]).substr(-2);
          } else if (dtparts[2].length === 2) {
            if (dateFormat.indexOf("/d/") > -1 || dateFormat.indexOf("/dd/") > -1) {
              result.date = "20" + dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
            } else {
              result.date = "20" + dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
            }
          } else {
            const isEN = dt.toLowerCase().indexOf("pm") > -1 || dt.toLowerCase().indexOf("p.m.") > -1 || dt.toLowerCase().indexOf("p. m.") > -1 || dt.toLowerCase().indexOf("am") > -1 || dt.toLowerCase().indexOf("a.m.") > -1 || dt.toLowerCase().indexOf("a. m.") > -1;
            if ((isEN || dateFormat.indexOf("/d/") > -1 || dateFormat.indexOf("/dd/") > -1) && dateFormat.indexOf("dd/") !== 0) {
              result.date = dtparts[2] + "-" + ("0" + dtparts[0]).substr(-2) + "-" + ("0" + dtparts[1]).substr(-2);
            } else {
              result.date = dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
            }
          }
        }
      }
      if (parts[0].indexOf(".") >= 0) {
        const dtparts = parts[0].split(".");
        if (dtparts.length === 3) {
          if (dateFormat.indexOf(".d.") > -1 || dateFormat.indexOf(".dd.") > -1) {
            result.date = dtparts[2] + "-" + ("0" + dtparts[0]).substr(-2) + "-" + ("0" + dtparts[1]).substr(-2);
          } else {
            result.date = dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
          }
        }
      }
      if (parts[0].indexOf("-") >= 0) {
        const dtparts = parts[0].split("-");
        if (dtparts.length === 3) {
          result.date = dtparts[0] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[2]).substr(-2);
        }
      }
    }
    if (parts[1]) {
      parts.shift();
      let time = parts.join(" ");
      result.time = parseTime(time, pmDesignator);
    }
    return result;
  };
  var parseHead = function(head, rights) {
    let space = rights > 0;
    let count = 1;
    let from3 = 0;
    let to = 0;
    let result = [];
    for (let i = 0;i < head.length; i++) {
      if (count <= rights) {
        if (/\s/.test(head[i]) && !space) {
          to = i - 1;
          result.push({
            from: from3,
            to: to + 1,
            cap: head.substring(from3, to + 1)
          });
          from3 = to + 2;
          count++;
        }
        space = head[i] === " ";
      } else {
        if (!/\s/.test(head[i]) && space) {
          to = i - 1;
          if (from3 < to) {
            result.push({
              from: from3,
              to,
              cap: head.substring(from3, to)
            });
          }
          from3 = to + 1;
          count++;
        }
        space = head[i] === " ";
      }
    }
    to = 5000;
    result.push({
      from: from3,
      to,
      cap: head.substring(from3, to)
    });
    let len = result.length;
    for (let i = 0;i < len; i++) {
      if (result[i].cap.replace(/\s/g, "").length === 0) {
        if (i + 1 < len) {
          result[i].to = result[i + 1].to;
          result[i].cap = result[i].cap + result[i + 1].cap;
          result.splice(i + 1, 1);
          len = len - 1;
        }
      }
    }
    return result;
  };
  var findObjectByKey = function(array, key, value) {
    for (let i = 0;i < array.length; i++) {
      if (array[i][key] === value) {
        return i;
      }
    }
    return -1;
  };
  var getWmic = function() {
    if (os.type() === "Windows_NT" && !wmicPath) {
      wmicPath = WINDIR + "\\system32\\wbem\\wmic.exe";
      if (!fs.existsSync(wmicPath)) {
        try {
          const wmicPathArray = execSync("WHERE WMIC", execOptsWin).toString().split("\r\n");
          if (wmicPathArray && wmicPathArray.length) {
            wmicPath = wmicPathArray[0];
          } else {
            wmicPath = "wmic";
          }
        } catch (e) {
          wmicPath = "wmic";
        }
      }
    }
    return wmicPath;
  };
  var wmic = function(command) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        try {
          powerShell(getWmic() + " " + command).then((stdout) => {
            resolve(stdout, "");
          });
        } catch (e) {
          resolve("", e);
        }
      });
    });
  };
  var getVboxmanage = function() {
    return _windows ? `"${process.env.VBOX_INSTALL_PATH || process.env.VBOX_MSI_INSTALL_PATH}\\VBoxManage.exe"` : "vboxmanage";
  };
  var powerShellProceedResults = function(data) {
    let id2 = "";
    let parts;
    let res = "";
    if (data.indexOf(_psCmdStart) >= 0) {
      parts = data.split(_psCmdStart);
      const parts2 = parts[1].split(_psIdSeperator);
      id2 = parts2[0];
      if (parts2.length > 1) {
        data = parts2.slice(1).join(_psIdSeperator);
      }
    }
    if (data.indexOf(_psCmdSeperator) >= 0) {
      parts = data.split(_psCmdSeperator);
      res = parts[0];
    }
    let remove = -1;
    for (let i = 0;i < _psCmds.length; i++) {
      if (_psCmds[i].id === id2) {
        remove = i;
        _psCmds[i].callback(res);
      }
    }
    if (remove >= 0) {
      _psCmds.splice(remove, 1);
    }
  };
  var powerShellStart = function() {
    if (!_psChild) {
      _psChild = spawn("powershell.exe", ["-NoProfile", "-NoLogo", "-InputFormat", "Text", "-NoExit", "-Command", "-"], {
        stdio: "pipe",
        windowsHide: true,
        maxBuffer: 1024 * 20000,
        encoding: "UTF-8",
        env: Object.assign({}, process.env, { LANG: "en_US.UTF-8" })
      });
      if (_psChild && _psChild.pid) {
        _psPersistent = true;
        _psChild.stdout.on("data", function(data) {
          _psResult = _psResult + data.toString("utf8");
          if (data.indexOf(_psCmdSeperator) >= 0) {
            powerShellProceedResults(_psResult);
            _psResult = "";
          }
        });
        _psChild.stderr.on("data", function() {
          powerShellProceedResults(_psResult + _psError);
        });
        _psChild.on("error", function() {
          powerShellProceedResults(_psResult + _psError);
        });
        _psChild.on("close", function() {
          if (_psChild) {
            _psChild.kill();
          }
        });
      }
    }
  };
  var powerShellRelease = function() {
    try {
      if (_psChild) {
        _psChild.stdin.write("exit" + os.EOL);
        _psChild.stdin.end();
        _psPersistent = false;
      }
    } catch (e) {
      if (_psChild) {
        _psChild.kill();
      }
    }
    _psChild = null;
  };
  var powerShell = function(cmd) {
    if (_psPersistent) {
      const id2 = Math.random().toString(36).substring(2, 12);
      return new Promise((resolve) => {
        process.nextTick(() => {
          function callback(data) {
            resolve(data);
          }
          _psCmds.push({
            id: id2,
            cmd,
            callback,
            start: new Date
          });
          try {
            if (_psChild && _psChild.pid) {
              _psChild.stdin.write(_psToUTF8 + "echo " + _psCmdStart + id2 + _psIdSeperator + "; " + os.EOL + cmd + os.EOL + "echo " + _psCmdSeperator + os.EOL);
            }
          } catch (e) {
            resolve("");
          }
        });
      });
    } else {
      let result = "";
      return new Promise((resolve) => {
        process.nextTick(() => {
          try {
            const child = spawn("powershell.exe", ["-NoProfile", "-NoLogo", "-InputFormat", "Text", "-NoExit", "-ExecutionPolicy", "Unrestricted", "-Command", "-"], {
              stdio: "pipe",
              windowsHide: true,
              maxBuffer: 1024 * 20000,
              encoding: "UTF-8",
              env: Object.assign({}, process.env, { LANG: "en_US.UTF-8" })
            });
            if (child && !child.pid) {
              child.on("error", function() {
                resolve(result);
              });
            }
            if (child && child.pid) {
              child.stdout.on("data", function(data) {
                result = result + data.toString("utf8");
              });
              child.stderr.on("data", function() {
                child.kill();
                resolve(result);
              });
              child.on("close", function() {
                child.kill();
                resolve(result);
              });
              child.on("error", function() {
                child.kill();
                resolve(result);
              });
              try {
                child.stdin.write(_psToUTF8 + cmd + os.EOL);
                child.stdin.write("exit" + os.EOL);
                child.stdin.end();
              } catch (e) {
                child.kill();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          } catch (e) {
            resolve(result);
          }
        });
      });
    }
  };
  var execSafe = function(cmd, args2, options2) {
    let result = "";
    options2 = options2 || {};
    return new Promise((resolve) => {
      process.nextTick(() => {
        try {
          const child = spawn(cmd, args2, options2);
          if (child && !child.pid) {
            child.on("error", function() {
              resolve(result);
            });
          }
          if (child && child.pid) {
            child.stdout.on("data", function(data) {
              result += data.toString();
            });
            child.on("close", function() {
              child.kill();
              resolve(result);
            });
            child.on("error", function() {
              child.kill();
              resolve(result);
            });
          } else {
            resolve(result);
          }
        } catch (e) {
          resolve(result);
        }
      });
    });
  };
  var getCodepage = function() {
    if (_windows) {
      if (!codepage) {
        try {
          const stdout = execSync("chcp", execOptsWin);
          const lines = stdout.toString().split("\r\n");
          const parts = lines[0].split(":");
          codepage = parts.length > 1 ? parts[1].replace(".", "").trim() : "";
        } catch (err) {
          codepage = "437";
        }
      }
      return codepage;
    }
    if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {
      if (!codepage) {
        try {
          const stdout = execSync("echo $LANG");
          const lines = stdout.toString().split("\r\n");
          const parts = lines[0].split(".");
          codepage = parts.length > 1 ? parts[1].trim() : "";
          if (!codepage) {
            codepage = "UTF-8";
          }
        } catch (err) {
          codepage = "UTF-8";
        }
      }
      return codepage;
    }
  };
  var smartMonToolsInstalled = function() {
    if (_smartMonToolsInstalled !== null) {
      return _smartMonToolsInstalled;
    }
    _smartMonToolsInstalled = false;
    if (_windows) {
      try {
        const pathArray = execSync("WHERE smartctl 2>nul", execOptsWin).toString().split("\r\n");
        if (pathArray && pathArray.length) {
          _smartMonToolsInstalled = pathArray[0].indexOf(":\\") >= 0;
        } else {
          _smartMonToolsInstalled = false;
        }
      } catch (e) {
        _smartMonToolsInstalled = false;
      }
    }
    if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {
      try {
        const pathArray = execSync("which smartctl 2>/dev/null", execOptsWin).toString().split("\r\n");
        _smartMonToolsInstalled = pathArray.length > 0;
      } catch (e) {
        util.noop();
      }
    }
    return _smartMonToolsInstalled;
  };
  var isRaspberry = function() {
    const PI_MODEL_NO = [
      "BCM2708",
      "BCM2709",
      "BCM2710",
      "BCM2711",
      "BCM2712",
      "BCM2835",
      "BCM2836",
      "BCM2837",
      "BCM2837B0"
    ];
    let cpuinfo = [];
    if (_rpi_cpuinfo !== null) {
      cpuinfo = _rpi_cpuinfo;
    } else {
      try {
        cpuinfo = fs.readFileSync("/proc/cpuinfo", { encoding: "utf8" }).toString().split("\n");
        _rpi_cpuinfo = cpuinfo;
      } catch (e) {
        return false;
      }
    }
    const hardware = getValue(cpuinfo, "hardware");
    return hardware && PI_MODEL_NO.indexOf(hardware) > -1;
  };
  var isRaspbian = function() {
    let osrelease = [];
    try {
      osrelease = fs.readFileSync("/etc/os-release", { encoding: "utf8" }).toString().split("\n");
    } catch (e) {
      return false;
    }
    const id2 = getValue(osrelease, "id", "=");
    return id2 && id2.indexOf("raspbian") > -1;
  };
  var execWin = function(cmd, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = execOptsWin;
    }
    let newCmd = "chcp 65001 > nul && cmd /C " + cmd + " && chcp " + codepage + " > nul";
    exec(newCmd, opts, function(error, stdout) {
      callback(error, stdout);
    });
  };
  var darwinXcodeExists = function() {
    const cmdLineToolsExists = fs.existsSync("/Library/Developer/CommandLineTools/usr/bin/");
    const xcodeAppExists = fs.existsSync("/Applications/Xcode.app/Contents/Developer/Tools");
    const xcodeExists = fs.existsSync("/Library/Developer/Xcode/");
    return cmdLineToolsExists || xcodeExists || xcodeAppExists;
  };
  var nanoSeconds = function() {
    const time = process.hrtime();
    if (!Array.isArray(time) || time.length !== 2) {
      return 0;
    }
    return +time[0] * 1e9 + +time[1];
  };
  var countUniqueLines = function(lines, startingWith) {
    startingWith = startingWith || "";
    const uniqueLines = [];
    lines.forEach((line) => {
      if (line.startsWith(startingWith)) {
        if (uniqueLines.indexOf(line) === -1) {
          uniqueLines.push(line);
        }
      }
    });
    return uniqueLines.length;
  };
  var countLines = function(lines, startingWith) {
    startingWith = startingWith || "";
    const uniqueLines = [];
    lines.forEach((line) => {
      if (line.startsWith(startingWith)) {
        uniqueLines.push(line);
      }
    });
    return uniqueLines.length;
  };
  var sanitizeShellString = function(str, strict) {
    if (typeof strict === "undefined") {
      strict = false;
    }
    const s = str || "";
    let result = "";
    const l = mathMin(s.length, 2000);
    for (let i = 0;i <= l; i++) {
      if (!(s[i] === undefined || s[i] === ">" || s[i] === "<" || s[i] === "*" || s[i] === "?" || s[i] === "[" || s[i] === "]" || s[i] === "|" || s[i] === "\u02DA" || s[i] === "$" || s[i] === ";" || s[i] === "&" || s[i] === "]" || s[i] === "#" || s[i] === "\\" || s[i] === "\t" || s[i] === "\n" || s[i] === "\r" || s[i] === "\'" || s[i] === "`" || s[i] === '"' || s[i].length > 1 || strict && s[i] === "(" || strict && s[i] === ")" || strict && s[i] === "@" || strict && s[i] === " " || strict && s[i] == "{" || strict && s[i] == ";" || strict && s[i] == "}")) {
        result = result + s[i];
      }
    }
    return result;
  };
  var isPrototypePolluted = function() {
    const s = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let notPolluted = true;
    let st = "";
    st.__proto__.replace = stringReplace;
    st.__proto__.toLowerCase = stringToLower;
    st.__proto__.toString = stringToString;
    st.__proto__.substr = stringSubstr;
    notPolluted = notPolluted || s.length !== 62;
    const ms = Date.now();
    if (typeof ms === "number" && ms > 1600000000000) {
      const l = ms % 100 + 15;
      for (let i = 0;i < l; i++) {
        const r = Math.random() * 61.99999999 + 1;
        const rs = parseInt(Math.floor(r).toString(), 10);
        const rs2 = parseInt(r.toString().split(".")[0], 10);
        const q = Math.random() * 61.99999999 + 1;
        const qs = parseInt(Math.floor(q).toString(), 10);
        const qs2 = parseInt(q.toString().split(".")[0], 10);
        notPolluted = notPolluted && r !== q;
        notPolluted = notPolluted && rs === rs2 && qs === qs2;
        st += s[rs - 1];
      }
      notPolluted = notPolluted && st.length === l;
      let p = Math.random() * l * 0.9999999999;
      let stm = st.substr(0, p) + " " + st.substr(p, 2000);
      stm.__proto__.replace = stringReplace;
      let sto = stm.replace(/ /g, "");
      notPolluted = notPolluted && st === sto;
      p = Math.random() * l * 0.9999999999;
      stm = st.substr(0, p) + "{" + st.substr(p, 2000);
      sto = stm.replace(/{/g, "");
      notPolluted = notPolluted && st === sto;
      p = Math.random() * l * 0.9999999999;
      stm = st.substr(0, p) + "*" + st.substr(p, 2000);
      sto = stm.replace(/\*/g, "");
      notPolluted = notPolluted && st === sto;
      p = Math.random() * l * 0.9999999999;
      stm = st.substr(0, p) + "$" + st.substr(p, 2000);
      sto = stm.replace(/\$/g, "");
      notPolluted = notPolluted && st === sto;
      const stl = st.toLowerCase();
      notPolluted = notPolluted && stl.length === l && stl[l - 1] && !stl[l];
      for (let i = 0;i < l; i++) {
        const s1 = st[i];
        s1.__proto__.toLowerCase = stringToLower;
        const s2 = stl ? stl[i] : "";
        const s1l = s1.toLowerCase();
        notPolluted = notPolluted && s1l[0] === s2 && s1l[0] && !s1l[1];
      }
    }
    return !notPolluted;
  };
  var hex2bin = function(hex) {
    return ("00000000" + parseInt(hex, 16).toString(2)).substr(-8);
  };
  var getFilesInPath = function(source) {
    const lstatSync = fs.lstatSync;
    const readdirSync = fs.readdirSync;
    const join = path2.join;
    function isDirectory(source2) {
      return lstatSync(source2).isDirectory();
    }
    function isFile(source2) {
      return lstatSync(source2).isFile();
    }
    function getDirectories(source2) {
      return readdirSync(source2).map(function(name2) {
        return join(source2, name2);
      }).filter(isDirectory);
    }
    function getFiles(source2) {
      return readdirSync(source2).map(function(name2) {
        return join(source2, name2);
      }).filter(isFile);
    }
    function getFilesRecursively(source2) {
      try {
        let dirs = getDirectories(source2);
        let files2 = dirs.map(function(dir) {
          return getFilesRecursively(dir);
        }).reduce(function(a, b) {
          return a.concat(b);
        }, []);
        return files2.concat(getFiles(source2));
      } catch (e) {
        return [];
      }
    }
    if (fs.existsSync(source)) {
      return getFilesRecursively(source);
    } else {
      return [];
    }
  };
  var decodePiCpuinfo = function(lines) {
    if (_rpi_cpuinfo === null) {
      _rpi_cpuinfo = lines;
    }
    const oldRevisionCodes = {
      "0002": {
        type: "B",
        revision: "1.0",
        memory: 256,
        manufacturer: "Egoman",
        processor: "BCM2835"
      },
      "0003": {
        type: "B",
        revision: "1.0",
        memory: 256,
        manufacturer: "Egoman",
        processor: "BCM2835"
      },
      "0004": {
        type: "B",
        revision: "2.0",
        memory: 256,
        manufacturer: "Sony UK",
        processor: "BCM2835"
      },
      "0005": {
        type: "B",
        revision: "2.0",
        memory: 256,
        manufacturer: "Qisda",
        processor: "BCM2835"
      },
      "0006": {
        type: "B",
        revision: "2.0",
        memory: 256,
        manufacturer: "Egoman",
        processor: "BCM2835"
      },
      "0007": {
        type: "A",
        revision: "2.0",
        memory: 256,
        manufacturer: "Egoman",
        processor: "BCM2835"
      },
      "0008": {
        type: "A",
        revision: "2.0",
        memory: 256,
        manufacturer: "Sony UK",
        processor: "BCM2835"
      },
      "0009": {
        type: "A",
        revision: "2.0",
        memory: 256,
        manufacturer: "Qisda",
        processor: "BCM2835"
      },
      "000d": {
        type: "B",
        revision: "2.0",
        memory: 512,
        manufacturer: "Egoman",
        processor: "BCM2835"
      },
      "000e": {
        type: "B",
        revision: "2.0",
        memory: 512,
        manufacturer: "Sony UK",
        processor: "BCM2835"
      },
      "000f": {
        type: "B",
        revision: "2.0",
        memory: 512,
        manufacturer: "Egoman",
        processor: "BCM2835"
      },
      "0010": {
        type: "B+",
        revision: "1.2",
        memory: 512,
        manufacturer: "Sony UK",
        processor: "BCM2835"
      },
      "0011": {
        type: "CM1",
        revision: "1.0",
        memory: 512,
        manufacturer: "Sony UK",
        processor: "BCM2835"
      },
      "0012": {
        type: "A+",
        revision: "1.1",
        memory: 256,
        manufacturer: "Sony UK",
        processor: "BCM2835"
      },
      "0013": {
        type: "B+",
        revision: "1.2",
        memory: 512,
        manufacturer: "Embest",
        processor: "BCM2835"
      },
      "0014": {
        type: "CM1",
        revision: "1.0",
        memory: 512,
        manufacturer: "Embest",
        processor: "BCM2835"
      },
      "0015": {
        type: "A+",
        revision: "1.1",
        memory: 256,
        manufacturer: "512MB	Embest",
        processor: "BCM2835"
      }
    };
    const processorList = [
      "BCM2835",
      "BCM2836",
      "BCM2837",
      "BCM2711",
      "BCM2712"
    ];
    const manufacturerList = [
      "Sony UK",
      "Egoman",
      "Embest",
      "Sony Japan",
      "Embest",
      "Stadium"
    ];
    const typeList = {
      "00": "A",
      "01": "B",
      "02": "A+",
      "03": "B+",
      "04": "2B",
      "05": "Alpha (early prototype)",
      "06": "CM1",
      "08": "3B",
      "09": "Zero",
      "0a": "CM3",
      "0c": "Zero W",
      "0d": "3B+",
      "0e": "3A+",
      "0f": "Internal use only",
      "10": "CM3+",
      "11": "4B",
      "12": "Zero 2 W",
      "13": "400",
      "14": "CM4",
      "15": "CM4S",
      "17": "5"
    };
    const revisionCode = getValue(lines, "revision", ":", true);
    const model = getValue(lines, "model:", ":", true);
    const serial = getValue(lines, "serial", ":", true);
    let result = {};
    if ({}.hasOwnProperty.call(oldRevisionCodes, revisionCode)) {
      result = {
        model,
        serial,
        revisionCode,
        memory: oldRevisionCodes[revisionCode].memory,
        manufacturer: oldRevisionCodes[revisionCode].manufacturer,
        processor: oldRevisionCodes[revisionCode].processor,
        type: oldRevisionCodes[revisionCode].type,
        revision: oldRevisionCodes[revisionCode].revision
      };
    } else {
      const revision = ("00000000" + getValue(lines, "revision", ":", true).toLowerCase()).substr(-8);
      const memSizeCode = parseInt(hex2bin(revision.substr(2, 1)).substr(5, 3), 2) || 0;
      const manufacturer = manufacturerList[parseInt(revision.substr(3, 1), 10)];
      const processor = processorList[parseInt(revision.substr(4, 1), 10)];
      const typeCode = revision.substr(5, 2);
      result = {
        model,
        serial,
        revisionCode,
        memory: 256 * Math.pow(2, memSizeCode),
        manufacturer,
        processor,
        type: {}.hasOwnProperty.call(typeList, typeCode) ? typeList[typeCode] : "",
        revision: "1." + revision.substr(7, 1)
      };
    }
    return result;
  };
  var getRpiGpu = function() {
    let cpuinfo = null;
    if (_rpi_cpuinfo !== null) {
      cpuinfo = _rpi_cpuinfo;
    } else {
      try {
        cpuinfo = fs.readFileSync("/proc/cpuinfo", { encoding: "utf8" }).toString().split("\n");
        _rpi_cpuinfo = cpuinfo;
      } catch (e) {
        return false;
      }
    }
    const rpi = decodePiCpuinfo(cpuinfo);
    if (rpi.type === "4B" || rpi.type === "CM4" || rpi.type === "CM4S" || rpi.type === "400") {
      return "VideoCore VI";
    }
    if (rpi.type === "5") {
      return "VideoCore VII";
    }
    return "VideoCore IV";
  };
  var promiseAll = function(promises) {
    const resolvingPromises = promises.map(function(promise) {
      return new Promise(function(resolve) {
        let payload = new Array(2);
        promise.then(function(result) {
          payload[0] = result;
        }).catch(function(error) {
          payload[1] = error;
        }).then(function() {
          resolve(payload);
        });
      });
    });
    const errors = [];
    const results = [];
    return Promise.all(resolvingPromises).then(function(items) {
      items.forEach(function(payload) {
        if (payload[1]) {
          errors.push(payload[1]);
          results.push(null);
        } else {
          errors.push(null);
          results.push(payload[0]);
        }
      });
      return {
        errors,
        results
      };
    });
  };
  var promisify = function(nodeStyleFunction) {
    return function() {
      const args2 = Array.prototype.slice.call(arguments);
      return new Promise(function(resolve, reject) {
        args2.push(function(err, data) {
          if (err) {
            reject(err);
          } else {
            resolve(data);
          }
        });
        nodeStyleFunction.apply(null, args2);
      });
    };
  };
  var promisifySave = function(nodeStyleFunction) {
    return function() {
      const args2 = Array.prototype.slice.call(arguments);
      return new Promise(function(resolve) {
        args2.push(function(err, data) {
          resolve(data);
        });
        nodeStyleFunction.apply(null, args2);
      });
    };
  };
  var linuxVersion = function() {
    let result = "";
    if (_linux) {
      try {
        result = execSync("uname -v").toString();
      } catch (e) {
        result = "";
      }
    }
    return result;
  };
  var plistParser = function(xmlStr) {
    const tags = ["array", "dict", "key", "string", "integer", "date", "real", "data", "boolean", "arrayEmpty"];
    const startStr = "<plist version";
    let pos = xmlStr.indexOf(startStr);
    let len = xmlStr.length;
    while (xmlStr[pos] !== ">" && pos < len) {
      pos++;
    }
    let depth = 0;
    let inTagStart = false;
    let inTagContent = false;
    let inTagEnd = false;
    let metaData = [{ tagStart: "", tagEnd: "", tagContent: "", key: "", data: null }];
    let c = "";
    let cn = xmlStr[pos];
    while (pos < len) {
      c = cn;
      if (pos + 1 < len) {
        cn = xmlStr[pos + 1];
      }
      if (c === "<") {
        inTagContent = false;
        if (cn === "/") {
          inTagEnd = true;
        } else if (metaData[depth].tagStart) {
          metaData[depth].tagContent = "";
          if (!metaData[depth].data) {
            metaData[depth].data = metaData[depth].tagStart === "array" ? [] : {};
          }
          depth++;
          metaData.push({ tagStart: "", tagEnd: "", tagContent: "", key: null, data: null });
          inTagStart = true;
          inTagContent = false;
        } else if (!inTagStart) {
          inTagStart = true;
        }
      } else if (c === ">") {
        if (metaData[depth].tagStart === "true/") {
          inTagStart = false;
          inTagEnd = true;
          metaData[depth].tagStart = "";
          metaData[depth].tagEnd = "/boolean";
          metaData[depth].data = true;
        }
        if (metaData[depth].tagStart === "false/") {
          inTagStart = false;
          inTagEnd = true;
          metaData[depth].tagStart = "";
          metaData[depth].tagEnd = "/boolean";
          metaData[depth].data = false;
        }
        if (metaData[depth].tagStart === "array/") {
          inTagStart = false;
          inTagEnd = true;
          metaData[depth].tagStart = "";
          metaData[depth].tagEnd = "/arrayEmpty";
          metaData[depth].data = [];
        }
        if (inTagContent) {
          inTagContent = false;
        }
        if (inTagStart) {
          inTagStart = false;
          inTagContent = true;
          if (metaData[depth].tagStart === "array") {
            metaData[depth].data = [];
          }
          if (metaData[depth].tagStart === "dict") {
            metaData[depth].data = {};
          }
        }
        if (inTagEnd) {
          inTagEnd = false;
          if (metaData[depth].tagEnd && tags.indexOf(metaData[depth].tagEnd.substr(1)) >= 0) {
            if (metaData[depth].tagEnd === "/dict" || metaData[depth].tagEnd === "/array") {
              if (depth > 1 && metaData[depth - 2].tagStart === "array") {
                metaData[depth - 2].data.push(metaData[depth - 1].data);
              }
              if (depth > 1 && metaData[depth - 2].tagStart === "dict") {
                metaData[depth - 2].data[metaData[depth - 1].key] = metaData[depth - 1].data;
              }
              depth--;
              metaData.pop();
              metaData[depth].tagContent = "";
              metaData[depth].tagStart = "";
              metaData[depth].tagEnd = "";
            } else {
              if (metaData[depth].tagEnd === "/key" && metaData[depth].tagContent) {
                metaData[depth].key = metaData[depth].tagContent;
              } else {
                if (metaData[depth].tagEnd === "/real" && metaData[depth].tagContent) {
                  metaData[depth].data = parseFloat(metaData[depth].tagContent) || 0;
                }
                if (metaData[depth].tagEnd === "/integer" && metaData[depth].tagContent) {
                  metaData[depth].data = parseInt(metaData[depth].tagContent) || 0;
                }
                if (metaData[depth].tagEnd === "/string" && metaData[depth].tagContent) {
                  metaData[depth].data = metaData[depth].tagContent || "";
                }
                if (metaData[depth].tagEnd === "/boolean") {
                  metaData[depth].data = metaData[depth].tagContent || false;
                }
                if (metaData[depth].tagEnd === "/arrayEmpty") {
                  metaData[depth].data = metaData[depth].tagContent || [];
                }
                if (depth > 0 && metaData[depth - 1].tagStart === "array") {
                  metaData[depth - 1].data.push(metaData[depth].data);
                }
                if (depth > 0 && metaData[depth - 1].tagStart === "dict") {
                  metaData[depth - 1].data[metaData[depth].key] = metaData[depth].data;
                }
              }
              metaData[depth].tagContent = "";
              metaData[depth].tagStart = "";
              metaData[depth].tagEnd = "";
            }
          }
          metaData[depth].tagEnd = "";
          inTagStart = false;
          inTagContent = false;
        }
      } else {
        if (inTagStart) {
          metaData[depth].tagStart += c;
        }
        if (inTagEnd) {
          metaData[depth].tagEnd += c;
        }
        if (inTagContent) {
          metaData[depth].tagContent += c;
        }
      }
      pos++;
    }
    return metaData[0].data;
  };
  var strIsNumeric = function(str) {
    return typeof str === "string" && !isNaN(str) && !isNaN(parseFloat(str));
  };
  var plistReader = function(output) {
    const lines = output.split("\n");
    for (let i = 0;i < lines.length; i++) {
      if (lines[i].indexOf(" = ") >= 0) {
        const lineParts = lines[i].split(" = ");
        lineParts[0] = lineParts[0].trim();
        if (!lineParts[0].startsWith('"')) {
          lineParts[0] = '"' + lineParts[0] + '"';
        }
        lineParts[1] = lineParts[1].trim();
        if (lineParts[1].indexOf('"') === -1 && lineParts[1].endsWith(";")) {
          const valueString = lineParts[1].substring(0, lineParts[1].length - 1);
          if (!strIsNumeric(valueString)) {
            lineParts[1] = `"${valueString}";`;
          }
        }
        if (lineParts[1].indexOf('"') >= 0 && lineParts[1].endsWith(";")) {
          const valueString = lineParts[1].substring(0, lineParts[1].length - 1).replace(/"/g, "");
          if (strIsNumeric(valueString)) {
            lineParts[1] = `${valueString};`;
          }
        }
        lines[i] = lineParts.join(" : ");
      }
      lines[i] = lines[i].replace(/\(/g, "[").replace(/\)/g, "]").replace(/;/g, ",").trim();
      if (lines[i].startsWith("}") && lines[i - 1] && lines[i - 1].endsWith(",")) {
        lines[i - 1] = lines[i - 1].substring(0, lines[i - 1].length - 1);
      }
    }
    output = lines.join("");
    let obj = {};
    try {
      obj = JSON.parse(output);
    } catch (e) {
      noop();
    }
    return obj;
  };
  var semverCompare = function(v12, v2) {
    let res = 0;
    const parts1 = v12.split(".");
    const parts2 = v2.split(".");
    if (parts1[0] < parts2[0]) {
      res = 1;
    } else if (parts1[0] > parts2[0]) {
      res = -1;
    } else if (parts1[0] === parts2[0] && parts1.length >= 2 && parts2.length >= 2) {
      if (parts1[1] < parts2[1]) {
        res = 1;
      } else if (parts1[1] > parts2[1]) {
        res = -1;
      } else if (parts1[1] === parts2[1]) {
        if (parts1.length >= 3 && parts2.length >= 3) {
          if (parts1[2] < parts2[2]) {
            res = 1;
          } else if (parts1[2] > parts2[2]) {
            res = -1;
          }
        } else if (parts2.length >= 3) {
          res = 1;
        }
      }
    }
    return res;
  };
  var noop = function() {
  };
  var os = __require("os");
  var fs = __require("fs");
  var path2 = __require("path");
  var spawn = __require("child_process").spawn;
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var util = __require("util");
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _cores = 0;
  var wmicPath = "";
  var codepage = "";
  var _smartMonToolsInstalled = null;
  var _rpi_cpuinfo = null;
  var WINDIR = process.env.WINDIR || "C:\\Windows";
  var _psChild;
  var _psResult = "";
  var _psCmds = [];
  var _psPersistent = false;
  var _psToUTF8 = "$OutputEncoding = [System.Console]::OutputEncoding = [System.Console]::InputEncoding = [System.Text.Encoding]::UTF8 ; ";
  var _psCmdStart = "--###START###--";
  var _psError = "--ERROR--";
  var _psCmdSeperator = "--###ENDCMD###--";
  var _psIdSeperator = "--##ID##--";
  var execOptsWin = {
    windowsHide: true,
    maxBuffer: 1024 * 20000,
    encoding: "UTF-8",
    env: Object.assign({}, process.env, { LANG: "en_US.UTF-8" })
  };
  var stringReplace = new String().replace;
  var stringToLower = new String().toLowerCase;
  var stringToString = new String().toString;
  var stringSubstr = new String().substr;
  var stringTrim = new String().trim;
  var stringStartWith = new String().startsWith;
  var mathMin = Math.min;
  exports2.toInt = toInt;
  exports2.splitByNumber = splitByNumber;
  exports2.execOptsWin = execOptsWin;
  exports2.getCodepage = getCodepage;
  exports2.execWin = execWin;
  exports2.isFunction = isFunction;
  exports2.unique = unique;
  exports2.sortByKey = sortByKey;
  exports2.cores = cores;
  exports2.getValue = getValue;
  exports2.decodeEscapeSequence = decodeEscapeSequence;
  exports2.parseDateTime = parseDateTime;
  exports2.parseHead = parseHead;
  exports2.findObjectByKey = findObjectByKey;
  exports2.getWmic = getWmic;
  exports2.wmic = wmic;
  exports2.darwinXcodeExists = darwinXcodeExists;
  exports2.getVboxmanage = getVboxmanage;
  exports2.powerShell = powerShell;
  exports2.powerShellStart = powerShellStart;
  exports2.powerShellRelease = powerShellRelease;
  exports2.execSafe = execSafe;
  exports2.nanoSeconds = nanoSeconds;
  exports2.countUniqueLines = countUniqueLines;
  exports2.countLines = countLines;
  exports2.noop = noop;
  exports2.isRaspberry = isRaspberry;
  exports2.isRaspbian = isRaspbian;
  exports2.sanitizeShellString = sanitizeShellString;
  exports2.isPrototypePolluted = isPrototypePolluted;
  exports2.decodePiCpuinfo = decodePiCpuinfo;
  exports2.getRpiGpu = getRpiGpu;
  exports2.promiseAll = promiseAll;
  exports2.promisify = promisify;
  exports2.promisifySave = promisifySave;
  exports2.smartMonToolsInstalled = smartMonToolsInstalled;
  exports2.linuxVersion = linuxVersion;
  exports2.plistParser = plistParser;
  exports2.plistReader = plistReader;
  exports2.stringReplace = stringReplace;
  exports2.stringToLower = stringToLower;
  exports2.stringToString = stringToString;
  exports2.stringSubstr = stringSubstr;
  exports2.stringTrim = stringTrim;
  exports2.stringStartWith = stringStartWith;
  exports2.mathMin = mathMin;
  exports2.WINDIR = WINDIR;
  exports2.getFilesInPath = getFilesInPath;
  exports2.semverCompare = semverCompare;
});

// ../../node_modules/systeminformation/lib/system.js
var require_system = __commonJS((exports2) => {
  var system = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = {
          manufacturer: "",
          model: "Computer",
          version: "",
          serial: "-",
          uuid: "-",
          sku: "-",
          virtual: false
        };
        if (_linux || _freebsd || _openbsd || _netbsd) {
          exec("export LC_ALL=C; dmidecode -t system 2>/dev/null; unset LC_ALL", function(error, stdout) {
            let lines = stdout.toString().split("\n");
            result.manufacturer = util.getValue(lines, "manufacturer");
            result.model = util.getValue(lines, "product name");
            result.version = util.getValue(lines, "version");
            result.serial = util.getValue(lines, "serial number");
            result.uuid = util.getValue(lines, "uuid").toLowerCase();
            result.sku = util.getValue(lines, "sku number");
            const cmd = `echo -n "product_name: "; cat /sys/devices/virtual/dmi/id/product_name 2>/dev/null; echo;
            echo -n "product_serial: "; cat /sys/devices/virtual/dmi/id/product_serial 2>/dev/null; echo;
            echo -n "product_uuid: "; cat /sys/devices/virtual/dmi/id/product_uuid 2>/dev/null; echo;
            echo -n "product_version: "; cat /sys/devices/virtual/dmi/id/product_version 2>/dev/null; echo;
            echo -n "sys_vendor: "; cat /sys/devices/virtual/dmi/id/sys_vendor 2>/dev/null; echo;`;
            try {
              lines = execSync(cmd).toString().split("\n");
              result.manufacturer = result.manufacturer === "" ? util.getValue(lines, "sys_vendor") : result.manufacturer;
              result.model = result.model === "" ? util.getValue(lines, "product_name") : result.model;
              result.version = result.version === "" ? util.getValue(lines, "product_version") : result.version;
              result.serial = result.serial === "" ? util.getValue(lines, "product_serial") : result.serial;
              result.uuid = result.uuid === "" ? util.getValue(lines, "product_uuid").toLowerCase() : result.uuid;
            } catch (e) {
              util.noop();
            }
            if (!result.serial || result.serial.toLowerCase().indexOf("o.e.m.") !== -1) {
              result.serial = "-";
            }
            if (!result.manufacturer || result.manufacturer.toLowerCase().indexOf("o.e.m.") !== -1) {
              result.manufacturer = "";
            }
            if (!result.model || result.model.toLowerCase().indexOf("o.e.m.") !== -1) {
              result.model = "Computer";
            }
            if (!result.version || result.version.toLowerCase().indexOf("o.e.m.") !== -1) {
              result.version = "";
            }
            if (!result.sku || result.sku.toLowerCase().indexOf("o.e.m.") !== -1) {
              result.sku = "-";
            }
            if (result.model.toLowerCase() === "virtualbox" || result.model.toLowerCase() === "kvm" || result.model.toLowerCase() === "virtual machine" || result.model.toLowerCase() === "bochs" || result.model.toLowerCase().startsWith("vmware") || result.model.toLowerCase().startsWith("droplet")) {
              result.virtual = true;
              switch (result.model.toLowerCase()) {
                case "virtualbox":
                  result.virtualHost = "VirtualBox";
                  break;
                case "vmware":
                  result.virtualHost = "VMware";
                  break;
                case "kvm":
                  result.virtualHost = "KVM";
                  break;
                case "bochs":
                  result.virtualHost = "bochs";
                  break;
              }
            }
            if (result.manufacturer.toLowerCase().startsWith("vmware") || result.manufacturer.toLowerCase() === "xen") {
              result.virtual = true;
              switch (result.manufacturer.toLowerCase()) {
                case "vmware":
                  result.virtualHost = "VMware";
                  break;
                case "xen":
                  result.virtualHost = "Xen";
                  break;
              }
            }
            if (!result.virtual) {
              try {
                const disksById = execSync("ls -1 /dev/disk/by-id/ 2>/dev/null").toString();
                if (disksById.indexOf("_QEMU_") >= 0) {
                  result.virtual = true;
                  result.virtualHost = "QEMU";
                }
                if (disksById.indexOf("_VBOX_") >= 0) {
                  result.virtual = true;
                  result.virtualHost = "VirtualBox";
                }
              } catch (e) {
                util.noop();
              }
            }
            if (!result.virtual && (os.release().toLowerCase().indexOf("microsoft") >= 0 || os.release().toLowerCase().endsWith("wsl2"))) {
              const kernelVersion = parseFloat(os.release().toLowerCase());
              result.virtual = true;
              result.manufacturer = "Microsoft";
              result.model = "WSL";
              result.version = kernelVersion < 4.19 ? "1" : "2";
            }
            if ((_freebsd || _openbsd || _netbsd) && !result.virtualHost) {
              try {
                const procInfo = execSync("dmidecode -t 4");
                const procLines = procInfo.toString().split("\n");
                const procManufacturer = util.getValue(procLines, "manufacturer", ":", true);
                switch (procManufacturer.toLowerCase()) {
                  case "virtualbox":
                    result.virtualHost = "VirtualBox";
                    break;
                  case "vmware":
                    result.virtualHost = "VMware";
                    break;
                  case "kvm":
                    result.virtualHost = "KVM";
                    break;
                  case "bochs":
                    result.virtualHost = "bochs";
                    break;
                }
              } catch (e) {
                util.noop();
              }
            }
            if (fs.existsSync("/.dockerenv") || fs.existsSync("/.dockerinit")) {
              result.model = "Docker Container";
            }
            try {
              const stdout2 = execSync('dmesg 2>/dev/null | grep -iE "virtual|hypervisor" | grep -iE "vmware|qemu|kvm|xen" | grep -viE "Nested Virtualization|/virtual/"');
              let lines2 = stdout2.toString().split("\n");
              if (lines2.length > 0) {
                if (result.model === "Computer") {
                  result.model = "Virtual machine";
                }
                result.virtual = true;
                if (stdout2.toString().toLowerCase().indexOf("vmware") >= 0 && !result.virtualHost) {
                  result.virtualHost = "VMware";
                }
                if (stdout2.toString().toLowerCase().indexOf("qemu") >= 0 && !result.virtualHost) {
                  result.virtualHost = "QEMU";
                }
                if (stdout2.toString().toLowerCase().indexOf("xen") >= 0 && !result.virtualHost) {
                  result.virtualHost = "Xen";
                }
                if (stdout2.toString().toLowerCase().indexOf("kvm") >= 0 && !result.virtualHost) {
                  result.virtualHost = "KVM";
                }
              }
            } catch (e) {
              util.noop();
            }
            if (result.manufacturer === "" && result.model === "Computer" && result.version === "") {
              fs.readFile("/proc/cpuinfo", function(error2, stdout2) {
                if (!error2) {
                  let lines2 = stdout2.toString().split("\n");
                  result.model = util.getValue(lines2, "hardware", ":", true).toUpperCase();
                  result.version = util.getValue(lines2, "revision", ":", true).toLowerCase();
                  result.serial = util.getValue(lines2, "serial", ":", true);
                  const model = util.getValue(lines2, "model:", ":", true);
                  if ((result.model === "BCM2835" || result.model === "BCM2708" || result.model === "BCM2709" || result.model === "BCM2710" || result.model === "BCM2711" || result.model === "BCM2836" || result.model === "BCM2837") && model.toLowerCase().indexOf("raspberry") >= 0) {
                    const rPIRevision = util.decodePiCpuinfo(lines2);
                    result.model = rPIRevision.model;
                    result.version = rPIRevision.revisionCode;
                    result.manufacturer = "Raspberry Pi Foundation";
                    result.raspberry = {
                      manufacturer: rPIRevision.manufacturer,
                      processor: rPIRevision.processor,
                      type: rPIRevision.type,
                      revision: rPIRevision.revision
                    };
                  }
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          });
        }
        if (_darwin) {
          exec("ioreg -c IOPlatformExpertDevice -d 2", function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().replace(/[<>"]/g, "").split("\n");
              const model = util.splitByNumber(util.getValue(lines, "model", "=", true));
              const version3 = util.getValue(lines, "version", "=", true);
              result.manufacturer = util.getValue(lines, "manufacturer", "=", true);
              result.model = version3 ? util.getValue(lines, "model", "=", true) : model[0];
              result.version = version3 || model[1];
              result.serial = util.getValue(lines, "ioplatformserialnumber", "=", true);
              result.uuid = util.getValue(lines, "ioplatformuuid", "=", true).toLowerCase();
              result.sku = util.getValue(lines, "board-id", "=", true) || util.getValue(lines, "target-sub-type", "=", true);
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
        if (_windows) {
          try {
            util.powerShell("Get-CimInstance Win32_ComputerSystemProduct | select Name,Vendor,Version,IdentifyingNumber,UUID | fl").then((stdout, error) => {
              if (!error) {
                let lines = stdout.split("\r\n");
                result.manufacturer = util.getValue(lines, "vendor", ":");
                result.model = util.getValue(lines, "name", ":");
                result.version = util.getValue(lines, "version", ":");
                result.serial = util.getValue(lines, "identifyingnumber", ":");
                result.uuid = util.getValue(lines, "uuid", ":").toLowerCase();
                const model = result.model.toLowerCase();
                if (model === "virtualbox" || model === "kvm" || model === "virtual machine" || model === "bochs" || model.startsWith("vmware") || model.startsWith("qemu") || model.startsWith("parallels")) {
                  result.virtual = true;
                  if (model.startsWith("virtualbox")) {
                    result.virtualHost = "VirtualBox";
                  }
                  if (model.startsWith("vmware")) {
                    result.virtualHost = "VMware";
                  }
                  if (model.startsWith("kvm")) {
                    result.virtualHost = "KVM";
                  }
                  if (model.startsWith("bochs")) {
                    result.virtualHost = "bochs";
                  }
                  if (model.startsWith("qemu")) {
                    result.virtualHost = "KVM";
                  }
                  if (model.startsWith("parallels")) {
                    result.virtualHost = "Parallels";
                  }
                }
                const manufacturer = result.manufacturer.toLowerCase();
                if (manufacturer.startsWith("vmware") || manufacturer.startsWith("qemu") || manufacturer === "xen" || manufacturer.startsWith("parallels")) {
                  result.virtual = true;
                  if (manufacturer.startsWith("vmware")) {
                    result.virtualHost = "VMware";
                  }
                  if (manufacturer.startsWith("xen")) {
                    result.virtualHost = "Xen";
                  }
                  if (manufacturer.startsWith("qemu")) {
                    result.virtualHost = "KVM";
                  }
                  if (manufacturer.startsWith("parallels")) {
                    result.virtualHost = "Parallels";
                  }
                }
                util.powerShell('Get-CimInstance MS_Systeminformation -Namespace "root/wmi" | select systemsku | fl ').then((stdout2, error2) => {
                  if (!error2) {
                    let lines2 = stdout2.split("\r\n");
                    result.sku = util.getValue(lines2, "systemsku", ":");
                  }
                  if (!result.virtual) {
                    util.powerShell("Get-CimInstance Win32_bios | select Version, SerialNumber, SMBIOSBIOSVersion").then((stdout3, error3) => {
                      if (!error3) {
                        let lines2 = stdout3.toString();
                        if (lines2.indexOf("VRTUAL") >= 0 || lines2.indexOf("A M I ") >= 0 || lines2.indexOf("VirtualBox") >= 0 || lines2.indexOf("VMWare") >= 0 || lines2.indexOf("Xen") >= 0 || lines2.indexOf("Parallels") >= 0) {
                          result.virtual = true;
                          if (lines2.indexOf("VirtualBox") >= 0 && !result.virtualHost) {
                            result.virtualHost = "VirtualBox";
                          }
                          if (lines2.indexOf("VMware") >= 0 && !result.virtualHost) {
                            result.virtualHost = "VMware";
                          }
                          if (lines2.indexOf("Xen") >= 0 && !result.virtualHost) {
                            result.virtualHost = "Xen";
                          }
                          if (lines2.indexOf("VRTUAL") >= 0 && !result.virtualHost) {
                            result.virtualHost = "Hyper-V";
                          }
                          if (lines2.indexOf("A M I") >= 0 && !result.virtualHost) {
                            result.virtualHost = "Virtual PC";
                          }
                          if (lines2.indexOf("Parallels") >= 0 && !result.virtualHost) {
                            result.virtualHost = "Parallels";
                          }
                        }
                        if (callback) {
                          callback(result);
                        }
                        resolve(result);
                      } else {
                        if (callback) {
                          callback(result);
                        }
                        resolve(result);
                      }
                    });
                  } else {
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                });
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var cleanDefaults = function(s) {
    const cmpStr = s.toLowerCase();
    if (cmpStr.indexOf("o.e.m.") === -1 && cmpStr.indexOf("default string") === -1 && cmpStr !== "default") {
      return s || "";
    }
    return "";
  };
  var bios = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = {
          vendor: "",
          version: "",
          releaseDate: "",
          revision: ""
        };
        let cmd = "";
        if (_linux || _freebsd || _openbsd || _netbsd) {
          if (process.arch === "arm") {
            cmd = "cat /proc/cpuinfo | grep Serial";
          } else {
            cmd = "export LC_ALL=C; dmidecode -t bios 2>/dev/null; unset LC_ALL";
          }
          exec(cmd, function(error, stdout) {
            let lines = stdout.toString().split("\n");
            result.vendor = util.getValue(lines, "Vendor");
            result.version = util.getValue(lines, "Version");
            let datetime = util.getValue(lines, "Release Date");
            result.releaseDate = util.parseDateTime(datetime).date;
            result.revision = util.getValue(lines, "BIOS Revision");
            result.serial = util.getValue(lines, "SerialNumber");
            let language = util.getValue(lines, "Currently Installed Language").split("|")[0];
            if (language) {
              result.language = language;
            }
            if (lines.length && stdout.toString().indexOf("Characteristics:") >= 0) {
              const features = [];
              lines.forEach((line) => {
                if (line.indexOf(" is supported") >= 0) {
                  const feature = line.split(" is supported")[0].trim();
                  features.push(feature);
                }
              });
              result.features = features;
            }
            const cmd2 = `echo -n "bios_date: "; cat /sys/devices/virtual/dmi/id/bios_date 2>/dev/null; echo;
            echo -n "bios_vendor: "; cat /sys/devices/virtual/dmi/id/bios_vendor 2>/dev/null; echo;
            echo -n "bios_version: "; cat /sys/devices/virtual/dmi/id/bios_version 2>/dev/null; echo;`;
            try {
              lines = execSync(cmd2).toString().split("\n");
              result.vendor = !result.vendor ? util.getValue(lines, "bios_vendor") : result.vendor;
              result.version = !result.version ? util.getValue(lines, "bios_version") : result.version;
              datetime = util.getValue(lines, "bios_date");
              result.releaseDate = !result.releaseDate ? util.parseDateTime(datetime).date : result.releaseDate;
            } catch (e) {
              util.noop();
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_darwin) {
          result.vendor = "Apple Inc.";
          exec("system_profiler SPHardwareDataType -json", function(error, stdout) {
            try {
              const hardwareData = JSON.parse(stdout.toString());
              if (hardwareData && hardwareData.SPHardwareDataType && hardwareData.SPHardwareDataType.length) {
                let bootRomVersion = hardwareData.SPHardwareDataType[0].boot_rom_version;
                bootRomVersion = bootRomVersion ? bootRomVersion.split("(")[0].trim() : null;
                result.version = bootRomVersion;
              }
            } catch (e) {
              util.noop();
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_sunos) {
          result.vendor = "Sun Microsystems";
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
        if (_windows) {
          try {
            util.powerShell('Get-CimInstance Win32_bios | select Description,Version,Manufacturer,@{n="ReleaseDate";e={$_.ReleaseDate.ToString("yyyy-MM-dd")}},BuildNumber,SerialNumber,SMBIOSBIOSVersion | fl').then((stdout, error) => {
              if (!error) {
                let lines = stdout.toString().split("\r\n");
                const description2 = util.getValue(lines, "description", ":");
                const version3 = util.getValue(lines, "SMBIOSBIOSVersion", ":");
                if (description2.indexOf(" Version ") !== -1) {
                  result.vendor = description2.split(" Version ")[0].trim();
                  result.version = description2.split(" Version ")[1].trim();
                } else if (description2.indexOf(" Ver: ") !== -1) {
                  result.vendor = util.getValue(lines, "manufacturer", ":");
                  result.version = description2.split(" Ver: ")[1].trim();
                } else {
                  result.vendor = util.getValue(lines, "manufacturer", ":");
                  result.version = version3 || util.getValue(lines, "version", ":");
                }
                result.releaseDate = util.getValue(lines, "releasedate", ":");
                result.revision = util.getValue(lines, "buildnumber", ":");
                result.serial = cleanDefaults(util.getValue(lines, "serialnumber", ":"));
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var baseboard = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = {
          manufacturer: "",
          model: "",
          version: "",
          serial: "-",
          assetTag: "-",
          memMax: null,
          memSlots: null
        };
        let cmd = "";
        if (_linux || _freebsd || _openbsd || _netbsd) {
          if (process.arch === "arm") {
            cmd = "cat /proc/cpuinfo | grep Serial";
          } else {
            cmd = "export LC_ALL=C; dmidecode -t 2 2>/dev/null; unset LC_ALL";
          }
          const workload = [];
          workload.push(execPromise(cmd));
          workload.push(execPromise("export LC_ALL=C; dmidecode -t memory 2>/dev/null"));
          util.promiseAll(workload).then((data) => {
            let lines = data.results[0] ? data.results[0].toString().split("\n") : [""];
            result.manufacturer = util.getValue(lines, "Manufacturer");
            result.model = util.getValue(lines, "Product Name");
            result.version = util.getValue(lines, "Version");
            result.serial = util.getValue(lines, "Serial Number");
            result.assetTag = util.getValue(lines, "Asset Tag");
            const cmd2 = `echo -n "board_asset_tag: "; cat /sys/devices/virtual/dmi/id/board_asset_tag 2>/dev/null; echo;
            echo -n "board_name: "; cat /sys/devices/virtual/dmi/id/board_name 2>/dev/null; echo;
            echo -n "board_serial: "; cat /sys/devices/virtual/dmi/id/board_serial 2>/dev/null; echo;
            echo -n "board_vendor: "; cat /sys/devices/virtual/dmi/id/board_vendor 2>/dev/null; echo;
            echo -n "board_version: "; cat /sys/devices/virtual/dmi/id/board_version 2>/dev/null; echo;`;
            try {
              lines = execSync(cmd2).toString().split("\n");
              result.manufacturer = !result.manufacturer ? util.getValue(lines, "board_vendor") : result.manufacturer;
              result.model = !result.model ? util.getValue(lines, "board_name") : result.model;
              result.version = !result.version ? util.getValue(lines, "board_version") : result.version;
              result.serial = !result.serial ? util.getValue(lines, "board_serial") : result.serial;
              result.assetTag = !result.assetTag ? util.getValue(lines, "board_asset_tag") : result.assetTag;
            } catch (e) {
              util.noop();
            }
            if (result.serial.toLowerCase().indexOf("o.e.m.") !== -1) {
              result.serial = "-";
            }
            if (result.assetTag.toLowerCase().indexOf("o.e.m.") !== -1) {
              result.assetTag = "-";
            }
            lines = data.results[1] ? data.results[1].toString().split("\n") : [""];
            result.memMax = util.toInt(util.getValue(lines, "Maximum Capacity")) * 1024 * 1024 * 1024 || null;
            result.memSlots = util.toInt(util.getValue(lines, "Number Of Devices")) || null;
            let linesRpi = "";
            try {
              linesRpi = fs.readFileSync("/proc/cpuinfo").toString().split("\n");
            } catch (e) {
              util.noop();
            }
            if (linesRpi) {
              const hardware = util.getValue(linesRpi, "hardware");
              if (hardware.startsWith("BCM")) {
                const rpi = util.decodePiCpuinfo(linesRpi);
                result.manufacturer = rpi.manufacturer;
                result.model = "Raspberry Pi";
                result.serial = rpi.serial;
                result.version = rpi.type + " - " + rpi.revision;
                result.memMax = os.totalmem();
                result.memSlots = 0;
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_darwin) {
          const workload = [];
          workload.push(execPromise("ioreg -c IOPlatformExpertDevice -d 2"));
          workload.push(execPromise("system_profiler SPMemoryDataType"));
          util.promiseAll(workload).then((data) => {
            let lines = data.results[0] ? data.results[0].toString().replace(/[<>"]/g, "").split("\n") : [""];
            result.manufacturer = util.getValue(lines, "manufacturer", "=", true);
            result.model = util.getValue(lines, "model", "=", true);
            result.version = util.getValue(lines, "version", "=", true);
            result.serial = util.getValue(lines, "ioplatformserialnumber", "=", true);
            result.assetTag = util.getValue(lines, "board-id", "=", true);
            let devices = data.results[1] ? data.results[1].toString().split("        BANK ") : [""];
            if (devices.length === 1) {
              devices = data.results[1] ? data.results[1].toString().split("        DIMM") : [""];
            }
            devices.shift();
            result.memSlots = devices.length;
            if (os.arch() === "arm64") {
              result.memSlots = 0;
              result.memMax = os.totalmem();
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
        if (_windows) {
          try {
            const workload = [];
            const win10plus = parseInt(os.release()) >= 10;
            const maxCapacityAttribute = win10plus ? "MaxCapacityEx" : "MaxCapacity";
            workload.push(util.powerShell("Get-CimInstance Win32_baseboard | select Model,Manufacturer,Product,Version,SerialNumber,PartNumber,SKU | fl"));
            workload.push(util.powerShell(`Get-CimInstance Win32_physicalmemoryarray | select ${maxCapacityAttribute}, MemoryDevices | fl`));
            util.promiseAll(workload).then((data) => {
              let lines = data.results[0] ? data.results[0].toString().split("\r\n") : [""];
              result.manufacturer = cleanDefaults(util.getValue(lines, "manufacturer", ":"));
              result.model = cleanDefaults(util.getValue(lines, "model", ":"));
              if (!result.model) {
                result.model = cleanDefaults(util.getValue(lines, "product", ":"));
              }
              result.version = cleanDefaults(util.getValue(lines, "version", ":"));
              result.serial = cleanDefaults(util.getValue(lines, "serialnumber", ":"));
              result.assetTag = cleanDefaults(util.getValue(lines, "partnumber", ":"));
              if (!result.assetTag) {
                result.assetTag = cleanDefaults(util.getValue(lines, "sku", ":"));
              }
              lines = data.results[1] ? data.results[1].toString().split("\r\n") : [""];
              result.memMax = util.toInt(util.getValue(lines, maxCapacityAttribute, ":")) * (win10plus ? 1024 : 1) || null;
              result.memSlots = util.toInt(util.getValue(lines, "MemoryDevices", ":")) || null;
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var macOsChassisType = function(model) {
    model = model.toLowerCase();
    if (model.startsWith("macbookair")) {
      return "Notebook";
    }
    if (model.startsWith("macbookpro")) {
      return "Laptop";
    }
    if (model.startsWith("macbook")) {
      return "Notebook";
    }
    if (model.startsWith("macmini")) {
      return "Desktop";
    }
    if (model.startsWith("imac")) {
      return "Desktop";
    }
    if (model.startsWith("macstudio")) {
      return "Desktop";
    }
    if (model.startsWith("macpro")) {
      return "Tower";
    }
    return "Other";
  };
  var chassis = function(callback) {
    const chassisTypes = [
      "Other",
      "Unknown",
      "Desktop",
      "Low Profile Desktop",
      "Pizza Box",
      "Mini Tower",
      "Tower",
      "Portable",
      "Laptop",
      "Notebook",
      "Hand Held",
      "Docking Station",
      "All in One",
      "Sub Notebook",
      "Space-Saving",
      "Lunch Box",
      "Main System Chassis",
      "Expansion Chassis",
      "SubChassis",
      "Bus Expansion Chassis",
      "Peripheral Chassis",
      "Storage Chassis",
      "Rack Mount Chassis",
      "Sealed-Case PC",
      "Multi-System Chassis",
      "Compact PCI",
      "Advanced TCA",
      "Blade",
      "Blade Enclosure",
      "Tablet",
      "Convertible",
      "Detachable",
      "IoT Gateway ",
      "Embedded PC",
      "Mini PC",
      "Stick PC"
    ];
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = {
          manufacturer: "",
          model: "",
          type: "",
          version: "",
          serial: "-",
          assetTag: "-",
          sku: ""
        };
        if (_linux || _freebsd || _openbsd || _netbsd) {
          const cmd = `echo -n "chassis_asset_tag: "; cat /sys/devices/virtual/dmi/id/chassis_asset_tag 2>/dev/null; echo;
            echo -n "chassis_serial: "; cat /sys/devices/virtual/dmi/id/chassis_serial 2>/dev/null; echo;
            echo -n "chassis_type: "; cat /sys/devices/virtual/dmi/id/chassis_type 2>/dev/null; echo;
            echo -n "chassis_vendor: "; cat /sys/devices/virtual/dmi/id/chassis_vendor 2>/dev/null; echo;
            echo -n "chassis_version: "; cat /sys/devices/virtual/dmi/id/chassis_version 2>/dev/null; echo;`;
          exec(cmd, function(error, stdout) {
            let lines = stdout.toString().split("\n");
            result.manufacturer = util.getValue(lines, "chassis_vendor");
            const ctype = parseInt(util.getValue(lines, "chassis_type").replace(/\D/g, ""));
            result.type = ctype && !isNaN(ctype) && ctype < chassisTypes.length ? chassisTypes[ctype - 1] : "";
            result.version = util.getValue(lines, "chassis_version");
            result.serial = util.getValue(lines, "chassis_serial");
            result.assetTag = util.getValue(lines, "chassis_asset_tag");
            if (result.manufacturer.toLowerCase().indexOf("o.e.m.") !== -1) {
              result.manufacturer = "-";
            }
            if (result.version.toLowerCase().indexOf("o.e.m.") !== -1) {
              result.version = "-";
            }
            if (result.serial.toLowerCase().indexOf("o.e.m.") !== -1) {
              result.serial = "-";
            }
            if (result.assetTag.toLowerCase().indexOf("o.e.m.") !== -1) {
              result.assetTag = "-";
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_darwin) {
          exec("ioreg -c IOPlatformExpertDevice -d 2", function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().replace(/[<>"]/g, "").split("\n");
              const model = util.getValue(lines, "model", "=", true);
              const modelParts = util.splitByNumber(model);
              const version3 = util.getValue(lines, "version", "=", true);
              result.manufacturer = util.getValue(lines, "manufacturer", "=", true);
              result.model = version3 ? util.getValue(lines, "model", "=", true) : modelParts[0];
              result.type = macOsChassisType(result.model);
              result.version = version3 || model;
              result.serial = util.getValue(lines, "ioplatformserialnumber", "=", true);
              result.assetTag = util.getValue(lines, "board-id", "=", true) || util.getValue(lines, "target-type", "=", true);
              result.sku = util.getValue(lines, "target-sub-type", "=", true);
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
        if (_windows) {
          try {
            util.powerShell("Get-CimInstance Win32_SystemEnclosure | select Model,Manufacturer,ChassisTypes,Version,SerialNumber,PartNumber,SKU,SMBIOSAssetTag | fl").then((stdout, error) => {
              if (!error) {
                let lines = stdout.toString().split("\r\n");
                result.manufacturer = cleanDefaults(util.getValue(lines, "manufacturer", ":"));
                result.model = cleanDefaults(util.getValue(lines, "model", ":"));
                const ctype = parseInt(util.getValue(lines, "ChassisTypes", ":").replace(/\D/g, ""));
                result.type = ctype && !isNaN(ctype) && ctype < chassisTypes.length ? chassisTypes[ctype - 1] : "";
                result.version = cleanDefaults(util.getValue(lines, "version", ":"));
                result.serial = cleanDefaults(util.getValue(lines, "serialnumber", ":"));
                result.assetTag = cleanDefaults(util.getValue(lines, "partnumber", ":"));
                if (!result.assetTag) {
                  result.assetTag = cleanDefaults(util.getValue(lines, "SMBIOSAssetTag", ":"));
                }
                result.sku = cleanDefaults(util.getValue(lines, "sku", ":"));
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var fs = __require("fs");
  var os = __require("os");
  var util = require_util4();
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var execPromise = util.promisify(__require("child_process").exec);
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  exports2.system = system;
  exports2.bios = bios;
  exports2.baseboard = baseboard;
  exports2.chassis = chassis;
});

// ../../node_modules/systeminformation/lib/osinfo.js
var require_osinfo = __commonJS((exports2) => {
  var time = function() {
    let t = new Date().toString().split(" ");
    return {
      current: Date.now(),
      uptime: os.uptime(),
      timezone: t.length >= 7 ? t[5] : "",
      timezoneName: Intl ? Intl.DateTimeFormat().resolvedOptions().timeZone : t.length >= 7 ? t.slice(6).join(" ").replace(/\(/g, "").replace(/\)/g, "") : ""
    };
  };
  var getLogoFile = function(distro) {
    distro = distro || "";
    distro = distro.toLowerCase();
    let result = _platform;
    if (_windows) {
      result = "windows";
    } else if (distro.indexOf("mac os") !== -1) {
      result = "apple";
    } else if (distro.indexOf("arch") !== -1) {
      result = "arch";
    } else if (distro.indexOf("centos") !== -1) {
      result = "centos";
    } else if (distro.indexOf("coreos") !== -1) {
      result = "coreos";
    } else if (distro.indexOf("debian") !== -1) {
      result = "debian";
    } else if (distro.indexOf("deepin") !== -1) {
      result = "deepin";
    } else if (distro.indexOf("elementary") !== -1) {
      result = "elementary";
    } else if (distro.indexOf("fedora") !== -1) {
      result = "fedora";
    } else if (distro.indexOf("gentoo") !== -1) {
      result = "gentoo";
    } else if (distro.indexOf("mageia") !== -1) {
      result = "mageia";
    } else if (distro.indexOf("mandriva") !== -1) {
      result = "mandriva";
    } else if (distro.indexOf("manjaro") !== -1) {
      result = "manjaro";
    } else if (distro.indexOf("mint") !== -1) {
      result = "mint";
    } else if (distro.indexOf("mx") !== -1) {
      result = "mx";
    } else if (distro.indexOf("openbsd") !== -1) {
      result = "openbsd";
    } else if (distro.indexOf("freebsd") !== -1) {
      result = "freebsd";
    } else if (distro.indexOf("opensuse") !== -1) {
      result = "opensuse";
    } else if (distro.indexOf("pclinuxos") !== -1) {
      result = "pclinuxos";
    } else if (distro.indexOf("puppy") !== -1) {
      result = "puppy";
    } else if (distro.indexOf("raspbian") !== -1) {
      result = "raspbian";
    } else if (distro.indexOf("reactos") !== -1) {
      result = "reactos";
    } else if (distro.indexOf("redhat") !== -1) {
      result = "redhat";
    } else if (distro.indexOf("slackware") !== -1) {
      result = "slackware";
    } else if (distro.indexOf("sugar") !== -1) {
      result = "sugar";
    } else if (distro.indexOf("steam") !== -1) {
      result = "steam";
    } else if (distro.indexOf("suse") !== -1) {
      result = "suse";
    } else if (distro.indexOf("mate") !== -1) {
      result = "ubuntu-mate";
    } else if (distro.indexOf("lubuntu") !== -1) {
      result = "lubuntu";
    } else if (distro.indexOf("xubuntu") !== -1) {
      result = "xubuntu";
    } else if (distro.indexOf("ubuntu") !== -1) {
      result = "ubuntu";
    } else if (distro.indexOf("solaris") !== -1) {
      result = "solaris";
    } else if (distro.indexOf("tails") !== -1) {
      result = "tails";
    } else if (distro.indexOf("feren") !== -1) {
      result = "ferenos";
    } else if (distro.indexOf("robolinux") !== -1) {
      result = "robolinux";
    } else if (_linux && distro) {
      result = distro.toLowerCase().trim().replace(/\s+/g, "-");
    }
    return result;
  };
  var getFQDN = function() {
    let fqdn = os.hostname;
    if (_linux || _darwin) {
      try {
        const stdout = execSync("hostnamectl --json short 2>/dev/null");
        const json = JSON.parse(stdout.toString());
        fqdn = json["StaticHostname"];
      } catch (e) {
        try {
          const stdout = execSync("hostname -f 2>/dev/null");
          fqdn = stdout.toString().split(os.EOL)[0];
        } catch (e2) {
          util.noop();
        }
      }
    }
    if (_freebsd || _openbsd || _netbsd) {
      try {
        const stdout = execSync("hostname 2>/dev/null");
        fqdn = stdout.toString().split(os.EOL)[0];
      } catch (e) {
        util.noop();
      }
    }
    if (_windows) {
      try {
        const stdout = execSync("echo %COMPUTERNAME%.%USERDNSDOMAIN%", util.execOptsWin);
        fqdn = stdout.toString().replace(".%USERDNSDOMAIN%", "").split(os.EOL)[0];
      } catch (e) {
        util.noop();
      }
    }
    return fqdn;
  };
  var osInfo = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = {
          platform: _platform === "win32" ? "Windows" : _platform,
          distro: "unknown",
          release: "unknown",
          codename: "",
          kernel: os.release(),
          arch: os.arch(),
          hostname: os.hostname(),
          fqdn: getFQDN(),
          codepage: "",
          logofile: "",
          serial: "",
          build: "",
          servicepack: "",
          uefi: false
        };
        if (_linux) {
          exec("cat /etc/*-release; cat /usr/lib/os-release; cat /etc/openwrt_release", function(error, stdout) {
            let release = {};
            let lines = stdout.toString().split("\n");
            lines.forEach(function(line) {
              if (line.indexOf("=") !== -1) {
                release[line.split("=")[0].trim().toUpperCase()] = line.split("=")[1].trim();
              }
            });
            result.distro = (release.DISTRIB_ID || release.NAME || "unknown").replace(/"/g, "");
            result.logofile = getLogoFile(result.distro);
            let releaseVersion = (release.VERSION || "").replace(/"/g, "");
            let codename = (release.DISTRIB_CODENAME || release.VERSION_CODENAME || "").replace(/"/g, "");
            const prettyName = (release.PRETTY_NAME || "").replace(/"/g, "");
            if (prettyName.indexOf(result.distro + " ") === 0) {
              releaseVersion = prettyName.replace(result.distro + " ", "").trim();
            }
            if (releaseVersion.indexOf("(") >= 0) {
              codename = releaseVersion.split("(")[1].replace(/[()]/g, "").trim();
              releaseVersion = releaseVersion.split("(")[0].trim();
            }
            result.release = (releaseVersion || release.DISTRIB_RELEASE || release.VERSION_ID || "unknown").replace(/"/g, "");
            result.codename = codename;
            result.codepage = util.getCodepage();
            result.build = (release.BUILD_ID || "").replace(/"/g, "").trim();
            isUefiLinux().then((uefi) => {
              result.uefi = uefi;
              uuid2().then((data) => {
                result.serial = data.os;
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            });
          });
        }
        if (_freebsd || _openbsd || _netbsd) {
          exec("sysctl kern.ostype kern.osrelease kern.osrevision kern.hostuuid machdep.bootmethod kern.geom.confxml", function(error, stdout) {
            let lines = stdout.toString().split("\n");
            const distro = util.getValue(lines, "kern.ostype");
            const logofile = getLogoFile(distro);
            const release = util.getValue(lines, "kern.osrelease").split("-")[0];
            const serial = util.getValue(lines, "kern.uuid");
            const bootmethod = util.getValue(lines, "machdep.bootmethod");
            const uefiConf = stdout.toString().indexOf("<type>efi</type>") >= 0;
            const uefi = bootmethod ? bootmethod.toLowerCase().indexOf("uefi") >= 0 : uefiConf ? uefiConf : null;
            result.distro = distro || result.distro;
            result.logofile = logofile || result.logofile;
            result.release = release || result.release;
            result.serial = serial || result.serial;
            result.codename = "";
            result.codepage = util.getCodepage();
            result.uefi = uefi || null;
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_darwin) {
          exec("sw_vers; sysctl kern.ostype kern.osrelease kern.osrevision kern.uuid", function(error, stdout) {
            let lines = stdout.toString().split("\n");
            result.serial = util.getValue(lines, "kern.uuid");
            result.distro = util.getValue(lines, "ProductName");
            result.release = (util.getValue(lines, "ProductVersion", ":", true, true) + " " + util.getValue(lines, "ProductVersionExtra", ":", true, true)).trim();
            result.build = util.getValue(lines, "BuildVersion");
            result.logofile = getLogoFile(result.distro);
            result.codename = "macOS";
            result.codename = result.release.indexOf("10.4") > -1 ? "Mac OS X Tiger" : result.codename;
            result.codename = result.release.indexOf("10.5") > -1 ? "Mac OS X Leopard" : result.codename;
            result.codename = result.release.indexOf("10.6") > -1 ? "Mac OS X Snow Leopard" : result.codename;
            result.codename = result.release.indexOf("10.7") > -1 ? "Mac OS X Lion" : result.codename;
            result.codename = result.release.indexOf("10.8") > -1 ? "OS X Mountain Lion" : result.codename;
            result.codename = result.release.indexOf("10.9") > -1 ? "OS X Mavericks" : result.codename;
            result.codename = result.release.indexOf("10.10") > -1 ? "OS X Yosemite" : result.codename;
            result.codename = result.release.indexOf("10.11") > -1 ? "OS X El Capitan" : result.codename;
            result.codename = result.release.indexOf("10.12") > -1 ? "macOS Sierra" : result.codename;
            result.codename = result.release.indexOf("10.13") > -1 ? "macOS High Sierra" : result.codename;
            result.codename = result.release.indexOf("10.14") > -1 ? "macOS Mojave" : result.codename;
            result.codename = result.release.indexOf("10.15") > -1 ? "macOS Catalina" : result.codename;
            result.codename = result.release.startsWith("11.") ? "macOS Big Sur" : result.codename;
            result.codename = result.release.startsWith("12.") ? "macOS Monterey" : result.codename;
            result.codename = result.release.startsWith("13.") ? "macOS Ventura" : result.codename;
            result.codename = result.release.startsWith("14.") ? "macOS Sonoma" : result.codename;
            result.codename = result.release.startsWith("15.") ? "macOS Sequoia" : result.codename;
            result.uefi = true;
            result.codepage = util.getCodepage();
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_sunos) {
          result.release = result.kernel;
          exec("uname -o", function(error, stdout) {
            let lines = stdout.toString().split("\n");
            result.distro = lines[0];
            result.logofile = getLogoFile(result.distro);
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_windows) {
          result.logofile = getLogoFile();
          result.release = result.kernel;
          try {
            const workload = [];
            workload.push(util.powerShell("Get-CimInstance Win32_OperatingSystem | select Caption,SerialNumber,BuildNumber,ServicePackMajorVersion,ServicePackMinorVersion | fl"));
            workload.push(util.powerShell("(Get-CimInstance Win32_ComputerSystem).HypervisorPresent"));
            workload.push(util.powerShell("Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.SystemInformation]::TerminalServerSession"));
            util.promiseAll(workload).then((data) => {
              let lines = data.results[0] ? data.results[0].toString().split("\r\n") : [""];
              result.distro = util.getValue(lines, "Caption", ":").trim();
              result.serial = util.getValue(lines, "SerialNumber", ":").trim();
              result.build = util.getValue(lines, "BuildNumber", ":").trim();
              result.servicepack = util.getValue(lines, "ServicePackMajorVersion", ":").trim() + "." + util.getValue(lines, "ServicePackMinorVersion", ":").trim();
              result.codepage = util.getCodepage();
              const hyperv = data.results[1] ? data.results[1].toString().toLowerCase() : "";
              result.hypervisor = hyperv.indexOf("true") !== -1;
              const term = data.results[2] ? data.results[2].toString() : "";
              result.remoteSession = term.toString().toLowerCase().indexOf("true") >= 0;
              isUefiWindows().then((uefi) => {
                result.uefi = uefi;
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var isUefiLinux = function() {
    return new Promise((resolve) => {
      process.nextTick(() => {
        fs.stat("/sys/firmware/efi", function(err) {
          if (!err) {
            return resolve(true);
          } else {
            exec('dmesg | grep -E "EFI v"', function(error, stdout) {
              if (!error) {
                const lines = stdout.toString().split("\n");
                return resolve(lines.length > 0);
              }
              return resolve(false);
            });
          }
        });
      });
    });
  };
  var isUefiWindows = function() {
    return new Promise((resolve) => {
      process.nextTick(() => {
        try {
          exec('findstr /C:"Detected boot environment" "%windir%\\Panther\\setupact.log"', util.execOptsWin, function(error, stdout) {
            if (!error) {
              const line = stdout.toString().split("\n\r")[0];
              return resolve(line.toLowerCase().indexOf("efi") >= 0);
            } else {
              exec("echo %firmware_type%", util.execOptsWin, function(error2, stdout2) {
                if (!error2) {
                  const line = stdout2.toString() || "";
                  return resolve(line.toLowerCase().indexOf("efi") >= 0);
                } else {
                  return resolve(false);
                }
              });
            }
          });
        } catch (e) {
          return resolve(false);
        }
      });
    });
  };
  var versions = function(apps, callback) {
    let versionObject = {
      kernel: os.release(),
      openssl: "",
      systemOpenssl: "",
      systemOpensslLib: "",
      node: process.versions.node,
      v8: process.versions.v8,
      npm: "",
      yarn: "",
      pm2: "",
      gulp: "",
      grunt: "",
      git: "",
      tsc: "",
      mysql: "",
      redis: "",
      mongodb: "",
      apache: "",
      nginx: "",
      php: "",
      docker: "",
      postfix: "",
      postgresql: "",
      perl: "",
      python: "",
      python3: "",
      pip: "",
      pip3: "",
      java: "",
      gcc: "",
      virtualbox: "",
      bash: "",
      zsh: "",
      fish: "",
      powershell: "",
      dotnet: ""
    };
    function checkVersionParam(apps2) {
      if (apps2 === "*") {
        return {
          versions: versionObject,
          counter: 30
        };
      }
      if (!Array.isArray(apps2)) {
        apps2 = apps2.trim().toLowerCase().replace(/,+/g, "|").replace(/ /g, "|");
        apps2 = apps2.split("|");
        const result = {
          versions: {},
          counter: 0
        };
        apps2.forEach((el) => {
          if (el) {
            for (let key in versionObject) {
              if ({}.hasOwnProperty.call(versionObject, key)) {
                if (key.toLowerCase() === el.toLowerCase() && !{}.hasOwnProperty.call(result.versions, key)) {
                  result.versions[key] = versionObject[key];
                  if (key === "openssl") {
                    result.versions.systemOpenssl = "";
                    result.versions.systemOpensslLib = "";
                  }
                  if (!result.versions[key]) {
                    result.counter++;
                  }
                }
              }
            }
          }
        });
        return result;
      }
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (util.isFunction(apps) && !callback) {
          callback = apps;
          apps = "*";
        } else {
          apps = apps || "*";
          if (typeof apps !== "string") {
            if (callback) {
              callback({});
            }
            return resolve({});
          }
        }
        const appsObj = checkVersionParam(apps);
        let totalFunctions = appsObj.counter;
        let functionProcessed = function() {
          return function() {
            if (--totalFunctions === 0) {
              if (callback) {
                callback(appsObj.versions);
              }
              resolve(appsObj.versions);
            }
          };
        }();
        let cmd = "";
        try {
          if ({}.hasOwnProperty.call(appsObj.versions, "openssl")) {
            appsObj.versions.openssl = process.versions.openssl;
            exec("openssl version", function(error, stdout) {
              if (!error) {
                let openssl_string = stdout.toString().split("\n")[0].trim();
                let openssl = openssl_string.split(" ");
                appsObj.versions.systemOpenssl = openssl.length > 0 ? openssl[1] : openssl[0];
                appsObj.versions.systemOpensslLib = openssl.length > 0 ? openssl[0] : "openssl";
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "npm")) {
            exec("npm -v", function(error, stdout) {
              if (!error) {
                appsObj.versions.npm = stdout.toString().split("\n")[0];
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "pm2")) {
            cmd = "pm2";
            if (_windows) {
              cmd += ".cmd";
            }
            exec(`${cmd} -v`, function(error, stdout) {
              if (!error) {
                let pm2 = stdout.toString().split("\n")[0].trim();
                if (!pm2.startsWith("[PM2]")) {
                  appsObj.versions.pm2 = pm2;
                }
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "yarn")) {
            exec("yarn --version", function(error, stdout) {
              if (!error) {
                appsObj.versions.yarn = stdout.toString().split("\n")[0];
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "gulp")) {
            cmd = "gulp";
            if (_windows) {
              cmd += ".cmd";
            }
            exec(`${cmd} --version`, function(error, stdout) {
              if (!error) {
                const gulp = stdout.toString().split("\n")[0] || "";
                appsObj.versions.gulp = (gulp.toLowerCase().split("version")[1] || "").trim();
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "tsc")) {
            cmd = "tsc";
            if (_windows) {
              cmd += ".cmd";
            }
            exec(`${cmd} --version`, function(error, stdout) {
              if (!error) {
                const tsc = stdout.toString().split("\n")[0] || "";
                appsObj.versions.tsc = (tsc.toLowerCase().split("version")[1] || "").trim();
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "grunt")) {
            cmd = "grunt";
            if (_windows) {
              cmd += ".cmd";
            }
            exec(`${cmd} --version`, function(error, stdout) {
              if (!error) {
                const grunt = stdout.toString().split("\n")[0] || "";
                appsObj.versions.grunt = (grunt.toLowerCase().split("cli v")[1] || "").trim();
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "git")) {
            if (_darwin) {
              const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/git") || fs.existsSync("/opt/homebrew/bin/git");
              if (util.darwinXcodeExists() || gitHomebrewExists) {
                exec("git --version", function(error, stdout) {
                  if (!error) {
                    let git = stdout.toString().split("\n")[0] || "";
                    git = (git.toLowerCase().split("version")[1] || "").trim();
                    appsObj.versions.git = (git.split(" ")[0] || "").trim();
                  }
                  functionProcessed();
                });
              } else {
                functionProcessed();
              }
            } else {
              exec("git --version", function(error, stdout) {
                if (!error) {
                  let git = stdout.toString().split("\n")[0] || "";
                  git = (git.toLowerCase().split("version")[1] || "").trim();
                  appsObj.versions.git = (git.split(" ")[0] || "").trim();
                }
                functionProcessed();
              });
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "apache")) {
            exec("apachectl -v 2>&1", function(error, stdout) {
              if (!error) {
                const apache = (stdout.toString().split("\n")[0] || "").split(":");
                appsObj.versions.apache = apache.length > 1 ? apache[1].replace("Apache", "").replace("/", "").split("(")[0].trim() : "";
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "nginx")) {
            exec("nginx -v 2>&1", function(error, stdout) {
              if (!error) {
                const nginx = stdout.toString().split("\n")[0] || "";
                appsObj.versions.nginx = (nginx.toLowerCase().split("/")[1] || "").trim();
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "mysql")) {
            exec("mysql -V", function(error, stdout) {
              if (!error) {
                let mysql = stdout.toString().split("\n")[0] || "";
                mysql = mysql.toLowerCase();
                if (mysql.indexOf(",") > -1) {
                  mysql = (mysql.split(",")[0] || "").trim();
                  const parts = mysql.split(" ");
                  appsObj.versions.mysql = (parts[parts.length - 1] || "").trim();
                } else {
                  if (mysql.indexOf(" ver ") > -1) {
                    mysql = mysql.split(" ver ")[1];
                    appsObj.versions.mysql = mysql.split(" ")[0];
                  }
                }
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "php")) {
            exec("php -v", function(error, stdout) {
              if (!error) {
                const php = stdout.toString().split("\n")[0] || "";
                let parts = php.split("(");
                if (parts[0].indexOf("-")) {
                  parts = parts[0].split("-");
                }
                appsObj.versions.php = parts[0].replace(/[^0-9.]/g, "");
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "redis")) {
            exec("redis-server --version", function(error, stdout) {
              if (!error) {
                const redis = stdout.toString().split("\n")[0] || "";
                const parts = redis.split(" ");
                appsObj.versions.redis = util.getValue(parts, "v", "=", true);
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "docker")) {
            exec("docker --version", function(error, stdout) {
              if (!error) {
                const docker = stdout.toString().split("\n")[0] || "";
                const parts = docker.split(" ");
                appsObj.versions.docker = parts.length > 2 && parts[2].endsWith(",") ? parts[2].slice(0, -1) : "";
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "postfix")) {
            exec("postconf -d | grep mail_version", function(error, stdout) {
              if (!error) {
                const postfix = stdout.toString().split("\n") || [];
                appsObj.versions.postfix = util.getValue(postfix, "mail_version", "=", true);
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "mongodb")) {
            exec("mongod --version", function(error, stdout) {
              if (!error) {
                const mongodb = stdout.toString().split("\n")[0] || "";
                appsObj.versions.mongodb = (mongodb.toLowerCase().split(",")[0] || "").replace(/[^0-9.]/g, "");
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "postgresql")) {
            if (_linux) {
              exec("locate bin/postgres", function(error, stdout) {
                if (!error) {
                  const postgresqlBin = stdout.toString().split("\n").sort();
                  if (postgresqlBin.length) {
                    exec(postgresqlBin[postgresqlBin.length - 1] + " -V", function(error2, stdout2) {
                      if (!error2) {
                        const postgresql = stdout2.toString().split("\n")[0].split(" ") || [];
                        appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                      }
                      functionProcessed();
                    });
                  } else {
                    functionProcessed();
                  }
                } else {
                  exec("psql -V", function(error2, stdout2) {
                    if (!error2) {
                      const postgresql = stdout2.toString().split("\n")[0].split(" ") || [];
                      appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                      appsObj.versions.postgresql = appsObj.versions.postgresql.split("-")[0];
                    }
                    functionProcessed();
                  });
                }
              });
            } else {
              if (_windows) {
                util.powerShell("Get-CimInstance Win32_Service | select caption | fl").then((stdout) => {
                  let serviceSections = stdout.split(/\n\s*\n/);
                  serviceSections.forEach((item) => {
                    if (item.trim() !== "") {
                      let lines = item.trim().split("\r\n");
                      let srvCaption = util.getValue(lines, "caption", ":", true).toLowerCase();
                      if (srvCaption.indexOf("postgresql") > -1) {
                        const parts = srvCaption.split(" server ");
                        if (parts.length > 1) {
                          appsObj.versions.postgresql = parts[1];
                        }
                      }
                    }
                  });
                  functionProcessed();
                });
              } else {
                exec("postgres -V", function(error, stdout) {
                  if (!error) {
                    const postgresql = stdout.toString().split("\n")[0].split(" ") || [];
                    appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                  }
                  functionProcessed();
                });
              }
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "perl")) {
            exec("perl -v", function(error, stdout) {
              if (!error) {
                const perl = stdout.toString().split("\n") || "";
                while (perl.length > 0 && perl[0].trim() === "") {
                  perl.shift();
                }
                if (perl.length > 0) {
                  appsObj.versions.perl = perl[0].split("(").pop().split(")")[0].replace("v", "");
                }
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "python")) {
            if (_darwin) {
              try {
                const stdout = execSync("sw_vers");
                const lines = stdout.toString().split("\n");
                const osVersion = util.getValue(lines, "ProductVersion", ":");
                const gitHomebrewExists1 = fs.existsSync("/usr/local/Cellar/python");
                const gitHomebrewExists2 = fs.existsSync("/opt/homebrew/bin/python");
                if (util.darwinXcodeExists() && util.semverCompare("12.0.1", osVersion) < 0 || gitHomebrewExists1 || gitHomebrewExists2) {
                  const cmd2 = gitHomebrewExists1 ? "/usr/local/Cellar/python -V 2>&1" : gitHomebrewExists2 ? "/opt/homebrew/bin/python -V 2>&1" : "python -V 2>&1";
                  exec(cmd2, function(error, stdout2) {
                    if (!error) {
                      const python = stdout2.toString().split("\n")[0] || "";
                      appsObj.versions.python = python.toLowerCase().replace("python", "").trim();
                    }
                    functionProcessed();
                  });
                } else {
                  functionProcessed();
                }
              } catch (e) {
                functionProcessed();
              }
            } else {
              exec("python -V 2>&1", function(error, stdout) {
                if (!error) {
                  const python = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.python = python.toLowerCase().replace("python", "").trim();
                }
                functionProcessed();
              });
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "python3")) {
            if (_darwin) {
              const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/python3") || fs.existsSync("/opt/homebrew/bin/python3");
              if (util.darwinXcodeExists() || gitHomebrewExists) {
                exec("python3 -V 2>&1", function(error, stdout) {
                  if (!error) {
                    const python = stdout.toString().split("\n")[0] || "";
                    appsObj.versions.python3 = python.toLowerCase().replace("python", "").trim();
                  }
                  functionProcessed();
                });
              } else {
                functionProcessed();
              }
            } else {
              exec("python3 -V 2>&1", function(error, stdout) {
                if (!error) {
                  const python = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.python3 = python.toLowerCase().replace("python", "").trim();
                }
                functionProcessed();
              });
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "pip")) {
            if (_darwin) {
              const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/pip") || fs.existsSync("/opt/homebrew/bin/pip");
              if (util.darwinXcodeExists() || gitHomebrewExists) {
                exec("pip -V 2>&1", function(error, stdout) {
                  if (!error) {
                    const pip = stdout.toString().split("\n")[0] || "";
                    const parts = pip.split(" ");
                    appsObj.versions.pip = parts.length >= 2 ? parts[1] : "";
                  }
                  functionProcessed();
                });
              } else {
                functionProcessed();
              }
            } else {
              exec("pip -V 2>&1", function(error, stdout) {
                if (!error) {
                  const pip = stdout.toString().split("\n")[0] || "";
                  const parts = pip.split(" ");
                  appsObj.versions.pip = parts.length >= 2 ? parts[1] : "";
                }
                functionProcessed();
              });
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "pip3")) {
            if (_darwin) {
              const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/pip3") || fs.existsSync("/opt/homebrew/bin/pip3");
              if (util.darwinXcodeExists() || gitHomebrewExists) {
                exec("pip3 -V 2>&1", function(error, stdout) {
                  if (!error) {
                    const pip = stdout.toString().split("\n")[0] || "";
                    const parts = pip.split(" ");
                    appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : "";
                  }
                  functionProcessed();
                });
              } else {
                functionProcessed();
              }
            } else {
              exec("pip3 -V 2>&1", function(error, stdout) {
                if (!error) {
                  const pip = stdout.toString().split("\n")[0] || "";
                  const parts = pip.split(" ");
                  appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : "";
                }
                functionProcessed();
              });
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "java")) {
            if (_darwin) {
              exec("/usr/libexec/java_home -V 2>&1", function(error, stdout) {
                if (!error && stdout.toString().toLowerCase().indexOf("no java runtime") === -1) {
                  exec("java -version 2>&1", function(error2, stdout2) {
                    if (!error2) {
                      const java = stdout2.toString().split("\n")[0] || "";
                      const parts = java.split('"');
                      appsObj.versions.java = parts.length === 3 ? parts[1].trim() : "";
                    }
                    functionProcessed();
                  });
                } else {
                  functionProcessed();
                }
              });
            } else {
              exec("java -version 2>&1", function(error, stdout) {
                if (!error) {
                  const java = stdout.toString().split("\n")[0] || "";
                  const parts = java.split('"');
                  appsObj.versions.java = parts.length === 3 ? parts[1].trim() : "";
                }
                functionProcessed();
              });
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "gcc")) {
            if (_darwin && util.darwinXcodeExists() || !_darwin) {
              exec("gcc -dumpversion", function(error, stdout) {
                if (!error) {
                  appsObj.versions.gcc = stdout.toString().split("\n")[0].trim() || "";
                }
                if (appsObj.versions.gcc.indexOf(".") > -1) {
                  functionProcessed();
                } else {
                  exec("gcc --version", function(error2, stdout2) {
                    if (!error2) {
                      const gcc = stdout2.toString().split("\n")[0].trim();
                      if (gcc.indexOf("gcc") > -1 && gcc.indexOf(")") > -1) {
                        const parts = gcc.split(")");
                        appsObj.versions.gcc = parts[1].trim() || appsObj.versions.gcc;
                      }
                    }
                    functionProcessed();
                  });
                }
              });
            } else {
              functionProcessed();
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "virtualbox")) {
            exec(util.getVboxmanage() + " -v 2>&1", function(error, stdout) {
              if (!error) {
                const vbox = stdout.toString().split("\n")[0] || "";
                const parts = vbox.split("r");
                appsObj.versions.virtualbox = parts[0];
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "bash")) {
            exec("bash --version", function(error, stdout) {
              if (!error) {
                const line = stdout.toString().split("\n")[0];
                const parts = line.split(" version ");
                if (parts.length > 1) {
                  appsObj.versions.bash = parts[1].split(" ")[0].split("(")[0];
                }
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "zsh")) {
            exec("zsh --version", function(error, stdout) {
              if (!error) {
                const line = stdout.toString().split("\n")[0];
                const parts = line.split("zsh ");
                if (parts.length > 1) {
                  appsObj.versions.zsh = parts[1].split(" ")[0];
                }
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "fish")) {
            exec("fish --version", function(error, stdout) {
              if (!error) {
                const line = stdout.toString().split("\n")[0];
                const parts = line.split(" version ");
                if (parts.length > 1) {
                  appsObj.versions.fish = parts[1].split(" ")[0];
                }
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "powershell")) {
            if (_windows) {
              util.powerShell("$PSVersionTable").then((stdout) => {
                const lines = stdout.toString().split("\n").map((line) => line.replace(/ +/g, " ").replace(/ +/g, ":"));
                appsObj.versions.powershell = util.getValue(lines, "psversion");
                functionProcessed();
              });
            } else {
              functionProcessed();
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "dotnet")) {
            if (_windows) {
              util.powerShell('gci "HKLM:\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP" -recurse | gp -name Version,Release -EA 0 | where { $_.PSChildName -match "^(?!S)\\p{L}"} | select PSChildName, Version, Release').then((stdout) => {
                const lines = stdout.toString().split("\r\n");
                let dotnet = "";
                lines.forEach((line) => {
                  line = line.replace(/ +/g, " ");
                  const parts = line.split(" ");
                  dotnet = dotnet || (parts[0].toLowerCase().startsWith("client") && parts.length > 2 ? parts[1].trim() : parts[0].toLowerCase().startsWith("full") && parts.length > 2 ? parts[1].trim() : "");
                });
                appsObj.versions.dotnet = dotnet.trim();
                functionProcessed();
              });
            } else {
              functionProcessed();
            }
          }
        } catch (e) {
          if (callback) {
            callback(appsObj.versions);
          }
          resolve(appsObj.versions);
        }
      });
    });
  };
  var shell = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (_windows) {
          resolve("cmd");
        } else {
          let result = "";
          exec("echo $SHELL", function(error, stdout) {
            if (!error) {
              result = stdout.toString().split("\n")[0];
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
      });
    });
  };
  var getUniqueMacAdresses = function() {
    let macs = [];
    try {
      const ifaces = os.networkInterfaces();
      for (let dev in ifaces) {
        if ({}.hasOwnProperty.call(ifaces, dev)) {
          ifaces[dev].forEach(function(details) {
            if (details && details.mac && details.mac !== "00:00:00:00:00:00") {
              const mac = details.mac.toLowerCase();
              if (macs.indexOf(mac) === -1) {
                macs.push(mac);
              }
            }
          });
        }
      }
      macs = macs.sort(function(a, b) {
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return 1;
        }
        return 0;
      });
    } catch (e) {
      macs.push("00:00:00:00:00:00");
    }
    return macs;
  };
  var uuid2 = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = {
          os: "",
          hardware: "",
          macs: getUniqueMacAdresses()
        };
        let parts;
        if (_darwin) {
          exec("system_profiler SPHardwareDataType -json", function(error, stdout) {
            if (!error) {
              try {
                const jsonObj = JSON.parse(stdout.toString());
                if (jsonObj.SPHardwareDataType && jsonObj.SPHardwareDataType.length > 0) {
                  const spHardware = jsonObj.SPHardwareDataType[0];
                  result.os = spHardware.platform_UUID.toLowerCase();
                  result.hardware = spHardware.serial_number;
                }
              } catch (e) {
                util.noop();
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_linux) {
          const cmd = `echo -n "os: "; cat /var/lib/dbus/machine-id 2> /dev/null ||
cat /etc/machine-id 2> /dev/null; echo;
echo -n "hardware: "; cat /sys/class/dmi/id/product_uuid 2> /dev/null; echo;`;
          exec(cmd, function(error, stdout) {
            const lines = stdout.toString().split("\n");
            result.os = util.getValue(lines, "os").toLowerCase();
            result.hardware = util.getValue(lines, "hardware").toLowerCase();
            if (!result.hardware) {
              const lines2 = fs.readFileSync("/proc/cpuinfo", { encoding: "utf8" }).toString().split("\n");
              const serial = util.getValue(lines2, "serial");
              result.hardware = serial || "";
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_freebsd || _openbsd || _netbsd) {
          exec("sysctl -i kern.hostid kern.hostuuid", function(error, stdout) {
            const lines = stdout.toString().split("\n");
            result.os = util.getValue(lines, "kern.hostid", ":").toLowerCase();
            result.hardware = util.getValue(lines, "kern.hostuuid", ":").toLowerCase();
            if (result.os.indexOf("unknown") >= 0) {
              result.os = "";
            }
            if (result.hardware.indexOf("unknown") >= 0) {
              result.hardware = "";
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_windows) {
          let sysdir = "%windir%\\System32";
          if (process.arch === "ia32" && Object.prototype.hasOwnProperty.call(process.env, "PROCESSOR_ARCHITEW6432")) {
            sysdir = "%windir%\\sysnative\\cmd.exe /c %windir%\\System32";
          }
          util.powerShell("Get-CimInstance Win32_ComputerSystemProduct | select UUID | fl").then((stdout) => {
            let lines = stdout.split("\r\n");
            result.hardware = util.getValue(lines, "uuid", ":").toLowerCase();
            exec(`${sysdir}\\reg query "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography" /v MachineGuid`, util.execOptsWin, function(error, stdout2) {
              parts = stdout2.toString().split("\n\r")[0].split("REG_SZ");
              result.os = parts.length > 1 ? parts[1].replace(/\r+|\n+|\s+/ig, "").toLowerCase() : "";
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          });
        }
      });
    });
  };
  var os = __require("os");
  var fs = __require("fs");
  var util = require_util4();
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  exports2.time = time;
  exports2.osInfo = osInfo;
  exports2.versions = versions;
  exports2.shell = shell;
  exports2.uuid = uuid2;
});

// ../../node_modules/systeminformation/lib/cpu.js
var require_cpu2 = __commonJS((exports2) => {
  var getSocketTypesByName = function(str) {
    let result = "";
    for (const key in socketTypesByName) {
      const names = socketTypesByName[key].split(" ");
      names.forEach((element) => {
        if (str.indexOf(element) >= 0) {
          result = key;
        }
      });
    }
    return result;
  };
  var cpuManufacturer = function(str) {
    let result = str;
    str = str.toLowerCase();
    if (str.indexOf("intel") >= 0) {
      result = "Intel";
    }
    if (str.indexOf("amd") >= 0) {
      result = "AMD";
    }
    if (str.indexOf("qemu") >= 0) {
      result = "QEMU";
    }
    if (str.indexOf("hygon") >= 0) {
      result = "Hygon";
    }
    if (str.indexOf("centaur") >= 0) {
      result = "WinChip/Via";
    }
    if (str.indexOf("vmware") >= 0) {
      result = "VMware";
    }
    if (str.indexOf("Xen") >= 0) {
      result = "Xen Hypervisor";
    }
    if (str.indexOf("tcg") >= 0) {
      result = "QEMU";
    }
    if (str.indexOf("apple") >= 0) {
      result = "Apple";
    }
    return result;
  };
  var cpuBrandManufacturer = function(res) {
    res.brand = res.brand.replace(/\(R\)+/g, "\xAE").replace(/\s+/g, " ").trim();
    res.brand = res.brand.replace(/\(TM\)+/g, "\u2122").replace(/\s+/g, " ").trim();
    res.brand = res.brand.replace(/\(C\)+/g, "\xA9").replace(/\s+/g, " ").trim();
    res.brand = res.brand.replace(/CPU+/g, "").replace(/\s+/g, " ").trim();
    res.manufacturer = cpuManufacturer(res.brand);
    let parts = res.brand.split(" ");
    parts.shift();
    res.brand = parts.join(" ");
    return res;
  };
  var getAMDSpeed = function(brand) {
    let result = "0";
    for (let key in AMDBaseFrequencies) {
      if ({}.hasOwnProperty.call(AMDBaseFrequencies, key)) {
        let parts = key.split("|");
        let found = 0;
        parts.forEach((item) => {
          if (brand.indexOf(item) > -1) {
            found++;
          }
        });
        if (found === parts.length) {
          result = AMDBaseFrequencies[key];
        }
      }
    }
    return parseFloat(result);
  };
  var getCpu = function() {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const UNKNOWN = "unknown";
        let result = {
          manufacturer: UNKNOWN,
          brand: UNKNOWN,
          vendor: "",
          family: "",
          model: "",
          stepping: "",
          revision: "",
          voltage: "",
          speed: 0,
          speedMin: 0,
          speedMax: 0,
          governor: "",
          cores: util.cores(),
          physicalCores: util.cores(),
          performanceCores: util.cores(),
          efficiencyCores: 0,
          processors: 1,
          socket: "",
          flags: "",
          virtualization: false,
          cache: {}
        };
        cpuFlags().then((flags) => {
          result.flags = flags;
          result.virtualization = flags.indexOf("vmx") > -1 || flags.indexOf("svm") > -1;
          if (_darwin) {
            exec("sysctl machdep.cpu hw.cpufrequency_max hw.cpufrequency_min hw.packages hw.physicalcpu_max hw.ncpu hw.tbfrequency hw.cpufamily hw.cpusubfamily", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              const modelline = util.getValue(lines, "machdep.cpu.brand_string");
              const modellineParts = modelline.split("@");
              result.brand = modellineParts[0].trim();
              const speed = modellineParts[1] ? modellineParts[1].trim() : "0";
              result.speed = parseFloat(speed.replace(/GHz+/g, ""));
              let tbFrequency = util.getValue(lines, "hw.tbfrequency") / 1e9;
              tbFrequency = tbFrequency < 0.1 ? tbFrequency * 100 : tbFrequency;
              result.speed = result.speed === 0 ? tbFrequency : result.speed;
              _cpu_speed = result.speed;
              result = cpuBrandManufacturer(result);
              result.speedMin = util.getValue(lines, "hw.cpufrequency_min") ? util.getValue(lines, "hw.cpufrequency_min") / 1e9 : result.speed;
              result.speedMax = util.getValue(lines, "hw.cpufrequency_max") ? util.getValue(lines, "hw.cpufrequency_max") / 1e9 : result.speed;
              result.vendor = util.getValue(lines, "machdep.cpu.vendor") || "Apple";
              result.family = util.getValue(lines, "machdep.cpu.family") || util.getValue(lines, "hw.cpufamily");
              result.model = util.getValue(lines, "machdep.cpu.model");
              result.stepping = util.getValue(lines, "machdep.cpu.stepping") || util.getValue(lines, "hw.cpusubfamily");
              result.virtualization = true;
              const countProcessors = util.getValue(lines, "hw.packages");
              const countCores = util.getValue(lines, "hw.physicalcpu_max");
              const countThreads = util.getValue(lines, "hw.ncpu");
              if (os.arch() === "arm64") {
                result.socket = "SOC";
                try {
                  const clusters = execSync("ioreg -c IOPlatformDevice -d 3 -r | grep cluster-type").toString().split("\n");
                  const efficiencyCores = clusters.filter((line) => line.indexOf('"E"') >= 0).length;
                  const performanceCores = clusters.filter((line) => line.indexOf('"P"') >= 0).length;
                  result.efficiencyCores = efficiencyCores;
                  result.performanceCores = performanceCores;
                } catch (e) {
                  util.noop();
                }
              }
              if (countProcessors) {
                result.processors = parseInt(countProcessors) || 1;
              }
              if (countCores && countThreads) {
                result.cores = parseInt(countThreads) || util.cores();
                result.physicalCores = parseInt(countCores) || util.cores();
              }
              cpuCache().then((res) => {
                result.cache = res;
                resolve(result);
              });
            });
          }
          if (_linux) {
            let modelline = "";
            let lines = [];
            if (os.cpus()[0] && os.cpus()[0].model) {
              modelline = os.cpus()[0].model;
            }
            exec('export LC_ALL=C; lscpu; echo -n "Governor: "; cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null; echo; unset LC_ALL', function(error, stdout) {
              if (!error) {
                lines = stdout.toString().split("\n");
              }
              modelline = util.getValue(lines, "model name") || modelline;
              modelline = util.getValue(lines, "bios model name") || modelline;
              const modellineParts = modelline.split("@");
              result.brand = modellineParts[0].trim();
              result.speed = modellineParts[1] ? parseFloat(modellineParts[1].trim()) : 0;
              if (result.speed === 0 && (result.brand.indexOf("AMD") > -1 || result.brand.toLowerCase().indexOf("ryzen") > -1)) {
                result.speed = getAMDSpeed(result.brand);
              }
              if (result.speed === 0) {
                const current = getCpuCurrentSpeedSync();
                if (current.avg !== 0) {
                  result.speed = current.avg;
                }
              }
              _cpu_speed = result.speed;
              result.speedMin = Math.round(parseFloat(util.getValue(lines, "cpu min mhz").replace(/,/g, ".")) / 10) / 100;
              result.speedMax = Math.round(parseFloat(util.getValue(lines, "cpu max mhz").replace(/,/g, ".")) / 10) / 100;
              result = cpuBrandManufacturer(result);
              result.vendor = cpuManufacturer(util.getValue(lines, "vendor id"));
              result.family = util.getValue(lines, "cpu family");
              result.model = util.getValue(lines, "model:");
              result.stepping = util.getValue(lines, "stepping");
              result.revision = util.getValue(lines, "cpu revision");
              result.cache.l1d = util.getValue(lines, "l1d cache");
              if (result.cache.l1d) {
                result.cache.l1d = parseInt(result.cache.l1d) * (result.cache.l1d.indexOf("M") !== -1 ? 1024 * 1024 : result.cache.l1d.indexOf("K") !== -1 ? 1024 : 1);
              }
              result.cache.l1i = util.getValue(lines, "l1i cache");
              if (result.cache.l1i) {
                result.cache.l1i = parseInt(result.cache.l1i) * (result.cache.l1i.indexOf("M") !== -1 ? 1024 * 1024 : result.cache.l1i.indexOf("K") !== -1 ? 1024 : 1);
              }
              result.cache.l2 = util.getValue(lines, "l2 cache");
              if (result.cache.l2) {
                result.cache.l2 = parseInt(result.cache.l2) * (result.cache.l2.indexOf("M") !== -1 ? 1024 * 1024 : result.cache.l2.indexOf("K") !== -1 ? 1024 : 1);
              }
              result.cache.l3 = util.getValue(lines, "l3 cache");
              if (result.cache.l3) {
                result.cache.l3 = parseInt(result.cache.l3) * (result.cache.l3.indexOf("M") !== -1 ? 1024 * 1024 : result.cache.l3.indexOf("K") !== -1 ? 1024 : 1);
              }
              const threadsPerCore = util.getValue(lines, "thread(s) per core") || "1";
              const processors = util.getValue(lines, "socket(s)") || "1";
              const threadsPerCoreInt = parseInt(threadsPerCore, 10);
              const processorsInt = parseInt(processors, 10) || 1;
              const coresPerSocket = parseInt(util.getValue(lines, "core(s) per socket"), 10);
              result.physicalCores = coresPerSocket ? coresPerSocket * processorsInt : result.cores / threadsPerCoreInt;
              result.performanceCores = threadsPerCoreInt > 1 ? result.cores - result.physicalCores : result.cores;
              result.efficiencyCores = threadsPerCoreInt > 1 ? result.cores - threadsPerCoreInt * result.performanceCores : 0;
              result.processors = processorsInt;
              result.governor = util.getValue(lines, "governor") || "";
              if (result.vendor === "ARM") {
                const linesRpi = fs.readFileSync("/proc/cpuinfo").toString().split("\n");
                const rPIRevision = util.decodePiCpuinfo(linesRpi);
                if (rPIRevision.model.toLowerCase().indexOf("raspberry") >= 0) {
                  result.family = result.manufacturer;
                  result.manufacturer = rPIRevision.manufacturer;
                  result.brand = rPIRevision.processor;
                  result.revision = rPIRevision.revisionCode;
                  result.socket = "SOC";
                }
              }
              let lines2 = [];
              exec('export LC_ALL=C; dmidecode \u2013t 4 2>/dev/null | grep "Upgrade: Socket"; unset LC_ALL', function(error2, stdout2) {
                lines2 = stdout2.toString().split("\n");
                if (lines2 && lines2.length) {
                  result.socket = util.getValue(lines2, "Upgrade").replace("Socket", "").trim() || result.socket;
                }
                resolve(result);
              });
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            let modelline = "";
            let lines = [];
            if (os.cpus()[0] && os.cpus()[0].model) {
              modelline = os.cpus()[0].model;
            }
            exec("export LC_ALL=C; dmidecode -t 4; dmidecode -t 7 unset LC_ALL", function(error, stdout) {
              let cache = [];
              if (!error) {
                const data = stdout.toString().split("# dmidecode");
                const processor = data.length > 1 ? data[1] : "";
                cache = data.length > 2 ? data[2].split("Cache Information") : [];
                lines = processor.split("\n");
              }
              result.brand = modelline.split("@")[0].trim();
              result.speed = modelline.split("@")[1] ? parseFloat(modelline.split("@")[1].trim()) : 0;
              if (result.speed === 0 && (result.brand.indexOf("AMD") > -1 || result.brand.toLowerCase().indexOf("ryzen") > -1)) {
                result.speed = getAMDSpeed(result.brand);
              }
              if (result.speed === 0) {
                const current = getCpuCurrentSpeedSync();
                if (current.avg !== 0) {
                  result.speed = current.avg;
                }
              }
              _cpu_speed = result.speed;
              result.speedMin = result.speed;
              result.speedMax = Math.round(parseFloat(util.getValue(lines, "max speed").replace(/Mhz/g, "")) / 10) / 100;
              result = cpuBrandManufacturer(result);
              result.vendor = cpuManufacturer(util.getValue(lines, "manufacturer"));
              let sig = util.getValue(lines, "signature");
              sig = sig.split(",");
              for (let i = 0;i < sig.length; i++) {
                sig[i] = sig[i].trim();
              }
              result.family = util.getValue(sig, "Family", " ", true);
              result.model = util.getValue(sig, "Model", " ", true);
              result.stepping = util.getValue(sig, "Stepping", " ", true);
              result.revision = "";
              const voltage = parseFloat(util.getValue(lines, "voltage"));
              result.voltage = isNaN(voltage) ? "" : voltage.toFixed(2);
              for (let i = 0;i < cache.length; i++) {
                lines = cache[i].split("\n");
                let cacheType = util.getValue(lines, "Socket Designation").toLowerCase().replace(" ", "-").split("-");
                cacheType = cacheType.length ? cacheType[0] : "";
                const sizeParts = util.getValue(lines, "Installed Size").split(" ");
                let size2 = parseInt(sizeParts[0], 10);
                const unit = sizeParts.length > 1 ? sizeParts[1] : "kb";
                size2 = size2 * (unit === "kb" ? 1024 : unit === "mb" ? 1024 * 1024 : unit === "gb" ? 1024 * 1024 * 1024 : 1);
                if (cacheType) {
                  if (cacheType === "l1") {
                    result.cache[cacheType + "d"] = size2 / 2;
                    result.cache[cacheType + "i"] = size2 / 2;
                  } else {
                    result.cache[cacheType] = size2;
                  }
                }
              }
              result.socket = util.getValue(lines, "Upgrade").replace("Socket", "").trim();
              const threadCount = util.getValue(lines, "thread count").trim();
              const coreCount = util.getValue(lines, "core count").trim();
              if (coreCount && threadCount) {
                result.cores = parseInt(threadCount, 10);
                result.physicalCores = parseInt(coreCount, 10);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            resolve(result);
          }
          if (_windows) {
            try {
              const workload = [];
              workload.push(util.powerShell("Get-CimInstance Win32_processor | select Name, Revision, L2CacheSize, L3CacheSize, Manufacturer, MaxClockSpeed, Description, UpgradeMethod, Caption, NumberOfLogicalProcessors, NumberOfCores | fl"));
              workload.push(util.powerShell("Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl"));
              workload.push(util.powerShell("(Get-CimInstance Win32_ComputerSystem).HypervisorPresent"));
              Promise.all(workload).then((data) => {
                let lines = data[0].split("\r\n");
                let name2 = util.getValue(lines, "name", ":") || "";
                if (name2.indexOf("@") >= 0) {
                  result.brand = name2.split("@")[0].trim();
                  result.speed = name2.split("@")[1] ? parseFloat(name2.split("@")[1].trim()) : 0;
                  _cpu_speed = result.speed;
                } else {
                  result.brand = name2.trim();
                  result.speed = 0;
                }
                result = cpuBrandManufacturer(result);
                result.revision = util.getValue(lines, "revision", ":");
                result.vendor = util.getValue(lines, "manufacturer", ":");
                result.speedMax = Math.round(parseFloat(util.getValue(lines, "maxclockspeed", ":").replace(/,/g, ".")) / 10) / 100;
                if (result.speed === 0 && (result.brand.indexOf("AMD") > -1 || result.brand.toLowerCase().indexOf("ryzen") > -1)) {
                  result.speed = getAMDSpeed(result.brand);
                }
                if (result.speed === 0) {
                  result.speed = result.speedMax;
                }
                result.speedMin = result.speed;
                let description2 = util.getValue(lines, "description", ":").split(" ");
                for (let i = 0;i < description2.length; i++) {
                  if (description2[i].toLowerCase().startsWith("family") && i + 1 < description2.length && description2[i + 1]) {
                    result.family = description2[i + 1];
                  }
                  if (description2[i].toLowerCase().startsWith("model") && i + 1 < description2.length && description2[i + 1]) {
                    result.model = description2[i + 1];
                  }
                  if (description2[i].toLowerCase().startsWith("stepping") && i + 1 < description2.length && description2[i + 1]) {
                    result.stepping = description2[i + 1];
                  }
                }
                const socketId = util.getValue(lines, "UpgradeMethod", ":");
                if (socketTypes[socketId]) {
                  result.socket = socketTypes[socketId];
                }
                const socketByName = getSocketTypesByName(name2);
                if (socketByName) {
                  result.socket = socketByName;
                }
                const countProcessors = util.countLines(lines, "Caption");
                const countThreads = util.getValue(lines, "NumberOfLogicalProcessors", ":");
                const countCores = util.getValue(lines, "NumberOfCores", ":");
                if (countProcessors) {
                  result.processors = parseInt(countProcessors) || 1;
                }
                if (countCores && countThreads) {
                  result.cores = parseInt(countThreads) || util.cores();
                  result.physicalCores = parseInt(countCores) || util.cores();
                }
                if (countProcessors > 1) {
                  result.cores = result.cores * countProcessors;
                  result.physicalCores = result.physicalCores * countProcessors;
                }
                result.cache = parseWinCache(data[0], data[1]);
                const hyperv = data[2] ? data[2].toString().toLowerCase() : "";
                result.virtualization = hyperv.indexOf("true") !== -1;
                resolve(result);
              });
            } catch (e) {
              resolve(result);
            }
          }
        });
      });
    });
  };
  var cpu = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        getCpu().then((result) => {
          if (callback) {
            callback(result);
          }
          resolve(result);
        });
      });
    });
  };
  var getCpuCurrentSpeedSync = function() {
    let cpus = os.cpus();
    let minFreq = 999999999;
    let maxFreq = 0;
    let avgFreq = 0;
    let cores = [];
    if (cpus && cpus.length) {
      for (let i in cpus) {
        if ({}.hasOwnProperty.call(cpus, i)) {
          let freq = cpus[i].speed > 100 ? (cpus[i].speed + 1) / 1000 : cpus[i].speed / 10;
          avgFreq = avgFreq + freq;
          if (freq > maxFreq) {
            maxFreq = freq;
          }
          if (freq < minFreq) {
            minFreq = freq;
          }
          cores.push(parseFloat(freq.toFixed(2)));
        }
      }
      avgFreq = avgFreq / cpus.length;
      return {
        min: parseFloat(minFreq.toFixed(2)),
        max: parseFloat(maxFreq.toFixed(2)),
        avg: parseFloat(avgFreq.toFixed(2)),
        cores
      };
    } else {
      return {
        min: 0,
        max: 0,
        avg: 0,
        cores
      };
    }
  };
  var cpuCurrentSpeed = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = getCpuCurrentSpeedSync();
        if (result.avg === 0 && _cpu_speed !== 0) {
          const currCpuSpeed = parseFloat(_cpu_speed);
          result = {
            min: currCpuSpeed,
            max: currCpuSpeed,
            avg: currCpuSpeed,
            cores: []
          };
        }
        if (callback) {
          callback(result);
        }
        resolve(result);
      });
    });
  };
  var cpuTemperature = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = {
          main: null,
          cores: [],
          max: null,
          socket: [],
          chipset: null
        };
        if (_linux) {
          try {
            const cmd2 = 'cat /sys/class/thermal/thermal_zone*/type  2>/dev/null; echo "-----"; cat /sys/class/thermal/thermal_zone*/temp 2>/dev/null;';
            const parts = execSync(cmd2).toString().split("-----\n");
            if (parts.length === 2) {
              const lines = parts[0].split("\n");
              const lines2 = parts[1].split("\n");
              for (let i = 0;i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith("acpi") && lines2[i]) {
                  result.socket.push(Math.round(parseInt(lines2[i], 10) / 100) / 10);
                }
                if (line.startsWith("pch") && lines2[i]) {
                  result.chipset = Math.round(parseInt(lines2[i], 10) / 100) / 10;
                }
              }
            }
          } catch (e) {
            util.noop();
          }
          const cmd = 'for mon in /sys/class/hwmon/hwmon*; do for label in "$mon"/temp*_label; do if [ -f $label ]; then value=${label%_*}_input; echo $(cat "$label")___$(cat "$value"); fi; done; done;';
          try {
            exec(cmd, function(error, stdout) {
              stdout = stdout.toString();
              const tdiePos = stdout.toLowerCase().indexOf("tdie");
              if (tdiePos !== -1) {
                stdout = stdout.substring(tdiePos);
              }
              let lines = stdout.split("\n");
              let tctl = 0;
              lines.forEach((line) => {
                const parts = line.split("___");
                const label = parts[0];
                const value = parts.length > 1 && parts[1] ? parts[1] : "0";
                if (value && label && label.toLowerCase() === "tctl") {
                  tctl = result.main = Math.round(parseInt(value, 10) / 100) / 10;
                }
                if (value && (label === undefined || label && label.toLowerCase().startsWith("core"))) {
                  result.cores.push(Math.round(parseInt(value, 10) / 100) / 10);
                } else if (value && label && result.main === null && (label.toLowerCase().indexOf("package") >= 0 || label.toLowerCase().indexOf("physical") >= 0 || label.toLowerCase() === "tccd1")) {
                  result.main = Math.round(parseInt(value, 10) / 100) / 10;
                }
              });
              if (tctl && result.main === null) {
                result.main = tctl;
              }
              if (result.cores.length > 0) {
                if (result.main === null) {
                  result.main = Math.round(result.cores.reduce((a, b) => a + b, 0) / result.cores.length);
                }
                let maxtmp = Math.max.apply(Math, result.cores);
                result.max = maxtmp > result.main ? maxtmp : result.main;
              }
              if (result.main !== null) {
                if (result.max === null) {
                  result.max = result.main;
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
                return;
              }
              exec("sensors", function(error2, stdout2) {
                if (!error2) {
                  let lines2 = stdout2.toString().split("\n");
                  let tdieTemp = null;
                  let newSectionStarts = true;
                  let section = "";
                  lines2.forEach(function(line) {
                    if (line.trim() === "") {
                      newSectionStarts = true;
                    } else if (newSectionStarts) {
                      if (line.trim().toLowerCase().startsWith("acpi")) {
                        section = "acpi";
                      }
                      if (line.trim().toLowerCase().startsWith("pch")) {
                        section = "pch";
                      }
                      if (line.trim().toLowerCase().startsWith("core")) {
                        section = "core";
                      }
                      newSectionStarts = false;
                    }
                    let regex = /[+-]([^]*)/g;
                    let temps = line.match(regex);
                    let firstPart = line.split(":")[0].toUpperCase();
                    if (section === "acpi") {
                      if (firstPart.indexOf("TEMP") !== -1) {
                        result.socket.push(parseFloat(temps));
                      }
                    } else if (section === "pch") {
                      if (firstPart.indexOf("TEMP") !== -1 && !result.chipset) {
                        result.chipset = parseFloat(temps);
                      }
                    }
                    if (firstPart.indexOf("PHYSICAL") !== -1 || firstPart.indexOf("PACKAGE") !== -1) {
                      result.main = parseFloat(temps);
                    }
                    if (firstPart.indexOf("CORE ") !== -1) {
                      result.cores.push(parseFloat(temps));
                    }
                    if (firstPart.indexOf("TDIE") !== -1 && tdieTemp === null) {
                      tdieTemp = parseFloat(temps);
                    }
                  });
                  if (result.cores.length > 0) {
                    result.main = Math.round(result.cores.reduce((a, b) => a + b, 0) / result.cores.length);
                    let maxtmp = Math.max.apply(Math, result.cores);
                    result.max = maxtmp > result.main ? maxtmp : result.main;
                  } else {
                    if (result.main === null && tdieTemp !== null) {
                      result.main = tdieTemp;
                      result.max = tdieTemp;
                    }
                  }
                  if (result.main !== null || result.max !== null) {
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                    return;
                  }
                }
                fs.stat("/sys/class/thermal/thermal_zone0/temp", function(err) {
                  if (err === null) {
                    fs.readFile("/sys/class/thermal/thermal_zone0/temp", function(error3, stdout3) {
                      if (!error3) {
                        let lines2 = stdout3.toString().split("\n");
                        if (lines2.length > 0) {
                          result.main = parseFloat(lines2[0]) / 1000;
                          result.max = result.main;
                        }
                      }
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    });
                  } else {
                    exec("/opt/vc/bin/vcgencmd measure_temp", function(error3, stdout3) {
                      if (!error3) {
                        let lines2 = stdout3.toString().split("\n");
                        if (lines2.length > 0 && lines2[0].indexOf("=")) {
                          result.main = parseFloat(lines2[0].split("=")[1]);
                          result.max = result.main;
                        }
                      }
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    });
                  }
                });
              });
            });
          } catch (er) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
        if (_freebsd || _openbsd || _netbsd) {
          exec("sysctl dev.cpu | grep temp", function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              let sum = 0;
              lines.forEach(function(line) {
                const parts = line.split(":");
                if (parts.length > 1) {
                  const temp = parseFloat(parts[1].replace(",", "."));
                  if (temp > result.max) {
                    result.max = temp;
                  }
                  sum = sum + temp;
                  result.cores.push(temp);
                }
              });
              if (result.cores.length) {
                result.main = Math.round(sum / result.cores.length * 100) / 100;
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_darwin) {
          let osxTemp = null;
          try {
            osxTemp = (()=>{throw new Error(`Cannot require module "osx-temperature-sensor"`);})();
          } catch (er) {
            osxTemp = null;
          }
          if (osxTemp) {
            result = osxTemp.cpuTemperature();
            if (result.main) {
              result.main = Math.round(result.main * 100) / 100;
            }
            if (result.max) {
              result.max = Math.round(result.max * 100) / 100;
            }
            if (result.cores && result.cores.length) {
              for (let i = 0;i < result.cores.length; i++) {
                result.cores[i] = Math.round(result.cores[i] * 100) / 100;
              }
            }
          }
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
        if (_sunos) {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
        if (_windows) {
          try {
            util.powerShell('Get-CimInstance MSAcpi_ThermalZoneTemperature -Namespace "root/wmi" | Select CurrentTemperature').then((stdout, error) => {
              if (!error) {
                let sum = 0;
                let lines = stdout.split("\r\n").filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
                lines.forEach(function(line) {
                  let value = (parseInt(line, 10) - 2732) / 10;
                  if (!isNaN(value)) {
                    sum = sum + value;
                    if (value > result.max) {
                      result.max = value;
                    }
                    result.cores.push(value);
                  }
                });
                if (result.cores.length) {
                  result.main = sum / result.cores.length;
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var cpuFlags = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = "";
        if (_windows) {
          try {
            exec('reg query "HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0" /v FeatureSet', util.execOptsWin, function(error, stdout) {
              if (!error) {
                let flag_hex = stdout.split("0x").pop().trim();
                let flag_bin_unpadded = parseInt(flag_hex, 16).toString(2);
                let flag_bin = "0".repeat(32 - flag_bin_unpadded.length) + flag_bin_unpadded;
                let all_flags = [
                  "fpu",
                  "vme",
                  "de",
                  "pse",
                  "tsc",
                  "msr",
                  "pae",
                  "mce",
                  "cx8",
                  "apic",
                  "",
                  "sep",
                  "mtrr",
                  "pge",
                  "mca",
                  "cmov",
                  "pat",
                  "pse-36",
                  "psn",
                  "clfsh",
                  "",
                  "ds",
                  "acpi",
                  "mmx",
                  "fxsr",
                  "sse",
                  "sse2",
                  "ss",
                  "htt",
                  "tm",
                  "ia64",
                  "pbe"
                ];
                for (let f = 0;f < all_flags.length; f++) {
                  if (flag_bin[f] === "1" && all_flags[f] !== "") {
                    result += " " + all_flags[f];
                  }
                }
                result = result.trim().toLowerCase();
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
        if (_linux) {
          try {
            exec("export LC_ALL=C; lscpu; unset LC_ALL", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                lines.forEach(function(line) {
                  if (line.split(":")[0].toUpperCase().indexOf("FLAGS") !== -1) {
                    result = line.split(":")[1].trim().toLowerCase();
                  }
                });
              }
              if (!result) {
                fs.readFile("/proc/cpuinfo", function(error2, stdout2) {
                  if (!error2) {
                    let lines = stdout2.toString().split("\n");
                    result = util.getValue(lines, "features", ":", true).toLowerCase();
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
        if (_freebsd || _openbsd || _netbsd) {
          exec("export LC_ALL=C; dmidecode -t 4 2>/dev/null; unset LC_ALL", function(error, stdout) {
            let flags = [];
            if (!error) {
              let parts = stdout.toString().split("\tFlags:");
              const lines = parts.length > 1 ? parts[1].split("\tVersion:")[0].split("\n") : [];
              lines.forEach(function(line) {
                let flag = (line.indexOf("(") ? line.split("(")[0].toLowerCase() : "").trim().replace(/\t/g, "");
                if (flag) {
                  flags.push(flag);
                }
              });
            }
            result = flags.join(" ").trim().toLowerCase();
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_darwin) {
          exec("sysctl machdep.cpu.features", function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              if (lines.length > 0 && lines[0].indexOf("machdep.cpu.features:") !== -1) {
                result = lines[0].split(":")[1].trim().toLowerCase();
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
      });
    });
  };
  var cpuCache = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = {
          l1d: null,
          l1i: null,
          l2: null,
          l3: null
        };
        if (_linux) {
          try {
            exec("export LC_ALL=C; lscpu; unset LC_ALL", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                lines.forEach(function(line) {
                  let parts = line.split(":");
                  if (parts[0].toUpperCase().indexOf("L1D CACHE") !== -1) {
                    result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts[0].toUpperCase().indexOf("L1I CACHE") !== -1) {
                    result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts[0].toUpperCase().indexOf("L2 CACHE") !== -1) {
                    result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts[0].toUpperCase().indexOf("L3 CACHE") !== -1) {
                    result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                });
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
        if (_freebsd || _openbsd || _netbsd) {
          exec("export LC_ALL=C; dmidecode -t 7 2>/dev/null; unset LC_ALL", function(error, stdout) {
            let cache = [];
            if (!error) {
              const data = stdout.toString();
              cache = data.split("Cache Information");
              cache.shift();
            }
            for (let i = 0;i < cache.length; i++) {
              const lines = cache[i].split("\n");
              let cacheType = util.getValue(lines, "Socket Designation").toLowerCase().replace(" ", "-").split("-");
              cacheType = cacheType.length ? cacheType[0] : "";
              const sizeParts = util.getValue(lines, "Installed Size").split(" ");
              let size2 = parseInt(sizeParts[0], 10);
              const unit = sizeParts.length > 1 ? sizeParts[1] : "kb";
              size2 = size2 * (unit === "kb" ? 1024 : unit === "mb" ? 1024 * 1024 : unit === "gb" ? 1024 * 1024 * 1024 : 1);
              if (cacheType) {
                if (cacheType === "l1") {
                  result.cache[cacheType + "d"] = size2 / 2;
                  result.cache[cacheType + "i"] = size2 / 2;
                } else {
                  result.cache[cacheType] = size2;
                }
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_darwin) {
          exec("sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize", function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              lines.forEach(function(line) {
                let parts = line.split(":");
                if (parts[0].toLowerCase().indexOf("hw.l1icachesize") !== -1) {
                  result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                }
                if (parts[0].toLowerCase().indexOf("hw.l1dcachesize") !== -1) {
                  result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                }
                if (parts[0].toLowerCase().indexOf("hw.l2cachesize") !== -1) {
                  result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                }
                if (parts[0].toLowerCase().indexOf("hw.l3cachesize") !== -1) {
                  result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                }
              });
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
        if (_windows) {
          try {
            const workload = [];
            workload.push(util.powerShell("Get-CimInstance Win32_processor | select L2CacheSize, L3CacheSize | fl"));
            workload.push(util.powerShell("Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl"));
            Promise.all(workload).then((data) => {
              result = parseWinCache(data[0], data[1]);
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var parseWinCache = function(linesProc, linesCache) {
    let result = {
      l1d: null,
      l1i: null,
      l2: null,
      l3: null
    };
    let lines = linesProc.split("\r\n");
    result.l1d = 0;
    result.l1i = 0;
    result.l2 = util.getValue(lines, "l2cachesize", ":");
    result.l3 = util.getValue(lines, "l3cachesize", ":");
    if (result.l2) {
      result.l2 = parseInt(result.l2, 10) * 1024;
    } else {
      result.l2 = 0;
    }
    if (result.l3) {
      result.l3 = parseInt(result.l3, 10) * 1024;
    } else {
      result.l3 = 0;
    }
    const parts = linesCache.split(/\n\s*\n/);
    let l1i = 0;
    let l1d = 0;
    let l2 = 0;
    parts.forEach(function(part) {
      const lines2 = part.split("\r\n");
      const cacheType = util.getValue(lines2, "CacheType");
      const level = util.getValue(lines2, "Level");
      const installedSize = util.getValue(lines2, "InstalledSize");
      if (level === "3" && cacheType === "3") {
        result.l1i = result.l1i + parseInt(installedSize, 10) * 1024;
      }
      if (level === "3" && cacheType === "4") {
        result.l1d = result.l1d + parseInt(installedSize, 10) * 1024;
      }
      if (level === "3" && cacheType === "5") {
        l1i = parseInt(installedSize, 10) / 2;
        l1d = parseInt(installedSize, 10) / 2;
      }
      if (level === "4" && cacheType === "5") {
        l2 = l2 + parseInt(installedSize, 10) * 1024;
      }
    });
    if (!result.l1i && !result.l1d) {
      result.l1i = l1i;
      result.l1d = l1d;
    }
    if (l2) {
      result.l2 = l2;
    }
    return result;
  };
  var getLoad = function() {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let loads = os.loadavg().map(function(x) {
          return x / util.cores();
        });
        let avgLoad = parseFloat(Math.max.apply(Math, loads).toFixed(2));
        let result = {};
        let now = Date.now() - _current_cpu.ms;
        if (now >= 200) {
          _current_cpu.ms = Date.now();
          const cpus = os.cpus().map(function(cpu2) {
            cpu2.times.steal = 0;
            cpu2.times.guest = 0;
            return cpu2;
          });
          let totalUser = 0;
          let totalSystem = 0;
          let totalNice = 0;
          let totalIrq = 0;
          let totalIdle = 0;
          let totalSteal = 0;
          let totalGuest = 0;
          let cores = [];
          _corecount = cpus && cpus.length ? cpus.length : 0;
          if (_linux) {
            try {
              const lines = execSync("cat /proc/stat 2>/dev/null | grep cpu", { encoding: "utf8" }).toString().split("\n");
              if (lines.length > 1) {
                lines.shift();
                if (lines.length === cpus.length) {
                  for (let i = 0;i < lines.length; i++) {
                    let parts = lines[i].split(" ");
                    if (parts.length >= 10) {
                      const steal = parseFloat(parts[8]) || 0;
                      const guest = parseFloat(parts[9]) || 0;
                      cpus[i].times.steal = steal;
                      cpus[i].times.guest = guest;
                    }
                  }
                }
              }
            } catch (e) {
              util.noop();
            }
          }
          for (let i = 0;i < _corecount; i++) {
            const cpu2 = cpus[i].times;
            totalUser += cpu2.user;
            totalSystem += cpu2.sys;
            totalNice += cpu2.nice;
            totalIdle += cpu2.idle;
            totalIrq += cpu2.irq;
            totalSteal += cpu2.steal || 0;
            totalGuest += cpu2.guest || 0;
            let tmpTick = _cpus && _cpus[i] && _cpus[i].totalTick ? _cpus[i].totalTick : 0;
            let tmpLoad = _cpus && _cpus[i] && _cpus[i].totalLoad ? _cpus[i].totalLoad : 0;
            let tmpUser = _cpus && _cpus[i] && _cpus[i].user ? _cpus[i].user : 0;
            let tmpSystem = _cpus && _cpus[i] && _cpus[i].sys ? _cpus[i].sys : 0;
            let tmpNice = _cpus && _cpus[i] && _cpus[i].nice ? _cpus[i].nice : 0;
            let tmpIdle = _cpus && _cpus[i] && _cpus[i].idle ? _cpus[i].idle : 0;
            let tmpIrq = _cpus && _cpus[i] && _cpus[i].irq ? _cpus[i].irq : 0;
            let tmpSteal = _cpus && _cpus[i] && _cpus[i].steal ? _cpus[i].steal : 0;
            let tmpGuest = _cpus && _cpus[i] && _cpus[i].guest ? _cpus[i].guest : 0;
            _cpus[i] = cpu2;
            _cpus[i].totalTick = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].steal + _cpus[i].guest + _cpus[i].idle;
            _cpus[i].totalLoad = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].steal + _cpus[i].guest;
            _cpus[i].currentTick = _cpus[i].totalTick - tmpTick;
            _cpus[i].load = _cpus[i].totalLoad - tmpLoad;
            _cpus[i].loadUser = _cpus[i].user - tmpUser;
            _cpus[i].loadSystem = _cpus[i].sys - tmpSystem;
            _cpus[i].loadNice = _cpus[i].nice - tmpNice;
            _cpus[i].loadIdle = _cpus[i].idle - tmpIdle;
            _cpus[i].loadIrq = _cpus[i].irq - tmpIrq;
            _cpus[i].loadSteal = _cpus[i].steal - tmpSteal;
            _cpus[i].loadGuest = _cpus[i].guest - tmpGuest;
            cores[i] = {};
            cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;
            cores[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;
            cores[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;
            cores[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;
            cores[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;
            cores[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;
            cores[i].loadSteal = _cpus[i].loadSteal / _cpus[i].currentTick * 100;
            cores[i].loadGuest = _cpus[i].loadGuest / _cpus[i].currentTick * 100;
            cores[i].rawLoad = _cpus[i].load;
            cores[i].rawLoadUser = _cpus[i].loadUser;
            cores[i].rawLoadSystem = _cpus[i].loadSystem;
            cores[i].rawLoadNice = _cpus[i].loadNice;
            cores[i].rawLoadIdle = _cpus[i].loadIdle;
            cores[i].rawLoadIrq = _cpus[i].loadIrq;
            cores[i].rawLoadSteal = _cpus[i].loadSteal;
            cores[i].rawLoadGuest = _cpus[i].loadGuest;
          }
          let totalTick = totalUser + totalSystem + totalNice + totalIrq + totalSteal + totalGuest + totalIdle;
          let totalLoad = totalUser + totalSystem + totalNice + totalIrq + totalSteal + totalGuest;
          let currentTick = totalTick - _current_cpu.tick;
          result = {
            avgLoad,
            currentLoad: (totalLoad - _current_cpu.load) / currentTick * 100,
            currentLoadUser: (totalUser - _current_cpu.user) / currentTick * 100,
            currentLoadSystem: (totalSystem - _current_cpu.system) / currentTick * 100,
            currentLoadNice: (totalNice - _current_cpu.nice) / currentTick * 100,
            currentLoadIdle: (totalIdle - _current_cpu.idle) / currentTick * 100,
            currentLoadIrq: (totalIrq - _current_cpu.irq) / currentTick * 100,
            currentLoadSteal: (totalSteal - _current_cpu.steal) / currentTick * 100,
            currentLoadGuest: (totalGuest - _current_cpu.guest) / currentTick * 100,
            rawCurrentLoad: totalLoad - _current_cpu.load,
            rawCurrentLoadUser: totalUser - _current_cpu.user,
            rawCurrentLoadSystem: totalSystem - _current_cpu.system,
            rawCurrentLoadNice: totalNice - _current_cpu.nice,
            rawCurrentLoadIdle: totalIdle - _current_cpu.idle,
            rawCurrentLoadIrq: totalIrq - _current_cpu.irq,
            rawCurrentLoadSteal: totalSteal - _current_cpu.steal,
            rawCurrentLoadGuest: totalGuest - _current_cpu.guest,
            cpus: cores
          };
          _current_cpu = {
            user: totalUser,
            nice: totalNice,
            system: totalSystem,
            idle: totalIdle,
            irq: totalIrq,
            steal: totalSteal,
            guest: totalGuest,
            tick: totalTick,
            load: totalLoad,
            ms: _current_cpu.ms,
            currentLoad: result.currentLoad,
            currentLoadUser: result.currentLoadUser,
            currentLoadSystem: result.currentLoadSystem,
            currentLoadNice: result.currentLoadNice,
            currentLoadIdle: result.currentLoadIdle,
            currentLoadIrq: result.currentLoadIrq,
            currentLoadSteal: result.currentLoadSteal,
            currentLoadGuest: result.currentLoadGuest,
            rawCurrentLoad: result.rawCurrentLoad,
            rawCurrentLoadUser: result.rawCurrentLoadUser,
            rawCurrentLoadSystem: result.rawCurrentLoadSystem,
            rawCurrentLoadNice: result.rawCurrentLoadNice,
            rawCurrentLoadIdle: result.rawCurrentLoadIdle,
            rawCurrentLoadIrq: result.rawCurrentLoadIrq,
            rawCurrentLoadSteal: result.rawCurrentLoadSteal,
            rawCurrentLoadGuest: result.rawCurrentLoadGuest
          };
        } else {
          let cores = [];
          for (let i = 0;i < _corecount; i++) {
            cores[i] = {};
            cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;
            cores[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;
            cores[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;
            cores[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;
            cores[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;
            cores[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;
            cores[i].rawLoad = _cpus[i].load;
            cores[i].rawLoadUser = _cpus[i].loadUser;
            cores[i].rawLoadSystem = _cpus[i].loadSystem;
            cores[i].rawLoadNice = _cpus[i].loadNice;
            cores[i].rawLoadIdle = _cpus[i].loadIdle;
            cores[i].rawLoadIrq = _cpus[i].loadIrq;
            cores[i].rawLoadSteal = _cpus[i].loadSteal;
            cores[i].rawLoadGuest = _cpus[i].loadGuest;
          }
          result = {
            avgLoad,
            currentLoad: _current_cpu.currentLoad,
            currentLoadUser: _current_cpu.currentLoadUser,
            currentLoadSystem: _current_cpu.currentLoadSystem,
            currentLoadNice: _current_cpu.currentLoadNice,
            currentLoadIdle: _current_cpu.currentLoadIdle,
            currentLoadIrq: _current_cpu.currentLoadIrq,
            currentLoadSteal: _current_cpu.currentLoadSteal,
            currentLoadGuest: _current_cpu.currentLoadGuest,
            rawCurrentLoad: _current_cpu.rawCurrentLoad,
            rawCurrentLoadUser: _current_cpu.rawCurrentLoadUser,
            rawCurrentLoadSystem: _current_cpu.rawCurrentLoadSystem,
            rawCurrentLoadNice: _current_cpu.rawCurrentLoadNice,
            rawCurrentLoadIdle: _current_cpu.rawCurrentLoadIdle,
            rawCurrentLoadIrq: _current_cpu.rawCurrentLoadIrq,
            rawCurrentLoadSteal: _current_cpu.rawCurrentLoadSteal,
            rawCurrentLoadGuest: _current_cpu.rawCurrentLoadGuest,
            cpus: cores
          };
        }
        resolve(result);
      });
    });
  };
  var currentLoad = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        getLoad().then((result) => {
          if (callback) {
            callback(result);
          }
          resolve(result);
        });
      });
    });
  };
  var getFullLoad = function() {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const cpus = os.cpus();
        let totalUser = 0;
        let totalSystem = 0;
        let totalNice = 0;
        let totalIrq = 0;
        let totalIdle = 0;
        let result = 0;
        if (cpus && cpus.length) {
          for (let i = 0, len = cpus.length;i < len; i++) {
            const cpu2 = cpus[i].times;
            totalUser += cpu2.user;
            totalSystem += cpu2.sys;
            totalNice += cpu2.nice;
            totalIrq += cpu2.irq;
            totalIdle += cpu2.idle;
          }
          let totalTicks = totalIdle + totalIrq + totalNice + totalSystem + totalUser;
          result = (totalTicks - totalIdle) / totalTicks * 100;
        }
        resolve(result);
      });
    });
  };
  var fullLoad = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        getFullLoad().then((result) => {
          if (callback) {
            callback(result);
          }
          resolve(result);
        });
      });
    });
  };
  var os = __require("os");
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var fs = __require("fs");
  var util = require_util4();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  var _cpu_speed = 0;
  var _current_cpu = {
    user: 0,
    nice: 0,
    system: 0,
    idle: 0,
    irq: 0,
    steal: 0,
    guest: 0,
    load: 0,
    tick: 0,
    ms: 0,
    currentLoad: 0,
    currentLoadUser: 0,
    currentLoadSystem: 0,
    currentLoadNice: 0,
    currentLoadIdle: 0,
    currentLoadIrq: 0,
    currentLoadSteal: 0,
    currentLoadGuest: 0,
    rawCurrentLoad: 0,
    rawCurrentLoadUser: 0,
    rawCurrentLoadSystem: 0,
    rawCurrentLoadNice: 0,
    rawCurrentLoadIdle: 0,
    rawCurrentLoadIrq: 0,
    rawCurrentLoadSteal: 0,
    rawCurrentLoadGuest: 0
  };
  var _cpus = [];
  var _corecount = 0;
  var AMDBaseFrequencies = {
    "8346": "1.8",
    "8347": "1.9",
    "8350": "2.0",
    "8354": "2.2",
    "8356|SE": "2.4",
    "8356": "2.3",
    "8360": "2.5",
    "2372": "2.1",
    "2373": "2.1",
    "2374": "2.2",
    "2376": "2.3",
    "2377": "2.3",
    "2378": "2.4",
    "2379": "2.4",
    "2380": "2.5",
    "2381": "2.5",
    "2382": "2.6",
    "2384": "2.7",
    "2386": "2.8",
    "2387": "2.8",
    "2389": "2.9",
    "2393": "3.1",
    "8374": "2.2",
    "8376": "2.3",
    "8378": "2.4",
    "8379": "2.4",
    "8380": "2.5",
    "8381": "2.5",
    "8382": "2.6",
    "8384": "2.7",
    "8386": "2.8",
    "8387": "2.8",
    "8389": "2.9",
    "8393": "3.1",
    "2419EE": "1.8",
    "2423HE": "2.0",
    "2425HE": "2.1",
    "2427": "2.2",
    "2431": "2.4",
    "2435": "2.6",
    "2439SE": "2.8",
    "8425HE": "2.1",
    "8431": "2.4",
    "8435": "2.6",
    "8439SE": "2.8",
    "4122": "2.2",
    "4130": "2.6",
    "4162EE": "1.7",
    "4164EE": "1.8",
    "4170HE": "2.1",
    "4174HE": "2.3",
    "4176HE": "2.4",
    "4180": "2.6",
    "4184": "2.8",
    "6124HE": "1.8",
    "6128HE": "2.0",
    "6132HE": "2.2",
    "6128": "2.0",
    "6134": "2.3",
    "6136": "2.4",
    "6140": "2.6",
    "6164HE": "1.7",
    "6166HE": "1.8",
    "6168": "1.9",
    "6172": "2.1",
    "6174": "2.2",
    "6176": "2.3",
    "6176SE": "2.3",
    "6180SE": "2.5",
    "3250": "2.5",
    "3260": "2.7",
    "3280": "2.4",
    "4226": "2.7",
    "4228": "2.8",
    "4230": "2.9",
    "4234": "3.1",
    "4238": "3.3",
    "4240": "3.4",
    "4256": "1.6",
    "4274": "2.5",
    "4276": "2.6",
    "4280": "2.8",
    "4284": "3.0",
    "6204": "3.3",
    "6212": "2.6",
    "6220": "3.0",
    "6234": "2.4",
    "6238": "2.6",
    "6262HE": "1.6",
    "6272": "2.1",
    "6274": "2.2",
    "6276": "2.3",
    "6278": "2.4",
    "6282SE": "2.6",
    "6284SE": "2.7",
    "6308": "3.5",
    "6320": "2.8",
    "6328": "3.2",
    "6338P": "2.3",
    "6344": "2.6",
    "6348": "2.8",
    "6366": "1.8",
    "6370P": "2.0",
    "6376": "2.3",
    "6378": "2.4",
    "6380": "2.5",
    "6386": "2.8",
    "FX|4100": "3.6",
    "FX|4120": "3.9",
    "FX|4130": "3.8",
    "FX|4150": "3.8",
    "FX|4170": "4.2",
    "FX|6100": "3.3",
    "FX|6120": "3.6",
    "FX|6130": "3.6",
    "FX|6200": "3.8",
    "FX|8100": "2.8",
    "FX|8120": "3.1",
    "FX|8140": "3.2",
    "FX|8150": "3.6",
    "FX|8170": "3.9",
    "FX|4300": "3.8",
    "FX|4320": "4.0",
    "FX|4350": "4.2",
    "FX|6300": "3.5",
    "FX|6350": "3.9",
    "FX|8300": "3.3",
    "FX|8310": "3.4",
    "FX|8320": "3.5",
    "FX|8350": "4.0",
    "FX|8370": "4.0",
    "FX|9370": "4.4",
    "FX|9590": "4.7",
    "FX|8320E": "3.2",
    "FX|8370E": "3.3",
    "1200": "3.1",
    "Pro 1200": "3.1",
    "1300X": "3.5",
    "Pro 1300": "3.5",
    "1400": "3.2",
    "1500X": "3.5",
    "Pro 1500": "3.5",
    "1600": "3.2",
    "1600X": "3.6",
    "Pro 1600": "3.2",
    "1700": "3.0",
    "Pro 1700": "3.0",
    "1700X": "3.4",
    "Pro 1700X": "3.4",
    "1800X": "3.6",
    "1900X": "3.8",
    "1920": "3.2",
    "1920X": "3.5",
    "1950X": "3.4",
    "200GE": "3.2",
    "Pro 200GE": "3.2",
    "220GE": "3.4",
    "240GE": "3.5",
    "3000G": "3.5",
    "300GE": "3.4",
    "3050GE": "3.4",
    "2200G": "3.5",
    "Pro 2200G": "3.5",
    "2200GE": "3.2",
    "Pro 2200GE": "3.2",
    "2400G": "3.6",
    "Pro 2400G": "3.6",
    "2400GE": "3.2",
    "Pro 2400GE": "3.2",
    "Pro 200U": "2.3",
    "300U": "2.4",
    "2200U": "2.5",
    "3200U": "2.6",
    "2300U": "2.0",
    "Pro 2300U": "2.0",
    "2500U": "2.0",
    "Pro 2500U": "2.2",
    "2600H": "3.2",
    "2700U": "2.0",
    "Pro 2700U": "2.2",
    "2800H": "3.3",
    "7351": "2.4",
    "7351P": "2.4",
    "7401": "2.0",
    "7401P": "2.0",
    "7551P": "2.0",
    "7551": "2.0",
    "7251": "2.1",
    "7261": "2.5",
    "7281": "2.1",
    "7301": "2.2",
    "7371": "3.1",
    "7451": "2.3",
    "7501": "2.0",
    "7571": "2.2",
    "7601": "2.2",
    V1500B: "2.2",
    V1780B: "3.35",
    V1202B: "2.3",
    V1404I: "2.0",
    V1605B: "2.0",
    V1756B: "3.25",
    V1807B: "3.35",
    "3101": "2.1",
    "3151": "2.7",
    "3201": "1.5",
    "3251": "2.5",
    "3255": "2.5",
    "3301": "2.0",
    "3351": "1.9",
    "3401": "1.85",
    "3451": "2.15",
    "1200|AF": "3.1",
    "2300X": "3.5",
    "2500X": "3.6",
    "2600": "3.4",
    "2600E": "3.1",
    "1600|AF": "3.2",
    "2600X": "3.6",
    "2700": "3.2",
    "2700E": "2.8",
    "Pro 2700": "3.2",
    "2700X": "3.7",
    "Pro 2700X": "3.6",
    "2920X": "3.5",
    "2950X": "3.5",
    "2970WX": "3.0",
    "2990WX": "3.0",
    "Pro 300GE": "3.4",
    "Pro 3125GE": "3.4",
    "3150G": "3.5",
    "Pro 3150G": "3.5",
    "3150GE": "3.3",
    "Pro 3150GE": "3.3",
    "3200G": "3.6",
    "Pro 3200G": "3.6",
    "3200GE": "3.3",
    "Pro 3200GE": "3.3",
    "3350G": "3.6",
    "Pro 3350G": "3.6",
    "3350GE": "3.3",
    "Pro 3350GE": "3.3",
    "3400G": "3.7",
    "Pro 3400G": "3.7",
    "3400GE": "3.3",
    "Pro 3400GE": "3.3",
    "3300U": "2.1",
    "PRO 3300U": "2.1",
    "3450U": "2.1",
    "3500U": "2.1",
    "PRO 3500U": "2.1",
    "3500C": "2.1",
    "3550H": "2.1",
    "3580U": "2.1",
    "3700U": "2.3",
    "PRO 3700U": "2.3",
    "3700C": "2.3",
    "3750H": "2.3",
    "3780U": "2.3",
    "3100": "3.6",
    "3300X": "3.8",
    "3500": "3.6",
    "3500X": "3.6",
    "3600": "3.6",
    "Pro 3600": "3.6",
    "3600X": "3.8",
    "3600XT": "3.8",
    "Pro 3700": "3.6",
    "3700X": "3.6",
    "3800X": "3.9",
    "3800XT": "3.9",
    "3900": "3.1",
    "Pro 3900": "3.1",
    "3900X": "3.8",
    "3900XT": "3.8",
    "3950X": "3.5",
    "3960X": "3.8",
    "3970X": "3.7",
    "3990X": "2.9",
    "3945WX": "4.0",
    "3955WX": "3.9",
    "3975WX": "3.5",
    "3995WX": "2.7",
    "4300GE": "3.5",
    "Pro 4300GE": "3.5",
    "4300G": "3.8",
    "Pro 4300G": "3.8",
    "4600GE": "3.3",
    "Pro 4650GE": "3.3",
    "4600G": "3.7",
    "Pro 4650G": "3.7",
    "4700GE": "3.1",
    "Pro 4750GE": "3.1",
    "4700G": "3.6",
    "Pro 4750G": "3.6",
    "4300U": "2.7",
    "4450U": "2.5",
    "Pro 4450U": "2.5",
    "4500U": "2.3",
    "4600U": "2.1",
    "PRO 4650U": "2.1",
    "4680U": "2.1",
    "4600HS": "3.0",
    "4600H": "3.0",
    "4700U": "2.0",
    "PRO 4750U": "1.7",
    "4800U": "1.8",
    "4800HS": "2.9",
    "4800H": "2.9",
    "4900HS": "3.0",
    "4900H": "3.3",
    "5300U": "2.6",
    "5500U": "2.1",
    "5700U": "1.8",
    "7232P": "3.1",
    "7302P": "3.0",
    "7402P": "2.8",
    "7502P": "2.5",
    "7702P": "2.0",
    "7252": "3.1",
    "7262": "3.2",
    "7272": "2.9",
    "7282": "2.8",
    "7302": "3.0",
    "7352": "2.3",
    "7402": "2.8",
    "7452": "2.35",
    "7502": "2.5",
    "7532": "2.4",
    "7542": "2.9",
    "7552": "2.2",
    "7642": "2.3",
    "7662": "2.0",
    "7702": "2.0",
    "7742": "2.25",
    "7H12": "2.6",
    "7F32": "3.7",
    "7F52": "3.5",
    "7F72": "3.2",
    "7773X": "2.2",
    "7763": "2.45",
    "7713": "2.0",
    "7713P": "2.0",
    "7663": "2.0",
    "7643": "2.3",
    "7573X": "2.8",
    "75F3": "2.95",
    "7543": "2.8",
    "7543P": "2.8",
    "7513": "2.6",
    "7473X": "2.8",
    "7453": "2.75",
    "74F3": "3.2",
    "7443": "2.85",
    "7443P": "2.85",
    "7413": "2.65",
    "7373X": "3.05",
    "73F3": "3.5",
    "7343": "3.2",
    "7313": "3.0",
    "7313P": "3.0",
    "72F3": "3.7",
    "5600X": "3.7",
    "5800X": "3.8",
    "5900X": "3.7",
    "5950X": "3.4",
    "5945WX": "4.1",
    "5955WX": "4.0",
    "5965WX": "3.8",
    "5975WX": "3.6",
    "5995WX": "2.7",
    "7960X": "4.2",
    "7970X": "4.0",
    "7980X": "3.2",
    "7965WX": "4.2",
    "7975WX": "4.0",
    "7985WX": "3.2",
    "7995WX": "2.5",
    "9754": "2.25",
    "9754S": "2.25",
    "9734": "2.2",
    "9684X": "2.55",
    "9384X": "3.1",
    "9184X": "3.55",
    "9654P": "2.4",
    "9654": "2.4",
    "9634": "2.25",
    "9554P": "3.1",
    "9554": "3.1",
    "9534": "2.45",
    "9474F": "3.6",
    "9454P": "2.75",
    "9454": "2.75",
    "9374F": "3.85",
    "9354P": "3.25",
    "9354": "3.25",
    "9334": "2.7",
    "9274F": "4.05",
    "9254": "2.9",
    "9224": "2.5",
    "9174F": "4.1",
    "9124": "3.0"
  };
  var socketTypes = {
    1: "Other",
    2: "Unknown",
    3: "Daughter Board",
    4: "ZIF Socket",
    5: "Replacement/Piggy Back",
    6: "None",
    7: "LIF Socket",
    8: "Slot 1",
    9: "Slot 2",
    10: "370 Pin Socket",
    11: "Slot A",
    12: "Slot M",
    13: "423",
    14: "A (Socket 462)",
    15: "478",
    16: "754",
    17: "940",
    18: "939",
    19: "mPGA604",
    20: "LGA771",
    21: "LGA775",
    22: "S1",
    23: "AM2",
    24: "F (1207)",
    25: "LGA1366",
    26: "G34",
    27: "AM3",
    28: "C32",
    29: "LGA1156",
    30: "LGA1567",
    31: "PGA988A",
    32: "BGA1288",
    33: "rPGA988B",
    34: "BGA1023",
    35: "BGA1224",
    36: "LGA1155",
    37: "LGA1356",
    38: "LGA2011",
    39: "FS1",
    40: "FS2",
    41: "FM1",
    42: "FM2",
    43: "LGA2011-3",
    44: "LGA1356-3",
    45: "LGA1150",
    46: "BGA1168",
    47: "BGA1234",
    48: "BGA1364",
    49: "AM4",
    50: "LGA1151",
    51: "BGA1356",
    52: "BGA1440",
    53: "BGA1515",
    54: "LGA3647-1",
    55: "SP3",
    56: "SP3r2",
    57: "LGA2066",
    58: "BGA1392",
    59: "BGA1510",
    60: "BGA1528",
    61: "LGA4189",
    62: "LGA1200",
    63: "LGA4677",
    64: "LGA1700",
    65: "BGA1744",
    66: "BGA1781",
    67: "BGA1211",
    68: "BGA2422",
    69: "LGA1211",
    70: "LGA2422",
    71: "LGA5773",
    72: "BGA5773"
  };
  var socketTypesByName = {
    LGA1150: "i7-5775C i3-4340 i3-4170 G3250 i3-4160T i3-4160 E3-1231 G3258 G3240 i7-4790S i7-4790K i7-4790 i5-4690K i5-4690 i5-4590T i5-4590S i5-4590 i5-4460 i3-4360 i3-4150 G1820 G3420 G3220 i7-4771 i5-4440 i3-4330 i3-4130T i3-4130 E3-1230 i7-4770S i7-4770K i7-4770 i5-4670K i5-4670 i5-4570T i5-4570S i5-4570 i5-4430",
    LGA1151: "i9-9900KS E-2288G E-2224 G5420 i9-9900T i9-9900 i7-9700T i7-9700F i7-9700E i7-9700 i5-9600 i5-9500T i5-9500F i5-9500 i5-9400T i3-9350K i3-9300 i3-9100T i3-9100F i3-9100 G4930 i9-9900KF i7-9700KF i5-9600KF i5-9400F i5-9400 i3-9350KF i9-9900K i7-9700K i5-9600K G5500 G5400 i7-8700T i7-8086K i5-8600 i5-8500T i5-8500 i5-8400T i3-8300 i3-8100T G4900 i7-8700K i7-8700 i5-8600K i5-8400 i3-8350K i3-8100 E3-1270 G4600 G4560 i7-7700T i7-7700K i7-7700 i5-7600K i5-7600 i5-7500T i5-7500 i5-7400 i3-7350K i3-7300 i3-7100T i3-7100 G3930 G3900 G4400 i7-6700T i7-6700K i7-6700 i5-6600K i5-6600 i5-6500T i5-6500 i5-6400T i5-6400 i3-6300 i3-6100T i3-6100 E3-1270 E3-1270 T4500 T4400",
    "1155": "G440 G460 G465 G470 G530T G540T G550T G1610T G1620T G530 G540 G1610 G550 G1620 G555 G1630 i3-2100T i3-2120T i3-3220T i3-3240T i3-3250T i3-2100 i3-2105 i3-2102 i3-3210 i3-3220 i3-2125 i3-2120 i3-3225 i3-2130 i3-3245 i3-3240 i3-3250 i5-3570T i5-2500T i5-2400S i5-2405S i5-2390T i5-3330S i5-2500S i5-3335S i5-2300 i5-3450S i5-3340S i5-3470S i5-3475S i5-3470T i5-2310 i5-3550S i5-2320 i5-3330 i5-3350P i5-3450 i5-2400 i5-3340 i5-3570S i5-2380P i5-2450P i5-3470 i5-2500K i5-3550 i5-2500 i5-3570 i5-3570K i5-2550K i7-3770T i7-2600S i7-3770S i7-2600K i7-2600 i7-3770 i7-3770K i7-2700K G620T G630T G640T G2020T G645T G2100T G2030T G622 G860T G620 G632 G2120T G630 G640 G2010 G840 G2020 G850 G645 G2030 G860 G2120 G870 G2130 G2140 E3-1220L E3-1220L E3-1260L E3-1265L E3-1220 E3-1225 E3-1220 E3-1235 E3-1225 E3-1230 E3-1230 E3-1240 E3-1245 E3-1270 E3-1275 E3-1240 E3-1245 E3-1270 E3-1280 E3-1275 E3-1290 E3-1280 E3-1290"
  };
  exports2.cpu = cpu;
  exports2.cpuCurrentSpeed = cpuCurrentSpeed;
  exports2.cpuTemperature = cpuTemperature;
  exports2.cpuFlags = cpuFlags;
  exports2.cpuCache = cpuCache;
  exports2.currentLoad = currentLoad;
  exports2.fullLoad = fullLoad;
});

// ../../node_modules/systeminformation/lib/memory.js
var require_memory = __commonJS((exports2) => {
  var mem = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = {
          total: os.totalmem(),
          free: os.freemem(),
          used: os.totalmem() - os.freemem(),
          active: os.totalmem() - os.freemem(),
          available: os.freemem(),
          buffers: 0,
          cached: 0,
          slab: 0,
          buffcache: 0,
          swaptotal: 0,
          swapused: 0,
          swapfree: 0,
          writeback: null,
          dirty: null
        };
        if (_linux) {
          try {
            fs.readFile("/proc/meminfo", function(error, stdout) {
              if (!error) {
                const lines = stdout.toString().split("\n");
                result.total = parseInt(util.getValue(lines, "memtotal"), 10);
                result.total = result.total ? result.total * 1024 : os.totalmem();
                result.free = parseInt(util.getValue(lines, "memfree"), 10);
                result.free = result.free ? result.free * 1024 : os.freemem();
                result.used = result.total - result.free;
                result.buffers = parseInt(util.getValue(lines, "buffers"), 10);
                result.buffers = result.buffers ? result.buffers * 1024 : 0;
                result.cached = parseInt(util.getValue(lines, "cached"), 10);
                result.cached = result.cached ? result.cached * 1024 : 0;
                result.slab = parseInt(util.getValue(lines, "slab"), 10);
                result.slab = result.slab ? result.slab * 1024 : 0;
                result.buffcache = result.buffers + result.cached + result.slab;
                let available = parseInt(util.getValue(lines, "memavailable"), 10);
                result.available = available ? available * 1024 : result.free + result.buffcache;
                result.active = result.total - result.available;
                result.swaptotal = parseInt(util.getValue(lines, "swaptotal"), 10);
                result.swaptotal = result.swaptotal ? result.swaptotal * 1024 : 0;
                result.swapfree = parseInt(util.getValue(lines, "swapfree"), 10);
                result.swapfree = result.swapfree ? result.swapfree * 1024 : 0;
                result.swapused = result.swaptotal - result.swapfree;
                result.writeback = parseInt(util.getValue(lines, "writeback"), 10);
                result.writeback = result.writeback ? result.writeback * 1024 : 0;
                result.dirty = parseInt(util.getValue(lines, "dirty"), 10);
                result.dirty = result.dirty ? result.dirty * 1024 : 0;
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
        if (_freebsd || _openbsd || _netbsd) {
          try {
            exec("/sbin/sysctl hw.realmem hw.physmem vm.stats.vm.v_page_count vm.stats.vm.v_wire_count vm.stats.vm.v_active_count vm.stats.vm.v_inactive_count vm.stats.vm.v_cache_count vm.stats.vm.v_free_count vm.stats.vm.v_page_size", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                const pagesize = parseInt(util.getValue(lines, "vm.stats.vm.v_page_size"), 10);
                const inactive = parseInt(util.getValue(lines, "vm.stats.vm.v_inactive_count"), 10) * pagesize;
                const cache = parseInt(util.getValue(lines, "vm.stats.vm.v_cache_count"), 10) * pagesize;
                result.total = parseInt(util.getValue(lines, "hw.realmem"), 10);
                if (isNaN(result.total)) {
                  result.total = parseInt(util.getValue(lines, "hw.physmem"), 10);
                }
                result.free = parseInt(util.getValue(lines, "vm.stats.vm.v_free_count"), 10) * pagesize;
                result.buffcache = inactive + cache;
                result.available = result.buffcache + result.free;
                result.active = result.total - result.free - result.buffcache;
                result.swaptotal = 0;
                result.swapfree = 0;
                result.swapused = 0;
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
        if (_sunos) {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
        if (_darwin) {
          let pageSize = 4096;
          try {
            let sysPpageSize = util.toInt(execSync("sysctl -n vm.pagesize").toString());
            pageSize = sysPpageSize || pageSize;
          } catch (e) {
            util.noop();
          }
          try {
            exec('vm_stat 2>/dev/null | grep "Pages active"', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result.active = parseInt(lines[0].split(":")[1], 10) * pageSize;
                result.buffcache = result.used - result.active;
                result.available = result.free + result.buffcache;
              }
              exec("sysctl -n vm.swapusage 2>/dev/null", function(error2, stdout2) {
                if (!error2) {
                  let lines = stdout2.toString().split("\n");
                  if (lines.length > 0) {
                    let firstline = lines[0].replace(/,/g, ".").replace(/M/g, "");
                    let lineArray = firstline.trim().split("  ");
                    lineArray.forEach((line) => {
                      if (line.toLowerCase().indexOf("total") !== -1) {
                        result.swaptotal = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                      }
                      if (line.toLowerCase().indexOf("used") !== -1) {
                        result.swapused = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                      }
                      if (line.toLowerCase().indexOf("free") !== -1) {
                        result.swapfree = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                      }
                    });
                  }
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
        if (_windows) {
          let swaptotal = 0;
          let swapused = 0;
          try {
            util.powerShell("Get-CimInstance Win32_PageFileUsage | Select AllocatedBaseSize, CurrentUsage").then((stdout, error) => {
              if (!error) {
                let lines = stdout.split("\r\n").filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
                lines.forEach(function(line) {
                  if (line !== "") {
                    line = line.trim().split(/\s\s+/);
                    swaptotal = swaptotal + (parseInt(line[0], 10) || 0);
                    swapused = swapused + (parseInt(line[1], 10) || 0);
                  }
                });
              }
              result.swaptotal = swaptotal * 1024 * 1024;
              result.swapused = swapused * 1024 * 1024;
              result.swapfree = result.swaptotal - result.swapused;
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var memLayout = function(callback) {
    function getManufacturerDarwin(manId) {
      if ({}.hasOwnProperty.call(OSX_RAM_manufacturers, manId)) {
        return OSX_RAM_manufacturers[manId];
      }
      return manId;
    }
    function getManufacturerLinux(manId) {
      const manIdSearch = manId.replace("0x", "").toUpperCase();
      if (manIdSearch.length === 4 && {}.hasOwnProperty.call(LINUX_RAM_manufacturers, manIdSearch)) {
        return LINUX_RAM_manufacturers[manIdSearch];
      }
      return manId;
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = [];
        if (_linux || _freebsd || _openbsd || _netbsd) {
          exec('export LC_ALL=C; dmidecode -t memory 2>/dev/null | grep -iE "Size:|Type|Speed|Manufacturer|Form Factor|Locator|Memory Device|Serial Number|Voltage|Part Number"; unset LC_ALL', function(error, stdout) {
            if (!error) {
              let devices = stdout.toString().split("Memory Device");
              devices.shift();
              devices.forEach(function(device) {
                let lines = device.split("\n");
                const sizeString = util.getValue(lines, "Size");
                const size2 = sizeString.indexOf("GB") >= 0 ? parseInt(sizeString, 10) * 1024 * 1024 * 1024 : parseInt(sizeString, 10) * 1024 * 1024;
                let bank = util.getValue(lines, "Bank Locator");
                if (bank.toLowerCase().indexOf("bad") >= 0) {
                  bank = "";
                }
                if (parseInt(util.getValue(lines, "Size"), 10) > 0) {
                  const totalWidth = util.toInt(util.getValue(lines, "Total Width"));
                  const dataWidth = util.toInt(util.getValue(lines, "Data Width"));
                  result.push({
                    size: size2,
                    bank,
                    type: util.getValue(lines, "Type:"),
                    ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,
                    clockSpeed: util.getValue(lines, "Configured Clock Speed:") ? parseInt(util.getValue(lines, "Configured Clock Speed:"), 10) : util.getValue(lines, "Speed:") ? parseInt(util.getValue(lines, "Speed:"), 10) : null,
                    formFactor: util.getValue(lines, "Form Factor:"),
                    manufacturer: getManufacturerLinux(util.getValue(lines, "Manufacturer:")),
                    partNum: util.getValue(lines, "Part Number:"),
                    serialNum: util.getValue(lines, "Serial Number:"),
                    voltageConfigured: parseFloat(util.getValue(lines, "Configured Voltage:")) || null,
                    voltageMin: parseFloat(util.getValue(lines, "Minimum Voltage:")) || null,
                    voltageMax: parseFloat(util.getValue(lines, "Maximum Voltage:")) || null
                  });
                } else {
                  result.push({
                    size: 0,
                    bank,
                    type: "Empty",
                    ecc: null,
                    clockSpeed: 0,
                    formFactor: util.getValue(lines, "Form Factor:"),
                    partNum: "",
                    serialNum: "",
                    voltageConfigured: null,
                    voltageMin: null,
                    voltageMax: null
                  });
                }
              });
            }
            if (!result.length) {
              result.push({
                size: os.totalmem(),
                bank: "",
                type: "",
                ecc: null,
                clockSpeed: 0,
                formFactor: "",
                partNum: "",
                serialNum: "",
                voltageConfigured: null,
                voltageMin: null,
                voltageMax: null
              });
              try {
                let stdout2 = execSync("cat /proc/cpuinfo 2>/dev/null");
                let lines = stdout2.toString().split("\n");
                let model = util.getValue(lines, "hardware", ":", true).toUpperCase();
                let version3 = util.getValue(lines, "revision", ":", true).toLowerCase();
                if (model === "BCM2835" || model === "BCM2708" || model === "BCM2709" || model === "BCM2835" || model === "BCM2837") {
                  const clockSpeed = {
                    "0": 400,
                    "1": 450,
                    "2": 450,
                    "3": 3200
                  };
                  result[0].type = "LPDDR2";
                  result[0].type = version3 && version3[2] && version3[2] === "3" ? "LPDDR4" : result[0].type;
                  result[0].ecc = false;
                  result[0].clockSpeed = version3 && version3[2] && clockSpeed[version3[2]] || 400;
                  result[0].clockSpeed = version3 && version3[4] && version3[4] === "d" ? 500 : result[0].clockSpeed;
                  result[0].formFactor = "SoC";
                  stdout2 = execSync("vcgencmd get_config sdram_freq 2>/dev/null");
                  lines = stdout2.toString().split("\n");
                  let freq = parseInt(util.getValue(lines, "sdram_freq", "=", true), 10) || 0;
                  if (freq) {
                    result[0].clockSpeed = freq;
                  }
                  stdout2 = execSync("vcgencmd measure_volts sdram_p 2>/dev/null");
                  lines = stdout2.toString().split("\n");
                  let voltage = parseFloat(util.getValue(lines, "volt", "=", true)) || 0;
                  if (voltage) {
                    result[0].voltageConfigured = voltage;
                    result[0].voltageMin = voltage;
                    result[0].voltageMax = voltage;
                  }
                }
              } catch (e) {
                util.noop();
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_darwin) {
          exec("system_profiler SPMemoryDataType", function(error, stdout) {
            if (!error) {
              const allLines = stdout.toString().split("\n");
              const eccStatus = util.getValue(allLines, "ecc", ":", true).toLowerCase();
              let devices = stdout.toString().split("        BANK ");
              let hasBank = true;
              if (devices.length === 1) {
                devices = stdout.toString().split("        DIMM");
                hasBank = false;
              }
              devices.shift();
              devices.forEach(function(device) {
                let lines = device.split("\n");
                const bank = (hasBank ? "BANK " : "DIMM") + lines[0].trim().split("/")[0];
                const size2 = parseInt(util.getValue(lines, "          Size"));
                if (size2) {
                  result.push({
                    size: size2 * 1024 * 1024 * 1024,
                    bank,
                    type: util.getValue(lines, "          Type:"),
                    ecc: eccStatus ? eccStatus === "enabled" : null,
                    clockSpeed: parseInt(util.getValue(lines, "          Speed:"), 10),
                    formFactor: "",
                    manufacturer: getManufacturerDarwin(util.getValue(lines, "          Manufacturer:")),
                    partNum: util.getValue(lines, "          Part Number:"),
                    serialNum: util.getValue(lines, "          Serial Number:"),
                    voltageConfigured: null,
                    voltageMin: null,
                    voltageMax: null
                  });
                } else {
                  result.push({
                    size: 0,
                    bank,
                    type: "Empty",
                    ecc: null,
                    clockSpeed: 0,
                    formFactor: "",
                    manufacturer: "",
                    partNum: "",
                    serialNum: "",
                    voltageConfigured: null,
                    voltageMin: null,
                    voltageMax: null
                  });
                }
              });
            }
            if (!result.length) {
              const lines = stdout.toString().split("\n");
              const size2 = parseInt(util.getValue(lines, "      Memory:"));
              const type2 = util.getValue(lines, "      Type:");
              if (size2 && type2) {
                result.push({
                  size: size2 * 1024 * 1024 * 1024,
                  bank: "0",
                  type: type2,
                  ecc: false,
                  clockSpeed: 0,
                  formFactor: "",
                  manufacturer: "Apple",
                  partNum: "",
                  serialNum: "",
                  voltageConfigured: null,
                  voltageMin: null,
                  voltageMax: null
                });
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
        if (_windows) {
          const memoryTypes = "Unknown|Other|DRAM|Synchronous DRAM|Cache DRAM|EDO|EDRAM|VRAM|SRAM|RAM|ROM|FLASH|EEPROM|FEPROM|EPROM|CDRAM|3DRAM|SDRAM|SGRAM|RDRAM|DDR|DDR2|DDR2 FB-DIMM|Reserved|DDR3|FBD2|DDR4|LPDDR|LPDDR2|LPDDR3|LPDDR4|Logical non-volatile device|HBM|HBM2|DDR5|LPDDR5".split("|");
          const FormFactors = "Unknown|Other|SIP|DIP|ZIP|SOJ|Proprietary|SIMM|DIMM|TSOP|PGA|RIMM|SODIMM|SRIMM|SMD|SSMP|QFP|TQFP|SOIC|LCC|PLCC|BGA|FPBGA|LGA".split("|");
          try {
            util.powerShell("Get-CimInstance Win32_PhysicalMemory | select DataWidth,TotalWidth,Capacity,BankLabel,MemoryType,SMBIOSMemoryType,ConfiguredClockSpeed,FormFactor,Manufacturer,PartNumber,SerialNumber,ConfiguredVoltage,MinVoltage,MaxVoltage,Tag | fl").then((stdout, error) => {
              if (!error) {
                let devices = stdout.toString().split(/\n\s*\n/);
                devices.shift();
                devices.forEach(function(device) {
                  let lines = device.split("\r\n");
                  const dataWidth = util.toInt(util.getValue(lines, "DataWidth", ":"));
                  const totalWidth = util.toInt(util.getValue(lines, "TotalWidth", ":"));
                  const size2 = parseInt(util.getValue(lines, "Capacity", ":"), 10) || 0;
                  const tag = util.getValue(lines, "Tag", ":");
                  const tagInt = util.splitByNumber(tag);
                  if (size2) {
                    result.push({
                      size: size2,
                      bank: util.getValue(lines, "BankLabel", ":") + (tagInt[1] ? "/" + tagInt[1] : ""),
                      type: memoryTypes[parseInt(util.getValue(lines, "MemoryType", ":"), 10) || parseInt(util.getValue(lines, "SMBIOSMemoryType", ":"), 10)],
                      ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,
                      clockSpeed: parseInt(util.getValue(lines, "ConfiguredClockSpeed", ":"), 10) || parseInt(util.getValue(lines, "Speed", ":"), 10) || 0,
                      formFactor: FormFactors[parseInt(util.getValue(lines, "FormFactor", ":"), 10) || 0],
                      manufacturer: util.getValue(lines, "Manufacturer", ":"),
                      partNum: util.getValue(lines, "PartNumber", ":"),
                      serialNum: util.getValue(lines, "SerialNumber", ":"),
                      voltageConfigured: (parseInt(util.getValue(lines, "ConfiguredVoltage", ":"), 10) || 0) / 1000,
                      voltageMin: (parseInt(util.getValue(lines, "MinVoltage", ":"), 10) || 0) / 1000,
                      voltageMax: (parseInt(util.getValue(lines, "MaxVoltage", ":"), 10) || 0) / 1000
                    });
                  }
                });
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var os = __require("os");
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var util = require_util4();
  var fs = __require("fs");
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  var OSX_RAM_manufacturers = {
    "0x014F": "Transcend Information",
    "0x2C00": "Micron Technology Inc.",
    "0x802C": "Micron Technology Inc.",
    "0x80AD": "Hynix Semiconductor Inc.",
    "0x80CE": "Samsung Electronics Inc.",
    "0xAD00": "Hynix Semiconductor Inc.",
    "0xCE00": "Samsung Electronics Inc.",
    "0x02FE": "Elpida",
    "0x5105": "Qimonda AG i. In.",
    "0x8551": "Qimonda AG i. In.",
    "0x859B": "Crucial",
    "0x04CD": "G-Skill"
  };
  var LINUX_RAM_manufacturers = {
    "017A": "Apacer",
    "0198": "HyperX",
    "029E": "Corsair",
    "04CB": "A-DATA",
    "04CD": "G-Skill",
    "059B": "Crucial",
    "00CE": "Samsung",
    "1315": "Crucial",
    "014F": "Transcend Information",
    "2C00": "Micron Technology Inc.",
    "802C": "Micron Technology Inc.",
    "80AD": "Hynix Semiconductor Inc.",
    "80CE": "Samsung Electronics Inc.",
    AD00: "Hynix Semiconductor Inc.",
    CE00: "Samsung Electronics Inc.",
    "02FE": "Elpida",
    "5105": "Qimonda AG i. In.",
    "8551": "Qimonda AG i. In.",
    "859B": "Crucial"
  };
  exports2.mem = mem;
  exports2.memLayout = memLayout;
});

// ../../node_modules/systeminformation/lib/battery.js
var require_battery = __commonJS((exports2, module2) => {
  var parseWinBatteryPart = function(lines, designedCapacity, fullChargeCapacity) {
    const result = {};
    let status = util.getValue(lines, "BatteryStatus", ":").trim();
    if (status >= 0) {
      const statusValue = status ? parseInt(status) : 0;
      result.status = statusValue;
      result.hasBattery = true;
      result.maxCapacity = fullChargeCapacity || parseInt(util.getValue(lines, "DesignCapacity", ":") || 0);
      result.designedCapacity = parseInt(util.getValue(lines, "DesignCapacity", ":") || designedCapacity);
      result.voltage = parseInt(util.getValue(lines, "DesignVoltage", ":") || 0) / 1000;
      result.capacityUnit = "mWh";
      result.percent = parseInt(util.getValue(lines, "EstimatedChargeRemaining", ":") || 0);
      result.currentCapacity = parseInt(result.maxCapacity * result.percent / 100);
      result.isCharging = statusValue >= 6 && statusValue <= 9 || statusValue === 11 || statusValue !== 3 && statusValue !== 1 && result.percent < 100;
      result.acConnected = result.isCharging || statusValue === 2;
      result.model = util.getValue(lines, "DeviceID", ":");
    } else {
      result.status = -1;
    }
    return result;
  };
  var exec = __require("child_process").exec;
  var fs = __require("fs");
  var util = require_util4();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  module2.exports = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = {
          hasBattery: false,
          cycleCount: 0,
          isCharging: false,
          designedCapacity: 0,
          maxCapacity: 0,
          currentCapacity: 0,
          voltage: 0,
          capacityUnit: "",
          percent: 0,
          timeRemaining: null,
          acConnected: true,
          type: "",
          model: "",
          manufacturer: "",
          serial: ""
        };
        if (_linux) {
          let battery_path = "";
          if (fs.existsSync("/sys/class/power_supply/BAT1/uevent")) {
            battery_path = "/sys/class/power_supply/BAT1/";
          } else if (fs.existsSync("/sys/class/power_supply/BAT0/uevent")) {
            battery_path = "/sys/class/power_supply/BAT0/";
          }
          let acConnected = false;
          let acPath = "";
          if (fs.existsSync("/sys/class/power_supply/AC/online")) {
            acPath = "/sys/class/power_supply/AC/online";
          } else if (fs.existsSync("/sys/class/power_supply/AC0/online")) {
            acPath = "/sys/class/power_supply/AC0/online";
          }
          if (acPath) {
            const file = fs.readFileSync(acPath);
            acConnected = file.toString().trim() === "1";
          }
          if (battery_path) {
            fs.readFile(battery_path + "uevent", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result.isCharging = util.getValue(lines, "POWER_SUPPLY_STATUS", "=").toLowerCase() === "charging";
                result.acConnected = acConnected || result.isCharging;
                result.voltage = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_VOLTAGE_NOW", "="), 10) / 1e6;
                result.capacityUnit = result.voltage ? "mWh" : "mAh";
                result.cycleCount = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CYCLE_COUNT", "="), 10);
                result.maxCapacity = Math.round(parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_FULL", "=", true, true), 10) / 1000 * (result.voltage || 1));
                const desingedMinVoltage = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_VOLTAGE_MIN_DESIGN", "="), 10) / 1e6;
                result.designedCapacity = Math.round(parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_FULL_DESIGN", "=", true, true), 10) / 1000 * (desingedMinVoltage || result.voltage || 1));
                result.currentCapacity = Math.round(parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_NOW", "="), 10) / 1000 * (result.voltage || 1));
                if (!result.maxCapacity) {
                  result.maxCapacity = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_FULL", "=", true, true), 10) / 1000;
                  result.designedCapacity = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_FULL_DESIGN", "=", true, true), 10) / 1000 | result.maxCapacity;
                  result.currentCapacity = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_NOW", "="), 10) / 1000;
                }
                const percent = util.getValue(lines, "POWER_SUPPLY_CAPACITY", "=");
                const energy = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_NOW", "="), 10);
                const power = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_POWER_NOW", "="), 10);
                const current = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CURRENT_NOW", "="), 10);
                const charge = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_NOW", "="), 10);
                result.percent = parseInt("0" + percent, 10);
                if (result.maxCapacity && result.currentCapacity) {
                  result.hasBattery = true;
                  if (!percent) {
                    result.percent = 100 * result.currentCapacity / result.maxCapacity;
                  }
                }
                if (result.isCharging) {
                  result.hasBattery = true;
                }
                if (energy && power) {
                  result.timeRemaining = Math.floor(energy / power * 60);
                } else if (current && charge) {
                  result.timeRemaining = Math.floor(charge / current * 60);
                } else if (current && result.currentCapacity) {
                  result.timeRemaining = Math.floor(result.currentCapacity / current * 60);
                }
                result.type = util.getValue(lines, "POWER_SUPPLY_TECHNOLOGY", "=");
                result.model = util.getValue(lines, "POWER_SUPPLY_MODEL_NAME", "=");
                result.manufacturer = util.getValue(lines, "POWER_SUPPLY_MANUFACTURER", "=");
                result.serial = util.getValue(lines, "POWER_SUPPLY_SERIAL_NUMBER", "=");
                if (callback) {
                  callback(result);
                }
                resolve(result);
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          } else {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
        if (_freebsd || _openbsd || _netbsd) {
          exec("sysctl -i hw.acpi.battery hw.acpi.acline", function(error, stdout) {
            let lines = stdout.toString().split("\n");
            const batteries = parseInt("0" + util.getValue(lines, "hw.acpi.battery.units"), 10);
            const percent = parseInt("0" + util.getValue(lines, "hw.acpi.battery.life"), 10);
            result.hasBattery = batteries > 0;
            result.cycleCount = null;
            result.isCharging = util.getValue(lines, "hw.acpi.acline") !== "1";
            result.acConnected = result.isCharging;
            result.maxCapacity = null;
            result.currentCapacity = null;
            result.capacityUnit = "unknown";
            result.percent = batteries ? percent : null;
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_darwin) {
          exec('ioreg -n AppleSmartBattery -r | egrep "CycleCount|IsCharging|DesignCapacity|MaxCapacity|CurrentCapacity|BatterySerialNumber|TimeRemaining|Voltage"; pmset -g batt | grep %', function(error, stdout) {
            if (stdout) {
              let lines = stdout.toString().replace(/ +/g, "").replace(/"+/g, "").replace(/-/g, "").split("\n");
              result.cycleCount = parseInt("0" + util.getValue(lines, "cyclecount", "="), 10);
              result.voltage = parseInt("0" + util.getValue(lines, "voltage", "="), 10) / 1000;
              result.capacityUnit = result.voltage ? "mWh" : "mAh";
              result.maxCapacity = Math.round(parseInt("0" + util.getValue(lines, "applerawmaxcapacity", "="), 10) * (result.voltage || 1));
              result.currentCapacity = Math.round(parseInt("0" + util.getValue(lines, "applerawcurrentcapacity", "="), 10) * (result.voltage || 1));
              result.designedCapacity = Math.round(parseInt("0" + util.getValue(lines, "DesignCapacity", "="), 10) * (result.voltage || 1));
              result.manufacturer = "Apple";
              result.serial = util.getValue(lines, "BatterySerialNumber", "=");
              let percent = null;
              const line = util.getValue(lines, "internal", "Battery");
              let parts = line.split(";");
              if (parts && parts[0]) {
                let parts2 = parts[0].split("\t");
                if (parts2 && parts2[1]) {
                  percent = parseFloat(parts2[1].trim().replace(/%/g, ""));
                }
              }
              if (parts && parts[1]) {
                result.isCharging = parts[1].trim() === "charging";
                result.acConnected = parts[1].trim() !== "discharging";
              } else {
                result.isCharging = util.getValue(lines, "ischarging", "=").toLowerCase() === "yes";
                result.acConnected = result.isCharging;
              }
              if (result.maxCapacity && result.currentCapacity) {
                result.hasBattery = true;
                result.type = "Li-ion";
                result.percent = percent !== null ? percent : Math.round(100 * result.currentCapacity / result.maxCapacity);
                if (!result.isCharging) {
                  result.timeRemaining = parseInt("0" + util.getValue(lines, "TimeRemaining", "="), 10);
                }
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
        if (_windows) {
          try {
            const workload = [];
            workload.push(util.powerShell("Get-CimInstance Win32_Battery | select BatteryStatus, DesignCapacity, DesignVoltage, EstimatedChargeRemaining, DeviceID | fl"));
            workload.push(util.powerShell("(Get-WmiObject -Class BatteryStaticData -Namespace ROOT/WMI).DesignedCapacity"));
            workload.push(util.powerShell("(Get-CimInstance -Class BatteryFullChargedCapacity -Namespace ROOT/WMI).FullChargedCapacity"));
            util.promiseAll(workload).then((data) => {
              if (data) {
                let parts = data.results[0].split(/\n\s*\n/);
                let batteries = [];
                const hasValue = (value) => /\S/.test(value);
                for (let i = 0;i < parts.length; i++) {
                  if (hasValue(parts[i]) && (!batteries.length || !hasValue(parts[i - 1]))) {
                    batteries.push([]);
                  }
                  if (hasValue(parts[i])) {
                    batteries[batteries.length - 1].push(parts[i]);
                  }
                }
                let designCapacities = data.results[1].split("\r\n").filter((e) => e);
                let fullChargeCapacities = data.results[2].split("\r\n").filter((e) => e);
                if (batteries.length) {
                  let first = false;
                  let additionalBatteries = [];
                  for (let i = 0;i < batteries.length; i++) {
                    let lines = batteries[i][0].split("\r\n");
                    const designedCapacity = designCapacities && designCapacities.length >= i + 1 && designCapacities[i] ? util.toInt(designCapacities[i]) : 0;
                    const fullChargeCapacity = fullChargeCapacities && fullChargeCapacities.length >= i + 1 && fullChargeCapacities[i] ? util.toInt(fullChargeCapacities[i]) : 0;
                    const parsed = parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity);
                    if (!first && parsed.status > 0 && parsed.status !== 10) {
                      result.hasBattery = parsed.hasBattery;
                      result.maxCapacity = parsed.maxCapacity;
                      result.designedCapacity = parsed.designedCapacity;
                      result.voltage = parsed.voltage;
                      result.capacityUnit = parsed.capacityUnit;
                      result.percent = parsed.percent;
                      result.currentCapacity = parsed.currentCapacity;
                      result.isCharging = parsed.isCharging;
                      result.acConnected = parsed.acConnected;
                      result.model = parsed.model;
                      first = true;
                    } else if (parsed.status !== -1) {
                      additionalBatteries.push({
                        hasBattery: parsed.hasBattery,
                        maxCapacity: parsed.maxCapacity,
                        designedCapacity: parsed.designedCapacity,
                        voltage: parsed.voltage,
                        capacityUnit: parsed.capacityUnit,
                        percent: parsed.percent,
                        currentCapacity: parsed.currentCapacity,
                        isCharging: parsed.isCharging,
                        timeRemaining: null,
                        acConnected: parsed.acConnected,
                        model: parsed.model,
                        type: "",
                        manufacturer: "",
                        serial: ""
                      });
                    }
                  }
                  if (!first && additionalBatteries.length) {
                    result = additionalBatteries[0];
                    additionalBatteries.shift();
                  }
                  if (additionalBatteries.length) {
                    result.additionalBatteries = additionalBatteries;
                  }
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
});

// ../../node_modules/systeminformation/lib/graphics.js
var require_graphics = __commonJS((exports2) => {
  var getVendorFromModel = function(model) {
    const manufacturers = [
      { pattern: "^LG.+", manufacturer: "LG" },
      { pattern: "^BENQ.+", manufacturer: "BenQ" },
      { pattern: "^ASUS.+", manufacturer: "Asus" },
      { pattern: "^DELL.+", manufacturer: "Dell" },
      { pattern: "^SAMSUNG.+", manufacturer: "Samsung" },
      { pattern: "^VIEWSON.+", manufacturer: "ViewSonic" },
      { pattern: "^SONY.+", manufacturer: "Sony" },
      { pattern: "^ACER.+", manufacturer: "Acer" },
      { pattern: "^AOC.+", manufacturer: "AOC Monitors" },
      { pattern: "^HP.+", manufacturer: "HP" },
      { pattern: "^EIZO.?", manufacturer: "Eizo" },
      { pattern: "^PHILIPS.?", manufacturer: "Philips" },
      { pattern: "^IIYAMA.?", manufacturer: "Iiyama" },
      { pattern: "^SHARP.?", manufacturer: "Sharp" },
      { pattern: "^NEC.?", manufacturer: "NEC" },
      { pattern: "^LENOVO.?", manufacturer: "Lenovo" },
      { pattern: "COMPAQ.?", manufacturer: "Compaq" },
      { pattern: "APPLE.?", manufacturer: "Apple" },
      { pattern: "INTEL.?", manufacturer: "Intel" },
      { pattern: "AMD.?", manufacturer: "AMD" },
      { pattern: "NVIDIA.?", manufacturer: "NVDIA" }
    ];
    let result = "";
    if (model) {
      model = model.toUpperCase();
      manufacturers.forEach((manufacturer) => {
        const re = RegExp(manufacturer.pattern);
        if (re.test(model)) {
          result = manufacturer.manufacturer;
        }
      });
    }
    return result;
  };
  var getVendorFromId = function(id2) {
    const vendors = {
      "610": "Apple",
      "1e6d": "LG",
      "10ac": "DELL",
      "4dd9": "Sony",
      "38a3": "NEC"
    };
    return vendors[id2] || "";
  };
  var vendorToId = function(str) {
    let result = "";
    str = (str || "").toLowerCase();
    if (str.indexOf("apple") >= 0) {
      result = "0x05ac";
    } else if (str.indexOf("nvidia") >= 0) {
      result = "0x10de";
    } else if (str.indexOf("intel") >= 0) {
      result = "0x8086";
    } else if (str.indexOf("ati") >= 0 || str.indexOf("amd") >= 0) {
      result = "0x1002";
    }
    return result;
  };
  var getMetalVersion = function(id2) {
    const families = {
      spdisplays_mtlgpufamilymac1: "mac1",
      spdisplays_mtlgpufamilymac2: "mac2",
      spdisplays_mtlgpufamilyapple1: "apple1",
      spdisplays_mtlgpufamilyapple2: "apple2",
      spdisplays_mtlgpufamilyapple3: "apple3",
      spdisplays_mtlgpufamilyapple4: "apple4",
      spdisplays_mtlgpufamilyapple5: "apple5",
      spdisplays_mtlgpufamilyapple6: "apple6",
      spdisplays_mtlgpufamilyapple7: "apple7",
      spdisplays_metalfeaturesetfamily11: "family1_v1",
      spdisplays_metalfeaturesetfamily12: "family1_v2",
      spdisplays_metalfeaturesetfamily13: "family1_v3",
      spdisplays_metalfeaturesetfamily14: "family1_v4",
      spdisplays_metalfeaturesetfamily21: "family2_v1"
    };
    return families[id2] || "";
  };
  var graphics = function(callback) {
    function parseLinesDarwin(graphicsArr) {
      const res = {
        controllers: [],
        displays: []
      };
      try {
        graphicsArr.forEach(function(item) {
          const bus = (item.sppci_bus || "").indexOf("builtin") > -1 ? "Built-In" : (item.sppci_bus || "").indexOf("pcie") > -1 ? "PCIe" : "";
          const vram = (parseInt(item.spdisplays_vram || "", 10) || 0) * ((item.spdisplays_vram || "").indexOf("GB") > -1 ? 1024 : 1);
          const vramDyn = (parseInt(item.spdisplays_vram_shared || "", 10) || 0) * ((item.spdisplays_vram_shared || "").indexOf("GB") > -1 ? 1024 : 1);
          let metalVersion = getMetalVersion(item.spdisplays_metal || item.spdisplays_metalfamily || "");
          res.controllers.push({
            vendor: getVendorFromModel(item.spdisplays_vendor || "") || item.spdisplays_vendor || "",
            model: item.sppci_model || "",
            bus,
            vramDynamic: bus === "Built-In",
            vram: vram || vramDyn || null,
            deviceId: item["spdisplays_device-id"] || "",
            vendorId: item["spdisplays_vendor-id"] || vendorToId((item["spdisplays_vendor"] || "") + (item.sppci_model || "")),
            external: item.sppci_device_type === "spdisplays_egpu",
            cores: item["sppci_cores"] || null,
            metalVersion
          });
          if (item.spdisplays_ndrvs && item.spdisplays_ndrvs.length) {
            item.spdisplays_ndrvs.forEach(function(displayItem) {
              const connectionType = displayItem["spdisplays_connection_type"] || "";
              const currentResolutionParts = (displayItem["_spdisplays_resolution"] || "").split("@");
              const currentResolution = currentResolutionParts[0].split("x");
              const pixelParts = (displayItem["_spdisplays_pixels"] || "").split("x");
              const pixelDepthString = displayItem["spdisplays_depth"] || "";
              const serial = displayItem["_spdisplays_display-serial-number"] || displayItem["_spdisplays_display-serial-number2"] || null;
              res.displays.push({
                vendor: getVendorFromId(displayItem["_spdisplays_display-vendor-id"] || "") || getVendorFromModel(displayItem["_name"] || ""),
                vendorId: displayItem["_spdisplays_display-vendor-id"] || "",
                model: displayItem["_name"] || "",
                productionYear: displayItem["_spdisplays_display-year"] || null,
                serial: serial !== "0" ? serial : null,
                displayId: displayItem["_spdisplays_displayID"] || null,
                main: displayItem["spdisplays_main"] ? displayItem["spdisplays_main"] === "spdisplays_yes" : false,
                builtin: (displayItem["spdisplays_display_type"] || "").indexOf("built-in") > -1,
                connection: connectionType.indexOf("_internal") > -1 ? "Internal" : connectionType.indexOf("_displayport") > -1 ? "Display Port" : connectionType.indexOf("_hdmi") > -1 ? "HDMI" : null,
                sizeX: null,
                sizeY: null,
                pixelDepth: pixelDepthString === "CGSThirtyBitColor" ? 30 : pixelDepthString === "CGSThirtytwoBitColor" ? 32 : pixelDepthString === "CGSTwentyfourBitColor" ? 24 : null,
                resolutionX: pixelParts.length > 1 ? parseInt(pixelParts[0], 10) : null,
                resolutionY: pixelParts.length > 1 ? parseInt(pixelParts[1], 10) : null,
                currentResX: currentResolution.length > 1 ? parseInt(currentResolution[0], 10) : null,
                currentResY: currentResolution.length > 1 ? parseInt(currentResolution[1], 10) : null,
                positionX: 0,
                positionY: 0,
                currentRefreshRate: currentResolutionParts.length > 1 ? parseInt(currentResolutionParts[1], 10) : null
              });
            });
          }
        });
        return res;
      } catch (e) {
        return res;
      }
    }
    function parseLinesLinuxControllers(lines) {
      let controllers = [];
      let currentController = {
        vendor: "",
        subVendor: "",
        model: "",
        bus: "",
        busAddress: "",
        vram: null,
        vramDynamic: false,
        pciID: ""
      };
      let isGraphicsController = false;
      let pciIDs = [];
      try {
        pciIDs = execSync('export LC_ALL=C; dmidecode -t 9 2>/dev/null; unset LC_ALL | grep "Bus Address: "').toString().split("\n");
        for (let i2 = 0;i2 < pciIDs.length; i2++) {
          pciIDs[i2] = pciIDs[i2].replace("Bus Address:", "").replace("0000:", "").trim();
        }
        pciIDs = pciIDs.filter(function(el) {
          return el != null && el;
        });
      } catch (e) {
        util.noop();
      }
      let i = 1;
      lines.forEach((line) => {
        let subsystem = "";
        if (i < lines.length && lines[i]) {
          subsystem = lines[i];
          if (subsystem.indexOf(":") > 0) {
            subsystem = subsystem.split(":")[1];
          }
        }
        if (line.trim() !== "") {
          if (line[0] !== " " && line[0] !== "\t") {
            let isExternal = pciIDs.indexOf(line.split(" ")[0]) >= 0;
            let vgapos = line.toLowerCase().indexOf(" vga ");
            let _3dcontrollerpos = line.toLowerCase().indexOf("3d controller");
            if (vgapos !== -1 || _3dcontrollerpos !== -1) {
              if (_3dcontrollerpos !== -1 && vgapos === -1) {
                vgapos = _3dcontrollerpos;
              }
              if (currentController.vendor || currentController.model || currentController.bus || currentController.vram !== null || currentController.vramDynamic) {
                controllers.push(currentController);
                currentController = {
                  vendor: "",
                  model: "",
                  bus: "",
                  busAddress: "",
                  vram: null,
                  vramDynamic: false
                };
              }
              const pciIDCandidate = line.split(" ")[0];
              if (/[\da-fA-F]{2}:[\da-fA-F]{2}\.[\da-fA-F]/.test(pciIDCandidate)) {
                currentController.busAddress = pciIDCandidate;
              }
              isGraphicsController = true;
              let endpos = line.search(/\[[0-9a-f]{4}:[0-9a-f]{4}]|$/);
              let parts = line.substr(vgapos, endpos - vgapos).split(":");
              currentController.busAddress = line.substr(0, vgapos).trim();
              if (parts.length > 1) {
                parts[1] = parts[1].trim();
                if (parts[1].toLowerCase().indexOf("corporation") >= 0) {
                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("corporation") + 11).trim();
                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("corporation") + 11, 200).split("(")[0].trim();
                  currentController.bus = pciIDs.length > 0 && isExternal ? "PCIe" : "Onboard";
                  currentController.vram = null;
                  currentController.vramDynamic = false;
                } else if (parts[1].toLowerCase().indexOf(" inc.") >= 0) {
                  if ((parts[1].match(/]/g) || []).length > 1) {
                    currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("]") + 1).trim();
                    currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("]") + 1, 200).trim().split("(")[0].trim();
                  } else {
                    currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(" inc.") + 5).trim();
                    currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(" inc.") + 5, 200).trim().split("(")[0].trim();
                  }
                  currentController.bus = pciIDs.length > 0 && isExternal ? "PCIe" : "Onboard";
                  currentController.vram = null;
                  currentController.vramDynamic = false;
                } else if (parts[1].toLowerCase().indexOf(" ltd.") >= 0) {
                  if ((parts[1].match(/]/g) || []).length > 1) {
                    currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("]") + 1).trim();
                    currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("]") + 1, 200).trim().split("(")[0].trim();
                  } else {
                    currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(" ltd.") + 5).trim();
                    currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(" ltd.") + 5, 200).trim().split("(")[0].trim();
                  }
                }
                if (currentController.model && subsystem.indexOf(currentController.model) !== -1) {
                  const subVendor = subsystem.split(currentController.model)[0].trim();
                  if (subVendor) {
                    currentController.subVendor = subVendor;
                  }
                }
              }
            } else {
              isGraphicsController = false;
            }
          }
          if (isGraphicsController) {
            let parts = line.split(":");
            if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("devicename") !== -1 && parts[1].toLowerCase().indexOf("onboard") !== -1) {
              currentController.bus = "Onboard";
            }
            if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("region") !== -1 && parts[1].toLowerCase().indexOf("memory") !== -1) {
              let memparts = parts[1].split("=");
              if (memparts.length > 1) {
                currentController.vram = parseInt(memparts[1]);
              }
            }
          }
        }
        i++;
      });
      if (currentController.vendor || currentController.model || currentController.bus || currentController.busAddress || currentController.vram !== null || currentController.vramDynamic) {
        controllers.push(currentController);
      }
      return controllers;
    }
    function parseLinesLinuxClinfo(controllers, lines) {
      const fieldPattern = /\[([^\]]+)\]\s+(\w+)\s+(.*)/;
      const devices = lines.reduce((devices2, line) => {
        const field = fieldPattern.exec(line.trim());
        if (field) {
          if (!devices2[field[1]]) {
            devices2[field[1]] = {};
          }
          devices2[field[1]][field[2]] = field[3];
        }
        return devices2;
      }, {});
      for (let deviceId in devices) {
        const device = devices[deviceId];
        if (device["CL_DEVICE_TYPE"] === "CL_DEVICE_TYPE_GPU") {
          let busAddress;
          if (device["CL_DEVICE_TOPOLOGY_AMD"]) {
            const bdf = device["CL_DEVICE_TOPOLOGY_AMD"].match(/[a-zA-Z0-9]+:\d+\.\d+/);
            if (bdf) {
              busAddress = bdf[0];
            }
          } else if (device["CL_DEVICE_PCI_BUS_ID_NV"] && device["CL_DEVICE_PCI_SLOT_ID_NV"]) {
            const bus = parseInt(device["CL_DEVICE_PCI_BUS_ID_NV"]);
            const slot = parseInt(device["CL_DEVICE_PCI_SLOT_ID_NV"]);
            if (!isNaN(bus) && !isNaN(slot)) {
              const b = bus & 255;
              const d = slot >> 3 & 255;
              const f = slot & 7;
              busAddress = `${b.toString().padStart(2, "0")}:${d.toString().padStart(2, "0")}.${f}`;
            }
          }
          if (busAddress) {
            let controller = controllers.find((controller2) => controller2.busAddress === busAddress);
            if (!controller) {
              controller = {
                vendor: "",
                model: "",
                bus: "",
                busAddress,
                vram: null,
                vramDynamic: false
              };
              controllers.push(controller);
            }
            controller.vendor = device["CL_DEVICE_VENDOR"];
            if (device["CL_DEVICE_BOARD_NAME_AMD"]) {
              controller.model = device["CL_DEVICE_BOARD_NAME_AMD"];
            } else {
              controller.model = device["CL_DEVICE_NAME"];
            }
            const memory = parseInt(device["CL_DEVICE_GLOBAL_MEM_SIZE"]);
            if (!isNaN(memory)) {
              controller.vram = Math.round(memory / 1024 / 1024);
            }
          }
        }
      }
      return controllers;
    }
    function getNvidiaSmi() {
      if (_nvidiaSmiPath) {
        return _nvidiaSmiPath;
      }
      if (_windows) {
        try {
          const basePath = util.WINDIR + "\\System32\\DriverStore\\FileRepository";
          const candidateDirs = fs.readdirSync(basePath).filter((dir) => {
            return fs.readdirSync([basePath, dir].join("/")).includes("nvidia-smi.exe");
          });
          const targetDir = candidateDirs.reduce((prevDir, currentDir) => {
            const previousNvidiaSmi = fs.statSync([basePath, prevDir, "nvidia-smi.exe"].join("/"));
            const currentNvidiaSmi = fs.statSync([basePath, currentDir, "nvidia-smi.exe"].join("/"));
            return previousNvidiaSmi.ctimeMs > currentNvidiaSmi.ctimeMs ? prevDir : currentDir;
          });
          if (targetDir) {
            _nvidiaSmiPath = [basePath, targetDir, "nvidia-smi.exe"].join("/");
          }
        } catch (e) {
          util.noop();
        }
      } else if (_linux) {
        _nvidiaSmiPath = "nvidia-smi";
      }
      return _nvidiaSmiPath;
    }
    function nvidiaSmi(options2) {
      const nvidiaSmiExe = getNvidiaSmi();
      options2 = options2 || util.execOptsWin;
      if (nvidiaSmiExe) {
        const nvidiaSmiOpts = "--query-gpu=driver_version,pci.sub_device_id,name,pci.bus_id,fan.speed,memory.total,memory.used,memory.free,utilization.gpu,utilization.memory,temperature.gpu,temperature.memory,power.draw,power.limit,clocks.gr,clocks.mem --format=csv,noheader,nounits";
        const cmd = nvidiaSmiExe + " " + nvidiaSmiOpts + (_linux ? "  2>/dev/null" : "");
        try {
          const res = execSync(cmd, options2).toString();
          return res;
        } catch (e) {
          util.noop();
        }
      }
      return "";
    }
    function nvidiaDevices() {
      function safeParseNumber(value) {
        if ([null, undefined].includes(value)) {
          return value;
        }
        return parseFloat(value);
      }
      const stdout = nvidiaSmi();
      if (!stdout) {
        return [];
      }
      const gpus = stdout.split("\n").filter(Boolean);
      let results = gpus.map((gpu) => {
        const splittedData = gpu.split(", ").map((value) => value.includes("N/A") ? undefined : value);
        if (splittedData.length === 16) {
          return {
            driverVersion: splittedData[0],
            subDeviceId: splittedData[1],
            name: splittedData[2],
            pciBus: splittedData[3],
            fanSpeed: safeParseNumber(splittedData[4]),
            memoryTotal: safeParseNumber(splittedData[5]),
            memoryUsed: safeParseNumber(splittedData[6]),
            memoryFree: safeParseNumber(splittedData[7]),
            utilizationGpu: safeParseNumber(splittedData[8]),
            utilizationMemory: safeParseNumber(splittedData[9]),
            temperatureGpu: safeParseNumber(splittedData[10]),
            temperatureMemory: safeParseNumber(splittedData[11]),
            powerDraw: safeParseNumber(splittedData[12]),
            powerLimit: safeParseNumber(splittedData[13]),
            clockCore: safeParseNumber(splittedData[14]),
            clockMemory: safeParseNumber(splittedData[15])
          };
        } else {
          return {};
        }
      });
      results = results.filter((item) => {
        return "pciBus" in item;
      });
      return results;
    }
    function mergeControllerNvidia(controller, nvidia) {
      if (nvidia.driverVersion) {
        controller.driverVersion = nvidia.driverVersion;
      }
      if (nvidia.subDeviceId) {
        controller.subDeviceId = nvidia.subDeviceId;
      }
      if (nvidia.name) {
        controller.name = nvidia.name;
      }
      if (nvidia.pciBus) {
        controller.pciBus = nvidia.pciBus;
      }
      if (nvidia.fanSpeed) {
        controller.fanSpeed = nvidia.fanSpeed;
      }
      if (nvidia.memoryTotal) {
        controller.memoryTotal = nvidia.memoryTotal;
        controller.vram = nvidia.memoryTotal;
        controller.vramDynamic = false;
      }
      if (nvidia.memoryUsed) {
        controller.memoryUsed = nvidia.memoryUsed;
      }
      if (nvidia.memoryFree) {
        controller.memoryFree = nvidia.memoryFree;
      }
      if (nvidia.utilizationGpu) {
        controller.utilizationGpu = nvidia.utilizationGpu;
      }
      if (nvidia.utilizationMemory) {
        controller.utilizationMemory = nvidia.utilizationMemory;
      }
      if (nvidia.temperatureGpu) {
        controller.temperatureGpu = nvidia.temperatureGpu;
      }
      if (nvidia.temperatureMemory) {
        controller.temperatureMemory = nvidia.temperatureMemory;
      }
      if (nvidia.powerDraw) {
        controller.powerDraw = nvidia.powerDraw;
      }
      if (nvidia.powerLimit) {
        controller.powerLimit = nvidia.powerLimit;
      }
      if (nvidia.clockCore) {
        controller.clockCore = nvidia.clockCore;
      }
      if (nvidia.clockMemory) {
        controller.clockMemory = nvidia.clockMemory;
      }
      return controller;
    }
    function parseLinesLinuxEdid(edid) {
      let result = {
        vendor: "",
        model: "",
        deviceName: "",
        main: false,
        builtin: false,
        connection: "",
        sizeX: null,
        sizeY: null,
        pixelDepth: null,
        resolutionX: null,
        resolutionY: null,
        currentResX: null,
        currentResY: null,
        positionX: 0,
        positionY: 0,
        currentRefreshRate: null
      };
      let start = 108;
      if (edid.substr(start, 6) === "000000") {
        start += 36;
      }
      if (edid.substr(start, 6) === "000000") {
        start += 36;
      }
      if (edid.substr(start, 6) === "000000") {
        start += 36;
      }
      if (edid.substr(start, 6) === "000000") {
        start += 36;
      }
      result.resolutionX = parseInt("0x0" + edid.substr(start + 8, 1) + edid.substr(start + 4, 2));
      result.resolutionY = parseInt("0x0" + edid.substr(start + 14, 1) + edid.substr(start + 10, 2));
      result.sizeX = parseInt("0x0" + edid.substr(start + 28, 1) + edid.substr(start + 24, 2));
      result.sizeY = parseInt("0x0" + edid.substr(start + 29, 1) + edid.substr(start + 26, 2));
      start = edid.indexOf("000000fc00");
      if (start >= 0) {
        let model_raw = edid.substr(start + 10, 26);
        if (model_raw.indexOf("0a") !== -1) {
          model_raw = model_raw.substr(0, model_raw.indexOf("0a"));
        }
        try {
          if (model_raw.length > 2) {
            result.model = model_raw.match(/.{1,2}/g).map(function(v) {
              return String.fromCharCode(parseInt(v, 16));
            }).join("");
          }
        } catch (e) {
          util.noop();
        }
      } else {
        result.model = "";
      }
      return result;
    }
    function parseLinesLinuxDisplays(lines, depth) {
      let displays = [];
      let currentDisplay = {
        vendor: "",
        model: "",
        deviceName: "",
        main: false,
        builtin: false,
        connection: "",
        sizeX: null,
        sizeY: null,
        pixelDepth: null,
        resolutionX: null,
        resolutionY: null,
        currentResX: null,
        currentResY: null,
        positionX: 0,
        positionY: 0,
        currentRefreshRate: null
      };
      let is_edid = false;
      let is_current = false;
      let edid_raw = "";
      let start = 0;
      for (let i = 1;i < lines.length; i++) {
        if (lines[i].trim() !== "") {
          if (lines[i][0] !== " " && lines[i][0] !== "\t" && lines[i].toLowerCase().indexOf(" connected ") !== -1) {
            if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {
              displays.push(currentDisplay);
              currentDisplay = {
                vendor: "",
                model: "",
                main: false,
                builtin: false,
                connection: "",
                sizeX: null,
                sizeY: null,
                pixelDepth: null,
                resolutionX: null,
                resolutionY: null,
                currentResX: null,
                currentResY: null,
                positionX: 0,
                positionY: 0,
                currentRefreshRate: null
              };
            }
            let parts = lines[i].split(" ");
            currentDisplay.connection = parts[0];
            currentDisplay.main = lines[i].toLowerCase().indexOf(" primary ") >= 0;
            currentDisplay.builtin = parts[0].toLowerCase().indexOf("edp") >= 0;
          }
          if (is_edid) {
            if (lines[i].search(/\S|$/) > start) {
              edid_raw += lines[i].toLowerCase().trim();
            } else {
              let edid_decoded = parseLinesLinuxEdid(edid_raw);
              currentDisplay.vendor = edid_decoded.vendor;
              currentDisplay.model = edid_decoded.model;
              currentDisplay.resolutionX = edid_decoded.resolutionX;
              currentDisplay.resolutionY = edid_decoded.resolutionY;
              currentDisplay.sizeX = edid_decoded.sizeX;
              currentDisplay.sizeY = edid_decoded.sizeY;
              currentDisplay.pixelDepth = depth;
              is_edid = false;
            }
          }
          if (lines[i].toLowerCase().indexOf("edid:") >= 0) {
            is_edid = true;
            start = lines[i].search(/\S|$/);
          }
          if (lines[i].toLowerCase().indexOf("*current") >= 0) {
            const parts1 = lines[i].split("(");
            if (parts1 && parts1.length > 1 && parts1[0].indexOf("x") >= 0) {
              const resParts = parts1[0].trim().split("x");
              currentDisplay.currentResX = util.toInt(resParts[0]);
              currentDisplay.currentResY = util.toInt(resParts[1]);
            }
            is_current = true;
          }
          if (is_current && lines[i].toLowerCase().indexOf("clock") >= 0 && lines[i].toLowerCase().indexOf("hz") >= 0 && lines[i].toLowerCase().indexOf("v: height") >= 0) {
            const parts1 = lines[i].split("clock");
            if (parts1 && parts1.length > 1 && parts1[1].toLowerCase().indexOf("hz") >= 0) {
              currentDisplay.currentRefreshRate = util.toInt(parts1[1]);
            }
            is_current = false;
          }
        }
      }
      if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {
        displays.push(currentDisplay);
      }
      return displays;
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = {
          controllers: [],
          displays: []
        };
        if (_darwin) {
          let cmd = "system_profiler -xml -detailLevel full SPDisplaysDataType";
          exec(cmd, function(error, stdout) {
            if (!error) {
              try {
                const output = stdout.toString();
                result = parseLinesDarwin(util.plistParser(output)[0]._items);
              } catch (e) {
                util.noop();
              }
              try {
                stdout = execSync('defaults read /Library/Preferences/com.apple.windowserver.plist 2>/dev/null;defaults read /Library/Preferences/com.apple.windowserver.displays.plist 2>/dev/null; echo ""', { maxBuffer: 1024 * 20000 });
                const output = (stdout || "").toString();
                const obj = util.plistReader(output);
                if (obj["DisplayAnyUserSets"] && obj["DisplayAnyUserSets"]["Configs"] && obj["DisplayAnyUserSets"]["Configs"][0] && obj["DisplayAnyUserSets"]["Configs"][0]["DisplayConfig"]) {
                  const current = obj["DisplayAnyUserSets"]["Configs"][0]["DisplayConfig"];
                  let i = 0;
                  current.forEach((o) => {
                    if (o["CurrentInfo"] && o["CurrentInfo"]["OriginX"] !== undefined && result.displays && result.displays[i]) {
                      result.displays[i].positionX = o["CurrentInfo"]["OriginX"];
                    }
                    if (o["CurrentInfo"] && o["CurrentInfo"]["OriginY"] !== undefined && result.displays && result.displays[i]) {
                      result.displays[i].positionY = o["CurrentInfo"]["OriginY"];
                    }
                    i++;
                  });
                }
                if (obj["DisplayAnyUserSets"] && obj["DisplayAnyUserSets"].length > 0 && obj["DisplayAnyUserSets"][0].length > 0 && obj["DisplayAnyUserSets"][0][0]["DisplayID"]) {
                  const current = obj["DisplayAnyUserSets"][0];
                  let i = 0;
                  current.forEach((o) => {
                    if ("OriginX" in o && result.displays && result.displays[i]) {
                      result.displays[i].positionX = o["OriginX"];
                    }
                    if ("OriginY" in o && result.displays && result.displays[i]) {
                      result.displays[i].positionY = o["OriginY"];
                    }
                    if (o["Mode"] && o["Mode"]["BitsPerPixel"] !== undefined && result.displays && result.displays[i]) {
                      result.displays[i].pixelDepth = o["Mode"]["BitsPerPixel"];
                    }
                    i++;
                  });
                }
              } catch (e) {
                util.noop();
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_linux) {
          if (util.isRaspberry() && util.isRaspbian()) {
            let cmd = 'fbset -s | grep \'mode "\'; vcgencmd get_mem gpu; tvservice -s; tvservice -n;';
            exec(cmd, function(error, stdout) {
              let lines = stdout.toString().split("\n");
              if (lines.length > 3 && lines[0].indexOf('mode "') >= -1 && lines[2].indexOf("0x12000a") > -1) {
                const parts = lines[0].replace("mode", "").replace(/"/g, "").trim().split("x");
                if (parts.length === 2) {
                  result.displays.push({
                    vendor: "",
                    model: util.getValue(lines, "device_name", "="),
                    main: true,
                    builtin: false,
                    connection: "HDMI",
                    sizeX: null,
                    sizeY: null,
                    pixelDepth: null,
                    resolutionX: parseInt(parts[0], 10),
                    resolutionY: parseInt(parts[1], 10),
                    currentResX: null,
                    currentResY: null,
                    positionX: 0,
                    positionY: 0,
                    currentRefreshRate: null
                  });
                }
              }
              if (lines.length > 1 && stdout.toString().indexOf("gpu=") >= -1) {
                result.controllers.push({
                  vendor: "Broadcom",
                  model: util.getRpiGpu(),
                  bus: "",
                  vram: util.getValue(lines, "gpu", "=").replace("M", ""),
                  vramDynamic: true
                });
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } else {
            let cmd = "lspci -vvv  2>/dev/null";
            exec(cmd, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result.controllers = parseLinesLinuxControllers(lines);
                const nvidiaData = nvidiaDevices();
                result.controllers = result.controllers.map((controller) => {
                  return mergeControllerNvidia(controller, nvidiaData.find((contr) => contr.pciBus.toLowerCase().endsWith(controller.busAddress.toLowerCase())) || {});
                });
              }
              let cmd2 = "clinfo --raw";
              exec(cmd2, function(error2, stdout2) {
                if (!error2) {
                  let lines = stdout2.toString().split("\n");
                  result.controllers = parseLinesLinuxClinfo(result.controllers, lines);
                }
                let cmd3 = "xdpyinfo 2>/dev/null | grep \'depth of root window\' | awk \'{ print $5 }\'";
                exec(cmd3, function(error3, stdout3) {
                  let depth = 0;
                  if (!error3) {
                    let lines = stdout3.toString().split("\n");
                    depth = parseInt(lines[0]) || 0;
                  }
                  let cmd4 = "xrandr --verbose 2>/dev/null";
                  exec(cmd4, function(error4, stdout4) {
                    if (!error4) {
                      let lines = stdout4.toString().split("\n");
                      result.displays = parseLinesLinuxDisplays(lines, depth);
                    }
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                });
              });
            });
          }
        }
        if (_freebsd || _openbsd || _netbsd) {
          if (callback) {
            callback(null);
          }
          resolve(null);
        }
        if (_sunos) {
          if (callback) {
            callback(null);
          }
          resolve(null);
        }
        if (_windows) {
          try {
            const workload = [];
            workload.push(util.powerShell("Get-CimInstance win32_VideoController | fl *"));
            workload.push(util.powerShell('gp "HKLM:\\SYSTEM\\ControlSet001\\Control\\Class\\{4d36e968-e325-11ce-bfc1-08002be10318}\\*" -ErrorAction SilentlyContinue | where MatchingDeviceId $null -NE | select MatchingDeviceId,HardwareInformation.qwMemorySize | fl'));
            workload.push(util.powerShell("Get-CimInstance win32_desktopmonitor | fl *"));
            workload.push(util.powerShell("Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorBasicDisplayParams | fl"));
            workload.push(util.powerShell("Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.Screen]::AllScreens"));
            workload.push(util.powerShell("Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorConnectionParams | fl"));
            workload.push(util.powerShell('gwmi WmiMonitorID -Namespace root\\wmi | ForEach-Object {(($_.ManufacturerName -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.ProductCodeID -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.UserFriendlyName -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.SerialNumberID -notmatch 0 | foreach {[char]$_}) -join "") + "|" + $_.InstanceName}'));
            const nvidiaData = nvidiaDevices();
            Promise.all(workload).then((data) => {
              let csections = data[0].replace(/\r/g, "").split(/\n\s*\n/);
              let vsections = data[1].replace(/\r/g, "").split(/\n\s*\n/);
              result.controllers = parseLinesWindowsControllers(csections, vsections);
              result.controllers = result.controllers.map((controller) => {
                if (controller.vendor.toLowerCase() === "nvidia") {
                  return mergeControllerNvidia(controller, nvidiaData.find((device) => {
                    let windowsSubDeviceId = (controller.subDeviceId || "").toLowerCase();
                    const nvidiaSubDeviceIdParts = device.subDeviceId.split("x");
                    let nvidiaSubDeviceId = nvidiaSubDeviceIdParts.length > 1 ? nvidiaSubDeviceIdParts[1].toLowerCase() : nvidiaSubDeviceIdParts[0].toLowerCase();
                    const lengthDifference = Math.abs(windowsSubDeviceId.length - nvidiaSubDeviceId.length);
                    if (windowsSubDeviceId.length > nvidiaSubDeviceId.length) {
                      for (let i = 0;i < lengthDifference; i++) {
                        nvidiaSubDeviceId = "0" + nvidiaSubDeviceId;
                      }
                    } else if (windowsSubDeviceId.length < nvidiaSubDeviceId.length) {
                      for (let i = 0;i < lengthDifference; i++) {
                        windowsSubDeviceId = "0" + windowsSubDeviceId;
                      }
                    }
                    return windowsSubDeviceId === nvidiaSubDeviceId;
                  }) || {});
                } else {
                  return controller;
                }
              });
              let dsections = data[2].replace(/\r/g, "").split(/\n\s*\n/);
              if (dsections[0].trim() === "") {
                dsections.shift();
              }
              if (dsections.length && dsections[dsections.length - 1].trim() === "") {
                dsections.pop();
              }
              let msections = data[3].replace(/\r/g, "").split("Active ");
              msections.shift();
              let ssections = data[4].replace(/\r/g, "").split("BitsPerPixel ");
              ssections.shift();
              let tsections = data[5].replace(/\r/g, "").split(/\n\s*\n/);
              tsections.shift();
              const res = data[6].replace(/\r/g, "").split(/\n/);
              let isections = [];
              res.forEach((element) => {
                const parts = element.split("|");
                if (parts.length === 5) {
                  isections.push({
                    vendor: parts[0],
                    code: parts[1],
                    model: parts[2],
                    serial: parts[3],
                    instanceId: parts[4]
                  });
                }
              });
              result.displays = parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections);
              if (result.displays.length === 1) {
                if (_resolutionX) {
                  result.displays[0].resolutionX = _resolutionX;
                  if (!result.displays[0].currentResX) {
                    result.displays[0].currentResX = _resolutionX;
                  }
                }
                if (_resolutionY) {
                  result.displays[0].resolutionY = _resolutionY;
                  if (result.displays[0].currentResY === 0) {
                    result.displays[0].currentResY = _resolutionY;
                  }
                }
                if (_pixelDepth) {
                  result.displays[0].pixelDepth = _pixelDepth;
                }
              }
              result.displays = result.displays.map((element) => {
                if (_refreshRate && !element.currentRefreshRate) {
                  element.currentRefreshRate = _refreshRate;
                }
                return element;
              });
              if (callback) {
                callback(result);
              }
              resolve(result);
            }).catch(() => {
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
    function parseLinesWindowsControllers(sections, vections) {
      const memorySizes = {};
      for (const i in vections) {
        if ({}.hasOwnProperty.call(vections, i)) {
          if (vections[i].trim() !== "") {
            const lines = vections[i].trim().split("\n");
            const matchingDeviceId = util.getValue(lines, "MatchingDeviceId").match(/PCI\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);
            if (matchingDeviceId) {
              const quadWordmemorySize = parseInt(util.getValue(lines, "HardwareInformation.qwMemorySize"));
              if (!isNaN(quadWordmemorySize)) {
                let deviceId = matchingDeviceId[1].toUpperCase() + "&" + matchingDeviceId[2].toUpperCase();
                if (matchingDeviceId[3]) {
                  deviceId += "&" + matchingDeviceId[3].toUpperCase();
                }
                if (matchingDeviceId[4]) {
                  deviceId += "&" + matchingDeviceId[4].toUpperCase();
                }
                memorySizes[deviceId] = quadWordmemorySize;
              }
            }
          }
        }
      }
      let controllers = [];
      for (let i in sections) {
        if ({}.hasOwnProperty.call(sections, i)) {
          if (sections[i].trim() !== "") {
            let lines = sections[i].trim().split("\n");
            let pnpDeviceId = util.getValue(lines, "PNPDeviceID", ":").match(/PCI\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);
            let subDeviceId = null;
            let memorySize = null;
            if (pnpDeviceId) {
              subDeviceId = pnpDeviceId[3] || "";
              if (subDeviceId) {
                subDeviceId = subDeviceId.split("_")[1];
              }
              if (memorySize == null && pnpDeviceId[3] && pnpDeviceId[4]) {
                const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[3].toUpperCase() + "&" + pnpDeviceId[4].toUpperCase();
                if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                  memorySize = memorySizes[deviceId];
                }
              }
              if (memorySize == null && pnpDeviceId[3]) {
                const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[3].toUpperCase();
                if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                  memorySize = memorySizes[deviceId];
                }
              }
              if (memorySize == null && pnpDeviceId[4]) {
                const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[4].toUpperCase();
                if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                  memorySize = memorySizes[deviceId];
                }
              }
              if (memorySize == null) {
                const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase();
                if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                  memorySize = memorySizes[deviceId];
                }
              }
            }
            controllers.push({
              vendor: util.getValue(lines, "AdapterCompatibility", ":"),
              model: util.getValue(lines, "name", ":"),
              bus: util.getValue(lines, "PNPDeviceID", ":").startsWith("PCI") ? "PCI" : "",
              vram: (memorySize == null ? util.toInt(util.getValue(lines, "AdapterRAM", ":")) : memorySize) / 1024 / 1024,
              vramDynamic: util.getValue(lines, "VideoMemoryType", ":") === "2",
              subDeviceId
            });
            _resolutionX = util.toInt(util.getValue(lines, "CurrentHorizontalResolution", ":")) || _resolutionX;
            _resolutionY = util.toInt(util.getValue(lines, "CurrentVerticalResolution", ":")) || _resolutionY;
            _refreshRate = util.toInt(util.getValue(lines, "CurrentRefreshRate", ":")) || _refreshRate;
            _pixelDepth = util.toInt(util.getValue(lines, "CurrentBitsPerPixel", ":")) || _pixelDepth;
          }
        }
      }
      return controllers;
    }
    function parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections) {
      let displays = [];
      let vendor = "";
      let model = "";
      let deviceID = "";
      let resolutionX = 0;
      let resolutionY = 0;
      if (dsections && dsections.length) {
        let linesDisplay = dsections[0].split("\n");
        vendor = util.getValue(linesDisplay, "MonitorManufacturer", ":");
        model = util.getValue(linesDisplay, "Name", ":");
        deviceID = util.getValue(linesDisplay, "PNPDeviceID", ":").replace(/&amp;/g, "&").toLowerCase();
        resolutionX = util.toInt(util.getValue(linesDisplay, "ScreenWidth", ":"));
        resolutionY = util.toInt(util.getValue(linesDisplay, "ScreenHeight", ":"));
      }
      for (let i = 0;i < ssections.length; i++) {
        if (ssections[i].trim() !== "") {
          ssections[i] = "BitsPerPixel " + ssections[i];
          msections[i] = "Active " + msections[i];
          if (tsections.length === 0 || tsections[i] === undefined) {
            tsections[i] = "Unknown";
          }
          let linesScreen = ssections[i].split("\n");
          let linesMonitor = msections[i].split("\n");
          let linesConnection = tsections[i].split("\n");
          const bitsPerPixel = util.getValue(linesScreen, "BitsPerPixel");
          const bounds = util.getValue(linesScreen, "Bounds").replace("{", "").replace("}", "").replace(/=/g, ":").split(",");
          const primary = util.getValue(linesScreen, "Primary");
          const sizeX = util.getValue(linesMonitor, "MaxHorizontalImageSize");
          const sizeY = util.getValue(linesMonitor, "MaxVerticalImageSize");
          const instanceName = util.getValue(linesMonitor, "InstanceName").toLowerCase();
          const videoOutputTechnology = util.getValue(linesConnection, "VideoOutputTechnology");
          const deviceName = util.getValue(linesScreen, "DeviceName");
          let displayVendor = "";
          let displayModel = "";
          isections.forEach((element) => {
            if (element.instanceId.toLowerCase().startsWith(instanceName) && vendor.startsWith("(") && model.startsWith("PnP")) {
              displayVendor = element.vendor;
              displayModel = element.model;
            }
          });
          displays.push({
            vendor: instanceName.startsWith(deviceID) && displayVendor === "" ? vendor : displayVendor,
            model: instanceName.startsWith(deviceID) && displayModel === "" ? model : displayModel,
            deviceName,
            main: primary.toLowerCase() === "true",
            builtin: videoOutputTechnology === "2147483648",
            connection: videoOutputTechnology && videoTypes[videoOutputTechnology] ? videoTypes[videoOutputTechnology] : "",
            resolutionX: util.toInt(util.getValue(bounds, "Width", ":")),
            resolutionY: util.toInt(util.getValue(bounds, "Height", ":")),
            sizeX: sizeX ? parseInt(sizeX, 10) : null,
            sizeY: sizeY ? parseInt(sizeY, 10) : null,
            pixelDepth: bitsPerPixel,
            currentResX: util.toInt(util.getValue(bounds, "Width", ":")),
            currentResY: util.toInt(util.getValue(bounds, "Height", ":")),
            positionX: util.toInt(util.getValue(bounds, "X", ":")),
            positionY: util.toInt(util.getValue(bounds, "Y", ":"))
          });
        }
      }
      if (ssections.length === 0) {
        displays.push({
          vendor,
          model,
          main: true,
          sizeX: null,
          sizeY: null,
          resolutionX,
          resolutionY,
          pixelDepth: null,
          currentResX: resolutionX,
          currentResY: resolutionY,
          positionX: 0,
          positionY: 0
        });
      }
      return displays;
    }
  };
  var fs = __require("fs");
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var util = require_util4();
  var _platform = process.platform;
  var _nvidiaSmiPath = "";
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  var _resolutionX = 0;
  var _resolutionY = 0;
  var _pixelDepth = 0;
  var _refreshRate = 0;
  var videoTypes = {
    "-2": "UNINITIALIZED",
    "-1": "OTHER",
    "0": "HD15",
    "1": "SVIDEO",
    "2": "Composite video",
    "3": "Component video",
    "4": "DVI",
    "5": "HDMI",
    "6": "LVDS",
    "8": "D_JPN",
    "9": "SDI",
    "10": "DP",
    "11": "DP embedded",
    "12": "UDI",
    "13": "UDI embedded",
    "14": "SDTVDONGLE",
    "15": "MIRACAST",
    "2147483648": "INTERNAL"
  };
  exports2.graphics = graphics;
});

// ../../node_modules/systeminformation/lib/filesystem.js
var require_filesystem = __commonJS((exports2) => {
  var fsSize = function(drive, callback) {
    if (util.isFunction(drive)) {
      callback = drive;
      drive = "";
    }
    let macOsDisks = [];
    let osMounts = [];
    function getmacOsFsType(fs2) {
      if (!fs2.startsWith("/")) {
        return "NFS";
      }
      const parts = fs2.split("/");
      const fsShort = parts[parts.length - 1];
      const macOsDisksSingle = macOsDisks.filter((item) => item.indexOf(fsShort) >= 0);
      if (macOsDisksSingle.length === 1 && macOsDisksSingle[0].indexOf("APFS") >= 0) {
        return "APFS";
      }
      return "HFS";
    }
    function isLinuxTmpFs(fs2) {
      const linuxTmpFileSystems = ["rootfs", "unionfs", "squashfs", "cramfs", "initrd", "initramfs", "devtmpfs", "tmpfs", "udev", "devfs", "specfs", "type", "appimaged"];
      let result = false;
      linuxTmpFileSystems.forEach((linuxFs) => {
        if (fs2.toLowerCase().indexOf(linuxFs) >= 0) {
          result = true;
        }
      });
      return result;
    }
    function filterLines(stdout) {
      let lines = stdout.toString().split("\n");
      lines.shift();
      if (stdout.toString().toLowerCase().indexOf("filesystem")) {
        let removeLines = 0;
        for (let i = 0;i < lines.length; i++) {
          if (lines[i] && lines[i].toLowerCase().startsWith("filesystem")) {
            removeLines = i;
          }
        }
        for (let i = 0;i < removeLines; i++) {
          lines.shift();
        }
      }
      return lines;
    }
    function parseDf(lines) {
      let data = [];
      lines.forEach(function(line) {
        if (line !== "") {
          line = line.replace(/ +/g, " ").split(" ");
          if (line && (line[0].startsWith("/") || line[6] && line[6] === "/" || line[0].indexOf("/") > 0 || line[0].indexOf(":") === 1 || !_darwin && !isLinuxTmpFs(line[1]))) {
            const fs2 = line[0];
            const fsType = _linux || _freebsd || _openbsd || _netbsd ? line[1] : getmacOsFsType(line[0]);
            const size2 = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[2] : line[1]) * 1024;
            const used = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[3] : line[2]) * 1024;
            const available = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[4] : line[3]) * 1024;
            const use = parseFloat((100 * (used / (used + available))).toFixed(2));
            let rw = osMounts && Object.keys(osMounts).length > 0 ? osMounts[fs2] || false : null;
            line.splice(0, _linux || _freebsd || _openbsd || _netbsd ? 6 : 5);
            const mount = line.join(" ");
            if (!data.find((el) => el.fs === fs2 && el.type === fsType)) {
              data.push({
                fs: fs2,
                type: fsType,
                size: size2,
                used,
                available,
                use,
                mount,
                rw
              });
            }
          }
        }
      });
      return data;
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        let data = [];
        if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
          let cmd = "";
          macOsDisks = [];
          osMounts = {};
          if (_darwin) {
            cmd = "df -kP";
            try {
              macOsDisks = execSync("diskutil list").toString().split("\n").filter((line) => {
                return !line.startsWith("/") && line.indexOf(":") > 0;
              });
              execSync("mount").toString().split("\n").filter((line) => {
                return line.startsWith("/");
              }).forEach((line) => {
                osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("read-only") === -1;
              });
            } catch (e) {
              util.noop();
            }
          }
          if (_linux) {
            try {
              cmd = "export LC_ALL=C; df -lkPTx squashfs; unset LC_ALL";
              execSync("cat /proc/mounts 2>/dev/null").toString().split("\n").filter((line) => {
                return line.startsWith("/");
              }).forEach((line) => {
                osMounts[line.split(" ")[0]] = osMounts[line.split(" ")[0]] || false;
                if (line.toLowerCase().indexOf("/snap/") === -1) {
                  osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("rw,") >= 0 || line.toLowerCase().indexOf(" rw ") >= 0;
                }
              });
            } catch (e) {
              util.noop();
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            try {
              cmd = "df -lkPT";
              execSync("mount").toString().split("\n").forEach((line) => {
                osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("read-only") === -1;
              });
            } catch (e) {
              util.noop();
            }
          }
          exec(cmd, { maxBuffer: 1024 * 1024 }, function(error, stdout) {
            let lines = filterLines(stdout);
            data = parseDf(lines);
            if (drive) {
              data = data.filter((item) => {
                return item.fs.toLowerCase().indexOf(drive.toLowerCase()) >= 0 || item.mount.toLowerCase().indexOf(drive.toLowerCase()) >= 0;
              });
            }
            if ((!error || data.length) && stdout.toString().trim() !== "") {
              if (callback) {
                callback(data);
              }
              resolve(data);
            } else {
              exec("df -kPT", { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
                if (!error2) {
                  let lines2 = filterLines(stdout2);
                  data = parseDf(lines2);
                }
                if (callback) {
                  callback(data);
                }
                resolve(data);
              });
            }
          });
        }
        if (_sunos) {
          if (callback) {
            callback(data);
          }
          resolve(data);
        }
        if (_windows) {
          try {
            const cmd = `Get-WmiObject Win32_logicaldisk | select Access,Caption,FileSystem,FreeSpace,Size ${drive ? "| where -property Caption -eq " + drive : ""} | fl`;
            util.powerShell(cmd).then((stdout, error) => {
              if (!error) {
                let devices = stdout.toString().split(/\n\s*\n/);
                devices.forEach(function(device) {
                  let lines = device.split("\r\n");
                  const size2 = util.toInt(util.getValue(lines, "size", ":"));
                  const free = util.toInt(util.getValue(lines, "freespace", ":"));
                  const caption = util.getValue(lines, "caption", ":");
                  const rwValue = util.getValue(lines, "access", ":");
                  const rw = rwValue ? util.toInt(rwValue) !== 1 : null;
                  if (size2) {
                    data.push({
                      fs: caption,
                      type: util.getValue(lines, "filesystem", ":"),
                      size: size2,
                      used: size2 - free,
                      available: free,
                      use: parseFloat((100 * (size2 - free) / size2).toFixed(2)),
                      mount: caption,
                      rw
                    });
                  }
                });
              }
              if (callback) {
                callback(data);
              }
              resolve(data);
            });
          } catch (e) {
            if (callback) {
              callback(data);
            }
            resolve(data);
          }
        }
      });
    });
  };
  var fsOpenFiles = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const result = {
          max: null,
          allocated: null,
          available: null
        };
        if (_freebsd || _openbsd || _netbsd || _darwin) {
          let cmd = "sysctl -i kern.maxfiles kern.num_files kern.open_files";
          exec(cmd, { maxBuffer: 1024 * 1024 }, function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              result.max = parseInt(util.getValue(lines, "kern.maxfiles", ":"), 10);
              result.allocated = parseInt(util.getValue(lines, "kern.num_files", ":"), 10) || parseInt(util.getValue(lines, "kern.open_files", ":"), 10);
              result.available = result.max - result.allocated;
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_linux) {
          fs.readFile("/proc/sys/fs/file-nr", function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              if (lines[0]) {
                const parts = lines[0].replace(/\s+/g, " ").split(" ");
                if (parts.length === 3) {
                  result.allocated = parseInt(parts[0], 10);
                  result.available = parseInt(parts[1], 10);
                  result.max = parseInt(parts[2], 10);
                  if (!result.available) {
                    result.available = result.max - result.allocated;
                  }
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            } else {
              fs.readFile("/proc/sys/fs/file-max", function(error2, stdout2) {
                if (!error2) {
                  let lines = stdout2.toString().split("\n");
                  if (lines[0]) {
                    result.max = parseInt(lines[0], 10);
                  }
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            }
          });
        }
        if (_sunos) {
          if (callback) {
            callback(null);
          }
          resolve(null);
        }
        if (_windows) {
          if (callback) {
            callback(null);
          }
          resolve(null);
        }
      });
    });
  };
  var parseBytes = function(s) {
    return parseInt(s.substr(s.indexOf(" (") + 2, s.indexOf(" Bytes)") - 10));
  };
  var parseDevices = function(lines) {
    let devices = [];
    let i = 0;
    lines.forEach((line) => {
      if (line.length > 0) {
        if (line[0] === "*") {
          i++;
        } else {
          let parts = line.split(":");
          if (parts.length > 1) {
            if (!devices[i]) {
              devices[i] = {
                name: "",
                identifier: "",
                type: "disk",
                fsType: "",
                mount: "",
                size: 0,
                physical: "HDD",
                uuid: "",
                label: "",
                model: "",
                serial: "",
                removable: false,
                protocol: "",
                group: "",
                device: ""
              };
            }
            parts[0] = parts[0].trim().toUpperCase().replace(/ +/g, "");
            parts[1] = parts[1].trim();
            if (parts[0] === "DEVICEIDENTIFIER") {
              devices[i].identifier = parts[1];
            }
            if (parts[0] === "DEVICENODE") {
              devices[i].name = parts[1];
            }
            if (parts[0] === "VOLUMENAME") {
              if (parts[1].indexOf("Not applicable") === -1) {
                devices[i].label = parts[1];
              }
            }
            if (parts[0] === "PROTOCOL") {
              devices[i].protocol = parts[1];
            }
            if (parts[0] === "DISKSIZE") {
              devices[i].size = parseBytes(parts[1]);
            }
            if (parts[0] === "FILESYSTEMPERSONALITY") {
              devices[i].fsType = parts[1];
            }
            if (parts[0] === "MOUNTPOINT") {
              devices[i].mount = parts[1];
            }
            if (parts[0] === "VOLUMEUUID") {
              devices[i].uuid = parts[1];
            }
            if (parts[0] === "READ-ONLYMEDIA" && parts[1] === "Yes") {
              devices[i].physical = "CD/DVD";
            }
            if (parts[0] === "SOLIDSTATE" && parts[1] === "Yes") {
              devices[i].physical = "SSD";
            }
            if (parts[0] === "VIRTUAL") {
              devices[i].type = "virtual";
            }
            if (parts[0] === "REMOVABLEMEDIA") {
              devices[i].removable = parts[1] === "Removable";
            }
            if (parts[0] === "PARTITIONTYPE") {
              devices[i].type = "part";
            }
            if (parts[0] === "DEVICE/MEDIANAME") {
              devices[i].model = parts[1];
            }
          }
        }
      }
    });
    return devices;
  };
  var parseBlk = function(lines) {
    let data = [];
    lines.filter((line) => line !== "").forEach((line) => {
      try {
        line = decodeURIComponent(line.replace(/\\x/g, "%"));
        line = line.replace(/\\/g, "\\\\");
        let disk = JSON.parse(line);
        data.push({
          name: disk.name,
          type: disk.type,
          fsType: disk.fsType,
          mount: disk.mountpoint,
          size: parseInt(disk.size),
          physical: disk.type === "disk" ? disk.rota === "0" ? "SSD" : "HDD" : disk.type === "rom" ? "CD/DVD" : "",
          uuid: disk.uuid,
          label: disk.label,
          model: (disk.model || "").trim(),
          serial: disk.serial,
          removable: disk.rm === "1",
          protocol: disk.tran,
          group: disk.group || ""
        });
      } catch (e) {
        util.noop();
      }
    });
    data = util.unique(data);
    data = util.sortByKey(data, ["type", "name"]);
    return data;
  };
  var decodeMdabmData = function(lines) {
    const raid = util.getValue(lines, "md_level", "=");
    const label = util.getValue(lines, "md_name", "=");
    const uuid2 = util.getValue(lines, "md_uuid", "=");
    const members = [];
    lines.forEach((line) => {
      if (line.toLowerCase().startsWith("md_device_dev") && line.toLowerCase().indexOf("/dev/") > 0) {
        members.push(line.split("/dev/")[1]);
      }
    });
    return {
      raid,
      label,
      uuid: uuid2,
      members
    };
  };
  var raidMatchLinux = function(data) {
    let result = data;
    try {
      data.forEach((element) => {
        if (element.type.startsWith("raid")) {
          const lines = execSync(`mdadm --export --detail /dev/${element.name}`).toString().split("\n");
          const mdData = decodeMdabmData(lines);
          element.label = mdData.label;
          element.uuid = mdData.uuid;
          if (mdData.members && mdData.members.length && mdData.raid === element.type) {
            result = result.map((blockdevice) => {
              if (blockdevice.fsType === "linux_raid_member" && mdData.members.indexOf(blockdevice.name) >= 0) {
                blockdevice.group = element.name;
              }
              return blockdevice;
            });
          }
        }
      });
    } catch (e) {
      util.noop();
    }
    return result;
  };
  var getDevicesLinux = function(data) {
    const result = [];
    data.forEach((element) => {
      if (element.type.startsWith("disk")) {
        result.push(element.name);
      }
    });
    return result;
  };
  var matchDevicesLinux = function(data) {
    let result = data;
    try {
      const devices = getDevicesLinux(data);
      result = result.map((blockdevice) => {
        if (blockdevice.type.startsWith("part") || blockdevice.type.startsWith("disk")) {
          devices.forEach((element) => {
            if (blockdevice.name.startsWith(element)) {
              blockdevice.device = "/dev/" + element;
            }
          });
        }
        return blockdevice;
      });
    } catch (e) {
      util.noop();
    }
    return result;
  };
  var getDevicesMac = function(data) {
    const result = [];
    data.forEach((element) => {
      if (element.type.startsWith("disk")) {
        result.push({ name: element.name, model: element.model, device: element.name });
      }
      if (element.type.startsWith("virtual")) {
        let device = "";
        result.forEach((e) => {
          if (e.model === element.model) {
            device = e.device;
          }
        });
        if (device) {
          result.push({ name: element.name, model: element.model, device });
        }
      }
    });
    return result;
  };
  var matchDevicesMac = function(data) {
    let result = data;
    try {
      const devices = getDevicesMac(data);
      result = result.map((blockdevice) => {
        if (blockdevice.type.startsWith("part") || blockdevice.type.startsWith("disk") || blockdevice.type.startsWith("virtual")) {
          devices.forEach((element) => {
            if (blockdevice.name.startsWith(element.name)) {
              blockdevice.device = element.device;
            }
          });
        }
        return blockdevice;
      });
    } catch (e) {
      util.noop();
    }
    return result;
  };
  var getDevicesWin = function(diskDrives) {
    const result = [];
    diskDrives.forEach((element) => {
      const lines = element.split("\r\n");
      const device = util.getValue(lines, "DeviceID", ":");
      let partitions = element.split("@{DeviceID=");
      if (partitions.length > 1) {
        partitions = partitions.slice(1);
        partitions.forEach((partition) => {
          result.push({ name: partition.split(";")[0].toUpperCase(), device });
        });
      }
    });
    return result;
  };
  var matchDevicesWin = function(data, diskDrives) {
    const devices = getDevicesWin(diskDrives);
    data.map((element) => {
      const filteresDevices = devices.filter((e) => {
        return e.name === element.name.toUpperCase();
      });
      if (filteresDevices.length > 0) {
        element.device = filteresDevices[0].device;
      }
      return element;
    });
    return data;
  };
  var blkStdoutToObject = function(stdout) {
    return stdout.toString().replace(/NAME=/g, '{"name":').replace(/FSTYPE=/g, ',"fsType":').replace(/TYPE=/g, ',"type":').replace(/SIZE=/g, ',"size":').replace(/MOUNTPOINT=/g, ',"mountpoint":').replace(/UUID=/g, ',"uuid":').replace(/ROTA=/g, ',"rota":').replace(/RO=/g, ',"ro":').replace(/RM=/g, ',"rm":').replace(/TRAN=/g, ',"tran":').replace(/SERIAL=/g, ',"serial":').replace(/LABEL=/g, ',"label":').replace(/MODEL=/g, ',"model":').replace(/OWNER=/g, ',"owner":').replace(/GROUP=/g, ',"group":').replace(/\n/g, "}\n");
  };
  var blockDevices = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let data = [];
        if (_linux) {
          exec("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER 2>/dev/null", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
            if (!error) {
              let lines = blkStdoutToObject(stdout).split("\n");
              data = parseBlk(lines);
              data = raidMatchLinux(data);
              data = matchDevicesLinux(data);
              if (callback) {
                callback(data);
              }
              resolve(data);
            } else {
              exec("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER 2>/dev/null", { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
                if (!error2) {
                  let lines = blkStdoutToObject(stdout2).split("\n");
                  data = parseBlk(lines);
                  data = raidMatchLinux(data);
                }
                if (callback) {
                  callback(data);
                }
                resolve(data);
              });
            }
          });
        }
        if (_darwin) {
          exec("diskutil info -all", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              data = parseDevices(lines);
              data = matchDevicesMac(data);
            }
            if (callback) {
              callback(data);
            }
            resolve(data);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(data);
          }
          resolve(data);
        }
        if (_windows) {
          let drivetypes = ["Unknown", "NoRoot", "Removable", "Local", "Network", "CD/DVD", "RAM"];
          try {
            const workload = [];
            workload.push(util.powerShell("Get-CimInstance -ClassName Win32_LogicalDisk | select Caption,DriveType,Name,FileSystem,Size,VolumeSerialNumber,VolumeName | fl"));
            workload.push(util.powerShell("Get-WmiObject -Class Win32_diskdrive | Select-Object -Property PNPDeviceId,DeviceID, Model, Size, @{L=\'Partitions\'; E={$_.GetRelated(\'Win32_DiskPartition\').GetRelated(\'Win32_LogicalDisk\') | Select-Object -Property DeviceID, VolumeName, Size, FreeSpace}} | fl"));
            util.promiseAll(workload).then((res) => {
              let logicalDisks = res.results[0].toString().split(/\n\s*\n/);
              let diskDrives = res.results[1].toString().split(/\n\s*\n/);
              logicalDisks.forEach(function(device) {
                let lines = device.split("\r\n");
                let drivetype = util.getValue(lines, "drivetype", ":");
                if (drivetype) {
                  data.push({
                    name: util.getValue(lines, "name", ":"),
                    identifier: util.getValue(lines, "caption", ":"),
                    type: "disk",
                    fsType: util.getValue(lines, "filesystem", ":").toLowerCase(),
                    mount: util.getValue(lines, "caption", ":"),
                    size: util.getValue(lines, "size", ":"),
                    physical: drivetype >= 0 && drivetype <= 6 ? drivetypes[drivetype] : drivetypes[0],
                    uuid: util.getValue(lines, "volumeserialnumber", ":"),
                    label: util.getValue(lines, "volumename", ":"),
                    model: "",
                    serial: util.getValue(lines, "volumeserialnumber", ":"),
                    removable: drivetype === "2",
                    protocol: "",
                    group: "",
                    device: ""
                  });
                }
              });
              data = matchDevicesWin(data, diskDrives);
              if (callback) {
                callback(data);
              }
              resolve(data);
            });
          } catch (e) {
            if (callback) {
              callback(data);
            }
            resolve(data);
          }
        }
        if (_freebsd || _openbsd || _netbsd) {
          if (callback) {
            callback(null);
          }
          resolve(null);
        }
      });
    });
  };
  var calcFsSpeed = function(rx, wx) {
    let result = {
      rx: 0,
      wx: 0,
      tx: 0,
      rx_sec: null,
      wx_sec: null,
      tx_sec: null,
      ms: 0
    };
    if (_fs_speed && _fs_speed.ms) {
      result.rx = rx;
      result.wx = wx;
      result.tx = result.rx + result.wx;
      result.ms = Date.now() - _fs_speed.ms;
      result.rx_sec = (result.rx - _fs_speed.bytes_read) / (result.ms / 1000);
      result.wx_sec = (result.wx - _fs_speed.bytes_write) / (result.ms / 1000);
      result.tx_sec = result.rx_sec + result.wx_sec;
      _fs_speed.rx_sec = result.rx_sec;
      _fs_speed.wx_sec = result.wx_sec;
      _fs_speed.tx_sec = result.tx_sec;
      _fs_speed.bytes_read = result.rx;
      _fs_speed.bytes_write = result.wx;
      _fs_speed.bytes_overall = result.rx + result.wx;
      _fs_speed.ms = Date.now();
      _fs_speed.last_ms = result.ms;
    } else {
      result.rx = rx;
      result.wx = wx;
      result.tx = result.rx + result.wx;
      _fs_speed.rx_sec = null;
      _fs_speed.wx_sec = null;
      _fs_speed.tx_sec = null;
      _fs_speed.bytes_read = result.rx;
      _fs_speed.bytes_write = result.wx;
      _fs_speed.bytes_overall = result.rx + result.wx;
      _fs_speed.ms = Date.now();
      _fs_speed.last_ms = 0;
    }
    return result;
  };
  var fsStats = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (_windows || _freebsd || _openbsd || _netbsd || _sunos) {
          return resolve(null);
        }
        let result = {
          rx: 0,
          wx: 0,
          tx: 0,
          rx_sec: null,
          wx_sec: null,
          tx_sec: null,
          ms: 0
        };
        let rx = 0;
        let wx = 0;
        if (_fs_speed && !_fs_speed.ms || _fs_speed && _fs_speed.ms && Date.now() - _fs_speed.ms >= 500) {
          if (_linux) {
            exec("lsblk -r 2>/dev/null | grep /", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                let fs_filter = [];
                lines.forEach(function(line) {
                  if (line !== "") {
                    line = line.trim().split(" ");
                    if (fs_filter.indexOf(line[0]) === -1) {
                      fs_filter.push(line[0]);
                    }
                  }
                });
                let output = fs_filter.join("|");
                exec('cat /proc/diskstats | egrep "' + output + '"', { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
                  if (!error2) {
                    let lines2 = stdout2.toString().split("\n");
                    lines2.forEach(function(line) {
                      line = line.trim();
                      if (line !== "") {
                        line = line.replace(/ +/g, " ").split(" ");
                        rx += parseInt(line[5]) * 512;
                        wx += parseInt(line[9]) * 512;
                      }
                    });
                    result = calcFsSpeed(rx, wx);
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          }
          if (_darwin) {
            exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n "/IOBlockStorageDriver/,/Statistics/p" | grep "Statistics" | tr -cd "01234567890,\n"', { maxBuffer: 1024 * 1024 }, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                lines.forEach(function(line) {
                  line = line.trim();
                  if (line !== "") {
                    line = line.split(",");
                    rx += parseInt(line[2]);
                    wx += parseInt(line[9]);
                  }
                });
                result = calcFsSpeed(rx, wx);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
        } else {
          result.ms = _fs_speed.last_ms;
          result.rx = _fs_speed.bytes_read;
          result.wx = _fs_speed.bytes_write;
          result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;
          result.rx_sec = _fs_speed.rx_sec;
          result.wx_sec = _fs_speed.wx_sec;
          result.tx_sec = _fs_speed.tx_sec;
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
      });
    });
  };
  var calcDiskIO = function(rIO, wIO, rWaitTime, wWaitTime, tWaitTime) {
    let result = {
      rIO: 0,
      wIO: 0,
      tIO: 0,
      rIO_sec: null,
      wIO_sec: null,
      tIO_sec: null,
      rWaitTime: 0,
      wWaitTime: 0,
      tWaitTime: 0,
      rWaitPercent: null,
      wWaitPercent: null,
      tWaitPercent: null,
      ms: 0
    };
    if (_disk_io && _disk_io.ms) {
      result.rIO = rIO;
      result.wIO = wIO;
      result.tIO = rIO + wIO;
      result.ms = Date.now() - _disk_io.ms;
      result.rIO_sec = (result.rIO - _disk_io.rIO) / (result.ms / 1000);
      result.wIO_sec = (result.wIO - _disk_io.wIO) / (result.ms / 1000);
      result.tIO_sec = result.rIO_sec + result.wIO_sec;
      result.rWaitTime = rWaitTime;
      result.wWaitTime = wWaitTime;
      result.tWaitTime = tWaitTime;
      result.rWaitPercent = (result.rWaitTime - _disk_io.rWaitTime) * 100 / result.ms;
      result.wWaitPercent = (result.wWaitTime - _disk_io.wWaitTime) * 100 / result.ms;
      result.tWaitPercent = (result.tWaitTime - _disk_io.tWaitTime) * 100 / result.ms;
      _disk_io.rIO = rIO;
      _disk_io.wIO = wIO;
      _disk_io.rIO_sec = result.rIO_sec;
      _disk_io.wIO_sec = result.wIO_sec;
      _disk_io.tIO_sec = result.tIO_sec;
      _disk_io.rWaitTime = rWaitTime;
      _disk_io.wWaitTime = wWaitTime;
      _disk_io.tWaitTime = tWaitTime;
      _disk_io.rWaitPercent = result.rWaitPercent;
      _disk_io.wWaitPercent = result.wWaitPercent;
      _disk_io.tWaitPercent = result.tWaitPercent;
      _disk_io.last_ms = result.ms;
      _disk_io.ms = Date.now();
    } else {
      result.rIO = rIO;
      result.wIO = wIO;
      result.tIO = rIO + wIO;
      result.rWaitTime = rWaitTime;
      result.wWaitTime = wWaitTime;
      result.tWaitTime = tWaitTime;
      _disk_io.rIO = rIO;
      _disk_io.wIO = wIO;
      _disk_io.rIO_sec = null;
      _disk_io.wIO_sec = null;
      _disk_io.tIO_sec = null;
      _disk_io.rWaitTime = rWaitTime;
      _disk_io.wWaitTime = wWaitTime;
      _disk_io.tWaitTime = tWaitTime;
      _disk_io.rWaitPercent = null;
      _disk_io.wWaitPercent = null;
      _disk_io.tWaitPercent = null;
      _disk_io.last_ms = 0;
      _disk_io.ms = Date.now();
    }
    return result;
  };
  var disksIO = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (_windows) {
          return resolve(null);
        }
        if (_sunos) {
          return resolve(null);
        }
        let result = {
          rIO: 0,
          wIO: 0,
          tIO: 0,
          rIO_sec: null,
          wIO_sec: null,
          tIO_sec: null,
          rWaitTime: 0,
          wWaitTime: 0,
          tWaitTime: 0,
          rWaitPercent: null,
          wWaitPercent: null,
          tWaitPercent: null,
          ms: 0
        };
        let rIO = 0;
        let wIO = 0;
        let rWaitTime = 0;
        let wWaitTime = 0;
        let tWaitTime = 0;
        if (_disk_io && !_disk_io.ms || _disk_io && _disk_io.ms && Date.now() - _disk_io.ms >= 500) {
          if (_linux || _freebsd || _openbsd || _netbsd) {
            let cmd = 'for mount in `lsblk 2>/dev/null | grep " disk " | sed "s/[\u2502\u2514\u2500\u251C]//g" | awk \'{$1=$1};1\' | cut -d " " -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r "s/ +/;/g" | sed -r "s/^;//"; done';
            exec(cmd, { maxBuffer: 1024 * 1024 }, function(error, stdout) {
              if (!error) {
                let lines = stdout.split("\n");
                lines.forEach(function(line) {
                  if (!line) {
                    return;
                  }
                  let stats = line.split(";");
                  rIO += parseInt(stats[0]);
                  wIO += parseInt(stats[4]);
                  rWaitTime += parseInt(stats[3]);
                  wWaitTime += parseInt(stats[7]);
                  tWaitTime += parseInt(stats[10]);
                });
                result = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);
                if (callback) {
                  callback(result);
                }
                resolve(result);
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          }
          if (_darwin) {
            exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n "/IOBlockStorageDriver/,/Statistics/p" | grep "Statistics" | tr -cd "01234567890,\n"', { maxBuffer: 1024 * 1024 }, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                lines.forEach(function(line) {
                  line = line.trim();
                  if (line !== "") {
                    line = line.split(",");
                    rIO += parseInt(line[10]);
                    wIO += parseInt(line[0]);
                  }
                });
                result = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
        } else {
          result.rIO = _disk_io.rIO;
          result.wIO = _disk_io.wIO;
          result.tIO = _disk_io.rIO + _disk_io.wIO;
          result.ms = _disk_io.last_ms;
          result.rIO_sec = _disk_io.rIO_sec;
          result.wIO_sec = _disk_io.wIO_sec;
          result.tIO_sec = _disk_io.tIO_sec;
          result.rWaitTime = _disk_io.rWaitTime;
          result.wWaitTime = _disk_io.wWaitTime;
          result.tWaitTime = _disk_io.tWaitTime;
          result.rWaitPercent = _disk_io.rWaitPercent;
          result.wWaitPercent = _disk_io.wWaitPercent;
          result.tWaitPercent = _disk_io.tWaitPercent;
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
      });
    });
  };
  var diskLayout = function(callback) {
    function getVendorFromModel(model) {
      const diskManufacturers = [
        { pattern: "WESTERN.*", manufacturer: "Western Digital" },
        { pattern: "^WDC.*", manufacturer: "Western Digital" },
        { pattern: "WD.*", manufacturer: "Western Digital" },
        { pattern: "TOSHIBA.*", manufacturer: "Toshiba" },
        { pattern: "HITACHI.*", manufacturer: "Hitachi" },
        { pattern: "^IC.*", manufacturer: "Hitachi" },
        { pattern: "^HTS.*", manufacturer: "Hitachi" },
        { pattern: "SANDISK.*", manufacturer: "SanDisk" },
        { pattern: "KINGSTON.*", manufacturer: "Kingston Technology" },
        { pattern: "^SONY.*", manufacturer: "Sony" },
        { pattern: "TRANSCEND.*", manufacturer: "Transcend" },
        { pattern: "SAMSUNG.*", manufacturer: "Samsung" },
        { pattern: "^ST(?!I\\ ).*", manufacturer: "Seagate" },
        { pattern: "^STI\\ .*", manufacturer: "SimpleTech" },
        { pattern: "^D...-.*", manufacturer: "IBM" },
        { pattern: "^IBM.*", manufacturer: "IBM" },
        { pattern: "^FUJITSU.*", manufacturer: "Fujitsu" },
        { pattern: "^MP.*", manufacturer: "Fujitsu" },
        { pattern: "^MK.*", manufacturer: "Toshiba" },
        { pattern: "MAXTO.*", manufacturer: "Maxtor" },
        { pattern: "PIONEER.*", manufacturer: "Pioneer" },
        { pattern: "PHILIPS.*", manufacturer: "Philips" },
        { pattern: "QUANTUM.*", manufacturer: "Quantum Technology" },
        { pattern: "FIREBALL.*", manufacturer: "Quantum Technology" },
        { pattern: "^VBOX.*", manufacturer: "VirtualBox" },
        { pattern: "CORSAIR.*", manufacturer: "Corsair Components" },
        { pattern: "CRUCIAL.*", manufacturer: "Crucial" },
        { pattern: "ECM.*", manufacturer: "ECM" },
        { pattern: "INTEL.*", manufacturer: "INTEL" },
        { pattern: "EVO.*", manufacturer: "Samsung" },
        { pattern: "APPLE.*", manufacturer: "Apple" }
      ];
      let result = "";
      if (model) {
        model = model.toUpperCase();
        diskManufacturers.forEach((manufacturer) => {
          const re = RegExp(manufacturer.pattern);
          if (re.test(model)) {
            result = manufacturer.manufacturer;
          }
        });
      }
      return result;
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        const commitResult = (res) => {
          for (let i = 0;i < res.length; i++) {
            delete res[i].BSDName;
          }
          if (callback) {
            callback(res);
          }
          resolve(res);
        };
        let result = [];
        let cmd = "";
        if (_linux) {
          let cmdFullSmart = "";
          exec("export LC_ALL=C; lsblk -ablJO 2>/dev/null; unset LC_ALL", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
            if (!error) {
              try {
                const out = stdout.toString().trim();
                let devices = [];
                try {
                  const outJSON = JSON.parse(out);
                  if (outJSON && {}.hasOwnProperty.call(outJSON, "blockdevices")) {
                    devices = outJSON.blockdevices.filter((item) => {
                      return item.type === "disk" && item.size > 0 && (item.model !== null || item.mountpoint === null && item.label === null && item.fstype === null && item.parttype === null && item.path && item.path.indexOf("/ram") !== 0 && item.path.indexOf("/loop") !== 0 && item["disc-max"] && item["disc-max"] !== 0);
                    });
                  }
                } catch (e) {
                  try {
                    const out2 = execSync("export LC_ALL=C; lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER,GROUP 2>/dev/null; unset LC_ALL").toString();
                    let lines = blkStdoutToObject(out2).split("\n");
                    const data = parseBlk(lines);
                    devices = data.filter((item) => {
                      return item.type === "disk" && item.size > 0 && (item.model !== null && item.model !== "" || item.mount === "" && item.label === "" && item.fsType === "");
                    });
                  } catch (e2) {
                    util.noop();
                  }
                }
                devices.forEach((device) => {
                  let mediumType = "";
                  const BSDName = "/dev/" + device.name;
                  const logical = device.name;
                  try {
                    mediumType = execSync("cat /sys/block/" + logical + "/queue/rotational 2>/dev/null").toString().split("\n")[0];
                  } catch (e) {
                    util.noop();
                  }
                  let interfaceType = device.tran ? device.tran.toUpperCase().trim() : "";
                  if (interfaceType === "NVME") {
                    mediumType = "2";
                    interfaceType = "PCIe";
                  }
                  result.push({
                    device: BSDName,
                    type: mediumType === "0" ? "SSD" : mediumType === "1" ? "HD" : mediumType === "2" ? "NVMe" : device.model && device.model.indexOf("SSD") > -1 ? "SSD" : device.model && device.model.indexOf("NVM") > -1 ? "NVMe" : "HD",
                    name: device.model || "",
                    vendor: getVendorFromModel(device.model) || (device.vendor ? device.vendor.trim() : ""),
                    size: device.size || 0,
                    bytesPerSector: null,
                    totalCylinders: null,
                    totalHeads: null,
                    totalSectors: null,
                    totalTracks: null,
                    tracksPerCylinder: null,
                    sectorsPerTrack: null,
                    firmwareRevision: device.rev ? device.rev.trim() : "",
                    serialNum: device.serial ? device.serial.trim() : "",
                    interfaceType,
                    smartStatus: "unknown",
                    temperature: null,
                    BSDName
                  });
                  cmd += `printf "\n${BSDName}|"; smartctl -H ${BSDName} | grep overall;`;
                  cmdFullSmart += `${cmdFullSmart ? 'printf ",";' : ""}smartctl -a -j ${BSDName};`;
                });
              } catch (e) {
                util.noop();
              }
            }
            if (cmdFullSmart) {
              exec(cmdFullSmart, { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
                try {
                  const data = JSON.parse(`[${stdout2}]`);
                  data.forEach((disk) => {
                    const diskBSDName = disk.smartctl.argv[disk.smartctl.argv.length - 1];
                    for (let i = 0;i < result.length; i++) {
                      if (result[i].BSDName === diskBSDName) {
                        result[i].smartStatus = disk.smart_status.passed ? "Ok" : disk.smart_status.passed === false ? "Predicted Failure" : "unknown";
                        if (disk.temperature && disk.temperature.current) {
                          result[i].temperature = disk.temperature.current;
                        }
                        result[i].smartData = disk;
                      }
                    }
                  });
                  commitResult(result);
                } catch (e) {
                  if (cmd) {
                    cmd = cmd + 'printf "\n"';
                    exec(cmd, { maxBuffer: 1024 * 1024 }, function(error3, stdout3) {
                      let lines = stdout3.toString().split("\n");
                      lines.forEach((line) => {
                        if (line) {
                          let parts = line.split("|");
                          if (parts.length === 2) {
                            let BSDName = parts[0];
                            parts[1] = parts[1].trim();
                            let parts2 = parts[1].split(":");
                            if (parts2.length === 2) {
                              parts2[1] = parts2[1].trim();
                              let status = parts2[1].toLowerCase();
                              for (let i = 0;i < result.length; i++) {
                                if (result[i].BSDName === BSDName) {
                                  result[i].smartStatus = status === "passed" ? "Ok" : status === "failed!" ? "Predicted Failure" : "unknown";
                                }
                              }
                            }
                          }
                        }
                      });
                      commitResult(result);
                    });
                  } else {
                    commitResult(result);
                  }
                }
              });
            } else {
              commitResult(result);
            }
          });
        }
        if (_freebsd || _openbsd || _netbsd) {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
        if (_sunos) {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
        if (_darwin) {
          exec("system_profiler SPSerialATADataType SPNVMeDataType SPUSBDataType", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              let linesSATA = [];
              let linesNVMe = [];
              let linesUSB = [];
              let dataType = "SATA";
              lines.forEach((line) => {
                if (line === "NVMExpress:") {
                  dataType = "NVMe";
                } else if (line === "USB:") {
                  dataType = "USB";
                } else if (line === "SATA/SATA Express:") {
                  dataType = "SATA";
                } else if (dataType === "SATA") {
                  linesSATA.push(line);
                } else if (dataType === "NVMe") {
                  linesNVMe.push(line);
                } else if (dataType === "USB") {
                  linesUSB.push(line);
                }
              });
              try {
                let devices = linesSATA.join("\n").split(" Physical Interconnect: ");
                devices.shift();
                devices.forEach(function(device) {
                  device = "InterfaceType: " + device;
                  let lines2 = device.split("\n");
                  const mediumType = util.getValue(lines2, "Medium Type", ":", true).trim();
                  const sizeStr = util.getValue(lines2, "capacity", ":", true).trim();
                  const BSDName = util.getValue(lines2, "BSD Name", ":", true).trim();
                  if (sizeStr) {
                    let sizeValue = 0;
                    if (sizeStr.indexOf("(") >= 0) {
                      sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""));
                    }
                    if (!sizeValue) {
                      sizeValue = parseInt(sizeStr);
                    }
                    if (sizeValue) {
                      const smartStatusString = util.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                      result.push({
                        device: BSDName,
                        type: mediumType.startsWith("Solid") ? "SSD" : "HD",
                        name: util.getValue(lines2, "Model", ":", true).trim(),
                        vendor: getVendorFromModel(util.getValue(lines2, "Model", ":", true).trim()) || util.getValue(lines2, "Manufacturer", ":", true),
                        size: sizeValue,
                        bytesPerSector: null,
                        totalCylinders: null,
                        totalHeads: null,
                        totalSectors: null,
                        totalTracks: null,
                        tracksPerCylinder: null,
                        sectorsPerTrack: null,
                        firmwareRevision: util.getValue(lines2, "Revision", ":", true).trim(),
                        serialNum: util.getValue(lines2, "Serial Number", ":", true).trim(),
                        interfaceType: util.getValue(lines2, "InterfaceType", ":", true).trim(),
                        smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                        temperature: null,
                        BSDName
                      });
                      cmd = cmd + 'printf "\n' + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                    }
                  }
                });
              } catch (e) {
                util.noop();
              }
              try {
                let devices = linesNVMe.join("\n").split("\n\n          Capacity:");
                devices.shift();
                devices.forEach(function(device) {
                  device = "!Capacity: " + device;
                  let lines2 = device.split("\n");
                  const linkWidth = util.getValue(lines2, "link width", ":", true).trim();
                  const sizeStr = util.getValue(lines2, "!capacity", ":", true).trim();
                  const BSDName = util.getValue(lines2, "BSD Name", ":", true).trim();
                  if (sizeStr) {
                    let sizeValue = 0;
                    if (sizeStr.indexOf("(") >= 0) {
                      sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""));
                    }
                    if (!sizeValue) {
                      sizeValue = parseInt(sizeStr);
                    }
                    if (sizeValue) {
                      const smartStatusString = util.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                      result.push({
                        device: BSDName,
                        type: "NVMe",
                        name: util.getValue(lines2, "Model", ":", true).trim(),
                        vendor: getVendorFromModel(util.getValue(lines2, "Model", ":", true).trim()),
                        size: sizeValue,
                        bytesPerSector: null,
                        totalCylinders: null,
                        totalHeads: null,
                        totalSectors: null,
                        totalTracks: null,
                        tracksPerCylinder: null,
                        sectorsPerTrack: null,
                        firmwareRevision: util.getValue(lines2, "Revision", ":", true).trim(),
                        serialNum: util.getValue(lines2, "Serial Number", ":", true).trim(),
                        interfaceType: ("PCIe " + linkWidth).trim(),
                        smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                        temperature: null,
                        BSDName
                      });
                      cmd = cmd + 'printf "\n' + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                    }
                  }
                });
              } catch (e) {
                util.noop();
              }
              try {
                let devices = linesUSB.join("\n").replaceAll("Media:\n ", "Model:").split("\n\n          Product ID:");
                devices.shift();
                devices.forEach(function(device) {
                  let lines2 = device.split("\n");
                  const sizeStr = util.getValue(lines2, "Capacity", ":", true).trim();
                  const BSDName = util.getValue(lines2, "BSD Name", ":", true).trim();
                  if (sizeStr) {
                    let sizeValue = 0;
                    if (sizeStr.indexOf("(") >= 0) {
                      sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""));
                    }
                    if (!sizeValue) {
                      sizeValue = parseInt(sizeStr);
                    }
                    if (sizeValue) {
                      const smartStatusString = util.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                      result.push({
                        device: BSDName,
                        type: "USB",
                        name: util.getValue(lines2, "Model", ":", true).trim().replaceAll(":", ""),
                        vendor: getVendorFromModel(util.getValue(lines2, "Model", ":", true).trim()),
                        size: sizeValue,
                        bytesPerSector: null,
                        totalCylinders: null,
                        totalHeads: null,
                        totalSectors: null,
                        totalTracks: null,
                        tracksPerCylinder: null,
                        sectorsPerTrack: null,
                        firmwareRevision: util.getValue(lines2, "Revision", ":", true).trim(),
                        serialNum: util.getValue(lines2, "Serial Number", ":", true).trim(),
                        interfaceType: "USB",
                        smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                        temperature: null,
                        BSDName
                      });
                      cmd = cmd + 'printf "\n' + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                    }
                  }
                });
              } catch (e) {
                util.noop();
              }
              if (cmd) {
                cmd = cmd + 'printf "\n"';
                exec(cmd, { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
                  let lines2 = stdout2.toString().split("\n");
                  lines2.forEach((line) => {
                    if (line) {
                      let parts = line.split("|");
                      if (parts.length === 2) {
                        let BSDName = parts[0];
                        parts[1] = parts[1].trim();
                        let parts2 = parts[1].split(":");
                        if (parts2.length === 2) {
                          parts2[1] = parts2[1].trim();
                          let status = parts2[1].toLowerCase();
                          for (let i = 0;i < result.length; i++) {
                            if (result[i].BSDName === BSDName) {
                              result[i].smartStatus = status === "not supported" ? "not supported" : status === "verified" ? "Ok" : status === "failing" ? "Predicted Failure" : "unknown";
                            }
                          }
                        }
                      }
                    }
                  });
                  for (let i = 0;i < result.length; i++) {
                    delete result[i].BSDName;
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              } else {
                for (let i = 0;i < result.length; i++) {
                  delete result[i].BSDName;
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            }
          });
        }
        if (_windows) {
          try {
            const workload = [];
            workload.push(util.powerShell("Get-CimInstance Win32_DiskDrive | select Caption,Size,Status,PNPDeviceId,DeviceId,BytesPerSector,TotalCylinders,TotalHeads,TotalSectors,TotalTracks,TracksPerCylinder,SectorsPerTrack,FirmwareRevision,SerialNumber,InterfaceType | fl"));
            workload.push(util.powerShell("Get-PhysicalDisk | select BusType,MediaType,FriendlyName,Model,SerialNumber,Size | fl"));
            if (util.smartMonToolsInstalled()) {
              try {
                const smartDev = JSON.parse(execSync("smartctl --scan -j").toString());
                if (smartDev && smartDev.devices && smartDev.devices.length > 0) {
                  smartDev.devices.forEach((dev) => {
                    workload.push(execPromiseSave(`smartctl -j -a ${dev.name}`, util.execOptsWin));
                  });
                }
              } catch (e) {
                util.noop();
              }
            }
            util.promiseAll(workload).then((data) => {
              let devices = data.results[0].toString().split(/\n\s*\n/);
              devices.forEach(function(device) {
                let lines = device.split("\r\n");
                const size2 = util.getValue(lines, "Size", ":").trim();
                const status = util.getValue(lines, "Status", ":").trim().toLowerCase();
                if (size2) {
                  result.push({
                    device: util.getValue(lines, "DeviceId", ":"),
                    type: device.indexOf("SSD") > -1 ? "SSD" : "HD",
                    name: util.getValue(lines, "Caption", ":"),
                    vendor: getVendorFromModel(util.getValue(lines, "Caption", ":", true).trim()),
                    size: parseInt(size2),
                    bytesPerSector: parseInt(util.getValue(lines, "BytesPerSector", ":")),
                    totalCylinders: parseInt(util.getValue(lines, "TotalCylinders", ":")),
                    totalHeads: parseInt(util.getValue(lines, "TotalHeads", ":")),
                    totalSectors: parseInt(util.getValue(lines, "TotalSectors", ":")),
                    totalTracks: parseInt(util.getValue(lines, "TotalTracks", ":")),
                    tracksPerCylinder: parseInt(util.getValue(lines, "TracksPerCylinder", ":")),
                    sectorsPerTrack: parseInt(util.getValue(lines, "SectorsPerTrack", ":")),
                    firmwareRevision: util.getValue(lines, "FirmwareRevision", ":").trim(),
                    serialNum: util.getValue(lines, "SerialNumber", ":").trim(),
                    interfaceType: util.getValue(lines, "InterfaceType", ":").trim(),
                    smartStatus: status === "ok" ? "Ok" : status === "degraded" ? "Degraded" : status === "pred fail" ? "Predicted Failure" : "Unknown",
                    temperature: null
                  });
                }
              });
              devices = data.results[1].split(/\n\s*\n/);
              devices.forEach(function(device) {
                let lines = device.split("\r\n");
                const serialNum = util.getValue(lines, "SerialNumber", ":").trim();
                const name2 = util.getValue(lines, "FriendlyName", ":").trim().replace("Msft ", "Microsoft");
                const size2 = util.getValue(lines, "Size", ":").trim();
                const model = util.getValue(lines, "Model", ":").trim();
                const interfaceType = util.getValue(lines, "BusType", ":").trim();
                let mediaType = util.getValue(lines, "MediaType", ":").trim();
                if (mediaType === "3" || mediaType === "HDD") {
                  mediaType = "HD";
                }
                if (mediaType === "4") {
                  mediaType = "SSD";
                }
                if (mediaType === "5") {
                  mediaType = "SCM";
                }
                if (mediaType === "Unspecified" && (model.toLowerCase().indexOf("virtual") > -1 || model.toLowerCase().indexOf("vbox") > -1)) {
                  mediaType = "Virtual";
                }
                if (size2) {
                  let i = util.findObjectByKey(result, "serialNum", serialNum);
                  if (i === -1 || serialNum === "") {
                    i = util.findObjectByKey(result, "name", name2);
                  }
                  if (i != -1) {
                    result[i].type = mediaType;
                    result[i].interfaceType = interfaceType;
                  }
                }
              });
              data.results.shift();
              data.results.shift();
              if (data.results.length) {
                data.results.forEach((smartStr) => {
                  try {
                    const smartData = JSON.parse(smartStr);
                    if (smartData.serial_number) {
                      const serialNum = smartData.serial_number;
                      let i = util.findObjectByKey(result, "serialNum", serialNum);
                      if (i != -1) {
                        result[i].smartStatus = smartData.smart_status && smartData.smart_status.passed ? "Ok" : smartData.smart_status && smartData.smart_status.passed === false ? "Predicted Failure" : "unknown";
                        if (smartData.temperature && smartData.temperature.current) {
                          result[i].temperature = smartData.temperature.current;
                        }
                        result[i].smartData = smartData;
                      }
                    }
                  } catch (e) {
                    util.noop();
                  }
                });
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var util = require_util4();
  var fs = __require("fs");
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var execPromiseSave = util.promisifySave(__require("child_process").exec);
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  var _fs_speed = {};
  var _disk_io = {};
  exports2.fsSize = fsSize;
  exports2.fsOpenFiles = fsOpenFiles;
  exports2.blockDevices = blockDevices;
  exports2.fsStats = fsStats;
  exports2.disksIO = disksIO;
  exports2.diskLayout = diskLayout;
});

// ../../node_modules/systeminformation/lib/network.js
var require_network = __commonJS((exports2) => {
  var getDefaultNetworkInterface = function() {
    let ifacename = "";
    let ifacenameFirst = "";
    try {
      let ifaces = os.networkInterfaces();
      let scopeid = 9999;
      for (let dev in ifaces) {
        if ({}.hasOwnProperty.call(ifaces, dev)) {
          ifaces[dev].forEach(function(details) {
            if (details && details.internal === false) {
              ifacenameFirst = ifacenameFirst || dev;
              if (details.scopeid && details.scopeid < scopeid) {
                ifacename = dev;
                scopeid = details.scopeid;
              }
            }
          });
        }
      }
      ifacename = ifacename || ifacenameFirst || "";
      if (_windows) {
        let defaultIp = "";
        const cmd = "netstat -r";
        const result = execSync(cmd, util.execOptsWin);
        const lines = result.toString().split(os.EOL);
        lines.forEach((line) => {
          line = line.replace(/\s+/g, " ").trim();
          if (line.indexOf("0.0.0.0 0.0.0.0") > -1 && !/[a-zA-Z]/.test(line)) {
            const parts = line.split(" ");
            if (parts.length >= 5) {
              defaultIp = parts[parts.length - 2];
            }
          }
        });
        if (defaultIp) {
          for (let dev in ifaces) {
            if ({}.hasOwnProperty.call(ifaces, dev)) {
              ifaces[dev].forEach(function(details) {
                if (details && details.address && details.address === defaultIp) {
                  ifacename = dev;
                }
              });
            }
          }
        }
      }
      if (_linux) {
        let cmd = "ip route 2> /dev/null | grep default";
        let result = execSync(cmd);
        let parts = result.toString().split("\n")[0].split(/\s+/);
        if (parts[0] === "none" && parts[5]) {
          ifacename = parts[5];
        } else if (parts[4]) {
          ifacename = parts[4];
        }
        if (ifacename.indexOf(":") > -1) {
          ifacename = ifacename.split(":")[1].trim();
        }
      }
      if (_darwin || _freebsd || _openbsd || _netbsd || _sunos) {
        let cmd = "";
        if (_linux) {
          cmd = "ip route 2> /dev/null | grep default | awk \'{print $5}\'";
        }
        if (_darwin) {
          cmd = "route -n get default 2>/dev/null | grep interface: | awk \'{print $2}\'";
        }
        if (_freebsd || _openbsd || _netbsd || _sunos) {
          cmd = "route get 0.0.0.0 | grep interface:";
        }
        let result = execSync(cmd);
        ifacename = result.toString().split("\n")[0];
        if (ifacename.indexOf(":") > -1) {
          ifacename = ifacename.split(":")[1].trim();
        }
      }
    } catch (e) {
      util.noop();
    }
    if (ifacename) {
      _default_iface = ifacename;
    }
    return _default_iface;
  };
  var getMacAddresses = function() {
    let iface = "";
    let mac = "";
    let result = {};
    if (_linux || _freebsd || _openbsd || _netbsd) {
      if (typeof pathToIp === "undefined") {
        try {
          const lines = execSync("which ip").toString().split("\n");
          if (lines.length && lines[0].indexOf(":") === -1 && lines[0].indexOf("/") === 0) {
            pathToIp = lines[0];
          } else {
            pathToIp = "";
          }
        } catch (e) {
          pathToIp = "";
        }
      }
      try {
        const cmd = "export LC_ALL=C; " + (pathToIp ? pathToIp + " link show up" : "/sbin/ifconfig") + "; unset LC_ALL";
        let res = execSync(cmd);
        const lines = res.toString().split("\n");
        for (let i = 0;i < lines.length; i++) {
          if (lines[i] && lines[i][0] !== " ") {
            if (pathToIp) {
              let nextline = lines[i + 1].trim().split(" ");
              if (nextline[0] === "link/ether") {
                iface = lines[i].split(" ")[1];
                iface = iface.slice(0, iface.length - 1);
                mac = nextline[1];
              }
            } else {
              iface = lines[i].split(" ")[0];
              mac = lines[i].split("HWaddr ")[1];
            }
            if (iface && mac) {
              result[iface] = mac.trim();
              iface = "";
              mac = "";
            }
          }
        }
      } catch (e) {
        util.noop();
      }
    }
    if (_darwin) {
      try {
        const cmd = "/sbin/ifconfig";
        let res = execSync(cmd);
        const lines = res.toString().split("\n");
        for (let i = 0;i < lines.length; i++) {
          if (lines[i] && lines[i][0] !== "\t" && lines[i].indexOf(":") > 0) {
            iface = lines[i].split(":")[0];
          } else if (lines[i].indexOf("\tether ") === 0) {
            mac = lines[i].split("\tether ")[1];
            if (iface && mac) {
              result[iface] = mac.trim();
              iface = "";
              mac = "";
            }
          }
        }
      } catch (e) {
        util.noop();
      }
    }
    return result;
  };
  var networkInterfaceDefault = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = getDefaultNetworkInterface();
        if (callback) {
          callback(result);
        }
        resolve(result);
      });
    });
  };
  var parseLinesWindowsNics = function(sections, nconfigsections) {
    let nics = [];
    for (let i in sections) {
      if ({}.hasOwnProperty.call(sections, i)) {
        if (sections[i].trim() !== "") {
          let lines = sections[i].trim().split("\r\n");
          let linesNicConfig = nconfigsections && nconfigsections[i] ? nconfigsections[i].trim().split("\r\n") : [];
          let netEnabled = util.getValue(lines, "NetEnabled", ":");
          let adapterType = util.getValue(lines, "AdapterTypeID", ":") === "9" ? "wireless" : "wired";
          let ifacename = util.getValue(lines, "Name", ":").replace(/\]/g, ")").replace(/\[/g, "(");
          let iface = util.getValue(lines, "NetConnectionID", ":").replace(/\]/g, ")").replace(/\[/g, "(");
          if (ifacename.toLowerCase().indexOf("wi-fi") >= 0 || ifacename.toLowerCase().indexOf("wireless") >= 0) {
            adapterType = "wireless";
          }
          if (netEnabled !== "") {
            const speed = parseInt(util.getValue(lines, "speed", ":").trim(), 10) / 1e6;
            nics.push({
              mac: util.getValue(lines, "MACAddress", ":").toLowerCase(),
              dhcp: util.getValue(linesNicConfig, "dhcpEnabled", ":").toLowerCase() === "true",
              name: ifacename,
              iface,
              netEnabled: netEnabled === "TRUE",
              speed: isNaN(speed) ? null : speed,
              operstate: util.getValue(lines, "NetConnectionStatus", ":") === "2" ? "up" : "down",
              type: adapterType
            });
          }
        }
      }
    }
    return nics;
  };
  var getWindowsNics = function() {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let cmd = "Get-CimInstance Win32_NetworkAdapter | fl *" + "; echo \'#-#-#-#\';";
        cmd += "Get-CimInstance Win32_NetworkAdapterConfiguration | fl DHCPEnabled" + "";
        try {
          util.powerShell(cmd).then((data) => {
            data = data.split("#-#-#-#");
            const nsections = (data[0] || "").split(/\n\s*\n/);
            const nconfigsections = (data[1] || "").split(/\n\s*\n/);
            resolve(parseLinesWindowsNics(nsections, nconfigsections));
          });
        } catch (e) {
          resolve([]);
        }
      });
    });
  };
  var getWindowsDNSsuffixes = function() {
    let iface = {};
    let dnsSuffixes = {
      primaryDNS: "",
      exitCode: 0,
      ifaces: []
    };
    try {
      const ipconfig = execSync("ipconfig /all", util.execOptsWin);
      const ipconfigArray = ipconfig.split("\r\n\r\n");
      ipconfigArray.forEach((element, index) => {
        if (index == 1) {
          const longPrimaryDNS = element.split("\r\n").filter((element2) => {
            return element2.toUpperCase().includes("DNS");
          });
          const primaryDNS = longPrimaryDNS[0].substring(longPrimaryDNS[0].lastIndexOf(":") + 1);
          dnsSuffixes.primaryDNS = primaryDNS.trim();
          if (!dnsSuffixes.primaryDNS) {
            dnsSuffixes.primaryDNS = "Not defined";
          }
        }
        if (index > 1) {
          if (index % 2 == 0) {
            const name2 = element.substring(element.lastIndexOf(" ") + 1).replace(":", "");
            iface.name = name2;
          } else {
            const connectionSpecificDNS = element.split("\r\n").filter((element2) => {
              return element2.toUpperCase().includes("DNS");
            });
            const dnsSuffix = connectionSpecificDNS[0].substring(connectionSpecificDNS[0].lastIndexOf(":") + 1);
            iface.dnsSuffix = dnsSuffix.trim();
            dnsSuffixes.ifaces.push(iface);
            iface = {};
          }
        }
      });
      return dnsSuffixes;
    } catch (error) {
      return {
        primaryDNS: "",
        exitCode: 0,
        ifaces: []
      };
    }
  };
  var getWindowsIfaceDNSsuffix = function(ifaces, ifacename) {
    let dnsSuffix = "";
    const interfaceName = ifacename + ".";
    try {
      const connectionDnsSuffix = ifaces.filter((iface) => {
        return interfaceName.includes(iface.name + ".");
      }).map((iface) => iface.dnsSuffix);
      if (connectionDnsSuffix[0]) {
        dnsSuffix = connectionDnsSuffix[0];
      }
      if (!dnsSuffix) {
        dnsSuffix = "";
      }
      return dnsSuffix;
    } catch (error) {
      return "Unknown";
    }
  };
  var getWindowsWiredProfilesInformation = function() {
    try {
      const result = execSync("netsh lan show profiles", util.execOptsWin);
      const profileList = result.split("\r\nProfile on interface");
      return profileList;
    } catch (error) {
      if (error.status === 1 && error.stdout.includes("AutoConfig")) {
        return "Disabled";
      }
      return [];
    }
  };
  var getWindowsWirelessIfaceSSID = function(interfaceName) {
    try {
      const result = execSync(`netsh wlan show  interface name="${interfaceName}" | findstr "SSID"`, util.execOptsWin);
      const SSID = result.split("\r\n").shift();
      const parseSSID = SSID.split(":").pop();
      return parseSSID;
    } catch (error) {
      return "Unknown";
    }
  };
  var getWindowsIEEE8021x = function(connectionType, iface, ifaces) {
    let i8021x = {
      state: "Unknown",
      protocol: "Unknown"
    };
    if (ifaces === "Disabled") {
      i8021x.state = "Disabled";
      i8021x.protocol = "Not defined";
      return i8021x;
    }
    if (connectionType == "wired" && ifaces.length > 0) {
      try {
        const iface8021xInfo = ifaces.find((element) => {
          return element.includes(iface + "\r\n");
        });
        const arrayIface8021xInfo = iface8021xInfo.split("\r\n");
        const state8021x = arrayIface8021xInfo.find((element) => {
          return element.includes("802.1x");
        });
        if (state8021x.includes("Disabled")) {
          i8021x.state = "Disabled";
          i8021x.protocol = "Not defined";
        } else if (state8021x.includes("Enabled")) {
          const protocol8021x = arrayIface8021xInfo.find((element) => {
            return element.includes("EAP");
          });
          i8021x.protocol = protocol8021x.split(":").pop();
          i8021x.state = "Enabled";
        }
      } catch (error) {
        return i8021x;
      }
    } else if (connectionType == "wireless") {
      let i8021xState = "";
      let i8021xProtocol = "";
      try {
        const SSID = getWindowsWirelessIfaceSSID(iface);
        if (SSID !== "Unknown") {
          i8021xState = execSync(`netsh wlan show profiles "${SSID}" | findstr "802.1X"`, util.execOptsWin);
          i8021xProtocol = execSync(`netsh wlan show profiles "${SSID}" | findstr "EAP"`, util.execOptsWin);
        }
        if (i8021xState.includes(":") && i8021xProtocol.includes(":")) {
          i8021x.state = i8021xState.split(":").pop();
          i8021x.protocol = i8021xProtocol.split(":").pop();
        }
      } catch (error) {
        if (error.status === 1 && error.stdout.includes("AutoConfig")) {
          i8021x.state = "Disabled";
          i8021x.protocol = "Not defined";
        }
        return i8021x;
      }
    }
    return i8021x;
  };
  var splitSectionsNics = function(lines) {
    const result = [];
    let section = [];
    lines.forEach(function(line) {
      if (!line.startsWith("\t") && !line.startsWith(" ")) {
        if (section.length) {
          result.push(section);
          section = [];
        }
      }
      section.push(line);
    });
    if (section.length) {
      result.push(section);
    }
    return result;
  };
  var parseLinesDarwinNics = function(sections) {
    let nics = [];
    sections.forEach((section) => {
      let nic = {
        iface: "",
        mtu: null,
        mac: "",
        ip6: "",
        ip4: "",
        speed: null,
        type: "",
        operstate: "",
        duplex: "",
        internal: false
      };
      const first = section[0];
      nic.iface = first.split(":")[0].trim();
      let parts = first.split("> mtu");
      nic.mtu = parts.length > 1 ? parseInt(parts[1], 10) : null;
      if (isNaN(nic.mtu)) {
        nic.mtu = null;
      }
      nic.internal = parts[0].toLowerCase().indexOf("loopback") > -1;
      section.forEach((line) => {
        if (line.trim().startsWith("ether ")) {
          nic.mac = line.split("ether ")[1].toLowerCase().trim();
        }
        if (line.trim().startsWith("inet6 ") && !nic.ip6) {
          nic.ip6 = line.split("inet6 ")[1].toLowerCase().split("%")[0].split(" ")[0];
        }
        if (line.trim().startsWith("inet ") && !nic.ip4) {
          nic.ip4 = line.split("inet ")[1].toLowerCase().split(" ")[0];
        }
      });
      let speed = util.getValue(section, "link rate");
      nic.speed = speed ? parseFloat(speed) : null;
      if (nic.speed === null) {
        speed = util.getValue(section, "uplink rate");
        nic.speed = speed ? parseFloat(speed) : null;
        if (nic.speed !== null && speed.toLowerCase().indexOf("gbps") >= 0) {
          nic.speed = nic.speed * 1000;
        }
      } else {
        if (speed.toLowerCase().indexOf("gbps") >= 0) {
          nic.speed = nic.speed * 1000;
        }
      }
      nic.type = util.getValue(section, "type").toLowerCase().indexOf("wi-fi") > -1 ? "wireless" : "wired";
      const operstate = util.getValue(section, "status").toLowerCase();
      nic.operstate = operstate === "active" ? "up" : operstate === "inactive" ? "down" : "unknown";
      nic.duplex = util.getValue(section, "media").toLowerCase().indexOf("half-duplex") > -1 ? "half" : "full";
      if (nic.ip6 || nic.ip4 || nic.mac) {
        nics.push(nic);
      }
    });
    return nics;
  };
  var getDarwinNics = function() {
    const cmd = "/sbin/ifconfig -v";
    try {
      const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split("\n");
      const nsections = splitSectionsNics(lines);
      return parseLinesDarwinNics(nsections);
    } catch (e) {
      return [];
    }
  };
  var getLinuxIfaceConnectionName = function(interfaceName) {
    const cmd = `nmcli device status 2>/dev/null | grep ${interfaceName}`;
    try {
      const result = execSync(cmd).toString();
      const resultFormat = result.replace(/\s+/g, " ").trim();
      const connectionNameLines = resultFormat.split(" ").slice(3);
      const connectionName = connectionNameLines.join(" ");
      return connectionName != "--" ? connectionName : "";
    } catch (e) {
      return "";
    }
  };
  var checkLinuxDCHPInterfaces = function(file) {
    let result = [];
    try {
      let cmd = `cat ${file} 2> /dev/null | grep 'iface\\|source'`;
      const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split("\n");
      lines.forEach((line) => {
        const parts = line.replace(/\s+/g, " ").trim().split(" ");
        if (parts.length >= 4) {
          if (line.toLowerCase().indexOf(" inet ") >= 0 && line.toLowerCase().indexOf("dhcp") >= 0) {
            result.push(parts[1]);
          }
        }
        if (line.toLowerCase().includes("source")) {
          let file2 = line.split(" ")[1];
          result = result.concat(checkLinuxDCHPInterfaces(file2));
        }
      });
    } catch (e) {
      util.noop();
    }
    return result;
  };
  var getLinuxDHCPNics = function() {
    let cmd = "ip a 2> /dev/null";
    let result = [];
    try {
      const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split("\n");
      const nsections = splitSectionsNics(lines);
      result = parseLinuxDHCPNics(nsections);
    } catch (e) {
      util.noop();
    }
    try {
      result = checkLinuxDCHPInterfaces("/etc/network/interfaces");
    } catch (e) {
      util.noop();
    }
    return result;
  };
  var parseLinuxDHCPNics = function(sections) {
    const result = [];
    if (sections && sections.length) {
      sections.forEach((lines) => {
        if (lines && lines.length) {
          const parts = lines[0].split(":");
          if (parts.length > 2) {
            for (let line of lines) {
              if (line.indexOf(" inet ") >= 0 && line.indexOf(" dynamic ") >= 0) {
                const parts2 = line.split(" ");
                const nic = parts2[parts2.length - 1].trim();
                result.push(nic);
                break;
              }
            }
          }
        }
      });
    }
    return result;
  };
  var getLinuxIfaceDHCPstatus = function(iface, connectionName, DHCPNics) {
    let result = false;
    if (connectionName) {
      const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep ipv4.method;`;
      try {
        const lines = execSync(cmd).toString();
        const resultFormat = lines.replace(/\s+/g, " ").trim();
        let dhcStatus = resultFormat.split(" ").slice(1).toString();
        switch (dhcStatus) {
          case "auto":
            result = true;
            break;
          default:
            result = false;
            break;
        }
        return result;
      } catch (e) {
        return DHCPNics.indexOf(iface) >= 0;
      }
    } else {
      return DHCPNics.indexOf(iface) >= 0;
    }
  };
  var getDarwinIfaceDHCPstatus = function(iface) {
    let result = false;
    const cmd = `ipconfig getpacket "${iface}" 2>/dev/null | grep lease_time;`;
    try {
      const lines = execSync(cmd).toString().split("\n");
      if (lines.length && lines[0].startsWith("lease_time")) {
        result = true;
      }
    } catch (e) {
      util.noop();
    }
    return result;
  };
  var getLinuxIfaceDNSsuffix = function(connectionName) {
    if (connectionName) {
      const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep ipv4.dns-search;`;
      try {
        const result = execSync(cmd).toString();
        const resultFormat = result.replace(/\s+/g, " ").trim();
        const dnsSuffix = resultFormat.split(" ").slice(1).toString();
        return dnsSuffix == "--" ? "Not defined" : dnsSuffix;
      } catch (e) {
        return "Unknown";
      }
    } else {
      return "Unknown";
    }
  };
  var getLinuxIfaceIEEE8021xAuth = function(connectionName) {
    if (connectionName) {
      const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep 802-1x.eap;`;
      try {
        const result = execSync(cmd).toString();
        const resultFormat = result.replace(/\s+/g, " ").trim();
        const authenticationProtocol = resultFormat.split(" ").slice(1).toString();
        return authenticationProtocol == "--" ? "" : authenticationProtocol;
      } catch (e) {
        return "Not defined";
      }
    } else {
      return "Not defined";
    }
  };
  var getLinuxIfaceIEEE8021xState = function(authenticationProtocol) {
    if (authenticationProtocol) {
      if (authenticationProtocol == "Not defined") {
        return "Disabled";
      }
      return "Enabled";
    } else {
      return "Unknown";
    }
  };
  var testVirtualNic = function(iface, ifaceName, mac) {
    const virtualMacs = ["00:00:00:00:00:00", "00:03:FF", "00:05:69", "00:0C:29", "00:0F:4B", "00:13:07", "00:13:BE", "00:15:5d", "00:16:3E", "00:1C:42", "00:21:F6", "00:24:0B", "00:50:56", "00:A0:B1", "00:E0:C8", "08:00:27", "0A:00:27", "18:92:2C", "16:DF:49", "3C:F3:92", "54:52:00", "FC:15:97"];
    if (mac) {
      return virtualMacs.filter((item) => {
        return mac.toUpperCase().toUpperCase().startsWith(item.substring(0, mac.length));
      }).length > 0 || iface.toLowerCase().indexOf(" virtual ") > -1 || ifaceName.toLowerCase().indexOf(" virtual ") > -1 || iface.toLowerCase().indexOf("vethernet ") > -1 || ifaceName.toLowerCase().indexOf("vethernet ") > -1 || iface.toLowerCase().startsWith("veth") || ifaceName.toLowerCase().startsWith("veth") || iface.toLowerCase().startsWith("vboxnet") || ifaceName.toLowerCase().startsWith("vboxnet");
    } else {
      return false;
    }
  };
  var networkInterfaces = function(callback, rescan, defaultString) {
    if (typeof callback === "string") {
      defaultString = callback;
      rescan = true;
      callback = null;
    }
    if (typeof callback === "boolean") {
      rescan = callback;
      callback = null;
      defaultString = "";
    }
    if (typeof rescan === "undefined") {
      rescan = true;
    }
    defaultString = defaultString || "";
    defaultString = "" + defaultString;
    return new Promise((resolve) => {
      process.nextTick(() => {
        let ifaces = os.networkInterfaces();
        let result = [];
        let nics = [];
        let dnsSuffixes = [];
        let nics8021xInfo = [];
        if (_darwin || _freebsd || _openbsd || _netbsd) {
          if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
            result = _networkInterfaces;
            if (callback) {
              callback(result);
            }
            resolve(result);
          } else {
            const defaultInterface = getDefaultNetworkInterface();
            _ifaces = JSON.parse(JSON.stringify(ifaces));
            nics = getDarwinNics();
            nics.forEach((nic) => {
              if ({}.hasOwnProperty.call(ifaces, nic.iface)) {
                ifaces[nic.iface].forEach(function(details) {
                  if (details.family === "IPv4" || details.family === 4) {
                    nic.ip4subnet = details.netmask;
                  }
                  if (details.family === "IPv6" || details.family === 6) {
                    nic.ip6subnet = details.netmask;
                  }
                });
              }
              let ifaceSanitized = "";
              const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(nic.iface);
              const l = util.mathMin(s.length, 2000);
              for (let i = 0;i <= l; i++) {
                if (s[i] !== undefined) {
                  ifaceSanitized = ifaceSanitized + s[i];
                }
              }
              result.push({
                iface: nic.iface,
                ifaceName: nic.iface,
                default: nic.iface === defaultInterface,
                ip4: nic.ip4,
                ip4subnet: nic.ip4subnet || "",
                ip6: nic.ip6,
                ip6subnet: nic.ip6subnet || "",
                mac: nic.mac,
                internal: nic.internal,
                virtual: nic.internal ? false : testVirtualNic(nic.iface, nic.iface, nic.mac),
                operstate: nic.operstate,
                type: nic.type,
                duplex: nic.duplex,
                mtu: nic.mtu,
                speed: nic.speed,
                dhcp: getDarwinIfaceDHCPstatus(ifaceSanitized),
                dnsSuffix: "",
                ieee8021xAuth: "",
                ieee8021xState: "",
                carrierChanges: 0
              });
            });
            _networkInterfaces = result;
            if (defaultString.toLowerCase().indexOf("default") >= 0) {
              result = result.filter((item) => item.default);
              if (result.length > 0) {
                result = result[0];
              } else {
                result = [];
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
        if (_linux) {
          if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
            result = _networkInterfaces;
            if (callback) {
              callback(result);
            }
            resolve(result);
          } else {
            _ifaces = JSON.parse(JSON.stringify(ifaces));
            _dhcpNics = getLinuxDHCPNics();
            const defaultInterface = getDefaultNetworkInterface();
            for (let dev in ifaces) {
              let ip4 = "";
              let ip4subnet = "";
              let ip6 = "";
              let ip6subnet = "";
              let mac = "";
              let duplex = "";
              let mtu = "";
              let speed = null;
              let carrierChanges = 0;
              let dhcp = false;
              let dnsSuffix = "";
              let ieee8021xAuth = "";
              let ieee8021xState = "";
              let type2 = "";
              if ({}.hasOwnProperty.call(ifaces, dev)) {
                let ifaceName = dev;
                ifaces[dev].forEach(function(details) {
                  if (details.family === "IPv4" || details.family === 4) {
                    ip4 = details.address;
                    ip4subnet = details.netmask;
                  }
                  if (details.family === "IPv6" || details.family === 6) {
                    if (!ip6 || ip6.match(/^fe80::/i)) {
                      ip6 = details.address;
                      ip6subnet = details.netmask;
                    }
                  }
                  mac = details.mac;
                  const nodeMainVersion = parseInt(process.versions.node.split("."), 10);
                  if (mac.indexOf("00:00:0") > -1 && (_linux || _darwin) && !details.internal && nodeMainVersion >= 8 && nodeMainVersion <= 11) {
                    if (Object.keys(_mac).length === 0) {
                      _mac = getMacAddresses();
                    }
                    mac = _mac[dev] || "";
                  }
                });
                let iface = dev.split(":")[0].trim().toLowerCase();
                let ifaceSanitized = "";
                const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(iface);
                const l = util.mathMin(s.length, 2000);
                for (let i = 0;i <= l; i++) {
                  if (s[i] !== undefined) {
                    ifaceSanitized = ifaceSanitized + s[i];
                  }
                }
                const cmd = `echo -n "addr_assign_type: "; cat /sys/class/net/${ifaceSanitized}/addr_assign_type 2>/dev/null; echo;
            echo -n "address: "; cat /sys/class/net/${ifaceSanitized}/address 2>/dev/null; echo;
            echo -n "addr_len: "; cat /sys/class/net/${ifaceSanitized}/addr_len 2>/dev/null; echo;
            echo -n "broadcast: "; cat /sys/class/net/${ifaceSanitized}/broadcast 2>/dev/null; echo;
            echo -n "carrier: "; cat /sys/class/net/${ifaceSanitized}/carrier 2>/dev/null; echo;
            echo -n "carrier_changes: "; cat /sys/class/net/${ifaceSanitized}/carrier_changes 2>/dev/null; echo;
            echo -n "dev_id: "; cat /sys/class/net/${ifaceSanitized}/dev_id 2>/dev/null; echo;
            echo -n "dev_port: "; cat /sys/class/net/${ifaceSanitized}/dev_port 2>/dev/null; echo;
            echo -n "dormant: "; cat /sys/class/net/${ifaceSanitized}/dormant 2>/dev/null; echo;
            echo -n "duplex: "; cat /sys/class/net/${ifaceSanitized}/duplex 2>/dev/null; echo;
            echo -n "flags: "; cat /sys/class/net/${ifaceSanitized}/flags 2>/dev/null; echo;
            echo -n "gro_flush_timeout: "; cat /sys/class/net/${ifaceSanitized}/gro_flush_timeout 2>/dev/null; echo;
            echo -n "ifalias: "; cat /sys/class/net/${ifaceSanitized}/ifalias 2>/dev/null; echo;
            echo -n "ifindex: "; cat /sys/class/net/${ifaceSanitized}/ifindex 2>/dev/null; echo;
            echo -n "iflink: "; cat /sys/class/net/${ifaceSanitized}/iflink 2>/dev/null; echo;
            echo -n "link_mode: "; cat /sys/class/net/${ifaceSanitized}/link_mode 2>/dev/null; echo;
            echo -n "mtu: "; cat /sys/class/net/${ifaceSanitized}/mtu 2>/dev/null; echo;
            echo -n "netdev_group: "; cat /sys/class/net/${ifaceSanitized}/netdev_group 2>/dev/null; echo;
            echo -n "operstate: "; cat /sys/class/net/${ifaceSanitized}/operstate 2>/dev/null; echo;
            echo -n "proto_down: "; cat /sys/class/net/${ifaceSanitized}/proto_down 2>/dev/null; echo;
            echo -n "speed: "; cat /sys/class/net/${ifaceSanitized}/speed 2>/dev/null; echo;
            echo -n "tx_queue_len: "; cat /sys/class/net/${ifaceSanitized}/tx_queue_len 2>/dev/null; echo;
            echo -n "type: "; cat /sys/class/net/${ifaceSanitized}/type 2>/dev/null; echo;
            echo -n "wireless: "; cat /proc/net/wireless 2>/dev/null | grep ${ifaceSanitized}; echo;
            echo -n "wirelessspeed: "; iw dev ${ifaceSanitized} link 2>&1 | grep bitrate; echo;`;
                let lines = [];
                try {
                  lines = execSync(cmd).toString().split("\n");
                  const connectionName = getLinuxIfaceConnectionName(ifaceSanitized);
                  dhcp = getLinuxIfaceDHCPstatus(ifaceSanitized, connectionName, _dhcpNics);
                  dnsSuffix = getLinuxIfaceDNSsuffix(connectionName);
                  ieee8021xAuth = getLinuxIfaceIEEE8021xAuth(connectionName);
                  ieee8021xState = getLinuxIfaceIEEE8021xState(ieee8021xAuth);
                } catch (e) {
                  util.noop();
                }
                duplex = util.getValue(lines, "duplex");
                duplex = duplex.startsWith("cat") ? "" : duplex;
                mtu = parseInt(util.getValue(lines, "mtu"), 10);
                let myspeed = parseInt(util.getValue(lines, "speed"), 10);
                speed = isNaN(myspeed) ? null : myspeed;
                let wirelessspeed = util.getValue(lines, "wirelessspeed").split("tx bitrate: ");
                if (speed === null && wirelessspeed.length === 2) {
                  myspeed = parseFloat(wirelessspeed[1]);
                  speed = isNaN(myspeed) ? null : myspeed;
                }
                carrierChanges = parseInt(util.getValue(lines, "carrier_changes"), 10);
                const operstate = util.getValue(lines, "operstate");
                type2 = operstate === "up" ? util.getValue(lines, "wireless").trim() ? "wireless" : "wired" : "unknown";
                if (ifaceSanitized === "lo" || ifaceSanitized.startsWith("bond")) {
                  type2 = "virtual";
                }
                let internal = ifaces[dev] && ifaces[dev][0] ? ifaces[dev][0].internal : false;
                if (dev.toLowerCase().indexOf("loopback") > -1 || ifaceName.toLowerCase().indexOf("loopback") > -1) {
                  internal = true;
                }
                const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);
                result.push({
                  iface: ifaceSanitized,
                  ifaceName,
                  default: iface === defaultInterface,
                  ip4,
                  ip4subnet,
                  ip6,
                  ip6subnet,
                  mac,
                  internal,
                  virtual,
                  operstate,
                  type: type2,
                  duplex,
                  mtu,
                  speed,
                  dhcp,
                  dnsSuffix,
                  ieee8021xAuth,
                  ieee8021xState,
                  carrierChanges
                });
              }
            }
            _networkInterfaces = result;
            if (defaultString.toLowerCase().indexOf("default") >= 0) {
              result = result.filter((item) => item.default);
              if (result.length > 0) {
                result = result[0];
              } else {
                result = [];
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
        if (_windows) {
          if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
            result = _networkInterfaces;
            if (callback) {
              callback(result);
            }
            resolve(result);
          } else {
            _ifaces = JSON.parse(JSON.stringify(ifaces));
            const defaultInterface = getDefaultNetworkInterface();
            getWindowsNics().then(function(nics2) {
              nics2.forEach((nic) => {
                let found = false;
                Object.keys(ifaces).forEach((key) => {
                  if (!found) {
                    ifaces[key].forEach((value) => {
                      if (Object.keys(value).indexOf("mac") >= 0) {
                        found = value["mac"] === nic.mac;
                      }
                    });
                  }
                });
                if (!found) {
                  ifaces[nic.name] = [{ mac: nic.mac }];
                }
              });
              nics8021xInfo = getWindowsWiredProfilesInformation();
              dnsSuffixes = getWindowsDNSsuffixes();
              for (let dev in ifaces) {
                let ifaceSanitized = "";
                const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(dev);
                const l = util.mathMin(s.length, 2000);
                for (let i = 0;i <= l; i++) {
                  if (s[i] !== undefined) {
                    ifaceSanitized = ifaceSanitized + s[i];
                  }
                }
                let iface = dev;
                let ip4 = "";
                let ip4subnet = "";
                let ip6 = "";
                let ip6subnet = "";
                let mac = "";
                let duplex = "";
                let mtu = "";
                let speed = null;
                let carrierChanges = 0;
                let operstate = "down";
                let dhcp = false;
                let dnsSuffix = "";
                let ieee8021xAuth = "";
                let ieee8021xState = "";
                let type2 = "";
                if ({}.hasOwnProperty.call(ifaces, dev)) {
                  let ifaceName = dev;
                  ifaces[dev].forEach(function(details) {
                    if (details.family === "IPv4" || details.family === 4) {
                      ip4 = details.address;
                      ip4subnet = details.netmask;
                    }
                    if (details.family === "IPv6" || details.family === 6) {
                      if (!ip6 || ip6.match(/^fe80::/i)) {
                        ip6 = details.address;
                        ip6subnet = details.netmask;
                      }
                    }
                    mac = details.mac;
                    const nodeMainVersion = parseInt(process.versions.node.split("."), 10);
                    if (mac.indexOf("00:00:0") > -1 && (_linux || _darwin) && !details.internal && nodeMainVersion >= 8 && nodeMainVersion <= 11) {
                      if (Object.keys(_mac).length === 0) {
                        _mac = getMacAddresses();
                      }
                      mac = _mac[dev] || "";
                    }
                  });
                  dnsSuffix = getWindowsIfaceDNSsuffix(dnsSuffixes.ifaces, ifaceSanitized);
                  let foundFirst = false;
                  nics2.forEach((detail) => {
                    if (detail.mac === mac && !foundFirst) {
                      iface = detail.iface || iface;
                      ifaceName = detail.name;
                      dhcp = detail.dhcp;
                      operstate = detail.operstate;
                      speed = operstate === "up" ? detail.speed : 0;
                      type2 = detail.type;
                      foundFirst = true;
                    }
                  });
                  if (dev.toLowerCase().indexOf("wlan") >= 0 || ifaceName.toLowerCase().indexOf("wlan") >= 0 || ifaceName.toLowerCase().indexOf("802.11n") >= 0 || ifaceName.toLowerCase().indexOf("wireless") >= 0 || ifaceName.toLowerCase().indexOf("wi-fi") >= 0 || ifaceName.toLowerCase().indexOf("wifi") >= 0) {
                    type2 = "wireless";
                  }
                  const IEEE8021x = getWindowsIEEE8021x(type2, ifaceSanitized, nics8021xInfo);
                  ieee8021xAuth = IEEE8021x.protocol;
                  ieee8021xState = IEEE8021x.state;
                  let internal = ifaces[dev] && ifaces[dev][0] ? ifaces[dev][0].internal : false;
                  if (dev.toLowerCase().indexOf("loopback") > -1 || ifaceName.toLowerCase().indexOf("loopback") > -1) {
                    internal = true;
                  }
                  const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);
                  result.push({
                    iface,
                    ifaceName,
                    default: iface === defaultInterface,
                    ip4,
                    ip4subnet,
                    ip6,
                    ip6subnet,
                    mac,
                    internal,
                    virtual,
                    operstate,
                    type: type2,
                    duplex,
                    mtu,
                    speed,
                    dhcp,
                    dnsSuffix,
                    ieee8021xAuth,
                    ieee8021xState,
                    carrierChanges
                  });
                }
              }
              _networkInterfaces = result;
              if (defaultString.toLowerCase().indexOf("default") >= 0) {
                result = result.filter((item) => item.default);
                if (result.length > 0) {
                  result = result[0];
                } else {
                  result = [];
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
        }
      });
    });
  };
  var calcNetworkSpeed = function(iface, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors) {
    let result = {
      iface,
      operstate,
      rx_bytes,
      rx_dropped,
      rx_errors,
      tx_bytes,
      tx_dropped,
      tx_errors,
      rx_sec: null,
      tx_sec: null,
      ms: 0
    };
    if (_network[iface] && _network[iface].ms) {
      result.ms = Date.now() - _network[iface].ms;
      result.rx_sec = rx_bytes - _network[iface].rx_bytes >= 0 ? (rx_bytes - _network[iface].rx_bytes) / (result.ms / 1000) : 0;
      result.tx_sec = tx_bytes - _network[iface].tx_bytes >= 0 ? (tx_bytes - _network[iface].tx_bytes) / (result.ms / 1000) : 0;
      _network[iface].rx_bytes = rx_bytes;
      _network[iface].tx_bytes = tx_bytes;
      _network[iface].rx_sec = result.rx_sec;
      _network[iface].tx_sec = result.tx_sec;
      _network[iface].ms = Date.now();
      _network[iface].last_ms = result.ms;
      _network[iface].operstate = operstate;
    } else {
      if (!_network[iface]) {
        _network[iface] = {};
      }
      _network[iface].rx_bytes = rx_bytes;
      _network[iface].tx_bytes = tx_bytes;
      _network[iface].rx_sec = null;
      _network[iface].tx_sec = null;
      _network[iface].ms = Date.now();
      _network[iface].last_ms = 0;
      _network[iface].operstate = operstate;
    }
    return result;
  };
  var networkStats = function(ifaces, callback) {
    let ifacesArray = [];
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (util.isFunction(ifaces) && !callback) {
          callback = ifaces;
          ifacesArray = [getDefaultNetworkInterface()];
        } else {
          if (typeof ifaces !== "string" && ifaces !== undefined) {
            if (callback) {
              callback([]);
            }
            return resolve([]);
          }
          ifaces = ifaces || getDefaultNetworkInterface();
          ifaces.__proto__.toLowerCase = util.stringToLower;
          ifaces.__proto__.replace = util.stringReplace;
          ifaces.__proto__.trim = util.stringTrim;
          ifaces = ifaces.trim().toLowerCase().replace(/,+/g, "|");
          ifacesArray = ifaces.split("|");
        }
        const result = [];
        const workload = [];
        if (ifacesArray.length && ifacesArray[0].trim() === "*") {
          ifacesArray = [];
          networkInterfaces(false).then((allIFaces) => {
            for (let iface of allIFaces) {
              ifacesArray.push(iface.iface);
            }
            networkStats(ifacesArray.join(",")).then((result2) => {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          });
        } else {
          for (let iface of ifacesArray) {
            workload.push(networkStatsSingle(iface.trim()));
          }
          if (workload.length) {
            Promise.all(workload).then((data) => {
              if (callback) {
                callback(data);
              }
              resolve(data);
            });
          } else {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var networkStatsSingle = function(iface) {
    function parseLinesWindowsPerfData(sections) {
      let perfData = [];
      for (let i in sections) {
        if ({}.hasOwnProperty.call(sections, i)) {
          if (sections[i].trim() !== "") {
            let lines = sections[i].trim().split("\r\n");
            perfData.push({
              name: util.getValue(lines, "Name", ":").replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase(),
              rx_bytes: parseInt(util.getValue(lines, "BytesReceivedPersec", ":"), 10),
              rx_errors: parseInt(util.getValue(lines, "PacketsReceivedErrors", ":"), 10),
              rx_dropped: parseInt(util.getValue(lines, "PacketsReceivedDiscarded", ":"), 10),
              tx_bytes: parseInt(util.getValue(lines, "BytesSentPersec", ":"), 10),
              tx_errors: parseInt(util.getValue(lines, "PacketsOutboundErrors", ":"), 10),
              tx_dropped: parseInt(util.getValue(lines, "PacketsOutboundDiscarded", ":"), 10)
            });
          }
        }
      }
      return perfData;
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        let ifaceSanitized = "";
        const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(iface);
        const l = util.mathMin(s.length, 2000);
        for (let i = 0;i <= l; i++) {
          if (s[i] !== undefined) {
            ifaceSanitized = ifaceSanitized + s[i];
          }
        }
        let result = {
          iface: ifaceSanitized,
          operstate: "unknown",
          rx_bytes: 0,
          rx_dropped: 0,
          rx_errors: 0,
          tx_bytes: 0,
          tx_dropped: 0,
          tx_errors: 0,
          rx_sec: null,
          tx_sec: null,
          ms: 0
        };
        let operstate = "unknown";
        let rx_bytes = 0;
        let tx_bytes = 0;
        let rx_dropped = 0;
        let rx_errors = 0;
        let tx_dropped = 0;
        let tx_errors = 0;
        let cmd, lines, stats;
        if (!_network[ifaceSanitized] || _network[ifaceSanitized] && !_network[ifaceSanitized].ms || _network[ifaceSanitized] && _network[ifaceSanitized].ms && Date.now() - _network[ifaceSanitized].ms >= 500) {
          if (_linux) {
            if (fs.existsSync("/sys/class/net/" + ifaceSanitized)) {
              cmd = "cat /sys/class/net/" + ifaceSanitized + "/operstate; " + "cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_bytes; " + "cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_bytes; " + "cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_dropped; " + "cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_errors; " + "cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_dropped; " + "cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_errors; ";
              exec(cmd, function(error, stdout) {
                if (!error) {
                  lines = stdout.toString().split("\n");
                  operstate = lines[0].trim();
                  rx_bytes = parseInt(lines[1], 10);
                  tx_bytes = parseInt(lines[2], 10);
                  rx_dropped = parseInt(lines[3], 10);
                  rx_errors = parseInt(lines[4], 10);
                  tx_dropped = parseInt(lines[5], 10);
                  tx_errors = parseInt(lines[6], 10);
                  result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                }
                resolve(result);
              });
            } else {
              resolve(result);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            cmd = "netstat -ibndI " + ifaceSanitized;
            exec(cmd, function(error, stdout) {
              if (!error) {
                lines = stdout.toString().split("\n");
                for (let i = 1;i < lines.length; i++) {
                  const line = lines[i].replace(/ +/g, " ").split(" ");
                  if (line && line[0] && line[7] && line[10]) {
                    rx_bytes = rx_bytes + parseInt(line[7]);
                    if (line[6].trim() !== "-") {
                      rx_dropped = rx_dropped + parseInt(line[6]);
                    }
                    if (line[5].trim() !== "-") {
                      rx_errors = rx_errors + parseInt(line[5]);
                    }
                    tx_bytes = tx_bytes + parseInt(line[10]);
                    if (line[12].trim() !== "-") {
                      tx_dropped = tx_dropped + parseInt(line[12]);
                    }
                    if (line[9].trim() !== "-") {
                      tx_errors = tx_errors + parseInt(line[9]);
                    }
                    operstate = "up";
                  }
                }
                result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            cmd = "ifconfig " + ifaceSanitized + ' | grep "status"';
            exec(cmd, function(error, stdout) {
              result.operstate = (stdout.toString().split(":")[1] || "").trim();
              result.operstate = (result.operstate || "").toLowerCase();
              result.operstate = result.operstate === "active" ? "up" : result.operstate === "inactive" ? "down" : "unknown";
              cmd = "netstat -bdI " + ifaceSanitized;
              exec(cmd, function(error2, stdout2) {
                if (!error2) {
                  lines = stdout2.toString().split("\n");
                  if (lines.length > 1 && lines[1].trim() !== "") {
                    stats = lines[1].replace(/ +/g, " ").split(" ");
                    const offset = stats.length > 11 ? 1 : 0;
                    rx_bytes = parseInt(stats[offset + 5]);
                    rx_dropped = parseInt(stats[offset + 10]);
                    rx_errors = parseInt(stats[offset + 4]);
                    tx_bytes = parseInt(stats[offset + 8]);
                    tx_dropped = parseInt(stats[offset + 10]);
                    tx_errors = parseInt(stats[offset + 7]);
                    result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, result.operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                  }
                }
                resolve(result);
              });
            });
          }
          if (_windows) {
            let perfData = [];
            let ifaceName = ifaceSanitized;
            util.powerShell("Get-CimInstance Win32_PerfRawData_Tcpip_NetworkInterface | select Name,BytesReceivedPersec,PacketsReceivedErrors,PacketsReceivedDiscarded,BytesSentPersec,PacketsOutboundErrors,PacketsOutboundDiscarded | fl").then((stdout, error) => {
              if (!error) {
                const psections = stdout.toString().split(/\n\s*\n/);
                perfData = parseLinesWindowsPerfData(psections);
              }
              networkInterfaces(false).then((interfaces) => {
                rx_bytes = 0;
                tx_bytes = 0;
                perfData.forEach((detail) => {
                  interfaces.forEach((det) => {
                    if ((det.iface.toLowerCase() === ifaceSanitized.toLowerCase() || det.mac.toLowerCase() === ifaceSanitized.toLowerCase() || det.ip4.toLowerCase() === ifaceSanitized.toLowerCase() || det.ip6.toLowerCase() === ifaceSanitized.toLowerCase() || det.ifaceName.replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase() === ifaceSanitized.replace(/[()[\] ]+/g, "").replace("#", "_").toLowerCase()) && det.ifaceName.replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase() === detail.name) {
                      ifaceName = det.iface;
                      rx_bytes = detail.rx_bytes;
                      rx_dropped = detail.rx_dropped;
                      rx_errors = detail.rx_errors;
                      tx_bytes = detail.tx_bytes;
                      tx_dropped = detail.tx_dropped;
                      tx_errors = detail.tx_errors;
                      operstate = det.operstate;
                    }
                  });
                });
                if (rx_bytes && tx_bytes) {
                  result = calcNetworkSpeed(ifaceName, parseInt(rx_bytes), parseInt(tx_bytes), operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                }
                resolve(result);
              });
            });
          }
        } else {
          result.rx_bytes = _network[ifaceSanitized].rx_bytes;
          result.tx_bytes = _network[ifaceSanitized].tx_bytes;
          result.rx_sec = _network[ifaceSanitized].rx_sec;
          result.tx_sec = _network[ifaceSanitized].tx_sec;
          result.ms = _network[ifaceSanitized].last_ms;
          result.operstate = _network[ifaceSanitized].operstate;
          resolve(result);
        }
      });
    });
  };
  var getProcessName = function(processes, pid) {
    let cmd = "";
    processes.forEach((line) => {
      const parts = line.split(" ");
      const id2 = parseInt(parts[0], 10) || -1;
      if (id2 === pid) {
        parts.shift();
        cmd = parts.join(" ").split(":")[0];
      }
    });
    cmd = cmd.split(" -")[0];
    const cmdParts = cmd.split("/");
    return cmdParts[cmdParts.length - 1];
  };
  var networkConnections = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = [];
        if (_linux || _freebsd || _openbsd || _netbsd) {
          let cmd = 'export LC_ALL=C; netstat -tunap | grep "ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN"; unset LC_ALL';
          if (_freebsd || _openbsd || _netbsd) {
            cmd = 'export LC_ALL=C; netstat -na | grep "ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN"; unset LC_ALL';
          }
          exec(cmd, { maxBuffer: 1024 * 20000 }, function(error, stdout) {
            let lines = stdout.toString().split("\n");
            if (!error && (lines.length > 1 || lines[0] != "")) {
              lines.forEach(function(line) {
                line = line.replace(/ +/g, " ").split(" ");
                if (line.length >= 7) {
                  let localip = line[3];
                  let localport = "";
                  let localaddress = line[3].split(":");
                  if (localaddress.length > 1) {
                    localport = localaddress[localaddress.length - 1];
                    localaddress.pop();
                    localip = localaddress.join(":");
                  }
                  let peerip = line[4];
                  let peerport = "";
                  let peeraddress = line[4].split(":");
                  if (peeraddress.length > 1) {
                    peerport = peeraddress[peeraddress.length - 1];
                    peeraddress.pop();
                    peerip = peeraddress.join(":");
                  }
                  let connstate = line[5];
                  let proc = line[6].split("/");
                  if (connstate) {
                    result.push({
                      protocol: line[0],
                      localAddress: localip,
                      localPort: localport,
                      peerAddress: peerip,
                      peerPort: peerport,
                      state: connstate,
                      pid: proc[0] && proc[0] !== "-" ? parseInt(proc[0], 10) : null,
                      process: proc[1] ? proc[1].split(" ")[0].split(":")[0] : ""
                    });
                  }
                }
              });
              if (callback) {
                callback(result);
              }
              resolve(result);
            } else {
              cmd = 'ss -tunap | grep "ESTAB\\|SYN-SENT\\|SYN-RECV\\|FIN-WAIT1\\|FIN-WAIT2\\|TIME-WAIT\\|CLOSE\\|CLOSE-WAIT\\|LAST-ACK\\|LISTEN\\|CLOSING"';
              exec(cmd, { maxBuffer: 1024 * 20000 }, function(error2, stdout2) {
                if (!error2) {
                  let lines2 = stdout2.toString().split("\n");
                  lines2.forEach(function(line) {
                    line = line.replace(/ +/g, " ").split(" ");
                    if (line.length >= 6) {
                      let localip = line[4];
                      let localport = "";
                      let localaddress = line[4].split(":");
                      if (localaddress.length > 1) {
                        localport = localaddress[localaddress.length - 1];
                        localaddress.pop();
                        localip = localaddress.join(":");
                      }
                      let peerip = line[5];
                      let peerport = "";
                      let peeraddress = line[5].split(":");
                      if (peeraddress.length > 1) {
                        peerport = peeraddress[peeraddress.length - 1];
                        peeraddress.pop();
                        peerip = peeraddress.join(":");
                      }
                      let connstate = line[1];
                      if (connstate === "ESTAB") {
                        connstate = "ESTABLISHED";
                      }
                      if (connstate === "TIME-WAIT") {
                        connstate = "TIME_WAIT";
                      }
                      let pid = null;
                      let process2 = "";
                      if (line.length >= 7 && line[6].indexOf("users:") > -1) {
                        let proc = line[6].replace('users:(("', "").replace(/"/g, "").split(",");
                        if (proc.length > 2) {
                          process2 = proc[0].split(" ")[0].split(":")[0];
                          pid = parseInt(proc[1], 10);
                        }
                      }
                      if (connstate) {
                        result.push({
                          protocol: line[0],
                          localAddress: localip,
                          localPort: localport,
                          peerAddress: peerip,
                          peerPort: peerport,
                          state: connstate,
                          pid,
                          process: process2
                        });
                      }
                    }
                  });
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            }
          });
        }
        if (_darwin) {
          let cmd = 'netstat -natvln | grep "tcp4\\|tcp6\\|udp4\\|udp6"';
          const states = "ESTABLISHED|SYN_SENT|SYN_RECV|FIN_WAIT1|FIN_WAIT2|TIME_WAIT|CLOSE|CLOSE_WAIT|LAST_ACK|LISTEN|CLOSING|UNKNOWN";
          exec(cmd, { maxBuffer: 1024 * 20000 }, function(error, stdout) {
            if (!error) {
              exec("ps -axo pid,command", { maxBuffer: 1024 * 20000 }, function(err2, stdout2) {
                let processes = stdout2.toString().split("\n");
                processes = processes.map((line) => {
                  return line.trim().replace(/ +/g, " ");
                });
                let lines = stdout.toString().split("\n");
                lines.forEach(function(line) {
                  line = line.replace(/ +/g, " ").split(" ");
                  if (line.length >= 8) {
                    let localip = line[3];
                    let localport = "";
                    let localaddress = line[3].split(".");
                    if (localaddress.length > 1) {
                      localport = localaddress[localaddress.length - 1];
                      localaddress.pop();
                      localip = localaddress.join(".");
                    }
                    let peerip = line[4];
                    let peerport = "";
                    let peeraddress = line[4].split(".");
                    if (peeraddress.length > 1) {
                      peerport = peeraddress[peeraddress.length - 1];
                      peeraddress.pop();
                      peerip = peeraddress.join(".");
                    }
                    const hasState = states.indexOf(line[5]) >= 0;
                    let connstate = hasState ? line[5] : "UNKNOWN";
                    let pid = parseInt(line[8 + (hasState ? 0 : -1)], 10);
                    if (connstate) {
                      result.push({
                        protocol: line[0],
                        localAddress: localip,
                        localPort: localport,
                        peerAddress: peerip,
                        peerPort: peerport,
                        state: connstate,
                        pid,
                        process: getProcessName(processes, pid)
                      });
                    }
                  }
                });
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            }
          });
        }
        if (_windows) {
          let cmd = "netstat -nao";
          try {
            exec(cmd, util.execOptsWin, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\r\n");
                lines.forEach(function(line) {
                  line = line.trim().replace(/ +/g, " ").split(" ");
                  if (line.length >= 4) {
                    let localip = line[1];
                    let localport = "";
                    let localaddress = line[1].split(":");
                    if (localaddress.length > 1) {
                      localport = localaddress[localaddress.length - 1];
                      localaddress.pop();
                      localip = localaddress.join(":");
                    }
                    localip = localip.replace(/\[/g, "").replace(/\]/g, "");
                    let peerip = line[2];
                    let peerport = "";
                    let peeraddress = line[2].split(":");
                    if (peeraddress.length > 1) {
                      peerport = peeraddress[peeraddress.length - 1];
                      peeraddress.pop();
                      peerip = peeraddress.join(":");
                    }
                    peerip = peerip.replace(/\[/g, "").replace(/\]/g, "");
                    let pid = util.toInt(line[4]);
                    let connstate = line[3];
                    if (connstate === "HERGESTELLT") {
                      connstate = "ESTABLISHED";
                    }
                    if (connstate.startsWith("ABH")) {
                      connstate = "LISTEN";
                    }
                    if (connstate === "SCHLIESSEN_WARTEN") {
                      connstate = "CLOSE_WAIT";
                    }
                    if (connstate === "WARTEND") {
                      connstate = "TIME_WAIT";
                    }
                    if (connstate === "SYN_GESENDET") {
                      connstate = "SYN_SENT";
                    }
                    if (connstate === "LISTENING") {
                      connstate = "LISTEN";
                    }
                    if (connstate === "SYN_RECEIVED") {
                      connstate = "SYN_RECV";
                    }
                    if (connstate === "FIN_WAIT_1") {
                      connstate = "FIN_WAIT1";
                    }
                    if (connstate === "FIN_WAIT_2") {
                      connstate = "FIN_WAIT2";
                    }
                    if (line[0].toLowerCase() !== "udp" && connstate) {
                      result.push({
                        protocol: line[0].toLowerCase(),
                        localAddress: localip,
                        localPort: localport,
                        peerAddress: peerip,
                        peerPort: peerport,
                        state: connstate,
                        pid,
                        process: ""
                      });
                    } else if (line[0].toLowerCase() === "udp") {
                      result.push({
                        protocol: line[0].toLowerCase(),
                        localAddress: localip,
                        localPort: localport,
                        peerAddress: peerip,
                        peerPort: peerport,
                        state: "",
                        pid: parseInt(line[3], 10),
                        process: ""
                      });
                    }
                  }
                });
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var networkGatewayDefault = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = "";
        if (_linux || _freebsd || _openbsd || _netbsd) {
          let cmd = "ip route get 1";
          try {
            exec(cmd, { maxBuffer: 1024 * 20000 }, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                const line = lines && lines[0] ? lines[0] : "";
                let parts = line.split(" via ");
                if (parts && parts[1]) {
                  parts = parts[1].split(" ");
                  result = parts[0];
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
        if (_darwin) {
          let cmd = "route -n get default";
          try {
            exec(cmd, { maxBuffer: 1024 * 20000 }, function(error, stdout) {
              if (!error) {
                const lines = stdout.toString().split("\n").map((line) => line.trim());
                result = util.getValue(lines, "gateway");
              }
              if (!result) {
                cmd = "netstat -rn | awk \'/default/ {print $2}\'";
                exec(cmd, { maxBuffer: 1024 * 20000 }, function(error2, stdout2) {
                  const lines = stdout2.toString().split("\n").map((line) => line.trim());
                  result = lines.find((line) => /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(line));
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
        if (_windows) {
          try {
            exec("netstat -r", util.execOptsWin, function(error, stdout) {
              const lines = stdout.toString().split(os.EOL);
              lines.forEach((line) => {
                line = line.replace(/\s+/g, " ").trim();
                if (line.indexOf("0.0.0.0 0.0.0.0") > -1 && !/[a-zA-Z]/.test(line)) {
                  const parts = line.split(" ");
                  if (parts.length >= 5 && parts[parts.length - 3].indexOf(".") > -1) {
                    result = parts[parts.length - 3];
                  }
                }
              });
              if (!result) {
                util.powerShell("Get-CimInstance -ClassName Win32_IP4RouteTable | Where-Object { $_.Destination -eq \'0.0.0.0\' -and $_.Mask -eq \'0.0.0.0\' }").then((data) => {
                  let lines2 = data.toString().split("\r\n");
                  if (lines2.length > 1 && !result) {
                    result = util.getValue(lines2, "NextHop");
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                });
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var os = __require("os");
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var fs = __require("fs");
  var util = require_util4();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  var _network = {};
  var _default_iface = "";
  var _ifaces = {};
  var _dhcpNics = [];
  var _networkInterfaces = [];
  var _mac = {};
  var pathToIp;
  exports2.getDefaultNetworkInterface = getDefaultNetworkInterface;
  exports2.networkInterfaceDefault = networkInterfaceDefault;
  exports2.networkInterfaces = networkInterfaces;
  exports2.networkStats = networkStats;
  exports2.networkConnections = networkConnections;
  exports2.networkGatewayDefault = networkGatewayDefault;
});

// ../../node_modules/systeminformation/lib/wifi.js
var require_wifi = __commonJS((exports2) => {
  var wifiDBFromQuality = function(quality) {
    const qual = parseFloat(quality);
    if (qual < 0) {
      return 0;
    }
    if (qual >= 100) {
      return -50;
    }
    return qual / 2 - 100;
  };
  var wifiQualityFromDB = function(db) {
    const result = 2 * (parseFloat(db) + 100);
    return result <= 100 ? result : 100;
  };
  var wifiFrequencyFromChannel = function(channel) {
    return {}.hasOwnProperty.call(_wifi_frequencies, channel) ? _wifi_frequencies[channel] : null;
  };
  var wifiChannelFromFrequencs = function(frequency) {
    let channel = 0;
    for (let key in _wifi_frequencies) {
      if ({}.hasOwnProperty.call(_wifi_frequencies, key)) {
        if (_wifi_frequencies[key] === frequency) {
          channel = util.toInt(key);
        }
      }
    }
    return channel;
  };
  var ifaceListLinux = function() {
    const result = [];
    const cmd = "iw dev 2>/dev/null";
    try {
      const all2 = execSync(cmd).toString().split("\n").map((line) => line.trim()).join("\n");
      const parts = all2.split("\nInterface ");
      parts.shift();
      parts.forEach((ifaceDetails) => {
        const lines = ifaceDetails.split("\n");
        const iface = lines[0];
        const id2 = util.toInt(util.getValue(lines, "ifindex", " "));
        const mac = util.getValue(lines, "addr", " ");
        const channel = util.toInt(util.getValue(lines, "channel", " "));
        result.push({
          id: id2,
          iface,
          mac,
          channel
        });
      });
      return result;
    } catch (e) {
      try {
        const all2 = execSync("nmcli -t -f general,wifi-properties,wired-properties,interface-flags,capabilities,nsp device show 2>/dev/null").toString();
        const parts = all2.split("\n\n");
        let i = 1;
        parts.forEach((ifaceDetails) => {
          const lines = ifaceDetails.split("\n");
          const iface = util.getValue(lines, "GENERAL.DEVICE");
          const type2 = util.getValue(lines, "GENERAL.TYPE");
          const id2 = i++;
          const mac = util.getValue(lines, "GENERAL.HWADDR");
          const channel = "";
          if (type2.toLowerCase() === "wifi") {
            result.push({
              id: id2,
              iface,
              mac,
              channel
            });
          }
        });
        return result;
      } catch (e2) {
        return [];
      }
    }
  };
  var nmiDeviceLinux = function(iface) {
    const cmd = `nmcli -t -f general,wifi-properties,capabilities,ip4,ip6 device show ${iface} 2>/dev/null`;
    try {
      const lines = execSync(cmd).toString().split("\n");
      const ssid = util.getValue(lines, "GENERAL.CONNECTION");
      return {
        iface,
        type: util.getValue(lines, "GENERAL.TYPE"),
        vendor: util.getValue(lines, "GENERAL.VENDOR"),
        product: util.getValue(lines, "GENERAL.PRODUCT"),
        mac: util.getValue(lines, "GENERAL.HWADDR").toLowerCase(),
        ssid: ssid !== "--" ? ssid : null
      };
    } catch (e) {
      return {};
    }
  };
  var nmiConnectionLinux = function(ssid) {
    const cmd = `nmcli -t --show-secrets connection show ${ssid} 2>/dev/null`;
    try {
      const lines = execSync(cmd).toString().split("\n");
      const bssid = util.getValue(lines, "802-11-wireless.seen-bssids").toLowerCase();
      return {
        ssid: ssid !== "--" ? ssid : null,
        uuid: util.getValue(lines, "connection.uuid"),
        type: util.getValue(lines, "connection.type"),
        autoconnect: util.getValue(lines, "connection.autoconnect") === "yes",
        security: util.getValue(lines, "802-11-wireless-security.key-mgmt"),
        bssid: bssid !== "--" ? bssid : null
      };
    } catch (e) {
      return {};
    }
  };
  var wpaConnectionLinux = function(iface) {
    if (!iface) {
      return {};
    }
    const cmd = `wpa_cli -i ${iface} status 2>&1`;
    try {
      const lines = execSync(cmd).toString().split("\n");
      const freq = util.toInt(util.getValue(lines, "freq", "="));
      return {
        ssid: util.getValue(lines, "ssid", "="),
        uuid: util.getValue(lines, "uuid", "="),
        security: util.getValue(lines, "key_mgmt", "="),
        freq,
        channel: wifiChannelFromFrequencs(freq),
        bssid: util.getValue(lines, "bssid", "=").toLowerCase()
      };
    } catch (e) {
      return {};
    }
  };
  var getWifiNetworkListNmi = function() {
    const result = [];
    const cmd = "nmcli -t -m multiline --fields active,ssid,bssid,mode,chan,freq,signal,security,wpa-flags,rsn-flags device wifi list 2>/dev/null";
    try {
      const stdout = execSync(cmd, { maxBuffer: 1024 * 20000 });
      const parts = stdout.toString().split("ACTIVE:");
      parts.shift();
      parts.forEach((part) => {
        part = "ACTIVE:" + part;
        const lines = part.split(os.EOL);
        const channel = util.getValue(lines, "CHAN");
        const frequency = util.getValue(lines, "FREQ").toLowerCase().replace("mhz", "").trim();
        const security = util.getValue(lines, "SECURITY").replace("(", "").replace(")", "");
        const wpaFlags = util.getValue(lines, "WPA-FLAGS").replace("(", "").replace(")", "");
        const rsnFlags = util.getValue(lines, "RSN-FLAGS").replace("(", "").replace(")", "");
        const quality = util.getValue(lines, "SIGNAL");
        result.push({
          ssid: util.getValue(lines, "SSID"),
          bssid: util.getValue(lines, "BSSID").toLowerCase(),
          mode: util.getValue(lines, "MODE"),
          channel: channel ? parseInt(channel, 10) : null,
          frequency: frequency ? parseInt(frequency, 10) : null,
          signalLevel: wifiDBFromQuality(quality),
          quality: quality ? parseInt(quality, 10) : null,
          security: security && security !== "none" ? security.split(" ") : [],
          wpaFlags: wpaFlags && wpaFlags !== "none" ? wpaFlags.split(" ") : [],
          rsnFlags: rsnFlags && rsnFlags !== "none" ? rsnFlags.split(" ") : []
        });
      });
      return result;
    } catch (e) {
      return [];
    }
  };
  var getWifiNetworkListIw = function(iface) {
    const result = [];
    try {
      let iwlistParts = execSync(`export LC_ALL=C; iwlist ${iface} scan 2>&1; unset LC_ALL`).toString().split("        Cell ");
      if (iwlistParts[0].indexOf("resource busy") >= 0) {
        return -1;
      }
      if (iwlistParts.length > 1) {
        iwlistParts.shift();
        iwlistParts.forEach((element) => {
          const lines = element.split("\n");
          const channel = util.getValue(lines, "channel", ":", true);
          const address = lines && lines.length && lines[0].indexOf("Address:") >= 0 ? lines[0].split("Address:")[1].trim().toLowerCase() : "";
          const mode = util.getValue(lines, "mode", ":", true);
          const frequency = util.getValue(lines, "frequency", ":", true);
          const qualityString = util.getValue(lines, "Quality", "=", true);
          const dbParts = qualityString.toLowerCase().split("signal level=");
          const db = dbParts.length > 1 ? util.toInt(dbParts[1]) : 0;
          const quality = db ? wifiQualityFromDB(db) : 0;
          const ssid = util.getValue(lines, "essid", ":", true);
          const isWpa = element.indexOf(" WPA ") >= 0;
          const isWpa2 = element.indexOf("WPA2 ") >= 0;
          const security = [];
          if (isWpa) {
            security.push("WPA");
          }
          if (isWpa2) {
            security.push("WPA2");
          }
          const wpaFlags = [];
          let wpaFlag = "";
          lines.forEach(function(line) {
            const l = line.trim().toLowerCase();
            if (l.indexOf("group cipher") >= 0) {
              if (wpaFlag) {
                wpaFlags.push(wpaFlag);
              }
              const parts = l.split(":");
              if (parts.length > 1) {
                wpaFlag = parts[1].trim().toUpperCase();
              }
            }
            if (l.indexOf("pairwise cipher") >= 0) {
              const parts = l.split(":");
              if (parts.length > 1) {
                if (parts[1].indexOf("tkip")) {
                  wpaFlag = wpaFlag ? "TKIP/" + wpaFlag : "TKIP";
                } else if (parts[1].indexOf("ccmp")) {
                  wpaFlag = wpaFlag ? "CCMP/" + wpaFlag : "CCMP";
                } else if (parts[1].indexOf("proprietary")) {
                  wpaFlag = wpaFlag ? "PROP/" + wpaFlag : "PROP";
                }
              }
            }
            if (l.indexOf("authentication suites") >= 0) {
              const parts = l.split(":");
              if (parts.length > 1) {
                if (parts[1].indexOf("802.1x")) {
                  wpaFlag = wpaFlag ? "802.1x/" + wpaFlag : "802.1x";
                } else if (parts[1].indexOf("psk")) {
                  wpaFlag = wpaFlag ? "PSK/" + wpaFlag : "PSK";
                }
              }
            }
          });
          if (wpaFlag) {
            wpaFlags.push(wpaFlag);
          }
          result.push({
            ssid,
            bssid: address,
            mode,
            channel: channel ? util.toInt(channel) : null,
            frequency: frequency ? util.toInt(frequency.replace(".", "")) : null,
            signalLevel: db,
            quality,
            security,
            wpaFlags,
            rsnFlags: []
          });
        });
      }
      return result;
    } catch (e) {
      return -1;
    }
  };
  var parseWifiDarwin = function(wifiObj) {
    const result = [];
    if (wifiObj) {
      wifiObj.forEach(function(wifiItem) {
        const signalLevel = wifiItem.RSSI;
        let security = [];
        let wpaFlags = [];
        let ssid = wifiItem.SSID_STR || "";
        if (wifiItem.WPA_IE) {
          security.push("WPA");
          if (wifiItem.WPA_IE.IE_KEY_WPA_UCIPHERS) {
            wifiItem.WPA_IE.IE_KEY_WPA_UCIPHERS.forEach(function(ciphers) {
              if (ciphers === 0 && wpaFlags.indexOf("unknown/TKIP") === -1) {
                wpaFlags.push("unknown/TKIP");
              }
              if (ciphers === 2 && wpaFlags.indexOf("PSK/TKIP") === -1) {
                wpaFlags.push("PSK/TKIP");
              }
              if (ciphers === 4 && wpaFlags.indexOf("PSK/AES") === -1) {
                wpaFlags.push("PSK/AES");
              }
            });
          }
        }
        if (wifiItem.RSN_IE) {
          security.push("WPA2");
          if (wifiItem.RSN_IE.IE_KEY_RSN_UCIPHERS) {
            wifiItem.RSN_IE.IE_KEY_RSN_UCIPHERS.forEach(function(ciphers) {
              if (ciphers === 0 && wpaFlags.indexOf("unknown/TKIP") === -1) {
                wpaFlags.push("unknown/TKIP");
              }
              if (ciphers === 2 && wpaFlags.indexOf("TKIP/TKIP") === -1) {
                wpaFlags.push("TKIP/TKIP");
              }
              if (ciphers === 4 && wpaFlags.indexOf("PSK/AES") === -1) {
                wpaFlags.push("PSK/AES");
              }
            });
          }
        }
        if (wifiItem.SSID && ssid === "") {
          try {
            ssid = Buffer.from(wifiItem.SSID, "base64").toString("utf8");
          } catch (err) {
            util.noop();
          }
        }
        result.push({
          ssid,
          bssid: wifiItem.BSSID || "",
          mode: "",
          channel: wifiItem.CHANNEL,
          frequency: wifiFrequencyFromChannel(wifiItem.CHANNEL),
          signalLevel: signalLevel ? parseInt(signalLevel, 10) : null,
          quality: wifiQualityFromDB(signalLevel),
          security,
          wpaFlags,
          rsnFlags: []
        });
      });
    }
    return result;
  };
  var wifiNetworks = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = [];
        if (_linux) {
          result = getWifiNetworkListNmi();
          if (result.length === 0) {
            try {
              const iwconfigParts = execSync("export LC_ALL=C; iwconfig 2>/dev/null; unset LC_ALL").toString().split("\n\n");
              let iface = "";
              iwconfigParts.forEach((element) => {
                if (element.indexOf("no wireless") === -1 && element.trim() !== "") {
                  iface = element.split(" ")[0];
                }
              });
              if (iface) {
                let ifaceSanitized = "";
                const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(iface, true);
                const l = util.mathMin(s.length, 2000);
                for (let i = 0;i <= l; i++) {
                  if (s[i] !== undefined) {
                    ifaceSanitized = ifaceSanitized + s[i];
                  }
                }
                const res = getWifiNetworkListIw(ifaceSanitized);
                if (res === -1) {
                  setTimeout(function(iface2) {
                    const res2 = getWifiNetworkListIw(iface2);
                    if (res2 != -1) {
                      result = res2;
                    }
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }, 4000);
                } else {
                  result = res;
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          } else {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        } else if (_darwin) {
          let cmd = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -s -x";
          exec(cmd, { maxBuffer: 1024 * 40000 }, function(error, stdout) {
            const output = stdout.toString();
            result = parseWifiDarwin(util.plistParser(output));
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        } else if (_windows) {
          let cmd = "netsh wlan show networks mode=Bssid";
          util.powerShell(cmd).then((stdout) => {
            const ssidParts = stdout.toString("utf8").split(os.EOL + os.EOL + "SSID ");
            ssidParts.shift();
            ssidParts.forEach((ssidPart) => {
              const ssidLines = ssidPart.split(os.EOL);
              if (ssidLines && ssidLines.length >= 8 && ssidLines[0].indexOf(":") >= 0) {
                const bssidsParts = ssidPart.split(" BSSID");
                bssidsParts.shift();
                bssidsParts.forEach((bssidPart) => {
                  const bssidLines = bssidPart.split(os.EOL);
                  const bssidLine = bssidLines[0].split(":");
                  bssidLine.shift();
                  const bssid = bssidLine.join(":").trim().toLowerCase();
                  const channel = bssidLines[3].split(":").pop().trim();
                  const quality = bssidLines[1].split(":").pop().trim();
                  result.push({
                    ssid: ssidLines[0].split(":").pop().trim(),
                    bssid,
                    mode: "",
                    channel: channel ? parseInt(channel, 10) : null,
                    frequency: wifiFrequencyFromChannel(channel),
                    signalLevel: wifiDBFromQuality(quality),
                    quality: quality ? parseInt(quality, 10) : null,
                    security: [ssidLines[2].split(":").pop().trim()],
                    wpaFlags: [ssidLines[3].split(":").pop().trim()],
                    rsnFlags: []
                  });
                });
              }
            });
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        } else {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
      });
    });
  };
  var getVendor = function(model) {
    model = model.toLowerCase();
    let result = "";
    if (model.indexOf("intel") >= 0) {
      result = "Intel";
    } else if (model.indexOf("realtek") >= 0) {
      result = "Realtek";
    } else if (model.indexOf("qualcom") >= 0) {
      result = "Qualcom";
    } else if (model.indexOf("broadcom") >= 0) {
      result = "Broadcom";
    } else if (model.indexOf("cavium") >= 0) {
      result = "Cavium";
    } else if (model.indexOf("cisco") >= 0) {
      result = "Cisco";
    } else if (model.indexOf("marvel") >= 0) {
      result = "Marvel";
    } else if (model.indexOf("zyxel") >= 0) {
      result = "Zyxel";
    } else if (model.indexOf("melanox") >= 0) {
      result = "Melanox";
    } else if (model.indexOf("d-link") >= 0) {
      result = "D-Link";
    } else if (model.indexOf("tp-link") >= 0) {
      result = "TP-Link";
    } else if (model.indexOf("asus") >= 0) {
      result = "Asus";
    } else if (model.indexOf("linksys") >= 0) {
      result = "Linksys";
    }
    return result;
  };
  var formatBssid = function(s) {
    s = s.replace(/</g, "").replace(/>/g, "").match(/.{1,2}/g) || [];
    return s.join(":");
  };
  var wifiConnections = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const result = [];
        if (_linux) {
          const ifaces = ifaceListLinux();
          const networkList = getWifiNetworkListNmi();
          ifaces.forEach((ifaceDetail) => {
            let ifaceSanitized = "";
            const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(ifaceDetail.iface, true);
            const ll = util.mathMin(s.length, 2000);
            for (let i = 0;i <= ll; i++) {
              if (s[i] !== undefined) {
                ifaceSanitized = ifaceSanitized + s[i];
              }
            }
            const nmiDetails = nmiDeviceLinux(ifaceSanitized);
            const wpaDetails = wpaConnectionLinux(ifaceSanitized);
            const ssid = nmiDetails.ssid || wpaDetails.ssid;
            const network = networkList.filter((nw) => nw.ssid === ssid);
            let ssidSanitized = "";
            const t = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(ssid, true);
            const l = util.mathMin(t.length, 2000);
            for (let i = 0;i <= l; i++) {
              if (t[i] !== undefined) {
                ssidSanitized = ssidSanitized + t[i];
              }
            }
            const nmiConnection = nmiConnectionLinux(ssidSanitized);
            const channel = network && network.length && network[0].channel ? network[0].channel : wpaDetails.channel ? wpaDetails.channel : null;
            const bssid = network && network.length && network[0].bssid ? network[0].bssid : wpaDetails.bssid ? wpaDetails.bssid : null;
            const signalLevel = network && network.length && network[0].signalLevel ? network[0].signalLevel : null;
            if (ssid && bssid) {
              result.push({
                id: ifaceDetail.id,
                iface: ifaceDetail.iface,
                model: nmiDetails.product,
                ssid,
                bssid: network && network.length && network[0].bssid ? network[0].bssid : wpaDetails.bssid ? wpaDetails.bssid : null,
                channel,
                frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                type: nmiConnection.type ? nmiConnection.type : "802.11",
                security: nmiConnection.security ? nmiConnection.security : wpaDetails.security ? wpaDetails.security : null,
                signalLevel,
                quality: wifiQualityFromDB(signalLevel),
                txRate: null
              });
            }
          });
          if (callback) {
            callback(result);
          }
          resolve(result);
        } else if (_darwin) {
          let cmd = "system_profiler SPNetworkDataType";
          exec(cmd, function(error, stdout) {
            const parts1 = stdout.toString().split("\n\n    Wi-Fi:\n\n");
            if (parts1.length > 1) {
              const lines = parts1[1].split("\n\n")[0].split("\n");
              const iface = util.getValue(lines, "BSD Device Name", ":", true);
              const model = util.getValue(lines, "hardware", ":", true);
              cmd = '/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I 2>/dev/null; echo "######" ; ioreg -n AppleBCMWLANSkywalkInterface -r 2>/dev/null';
              exec(cmd, function(error2, stdout2) {
                const parts = stdout2.toString().split("######");
                const lines2 = parts[0].split("\n");
                let lines3 = [];
                if (parts[1].indexOf("  | {") > 0 && parts[1].indexOf("  | }") > parts[1].indexOf("  | {")) {
                  lines3 = parts[1].split("  | {")[1].split("  | }")[0].replace(/ \| /g, "").replace(/"/g, "").split("\n");
                }
                if (lines2.length > 10) {
                  const ssid = util.getValue(lines2, "ssid", ":", true);
                  const bssid = util.getValue(lines2, "bssid", ":", true) || formatBssid(util.getValue(lines3, "IO80211BSSID", "=", true));
                  const security = util.getValue(lines2, "link auth", ":", true);
                  const txRate = util.getValue(lines2, "lastTxRate", ":", true);
                  const channel = util.getValue(lines2, "channel", ":", true).split(",")[0];
                  const type2 = "802.11";
                  const rssi = util.toInt(util.getValue(lines2, "agrCtlRSSI", ":", true));
                  const signalLevel = rssi;
                  if (ssid || bssid) {
                    result.push({
                      id: "Wi-Fi",
                      iface,
                      model,
                      ssid,
                      bssid,
                      channel: util.toInt(channel),
                      frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                      type: type2,
                      security,
                      signalLevel,
                      quality: wifiQualityFromDB(signalLevel),
                      txRate
                    });
                  }
                }
                if (lines3.length > 10) {
                  const ssid = util.getValue(lines3, "IO80211SSID", "=", true);
                  const bssid = formatBssid(util.getValue(lines3, "IO80211BSSID", "=", true));
                  const security = "";
                  const txRate = -1;
                  const signalLevel = -1;
                  const quality = -1;
                  const channel = util.getValue(lines3, "IO80211Channel", "=", true);
                  const type2 = "802.11";
                  if ((ssid || bssid) && !result.length) {
                    result.push({
                      id: "Wi-Fi",
                      iface,
                      model,
                      ssid,
                      bssid,
                      channel: util.toInt(channel),
                      frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                      type: type2,
                      security,
                      signalLevel,
                      quality,
                      txRate
                    });
                  }
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          });
        } else if (_windows) {
          let cmd = "netsh wlan show interfaces";
          util.powerShell(cmd).then(function(stdout) {
            const allLines = stdout.toString().split("\r\n");
            for (let i = 0;i < allLines.length; i++) {
              allLines[i] = allLines[i].trim();
            }
            const parts = allLines.join("\r\n").split(":\r\n\r\n");
            parts.shift();
            parts.forEach((part) => {
              const lines = part.split("\r\n");
              if (lines.length >= 5) {
                const iface = lines[0].indexOf(":") >= 0 ? lines[0].split(":")[1].trim() : "";
                const model = lines[1].indexOf(":") >= 0 ? lines[1].split(":")[1].trim() : "";
                const id2 = lines[2].indexOf(":") >= 0 ? lines[2].split(":")[1].trim() : "";
                const ssid = util.getValue(lines, "SSID", ":", true);
                const bssid = util.getValue(lines, "BSSID", ":", true);
                const quality = util.getValue(lines, "Signal", ":", true);
                const signalLevel = wifiDBFromQuality(quality);
                const type2 = util.getValue(lines, "Radio type", ":", true) || util.getValue(lines, "Type de radio", ":", true) || util.getValue(lines, "Funktyp", ":", true) || null;
                const security = util.getValue(lines, "authentication", ":", true) || util.getValue(lines, "Authentification", ":", true) || util.getValue(lines, "Authentifizierung", ":", true) || null;
                const channel = util.getValue(lines, "Channel", ":", true) || util.getValue(lines, "Canal", ":", true) || util.getValue(lines, "Kanal", ":", true) || null;
                const txRate = util.getValue(lines, "Transmit rate (mbps)", ":", true) || util.getValue(lines, "Transmission (mbit/s)", ":", true) || util.getValue(lines, "Empfangsrate (MBit/s)", ":", true) || null;
                if (model && id2 && ssid && bssid) {
                  result.push({
                    id: id2,
                    iface,
                    model,
                    ssid,
                    bssid,
                    channel: util.toInt(channel),
                    frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                    type: type2,
                    security,
                    signalLevel,
                    quality: quality ? parseInt(quality, 10) : null,
                    txRate: util.toInt(txRate) || null
                  });
                }
              }
            });
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        } else {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
      });
    });
  };
  var wifiInterfaces = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const result = [];
        if (_linux) {
          const ifaces = ifaceListLinux();
          ifaces.forEach((ifaceDetail) => {
            const nmiDetails = nmiDeviceLinux(ifaceDetail.iface);
            result.push({
              id: ifaceDetail.id,
              iface: ifaceDetail.iface,
              model: nmiDetails.product ? nmiDetails.product : null,
              vendor: nmiDetails.vendor ? nmiDetails.vendor : null,
              mac: ifaceDetail.mac
            });
          });
          if (callback) {
            callback(result);
          }
          resolve(result);
        } else if (_darwin) {
          let cmd = "system_profiler SPNetworkDataType";
          exec(cmd, function(error, stdout) {
            const parts1 = stdout.toString().split("\n\n    Wi-Fi:\n\n");
            if (parts1.length > 1) {
              const lines = parts1[1].split("\n\n")[0].split("\n");
              const iface = util.getValue(lines, "BSD Device Name", ":", true);
              const mac = util.getValue(lines, "MAC Address", ":", true);
              const model = util.getValue(lines, "hardware", ":", true);
              result.push({
                id: "Wi-Fi",
                iface,
                model,
                vendor: "",
                mac
              });
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        } else if (_windows) {
          let cmd = "netsh wlan show interfaces";
          util.powerShell(cmd).then(function(stdout) {
            const allLines = stdout.toString().split("\r\n");
            for (let i = 0;i < allLines.length; i++) {
              allLines[i] = allLines[i].trim();
            }
            const parts = allLines.join("\r\n").split(":\r\n\r\n");
            parts.shift();
            parts.forEach((part) => {
              const lines = part.split("\r\n");
              if (lines.length >= 5) {
                const iface = lines[0].indexOf(":") >= 0 ? lines[0].split(":")[1].trim() : "";
                const model = lines[1].indexOf(":") >= 0 ? lines[1].split(":")[1].trim() : "";
                const id2 = lines[2].indexOf(":") >= 0 ? lines[2].split(":")[1].trim() : "";
                const macParts = lines[3].indexOf(":") >= 0 ? lines[3].split(":") : [];
                macParts.shift();
                const mac = macParts.join(":").trim();
                const vendor = getVendor(model);
                if (iface && model && id2 && mac) {
                  result.push({
                    id: id2,
                    iface,
                    model,
                    vendor,
                    mac
                  });
                }
              }
            });
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        } else {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
      });
    });
  };
  var os = __require("os");
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var util = require_util4();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _wifi_frequencies = {
    1: 2412,
    2: 2417,
    3: 2422,
    4: 2427,
    5: 2432,
    6: 2437,
    7: 2442,
    8: 2447,
    9: 2452,
    10: 2457,
    11: 2462,
    12: 2467,
    13: 2472,
    14: 2484,
    32: 5160,
    34: 5170,
    36: 5180,
    38: 5190,
    40: 5200,
    42: 5210,
    44: 5220,
    46: 5230,
    48: 5240,
    50: 5250,
    52: 5260,
    54: 5270,
    56: 5280,
    58: 5290,
    60: 5300,
    62: 5310,
    64: 5320,
    68: 5340,
    96: 5480,
    100: 5500,
    102: 5510,
    104: 5520,
    106: 5530,
    108: 5540,
    110: 5550,
    112: 5560,
    114: 5570,
    116: 5580,
    118: 5590,
    120: 5600,
    122: 5610,
    124: 5620,
    126: 5630,
    128: 5640,
    132: 5660,
    134: 5670,
    136: 5680,
    138: 5690,
    140: 5700,
    142: 5710,
    144: 5720,
    149: 5745,
    151: 5755,
    153: 5765,
    155: 5775,
    157: 5785,
    159: 5795,
    161: 5805,
    165: 5825,
    169: 5845,
    173: 5865,
    183: 4915,
    184: 4920,
    185: 4925,
    187: 4935,
    188: 4940,
    189: 4945,
    192: 4960,
    196: 4980
  };
  exports2.wifiNetworks = wifiNetworks;
  exports2.wifiConnections = wifiConnections;
  exports2.wifiInterfaces = wifiInterfaces;
});

// ../../node_modules/systeminformation/lib/processes.js
var require_processes = __commonJS((exports2) => {
  var parseTimeUnix = function(time) {
    let result = time;
    let parts = time.replace(/ +/g, " ").split(" ");
    if (parts.length === 5) {
      result = parts[4] + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(parts[1].toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + parts[2]).slice(-2) + " " + parts[3];
    }
    return result;
  };
  var parseElapsedTime = function(etime) {
    let current = new Date;
    current = new Date(current.getTime() - current.getTimezoneOffset() * 60000);
    const elapsed = etime.split("-");
    const timeIndex = elapsed.length - 1;
    const days = timeIndex > 0 ? parseInt(elapsed[timeIndex - 1]) : 0;
    const timeStr = elapsed[timeIndex].split(":");
    const hours = timeStr.length === 3 ? parseInt(timeStr[0] || 0) : 0;
    const mins = parseInt(timeStr[timeStr.length === 3 ? 1 : 0] || 0);
    const secs = parseInt(timeStr[timeStr.length === 3 ? 2 : 1] || 0);
    const ms = (((days * 24 + hours) * 60 + mins) * 60 + secs) * 1000;
    let res = new Date(current.getTime());
    let result = res.toISOString().substring(0, 10) + " " + res.toISOString().substring(11, 19);
    try {
      res = new Date(current.getTime() - ms);
      result = res.toISOString().substring(0, 10) + " " + res.toISOString().substring(11, 19);
    } catch (e) {
      util.noop();
    }
    return result;
  };
  var services = function(srv, callback) {
    if (util.isFunction(srv) && !callback) {
      callback = srv;
      srv = "";
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (typeof srv !== "string") {
          if (callback) {
            callback([]);
          }
          return resolve([]);
        }
        if (srv) {
          let srvString = "";
          srvString.__proto__.toLowerCase = util.stringToLower;
          srvString.__proto__.replace = util.stringReplace;
          srvString.__proto__.trim = util.stringTrim;
          const s = util.sanitizeShellString(srv);
          const l = util.mathMin(s.length, 2000);
          for (let i = 0;i <= l; i++) {
            if (s[i] !== undefined) {
              srvString = srvString + s[i];
            }
          }
          srvString = srvString.trim().toLowerCase().replace(/, /g, "|").replace(/,+/g, "|");
          if (srvString === "") {
            srvString = "*";
          }
          if (util.isPrototypePolluted() && srvString !== "*") {
            srvString = "------";
          }
          let srvs = srvString.split("|");
          let result = [];
          let dataSrv = [];
          if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
            if ((_linux || _freebsd || _openbsd || _netbsd) && srvString === "*") {
              try {
                const tmpsrv = execSync("systemctl --all --type=service --no-legend 2> /dev/null").toString().split("\n");
                srvs = [];
                for (const s2 of tmpsrv) {
                  const name2 = s2.split(".service")[0];
                  if (name2 && s2.indexOf(" not-found ") === -1) {
                    srvs.push(name2.trim());
                  }
                }
                srvString = srvs.join("|");
              } catch (d) {
                try {
                  srvString = "";
                  const tmpsrv = execSync("service --status-all 2> /dev/null").toString().split("\n");
                  for (const s2 of tmpsrv) {
                    const parts = s2.split("]");
                    if (parts.length === 2) {
                      srvString += (srvString !== "" ? "|" : "") + parts[1].trim();
                    }
                  }
                  srvs = srvString.split("|");
                } catch (e) {
                  try {
                    const srvStr = execSync("ls /etc/init.d/ -m 2> /dev/null").toString().split("\n").join("");
                    srvString = "";
                    if (srvStr) {
                      const tmpsrv = srvStr.split(",");
                      for (const s2 of tmpsrv) {
                        const name2 = s2.trim();
                        if (name2) {
                          srvString += (srvString !== "" ? "|" : "") + name2;
                        }
                      }
                      srvs = srvString.split("|");
                    }
                  } catch (f) {
                    srvString = "";
                    srvs = [];
                  }
                }
              }
            }
            if (_darwin && srvString === "*") {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
            let args2 = _darwin ? ["-caxo", "pcpu,pmem,pid,command"] : ["-axo", "pcpu,pmem,pid,command"];
            if (srvString !== "" && srvs.length > 0) {
              util.execSafe("ps", args2).then((stdout) => {
                if (stdout) {
                  let lines = stdout.replace(/ +/g, " ").replace(/,+/g, ".").split("\n");
                  srvs.forEach(function(srv2) {
                    let ps;
                    if (_darwin) {
                      ps = lines.filter(function(e) {
                        return e.toLowerCase().indexOf(srv2) !== -1;
                      });
                    } else {
                      ps = lines.filter(function(e) {
                        return e.toLowerCase().indexOf(" " + srv2.toLowerCase() + ":") !== -1 || e.toLowerCase().indexOf("/" + srv2.toLowerCase()) !== -1;
                      });
                    }
                    const pids = [];
                    for (const p of ps) {
                      const pid = p.trim().split(" ")[2];
                      if (pid) {
                        pids.push(parseInt(pid, 10));
                      }
                    }
                    result.push({
                      name: srv2,
                      running: ps.length > 0,
                      startmode: "",
                      pids,
                      cpu: parseFloat(ps.reduce(function(pv, cv) {
                        return pv + parseFloat(cv.trim().split(" ")[0]);
                      }, 0).toFixed(2)),
                      mem: parseFloat(ps.reduce(function(pv, cv) {
                        return pv + parseFloat(cv.trim().split(" ")[1]);
                      }, 0).toFixed(2))
                    });
                  });
                  if (_linux) {
                    let cmd = 'cat /proc/stat | grep "cpu "';
                    for (let i in result) {
                      for (let j in result[i].pids) {
                        cmd += ";cat /proc/" + result[i].pids[j] + "/stat";
                      }
                    }
                    exec(cmd, { maxBuffer: 1024 * 20000 }, function(error, stdout2) {
                      let curr_processes = stdout2.toString().split("\n");
                      let all2 = parseProcStat(curr_processes.shift());
                      let list_new = {};
                      let resultProcess = {};
                      curr_processes.forEach((element) => {
                        resultProcess = calcProcStatLinux(element, all2, _services_cpu);
                        if (resultProcess.pid) {
                          let listPos = -1;
                          for (let i in result) {
                            for (let j in result[i].pids) {
                              if (parseInt(result[i].pids[j]) === parseInt(resultProcess.pid)) {
                                listPos = i;
                              }
                            }
                          }
                          if (listPos >= 0) {
                            result[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;
                          }
                          list_new[resultProcess.pid] = {
                            cpuu: resultProcess.cpuu,
                            cpus: resultProcess.cpus,
                            utime: resultProcess.utime,
                            stime: resultProcess.stime,
                            cutime: resultProcess.cutime,
                            cstime: resultProcess.cstime
                          };
                        }
                      });
                      _services_cpu.all = all2;
                      _services_cpu.list = Object.assign({}, list_new);
                      _services_cpu.ms = Date.now() - _services_cpu.ms;
                      _services_cpu.result = Object.assign({}, result);
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    });
                  } else {
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                } else {
                  args2 = ["-o", "comm"];
                  util.execSafe("ps", args2).then((stdout2) => {
                    if (stdout2) {
                      let lines = stdout2.replace(/ +/g, " ").replace(/,+/g, ".").split("\n");
                      srvs.forEach(function(srv2) {
                        let ps = lines.filter(function(e) {
                          return e.indexOf(srv2) !== -1;
                        });
                        result.push({
                          name: srv2,
                          running: ps.length > 0,
                          startmode: "",
                          cpu: 0,
                          mem: 0
                        });
                      });
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    } else {
                      srvs.forEach(function(srv2) {
                        result.push({
                          name: srv2,
                          running: false,
                          startmode: "",
                          cpu: 0,
                          mem: 0
                        });
                      });
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    }
                  });
                }
              });
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_windows) {
            try {
              let wincommand = "Get-CimInstance Win32_Service";
              if (srvs[0] !== "*") {
                wincommand += ' -Filter "';
                srvs.forEach((srv2) => {
                  wincommand += `Name='${srv2}' or `;
                });
                wincommand = `${wincommand.slice(0, -4)}"`;
              }
              wincommand += " | select Name,Caption,Started,StartMode,ProcessId | fl";
              util.powerShell(wincommand).then((stdout, error) => {
                if (!error) {
                  let serviceSections = stdout.split(/\n\s*\n/);
                  serviceSections.forEach((element) => {
                    if (element.trim() !== "") {
                      let lines = element.trim().split("\r\n");
                      let srvName = util.getValue(lines, "Name", ":", true).toLowerCase();
                      let srvCaption = util.getValue(lines, "Caption", ":", true).toLowerCase();
                      let started = util.getValue(lines, "Started", ":", true);
                      let startMode = util.getValue(lines, "StartMode", ":", true);
                      let pid = util.getValue(lines, "ProcessId", ":", true);
                      if (srvString === "*" || srvs.indexOf(srvName) >= 0 || srvs.indexOf(srvCaption) >= 0) {
                        result.push({
                          name: srvName,
                          running: started.toLowerCase() === "true",
                          startmode: startMode,
                          pids: [pid],
                          cpu: 0,
                          mem: 0
                        });
                        dataSrv.push(srvName);
                        dataSrv.push(srvCaption);
                      }
                    }
                  });
                  if (srvString !== "*") {
                    let srvsMissing = srvs.filter(function(e) {
                      return dataSrv.indexOf(e) === -1;
                    });
                    srvsMissing.forEach(function(srvName) {
                      result.push({
                        name: srvName,
                        running: false,
                        startmode: "",
                        pids: [],
                        cpu: 0,
                        mem: 0
                      });
                    });
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                } else {
                  srvs.forEach(function(srvName) {
                    result.push({
                      name: srvName,
                      running: false,
                      startmode: "",
                      cpu: 0,
                      mem: 0
                    });
                  });
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        } else {
          if (callback) {
            callback([]);
          }
          resolve([]);
        }
      });
    });
  };
  var parseProcStat = function(line) {
    let parts = line.replace(/ +/g, " ").split(" ");
    let user = parts.length >= 2 ? parseInt(parts[1]) : 0;
    let nice = parts.length >= 3 ? parseInt(parts[2]) : 0;
    let system = parts.length >= 4 ? parseInt(parts[3]) : 0;
    let idle = parts.length >= 5 ? parseInt(parts[4]) : 0;
    let iowait = parts.length >= 6 ? parseInt(parts[5]) : 0;
    let irq = parts.length >= 7 ? parseInt(parts[6]) : 0;
    let softirq = parts.length >= 8 ? parseInt(parts[7]) : 0;
    let steal = parts.length >= 9 ? parseInt(parts[8]) : 0;
    let guest = parts.length >= 10 ? parseInt(parts[9]) : 0;
    let guest_nice = parts.length >= 11 ? parseInt(parts[10]) : 0;
    return user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice;
  };
  var calcProcStatLinux = function(line, all2, _cpu_old) {
    let statparts = line.replace(/ +/g, " ").split(")");
    if (statparts.length >= 2) {
      let parts = statparts[1].split(" ");
      if (parts.length >= 16) {
        let pid = parseInt(statparts[0].split(" ")[0]);
        let utime = parseInt(parts[12]);
        let stime = parseInt(parts[13]);
        let cutime = parseInt(parts[14]);
        let cstime = parseInt(parts[15]);
        let cpuu = 0;
        let cpus = 0;
        if (_cpu_old.all > 0 && _cpu_old.list[pid]) {
          cpuu = (utime + cutime - _cpu_old.list[pid].utime - _cpu_old.list[pid].cutime) / (all2 - _cpu_old.all) * 100;
          cpus = (stime + cstime - _cpu_old.list[pid].stime - _cpu_old.list[pid].cstime) / (all2 - _cpu_old.all) * 100;
        } else {
          cpuu = (utime + cutime) / all2 * 100;
          cpus = (stime + cstime) / all2 * 100;
        }
        return {
          pid,
          utime,
          stime,
          cutime,
          cstime,
          cpuu,
          cpus
        };
      } else {
        return {
          pid: 0,
          utime: 0,
          stime: 0,
          cutime: 0,
          cstime: 0,
          cpuu: 0,
          cpus: 0
        };
      }
    } else {
      return {
        pid: 0,
        utime: 0,
        stime: 0,
        cutime: 0,
        cstime: 0,
        cpuu: 0,
        cpus: 0
      };
    }
  };
  var calcProcStatWin = function(procStat, all2, _cpu_old) {
    let cpuu = 0;
    let cpus = 0;
    if (_cpu_old.all > 0 && _cpu_old.list[procStat.pid]) {
      cpuu = (procStat.utime - _cpu_old.list[procStat.pid].utime) / (all2 - _cpu_old.all) * 100;
      cpus = (procStat.stime - _cpu_old.list[procStat.pid].stime) / (all2 - _cpu_old.all) * 100;
    } else {
      cpuu = procStat.utime / all2 * 100;
      cpus = procStat.stime / all2 * 100;
    }
    return {
      pid: procStat.pid,
      utime: procStat.utime,
      stime: procStat.stime,
      cpuu: cpuu > 0 ? cpuu : 0,
      cpus: cpus > 0 ? cpus : 0
    };
  };
  var processes = function(callback) {
    let parsedhead = [];
    function getName(command) {
      command = command || "";
      let result = command.split(" ")[0];
      if (result.substr(-1) === ":") {
        result = result.substr(0, result.length - 1);
      }
      if (result.substr(0, 1) !== "[") {
        let parts = result.split("/");
        if (isNaN(parseInt(parts[parts.length - 1]))) {
          result = parts[parts.length - 1];
        } else {
          result = parts[0];
        }
      }
      return result;
    }
    function parseLine(line) {
      let offset = 0;
      let offset2 = 0;
      function checkColumn(i) {
        offset = offset2;
        if (parsedhead[i]) {
          offset2 = line.substring(parsedhead[i].to + offset, 1e4).indexOf(" ");
        } else {
          offset2 = 1e4;
        }
      }
      checkColumn(0);
      const pid = parseInt(line.substring(parsedhead[0].from + offset, parsedhead[0].to + offset2));
      checkColumn(1);
      const ppid = parseInt(line.substring(parsedhead[1].from + offset, parsedhead[1].to + offset2));
      checkColumn(2);
      const cpu = parseFloat(line.substring(parsedhead[2].from + offset, parsedhead[2].to + offset2).replace(/,/g, "."));
      checkColumn(3);
      const mem = parseFloat(line.substring(parsedhead[3].from + offset, parsedhead[3].to + offset2).replace(/,/g, "."));
      checkColumn(4);
      const priority = parseInt(line.substring(parsedhead[4].from + offset, parsedhead[4].to + offset2));
      checkColumn(5);
      const vsz = parseInt(line.substring(parsedhead[5].from + offset, parsedhead[5].to + offset2));
      checkColumn(6);
      const rss = parseInt(line.substring(parsedhead[6].from + offset, parsedhead[6].to + offset2));
      checkColumn(7);
      const nice = parseInt(line.substring(parsedhead[7].from + offset, parsedhead[7].to + offset2)) || 0;
      checkColumn(8);
      const started = !_sunos ? parseElapsedTime(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim()) : parseTimeUnix(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim());
      checkColumn(9);
      let state = line.substring(parsedhead[9].from + offset, parsedhead[9].to + offset2).trim();
      state = state[0] === "R" ? "running" : state[0] === "S" ? "sleeping" : state[0] === "T" ? "stopped" : state[0] === "W" ? "paging" : state[0] === "X" ? "dead" : state[0] === "Z" ? "zombie" : state[0] === "D" || state[0] === "U" ? "blocked" : "unknown";
      checkColumn(10);
      let tty = line.substring(parsedhead[10].from + offset, parsedhead[10].to + offset2).trim();
      if (tty === "?" || tty === "??") {
        tty = "";
      }
      checkColumn(11);
      const user = line.substring(parsedhead[11].from + offset, parsedhead[11].to + offset2).trim();
      checkColumn(12);
      let cmdPath = "";
      let command = "";
      let params2 = "";
      let fullcommand = line.substring(parsedhead[12].from + offset, parsedhead[12].to + offset2).trim();
      if (fullcommand.substr(fullcommand.length - 1) === "]") {
        fullcommand = fullcommand.slice(0, -1);
      }
      if (fullcommand.substr(0, 1) === "[") {
        command = fullcommand.substring(1);
      } else {
        const p1 = fullcommand.indexOf("(");
        const p2 = fullcommand.indexOf(")");
        const p3 = fullcommand.indexOf("/");
        const p4 = fullcommand.indexOf(":");
        if (p1 < p2 && p1 < p3 && p3 < p2) {
          command = fullcommand.split(" ")[0];
          command = command.replace(/:/g, "");
        } else {
          if (p4 > 0 && (p3 === -1 || p3 > 3)) {
            command = fullcommand.split(" ")[0];
            command = command.replace(/:/g, "");
          } else {
            let firstParamPos = fullcommand.indexOf(" -");
            let firstParamPathPos = fullcommand.indexOf(" /");
            firstParamPos = firstParamPos >= 0 ? firstParamPos : 1e4;
            firstParamPathPos = firstParamPathPos >= 0 ? firstParamPathPos : 1e4;
            const firstPos = Math.min(firstParamPos, firstParamPathPos);
            let tmpCommand = fullcommand.substr(0, firstPos);
            const tmpParams = fullcommand.substr(firstPos);
            const lastSlashPos = tmpCommand.lastIndexOf("/");
            if (lastSlashPos >= 0) {
              cmdPath = tmpCommand.substr(0, lastSlashPos);
              tmpCommand = tmpCommand.substr(lastSlashPos + 1);
            }
            if (firstPos === 1e4 && tmpCommand.indexOf(" ") > -1) {
              const parts = tmpCommand.split(" ");
              if (fs.existsSync(path2.join(cmdPath, parts[0]))) {
                command = parts.shift();
                params2 = (parts.join(" ") + " " + tmpParams).trim();
              } else {
                command = tmpCommand.trim();
                params2 = tmpParams.trim();
              }
            } else {
              command = tmpCommand.trim();
              params2 = tmpParams.trim();
            }
          }
        }
      }
      return {
        pid,
        parentPid: ppid,
        name: _linux ? getName(command) : command,
        cpu,
        cpuu: 0,
        cpus: 0,
        mem,
        priority,
        memVsz: vsz,
        memRss: rss,
        nice,
        started,
        state,
        tty,
        user,
        command,
        params: params2,
        path: cmdPath
      };
    }
    function parseProcesses(lines) {
      let result = [];
      if (lines.length > 1) {
        let head = lines[0];
        parsedhead = util.parseHead(head, 8);
        lines.shift();
        lines.forEach(function(line) {
          if (line.trim() !== "") {
            result.push(parseLine(line));
          }
        });
      }
      return result;
    }
    function parseProcesses2(lines) {
      function formatDateTime(time) {
        const month = ("0" + (time.getMonth() + 1).toString()).slice(-2);
        const year = time.getFullYear().toString();
        const day = ("0" + time.getDate().toString()).slice(-2);
        const hours = ("0" + time.getHours().toString()).slice(-2);
        const mins = ("0" + time.getMinutes().toString()).slice(-2);
        const secs = ("0" + time.getSeconds().toString()).slice(-2);
        return year + "-" + month + "-" + day + " " + hours + ":" + mins + ":" + secs;
      }
      function parseElapsed(etime) {
        let started = "";
        if (etime.indexOf("d") >= 0) {
          const elapsed_parts = etime.split("d");
          started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 24 + elapsed_parts[1] * 1) * 60 * 60 * 1000));
        } else if (etime.indexOf("h") >= 0) {
          const elapsed_parts = etime.split("h");
          started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 60 + elapsed_parts[1] * 1) * 60 * 1000));
        } else if (etime.indexOf(":") >= 0) {
          const elapsed_parts = etime.split(":");
          started = formatDateTime(new Date(Date.now() - (elapsed_parts.length > 1 ? (elapsed_parts[0] * 60 + elapsed_parts[1]) * 1000 : elapsed_parts[0] * 1000)));
        }
        return started;
      }
      let result = [];
      lines.forEach(function(line) {
        if (line.trim() !== "") {
          line = line.trim().replace(/ +/g, " ").replace(/,+/g, ".");
          const parts = line.split(" ");
          const command = parts.slice(9).join(" ");
          const pmem = parseFloat((1 * parseInt(parts[3]) * 1024 / os.totalmem()).toFixed(1));
          const started = parseElapsed(parts[5]);
          result.push({
            pid: parseInt(parts[0]),
            parentPid: parseInt(parts[1]),
            name: getName(command),
            cpu: 0,
            cpuu: 0,
            cpus: 0,
            mem: pmem,
            priority: 0,
            memVsz: parseInt(parts[2]),
            memRss: parseInt(parts[3]),
            nice: parseInt(parts[4]),
            started,
            state: parts[6] === "R" ? "running" : parts[6] === "S" ? "sleeping" : parts[6] === "T" ? "stopped" : parts[6] === "W" ? "paging" : parts[6] === "X" ? "dead" : parts[6] === "Z" ? "zombie" : parts[6] === "D" || parts[6] === "U" ? "blocked" : "unknown",
            tty: parts[7],
            user: parts[8],
            command
          });
        }
      });
      return result;
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = {
          all: 0,
          running: 0,
          blocked: 0,
          sleeping: 0,
          unknown: 0,
          list: []
        };
        let cmd = "";
        if (_processes_cpu.ms && Date.now() - _processes_cpu.ms >= 500 || _processes_cpu.ms === 0) {
          if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {
            if (_linux) {
              cmd = "export LC_ALL=C; ps -axo pid:11,ppid:11,pcpu:6,pmem:6,pri:5,vsz:11,rss:11,ni:5,etime:30,state:5,tty:15,user:20,command; unset LC_ALL";
            }
            if (_freebsd || _openbsd || _netbsd) {
              cmd = "export LC_ALL=C; ps -axo pid,ppid,pcpu,pmem,pri,vsz,rss,ni,etime,state,tty,user,command; unset LC_ALL";
            }
            if (_darwin) {
              cmd = "ps -axo pid,ppid,pcpu,pmem,pri,vsz=temp_title_1,rss=temp_title_2,nice,etime=temp_title_3,state,tty,user,command -r";
            }
            if (_sunos) {
              cmd = "ps -Ao pid,ppid,pcpu,pmem,pri,vsz,rss,nice,stime,s,tty,user,comm";
            }
            exec(cmd, { maxBuffer: 1024 * 20000 }, function(error, stdout) {
              if (!error && stdout.toString().trim()) {
                result.list = parseProcesses(stdout.toString().split("\n")).slice();
                result.all = result.list.length;
                result.running = result.list.filter(function(e) {
                  return e.state === "running";
                }).length;
                result.blocked = result.list.filter(function(e) {
                  return e.state === "blocked";
                }).length;
                result.sleeping = result.list.filter(function(e) {
                  return e.state === "sleeping";
                }).length;
                if (_linux) {
                  cmd = 'cat /proc/stat | grep "cpu "';
                  result.list.forEach((element) => {
                    cmd += ";cat /proc/" + element.pid + "/stat";
                  });
                  exec(cmd, { maxBuffer: 1024 * 20000 }, function(error2, stdout2) {
                    let curr_processes = stdout2.toString().split("\n");
                    let all2 = parseProcStat(curr_processes.shift());
                    let list_new = {};
                    let resultProcess = {};
                    curr_processes.forEach((element) => {
                      resultProcess = calcProcStatLinux(element, all2, _processes_cpu);
                      if (resultProcess.pid) {
                        let listPos = result.list.map(function(e) {
                          return e.pid;
                        }).indexOf(resultProcess.pid);
                        if (listPos >= 0) {
                          result.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;
                          result.list[listPos].cpuu = resultProcess.cpuu;
                          result.list[listPos].cpus = resultProcess.cpus;
                        }
                        list_new[resultProcess.pid] = {
                          cpuu: resultProcess.cpuu,
                          cpus: resultProcess.cpus,
                          utime: resultProcess.utime,
                          stime: resultProcess.stime,
                          cutime: resultProcess.cutime,
                          cstime: resultProcess.cstime
                        };
                      }
                    });
                    _processes_cpu.all = all2;
                    _processes_cpu.list = Object.assign({}, list_new);
                    _processes_cpu.ms = Date.now() - _processes_cpu.ms;
                    _processes_cpu.result = Object.assign({}, result);
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              } else {
                cmd = "ps -o pid,ppid,vsz,rss,nice,etime,stat,tty,user,comm";
                if (_sunos) {
                  cmd = "ps -o pid,ppid,vsz,rss,nice,etime,s,tty,user,comm";
                }
                exec(cmd, { maxBuffer: 1024 * 20000 }, function(error2, stdout2) {
                  if (!error2) {
                    let lines = stdout2.toString().split("\n");
                    lines.shift();
                    result.list = parseProcesses2(lines).slice();
                    result.all = result.list.length;
                    result.running = result.list.filter(function(e) {
                      return e.state === "running";
                    }).length;
                    result.blocked = result.list.filter(function(e) {
                      return e.state === "blocked";
                    }).length;
                    result.sleeping = result.list.filter(function(e) {
                      return e.state === "sleeping";
                    }).length;
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  } else {
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                });
              }
            });
          } else if (_windows) {
            try {
              util.powerShell('Get-CimInstance Win32_Process | select-Object ProcessId,ParentProcessId,ExecutionState,Caption,CommandLine,ExecutablePath,UserModeTime,KernelModeTime,WorkingSetSize,Priority,PageFileUsage, @{n="CreationDate";e={$_.CreationDate.ToString("yyyy-MM-dd HH:mm:ss")}} | fl').then((stdout, error) => {
                if (!error) {
                  let processSections = stdout.split(/\n\s*\n/);
                  let procs = [];
                  let procStats = [];
                  let list_new = {};
                  let allcpuu = 0;
                  let allcpus = 0;
                  processSections.forEach((element) => {
                    if (element.trim() !== "") {
                      let lines = element.trim().split("\r\n");
                      let pid = parseInt(util.getValue(lines, "ProcessId", ":", true), 10);
                      let parentPid = parseInt(util.getValue(lines, "ParentProcessId", ":", true), 10);
                      let statusValue = util.getValue(lines, "ExecutionState", ":");
                      let name2 = util.getValue(lines, "Caption", ":", true);
                      let commandLine = util.getValue(lines, "CommandLine", ":", true);
                      let additionalCommand = false;
                      lines.forEach((line) => {
                        if (additionalCommand && line.toLowerCase().startsWith(" ")) {
                          commandLine += " " + line.trim();
                        } else {
                          additionalCommand = false;
                        }
                        if (line.toLowerCase().startsWith("commandline")) {
                          additionalCommand = true;
                        }
                      });
                      let commandPath = util.getValue(lines, "ExecutablePath", ":", true);
                      let utime = parseInt(util.getValue(lines, "UserModeTime", ":", true), 10);
                      let stime = parseInt(util.getValue(lines, "KernelModeTime", ":", true), 10);
                      let memw = parseInt(util.getValue(lines, "WorkingSetSize", ":", true), 10);
                      allcpuu = allcpuu + utime;
                      allcpus = allcpus + stime;
                      result.all++;
                      if (!statusValue) {
                        result.unknown++;
                      }
                      if (statusValue === "3") {
                        result.running++;
                      }
                      if (statusValue === "4" || statusValue === "5") {
                        result.blocked++;
                      }
                      procStats.push({
                        pid,
                        utime,
                        stime,
                        cpu: 0,
                        cpuu: 0,
                        cpus: 0
                      });
                      procs.push({
                        pid,
                        parentPid,
                        name: name2,
                        cpu: 0,
                        cpuu: 0,
                        cpus: 0,
                        mem: memw / os.totalmem() * 100,
                        priority: parseInt(util.getValue(lines, "Priority", ":", true), 10),
                        memVsz: parseInt(util.getValue(lines, "PageFileUsage", ":", true), 10),
                        memRss: Math.floor(parseInt(util.getValue(lines, "WorkingSetSize", ":", true), 10) / 1024),
                        nice: 0,
                        started: util.getValue(lines, "CreationDate", ":", true),
                        state: !statusValue ? _winStatusValues[0] : _winStatusValues[statusValue],
                        tty: "",
                        user: "",
                        command: commandLine || name2,
                        path: commandPath,
                        params: ""
                      });
                    }
                  });
                  result.sleeping = result.all - result.running - result.blocked - result.unknown;
                  result.list = procs;
                  procStats.forEach((element) => {
                    let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _processes_cpu);
                    let listPos = result.list.map(function(e) {
                      return e.pid;
                    }).indexOf(resultProcess.pid);
                    if (listPos >= 0) {
                      result.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;
                      result.list[listPos].cpuu = resultProcess.cpuu;
                      result.list[listPos].cpus = resultProcess.cpus;
                    }
                    list_new[resultProcess.pid] = {
                      cpuu: resultProcess.cpuu,
                      cpus: resultProcess.cpus,
                      utime: resultProcess.utime,
                      stime: resultProcess.stime
                    };
                  });
                  _processes_cpu.all = allcpuu + allcpus;
                  _processes_cpu.all_utime = allcpuu;
                  _processes_cpu.all_stime = allcpus;
                  _processes_cpu.list = Object.assign({}, list_new);
                  _processes_cpu.ms = Date.now() - _processes_cpu.ms;
                  _processes_cpu.result = Object.assign({}, result);
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          } else {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        } else {
          if (callback) {
            callback(_processes_cpu.result);
          }
          resolve(_processes_cpu.result);
        }
      });
    });
  };
  var processLoad = function(proc, callback) {
    if (util.isFunction(proc) && !callback) {
      callback = proc;
      proc = "";
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        proc = proc || "";
        if (typeof proc !== "string") {
          if (callback) {
            callback([]);
          }
          return resolve([]);
        }
        let processesString = "";
        processesString.__proto__.toLowerCase = util.stringToLower;
        processesString.__proto__.replace = util.stringReplace;
        processesString.__proto__.trim = util.stringTrim;
        const s = util.sanitizeShellString(proc);
        const l = util.mathMin(s.length, 2000);
        for (let i = 0;i <= l; i++) {
          if (s[i] !== undefined) {
            processesString = processesString + s[i];
          }
        }
        processesString = processesString.trim().toLowerCase().replace(/, /g, "|").replace(/,+/g, "|");
        if (processesString === "") {
          processesString = "*";
        }
        if (util.isPrototypePolluted() && processesString !== "*") {
          processesString = "------";
        }
        let processes2 = processesString.split("|");
        let result = [];
        const procSanitized = util.isPrototypePolluted() ? "" : util.sanitizeShellString(proc);
        if (procSanitized && processes2.length && processes2[0] !== "------") {
          if (_windows) {
            try {
              util.powerShell("Get-CimInstance Win32_Process | select ProcessId,Caption,UserModeTime,KernelModeTime,WorkingSetSize | fl").then((stdout, error) => {
                if (!error) {
                  let processSections = stdout.split(/\n\s*\n/);
                  let procStats = [];
                  let list_new = {};
                  let allcpuu = 0;
                  let allcpus = 0;
                  processSections.forEach((element) => {
                    if (element.trim() !== "") {
                      let lines = element.trim().split("\r\n");
                      let pid = parseInt(util.getValue(lines, "ProcessId", ":", true), 10);
                      let name2 = util.getValue(lines, "Caption", ":", true);
                      let utime = parseInt(util.getValue(lines, "UserModeTime", ":", true), 10);
                      let stime = parseInt(util.getValue(lines, "KernelModeTime", ":", true), 10);
                      let mem = parseInt(util.getValue(lines, "WorkingSetSize", ":", true), 10);
                      allcpuu = allcpuu + utime;
                      allcpus = allcpus + stime;
                      procStats.push({
                        pid,
                        name: name2,
                        utime,
                        stime,
                        cpu: 0,
                        cpuu: 0,
                        cpus: 0,
                        mem
                      });
                      let pname = "";
                      let inList = false;
                      processes2.forEach(function(proc2) {
                        if (name2.toLowerCase().indexOf(proc2.toLowerCase()) >= 0 && !inList) {
                          inList = true;
                          pname = proc2;
                        }
                      });
                      if (processesString === "*" || inList) {
                        let processFound = false;
                        result.forEach(function(item) {
                          if (item.proc.toLowerCase() === pname.toLowerCase()) {
                            item.pids.push(pid);
                            item.mem += mem / os.totalmem() * 100;
                            processFound = true;
                          }
                        });
                        if (!processFound) {
                          result.push({
                            proc: pname,
                            pid,
                            pids: [pid],
                            cpu: 0,
                            mem: mem / os.totalmem() * 100
                          });
                        }
                      }
                    }
                  });
                  if (processesString !== "*") {
                    let processesMissing = processes2.filter(function(name2) {
                      return procStats.filter(function(item) {
                        return item.name.toLowerCase().indexOf(name2) >= 0;
                      }).length === 0;
                    });
                    processesMissing.forEach(function(procName) {
                      result.push({
                        proc: procName,
                        pid: null,
                        pids: [],
                        cpu: 0,
                        mem: 0
                      });
                    });
                  }
                  procStats.forEach((element) => {
                    let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _process_cpu);
                    let listPos = -1;
                    for (let j = 0;j < result.length; j++) {
                      if (result[j].pid === resultProcess.pid || result[j].pids.indexOf(resultProcess.pid) >= 0) {
                        listPos = j;
                      }
                    }
                    if (listPos >= 0) {
                      result[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;
                    }
                    list_new[resultProcess.pid] = {
                      cpuu: resultProcess.cpuu,
                      cpus: resultProcess.cpus,
                      utime: resultProcess.utime,
                      stime: resultProcess.stime
                    };
                  });
                  _process_cpu.all = allcpuu + allcpus;
                  _process_cpu.all_utime = allcpuu;
                  _process_cpu.all_stime = allcpus;
                  _process_cpu.list = Object.assign({}, list_new);
                  _process_cpu.ms = Date.now() - _process_cpu.ms;
                  _process_cpu.result = JSON.parse(JSON.stringify(result));
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_darwin || _linux || _freebsd || _openbsd || _netbsd) {
            const params2 = ["-axo", "pid,ppid,pcpu,pmem,comm"];
            util.execSafe("ps", params2).then((stdout) => {
              if (stdout) {
                let procStats = [];
                let lines = stdout.toString().split("\n").filter(function(line) {
                  if (processesString === "*") {
                    return true;
                  }
                  if (line.toLowerCase().indexOf("grep") !== -1) {
                    return false;
                  }
                  let found = false;
                  processes2.forEach(function(item) {
                    found = found || line.toLowerCase().indexOf(item.toLowerCase()) >= 0;
                  });
                  return found;
                });
                lines.forEach(function(line) {
                  let data = line.trim().replace(/ +/g, " ").split(" ");
                  if (data.length > 4) {
                    procStats.push({
                      name: data[4].substring(data[4].lastIndexOf("/") + 1),
                      pid: parseInt(data[0]) || 0,
                      ppid: parseInt(data[1]) || 0,
                      cpu: parseFloat(data[2].replace(",", ".")),
                      mem: parseFloat(data[3].replace(",", "."))
                    });
                  }
                });
                procStats.forEach(function(item) {
                  let listPos = -1;
                  let inList = false;
                  let name2 = "";
                  for (let j = 0;j < result.length; j++) {
                    if (item.name.toLowerCase().indexOf(result[j].proc.toLowerCase()) >= 0) {
                      listPos = j;
                    }
                  }
                  processes2.forEach(function(proc2) {
                    if (item.name.toLowerCase().indexOf(proc2.toLowerCase()) >= 0 && !inList) {
                      inList = true;
                      name2 = proc2;
                    }
                  });
                  if (processesString === "*" || inList) {
                    if (listPos < 0) {
                      result.push({
                        proc: name2,
                        pid: item.pid,
                        pids: [item.pid],
                        cpu: item.cpu,
                        mem: item.mem
                      });
                    } else {
                      if (item.ppid < 10) {
                        result[listPos].pid = item.pid;
                      }
                      result[listPos].pids.push(item.pid);
                      result[listPos].cpu += item.cpu;
                      result[listPos].mem += item.mem;
                    }
                  }
                });
                if (processesString !== "*") {
                  let processesMissing = processes2.filter(function(name2) {
                    return procStats.filter(function(item) {
                      return item.name.toLowerCase().indexOf(name2) >= 0;
                    }).length === 0;
                  });
                  processesMissing.forEach(function(procName) {
                    result.push({
                      proc: procName,
                      pid: null,
                      pids: [],
                      cpu: 0,
                      mem: 0
                    });
                  });
                }
                if (_linux) {
                  result.forEach(function(item) {
                    item.cpu = 0;
                  });
                  let cmd = 'cat /proc/stat | grep "cpu "';
                  for (let i in result) {
                    for (let j in result[i].pids) {
                      cmd += ";cat /proc/" + result[i].pids[j] + "/stat";
                    }
                  }
                  exec(cmd, { maxBuffer: 1024 * 20000 }, function(error, stdout2) {
                    let curr_processes = stdout2.toString().split("\n");
                    let all2 = parseProcStat(curr_processes.shift());
                    let list_new = {};
                    let resultProcess = {};
                    curr_processes.forEach((element) => {
                      resultProcess = calcProcStatLinux(element, all2, _process_cpu);
                      if (resultProcess.pid) {
                        let resultItemId = -1;
                        for (let i in result) {
                          if (result[i].pids.indexOf(resultProcess.pid) >= 0) {
                            resultItemId = i;
                          }
                        }
                        if (resultItemId >= 0) {
                          result[resultItemId].cpu += resultProcess.cpuu + resultProcess.cpus;
                        }
                        list_new[resultProcess.pid] = {
                          cpuu: resultProcess.cpuu,
                          cpus: resultProcess.cpus,
                          utime: resultProcess.utime,
                          stime: resultProcess.stime,
                          cutime: resultProcess.cutime,
                          cstime: resultProcess.cstime
                        };
                      }
                    });
                    result.forEach(function(item) {
                      item.cpu = Math.round(item.cpu * 100) / 100;
                    });
                    _process_cpu.all = all2;
                    _process_cpu.list = Object.assign({}, list_new);
                    _process_cpu.ms = Date.now() - _process_cpu.ms;
                    _process_cpu.result = Object.assign({}, result);
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          }
        }
      });
    });
  };
  var os = __require("os");
  var fs = __require("fs");
  var path2 = __require("path");
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var util = require_util4();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  var _processes_cpu = {
    all: 0,
    all_utime: 0,
    all_stime: 0,
    list: {},
    ms: 0,
    result: {}
  };
  var _services_cpu = {
    all: 0,
    all_utime: 0,
    all_stime: 0,
    list: {},
    ms: 0,
    result: {}
  };
  var _process_cpu = {
    all: 0,
    all_utime: 0,
    all_stime: 0,
    list: {},
    ms: 0,
    result: {}
  };
  var _winStatusValues = {
    "0": "unknown",
    "1": "other",
    "2": "ready",
    "3": "running",
    "4": "blocked",
    "5": "suspended blocked",
    "6": "suspended ready",
    "7": "terminated",
    "8": "stopped",
    "9": "growing"
  };
  exports2.services = services;
  exports2.processes = processes;
  exports2.processLoad = processLoad;
});

// ../../node_modules/systeminformation/lib/users.js
var require_users = __commonJS((exports2) => {
  var parseUsersLinux = function(lines, phase) {
    let result = [];
    let result_who = [];
    let result_w = {};
    let w_first = true;
    let w_header = [];
    let w_pos = [];
    let who_line = {};
    let is_whopart = true;
    lines.forEach(function(line) {
      if (line === "---") {
        is_whopart = false;
      } else {
        let l = line.replace(/ +/g, " ").split(" ");
        if (is_whopart) {
          result_who.push({
            user: l[0],
            tty: l[1],
            date: l[2],
            time: l[3],
            ip: l && l.length > 4 ? l[4].replace(/\(/g, "").replace(/\)/g, "") : ""
          });
        } else {
          if (w_first) {
            w_header = l;
            w_header.forEach(function(item) {
              w_pos.push(line.indexOf(item));
            });
            w_first = false;
          } else {
            result_w.user = line.substring(w_pos[0], w_pos[1] - 1).trim();
            result_w.tty = line.substring(w_pos[1], w_pos[2] - 1).trim();
            result_w.ip = line.substring(w_pos[2], w_pos[3] - 1).replace(/\(/g, "").replace(/\)/g, "").trim();
            result_w.command = line.substring(w_pos[7], 1000).trim();
            who_line = result_who.filter(function(obj) {
              return obj.user.substring(0, 8).trim() === result_w.user && obj.tty === result_w.tty;
            });
            if (who_line.length === 1) {
              result.push({
                user: who_line[0].user,
                tty: who_line[0].tty,
                date: who_line[0].date,
                time: who_line[0].time,
                ip: who_line[0].ip,
                command: result_w.command
              });
            }
          }
        }
      }
    });
    if (result.length === 0 && phase === 2) {
      return result_who;
    } else {
      return result;
    }
  };
  var parseUsersDarwin = function(lines) {
    let result = [];
    let result_who = [];
    let result_w = {};
    let who_line = {};
    let is_whopart = true;
    lines.forEach(function(line) {
      if (line === "---") {
        is_whopart = false;
      } else {
        let l = line.replace(/ +/g, " ").split(" ");
        if (is_whopart) {
          result_who.push({
            user: l[0],
            tty: l[1],
            date: "" + new Date().getFullYear() + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(l[2].toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + l[3]).slice(-2),
            time: l[4]
          });
        } else {
          result_w.user = l[0];
          result_w.tty = l[1];
          result_w.ip = l[2] !== "-" ? l[2] : "";
          result_w.command = l.slice(5, 1000).join(" ");
          who_line = result_who.filter(function(obj) {
            return obj.user === result_w.user && (obj.tty.substring(3, 1000) === result_w.tty || obj.tty === result_w.tty);
          });
          if (who_line.length === 1) {
            result.push({
              user: who_line[0].user,
              tty: who_line[0].tty,
              date: who_line[0].date,
              time: who_line[0].time,
              ip: result_w.ip,
              command: result_w.command
            });
          }
        }
      }
    });
    return result;
  };
  var users = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = [];
        if (_linux) {
          exec('who --ips; echo "---"; w | tail -n +2', function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              result = parseUsersLinux(lines, 1);
              if (result.length === 0) {
                exec('who; echo "---"; w | tail -n +2', function(error2, stdout2) {
                  if (!error2) {
                    lines = stdout2.toString().split("\n");
                    result = parseUsersLinux(lines, 2);
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          });
        }
        if (_freebsd || _openbsd || _netbsd) {
          exec('who; echo "---"; w -ih', function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              result = parseUsersDarwin(lines);
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_sunos) {
          exec('who; echo "---"; w -h', function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              result = parseUsersDarwin(lines);
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_darwin) {
          exec('who; echo "---"; w -ih', function(error, stdout) {
            if (!error) {
              let lines = stdout.toString().split("\n");
              result = parseUsersDarwin(lines);
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_windows) {
          try {
            let cmd = 'Get-CimInstance Win32_LogonSession | select LogonId,@{n="StartTime";e={$_.StartTime.ToString("yyyy-MM-dd HH:mm:ss")}} | fl' + "; echo \'#-#-#-#\';";
            cmd += "Get-CimInstance Win32_LoggedOnUser | select antecedent,dependent | fl " + "; echo \'#-#-#-#\';";
            cmd += '$process = (Get-CimInstance Win32_Process -Filter "name = \'explorer.exe\'"); Invoke-CimMethod -InputObject $process[0] -MethodName GetOwner | select user, domain | fl; get-process -name explorer | select-object sessionid | fl; echo \'#-#-#-#\';';
            cmd += "query user";
            util.powerShell(cmd).then((data) => {
              if (data) {
                data = data.split("#-#-#-#");
                let sessions = parseWinSessions((data[0] || "").split(/\n\s*\n/));
                let loggedons = parseWinLoggedOn((data[1] || "").split(/\n\s*\n/));
                let queryUser = parseWinUsersQuery((data[3] || "").split("\r\n"));
                let users2 = parseWinUsers((data[2] || "").split(/\n\s*\n/), queryUser);
                for (let id2 in loggedons) {
                  if ({}.hasOwnProperty.call(loggedons, id2)) {
                    loggedons[id2].dateTime = {}.hasOwnProperty.call(sessions, id2) ? sessions[id2] : "";
                  }
                }
                users2.forEach((user) => {
                  let dateTime = "";
                  for (let id2 in loggedons) {
                    if ({}.hasOwnProperty.call(loggedons, id2)) {
                      if (loggedons[id2].user === user.user && (!dateTime || dateTime < loggedons[id2].dateTime)) {
                        dateTime = loggedons[id2].dateTime;
                      }
                    }
                  }
                  result.push({
                    user: user.user,
                    tty: user.tty,
                    date: `${dateTime.substring(0, 10)}`,
                    time: `${dateTime.substring(11, 19)}`,
                    ip: "",
                    command: ""
                  });
                });
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var parseWinSessions = function(sessionParts) {
    const sessions = {};
    sessionParts.forEach((session) => {
      const lines = session.split("\r\n");
      const id2 = util.getValue(lines, "LogonId");
      const starttime = util.getValue(lines, "starttime");
      if (id2) {
        sessions[id2] = starttime;
      }
    });
    return sessions;
  };
  var fuzzyMatch = function(name1, name2) {
    name1 = name1.toLowerCase();
    name2 = name2.toLowerCase();
    let eq = 0;
    let len = name1.length;
    if (name2.length > len) {
      len = name2.length;
    }
    for (let i = 0;i < len; i++) {
      const c1 = name1[i] || "";
      const c2 = name2[i] || "";
      if (c1 === c2) {
        eq++;
      }
    }
    return len > 10 ? eq / len > 0.9 : len > 0 ? eq / len > 0.8 : false;
  };
  var parseWinUsers = function(userParts, userQuery) {
    const users2 = [];
    userParts.forEach((user) => {
      const lines = user.split("\r\n");
      const domain = util.getValue(lines, "domain", ":", true);
      const username = util.getValue(lines, "user", ":", true);
      const sessionid = util.getValue(lines, "sessionid", ":", true);
      if (username) {
        const quser = userQuery.filter((item) => fuzzyMatch(item.user, username));
        users2.push({
          domain,
          user: username,
          tty: quser && quser[0] && quser[0].tty ? quser[0].tty : sessionid
        });
      }
    });
    return users2;
  };
  var parseWinLoggedOn = function(loggedonParts) {
    const loggedons = {};
    loggedonParts.forEach((loggedon) => {
      const lines = loggedon.split("\r\n");
      const antecendent = util.getValue(lines, "antecedent", ":", true);
      let parts = antecendent.split("=");
      const name2 = parts.length > 2 ? parts[1].split(",")[0].replace(/"/g, "").trim() : "";
      const domain = parts.length > 2 ? parts[2].replace(/"/g, "").replace(/\)/g, "").trim() : "";
      const dependent = util.getValue(lines, "dependent", ":", true);
      parts = dependent.split("=");
      const id2 = parts.length > 1 ? parts[1].replace(/"/g, "").replace(/\)/g, "").trim() : "";
      if (id2) {
        loggedons[id2] = {
          domain,
          user: name2
        };
      }
    });
    return loggedons;
  };
  var parseWinUsersQuery = function(lines) {
    lines = lines.filter((item) => item);
    let result = [];
    const header = lines[0];
    const headerDelimiter = [];
    if (header) {
      const start = header[0] === " " ? 1 : 0;
      headerDelimiter.push(start - 1);
      let nextSpace = 0;
      for (let i = start + 1;i < header.length; i++) {
        if (header[i] === " " && (header[i - 1] === " " || header[i - 1] === ".")) {
          nextSpace = i;
        } else {
          if (nextSpace) {
            headerDelimiter.push(nextSpace);
            nextSpace = 0;
          }
        }
      }
      for (let i = 1;i < lines.length; i++) {
        if (lines[i].trim()) {
          const user = lines[i].substring(headerDelimiter[0] + 1, headerDelimiter[1]).trim() || "";
          const tty = lines[i].substring(headerDelimiter[1] + 1, headerDelimiter[2] - 2).trim() || "";
          result.push({
            user,
            tty
          });
        }
      }
    }
    return result;
  };
  var exec = __require("child_process").exec;
  var util = require_util4();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  exports2.users = users;
});

// ../../node_modules/systeminformation/lib/internet.js
var require_internet = __commonJS((exports2) => {
  var inetChecksite = function(url, callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = {
          url,
          ok: false,
          status: 404,
          ms: null
        };
        if (typeof url !== "string") {
          if (callback) {
            callback(result);
          }
          return resolve(result);
        }
        let urlSanitized = "";
        const s = util.sanitizeShellString(url, true);
        const l = util.mathMin(s.length, 2000);
        for (let i = 0;i <= l; i++) {
          if (s[i] !== undefined) {
            s[i].__proto__.toLowerCase = util.stringToLower;
            const sl = s[i].toLowerCase();
            if (sl && sl[0] && !sl[1] && sl[0].length === 1) {
              urlSanitized = urlSanitized + sl[0];
            }
          }
        }
        result.url = urlSanitized;
        try {
          if (urlSanitized && !util.isPrototypePolluted()) {
            urlSanitized.__proto__.startsWith = util.stringStartWith;
            if (urlSanitized.startsWith("file:") || urlSanitized.startsWith("gopher:") || urlSanitized.startsWith("telnet:") || urlSanitized.startsWith("mailto:") || urlSanitized.startsWith("news:") || urlSanitized.startsWith("nntp:")) {
              if (callback) {
                callback(result);
              }
              return resolve(result);
            }
            let t = Date.now();
            if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {
              let args2 = ["-I", "--connect-timeout", "5", "-m", "5"];
              args2.push(urlSanitized);
              let cmd = "curl";
              util.execSafe(cmd, args2).then((stdout) => {
                const lines = stdout.split("\n");
                let statusCode = lines[0] && lines[0].indexOf(" ") >= 0 ? parseInt(lines[0].split(" ")[1], 10) : 404;
                result.status = statusCode || 404;
                result.ok = statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304;
                result.ms = result.ok ? Date.now() - t : null;
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            }
            if (_windows) {
              const http = urlSanitized.startsWith("https:") ? __require("https") : __require("http");
              try {
                http.get(urlSanitized, (res) => {
                  const statusCode = res.statusCode;
                  result.status = statusCode || 404;
                  result.ok = statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304;
                  if (statusCode !== 200) {
                    res.resume();
                    result.ms = result.ok ? Date.now() - t : null;
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  } else {
                    res.on("data", () => {
                    });
                    res.on("end", () => {
                      result.ms = result.ok ? Date.now() - t : null;
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    });
                  }
                }).on("error", () => {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              } catch (err) {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            }
          } else {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        } catch (err) {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
      });
    });
  };
  var inetLatency = function(host, callback) {
    if (util.isFunction(host) && !callback) {
      callback = host;
      host = "";
    }
    host = host || "8.8.8.8";
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (typeof host !== "string") {
          if (callback) {
            callback(null);
          }
          return resolve(null);
        }
        let hostSanitized = "";
        const s = (util.isPrototypePolluted() ? "8.8.8.8" : util.sanitizeShellString(host, true)).trim();
        const l = util.mathMin(s.length, 2000);
        for (let i = 0;i <= l; i++) {
          if (!(s[i] === undefined)) {
            s[i].__proto__.toLowerCase = util.stringToLower;
            const sl = s[i].toLowerCase();
            if (sl && sl[0] && !sl[1]) {
              hostSanitized = hostSanitized + sl[0];
            }
          }
        }
        hostSanitized.__proto__.startsWith = util.stringStartWith;
        if (hostSanitized.startsWith("file:") || hostSanitized.startsWith("gopher:") || hostSanitized.startsWith("telnet:") || hostSanitized.startsWith("mailto:") || hostSanitized.startsWith("news:") || hostSanitized.startsWith("nntp:")) {
          if (callback) {
            callback(null);
          }
          return resolve(null);
        }
        let params2;
        if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
          if (_linux) {
            params2 = ["-c", "2", "-w", "3", hostSanitized];
          }
          if (_freebsd || _openbsd || _netbsd) {
            params2 = ["-c", "2", "-t", "3", hostSanitized];
          }
          if (_darwin) {
            params2 = ["-c2", "-t3", hostSanitized];
          }
          util.execSafe("ping", params2).then((stdout) => {
            let result = null;
            if (stdout) {
              const lines = stdout.split("\n").filter((line2) => line2.indexOf("rtt") >= 0 || line2.indexOf("round-trip") >= 0 || line2.indexOf("avg") >= 0).join("\n");
              const line = lines.split("=");
              if (line.length > 1) {
                const parts = line[1].split("/");
                if (parts.length > 1) {
                  result = parseFloat(parts[1]);
                }
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_sunos) {
          const params3 = ["-s", "-a", hostSanitized, "56", "2"];
          const filt = "avg";
          util.execSafe("ping", params3, { timeout: 3000 }).then((stdout) => {
            let result = null;
            if (stdout) {
              const lines = stdout.split("\n").filter((line2) => line2.indexOf(filt) >= 0).join("\n");
              const line = lines.split("=");
              if (line.length > 1) {
                const parts = line[1].split("/");
                if (parts.length > 1) {
                  result = parseFloat(parts[1].replace(",", "."));
                }
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_windows) {
          let result = null;
          try {
            const params3 = [hostSanitized, "-n", "1"];
            util.execSafe("ping", params3, util.execOptsWin).then((stdout) => {
              if (stdout) {
                let lines = stdout.split("\r\n");
                lines.shift();
                lines.forEach(function(line) {
                  if ((line.toLowerCase().match(/ms/g) || []).length === 3) {
                    let l2 = line.replace(/ +/g, " ").split(" ");
                    if (l2.length > 6) {
                      result = parseFloat(l2[l2.length - 1]);
                    }
                  }
                });
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var util = require_util4();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  exports2.inetChecksite = inetChecksite;
  exports2.inetLatency = inetLatency;
});

// ../../node_modules/systeminformation/lib/dockerSocket.js
var require_dockerSocket = __commonJS((exports2, module2) => {
  var net = __require("net");
  var isWin = __require("os").type() === "Windows_NT";
  var socketPath = isWin ? "//./pipe/docker_engine" : "/var/run/docker.sock";

  class DockerSocket {
    getInfo(callback) {
      try {
        let socket = net.createConnection({ path: socketPath });
        let alldata = "";
        let data;
        socket.on("connect", () => {
          socket.write("GET http:/info HTTP/1.0\r\n\r\n");
        });
        socket.on("data", (data2) => {
          alldata = alldata + data2.toString();
        });
        socket.on("error", () => {
          socket = false;
          callback({});
        });
        socket.on("end", () => {
          let startbody = alldata.indexOf("\r\n\r\n");
          alldata = alldata.substring(startbody + 4);
          socket = false;
          try {
            data = JSON.parse(alldata);
            callback(data);
          } catch (err) {
            callback({});
          }
        });
      } catch (err) {
        callback({});
      }
    }
    listImages(all2, callback) {
      try {
        let socket = net.createConnection({ path: socketPath });
        let alldata = "";
        let data;
        socket.on("connect", () => {
          socket.write("GET http:/images/json" + (all2 ? "?all=1" : "") + " HTTP/1.0\r\n\r\n");
        });
        socket.on("data", (data2) => {
          alldata = alldata + data2.toString();
        });
        socket.on("error", () => {
          socket = false;
          callback({});
        });
        socket.on("end", () => {
          let startbody = alldata.indexOf("\r\n\r\n");
          alldata = alldata.substring(startbody + 4);
          socket = false;
          try {
            data = JSON.parse(alldata);
            callback(data);
          } catch (err) {
            callback({});
          }
        });
      } catch (err) {
        callback({});
      }
    }
    inspectImage(id2, callback) {
      id2 = id2 || "";
      if (id2) {
        try {
          let socket = net.createConnection({ path: socketPath });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/images/" + id2 + "/json?stream=0 HTTP/1.0\r\n\r\n");
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            let startbody = alldata.indexOf("\r\n\r\n");
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch (err) {
              callback({});
            }
          });
        } catch (err) {
          callback({});
        }
      } else {
        callback({});
      }
    }
    listContainers(all2, callback) {
      try {
        let socket = net.createConnection({ path: socketPath });
        let alldata = "";
        let data;
        socket.on("connect", () => {
          socket.write("GET http:/containers/json" + (all2 ? "?all=1" : "") + " HTTP/1.0\r\n\r\n");
        });
        socket.on("data", (data2) => {
          alldata = alldata + data2.toString();
        });
        socket.on("error", () => {
          socket = false;
          callback({});
        });
        socket.on("end", () => {
          let startbody = alldata.indexOf("\r\n\r\n");
          alldata = alldata.substring(startbody + 4);
          socket = false;
          try {
            data = JSON.parse(alldata);
            callback(data);
          } catch (err) {
            callback({});
          }
        });
      } catch (err) {
        callback({});
      }
    }
    getStats(id2, callback) {
      id2 = id2 || "";
      if (id2) {
        try {
          let socket = net.createConnection({ path: socketPath });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/containers/" + id2 + "/stats?stream=0 HTTP/1.0\r\n\r\n");
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            let startbody = alldata.indexOf("\r\n\r\n");
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch (err) {
              callback({});
            }
          });
        } catch (err) {
          callback({});
        }
      } else {
        callback({});
      }
    }
    getInspect(id2, callback) {
      id2 = id2 || "";
      if (id2) {
        try {
          let socket = net.createConnection({ path: socketPath });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/containers/" + id2 + "/json?stream=0 HTTP/1.0\r\n\r\n");
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            let startbody = alldata.indexOf("\r\n\r\n");
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch (err) {
              callback({});
            }
          });
        } catch (err) {
          callback({});
        }
      } else {
        callback({});
      }
    }
    getProcesses(id2, callback) {
      id2 = id2 || "";
      if (id2) {
        try {
          let socket = net.createConnection({ path: socketPath });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/containers/" + id2 + "/top?ps_args=-opid,ppid,pgid,vsz,time,etime,nice,ruser,user,rgroup,group,stat,rss,args HTTP/1.0\r\n\r\n");
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            let startbody = alldata.indexOf("\r\n\r\n");
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch (err) {
              callback({});
            }
          });
        } catch (err) {
          callback({});
        }
      } else {
        callback({});
      }
    }
    listVolumes(callback) {
      try {
        let socket = net.createConnection({ path: socketPath });
        let alldata = "";
        let data;
        socket.on("connect", () => {
          socket.write("GET http:/volumes HTTP/1.0\r\n\r\n");
        });
        socket.on("data", (data2) => {
          alldata = alldata + data2.toString();
        });
        socket.on("error", () => {
          socket = false;
          callback({});
        });
        socket.on("end", () => {
          let startbody = alldata.indexOf("\r\n\r\n");
          alldata = alldata.substring(startbody + 4);
          socket = false;
          try {
            data = JSON.parse(alldata);
            callback(data);
          } catch (err) {
            callback({});
          }
        });
      } catch (err) {
        callback({});
      }
    }
  }
  module2.exports = DockerSocket;
});

// ../../node_modules/systeminformation/lib/docker.js
var require_docker = __commonJS((exports2) => {
  var dockerInfo = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (!_docker_socket) {
          _docker_socket = new DockerSocket;
        }
        const result = {};
        _docker_socket.getInfo((data) => {
          result.id = data.ID;
          result.containers = data.Containers;
          result.containersRunning = data.ContainersRunning;
          result.containersPaused = data.ContainersPaused;
          result.containersStopped = data.ContainersStopped;
          result.images = data.Images;
          result.driver = data.Driver;
          result.memoryLimit = data.MemoryLimit;
          result.swapLimit = data.SwapLimit;
          result.kernelMemory = data.KernelMemory;
          result.cpuCfsPeriod = data.CpuCfsPeriod;
          result.cpuCfsQuota = data.CpuCfsQuota;
          result.cpuShares = data.CPUShares;
          result.cpuSet = data.CPUSet;
          result.ipv4Forwarding = data.IPv4Forwarding;
          result.bridgeNfIptables = data.BridgeNfIptables;
          result.bridgeNfIp6tables = data.BridgeNfIp6tables;
          result.debug = data.Debug;
          result.nfd = data.NFd;
          result.oomKillDisable = data.OomKillDisable;
          result.ngoroutines = data.NGoroutines;
          result.systemTime = data.SystemTime;
          result.loggingDriver = data.LoggingDriver;
          result.cgroupDriver = data.CgroupDriver;
          result.nEventsListener = data.NEventsListener;
          result.kernelVersion = data.KernelVersion;
          result.operatingSystem = data.OperatingSystem;
          result.osType = data.OSType;
          result.architecture = data.Architecture;
          result.ncpu = data.NCPU;
          result.memTotal = data.MemTotal;
          result.dockerRootDir = data.DockerRootDir;
          result.httpProxy = data.HttpProxy;
          result.httpsProxy = data.HttpsProxy;
          result.noProxy = data.NoProxy;
          result.name = data.Name;
          result.labels = data.Labels;
          result.experimentalBuild = data.ExperimentalBuild;
          result.serverVersion = data.ServerVersion;
          result.clusterStore = data.ClusterStore;
          result.clusterAdvertise = data.ClusterAdvertise;
          result.defaultRuntime = data.DefaultRuntime;
          result.liveRestoreEnabled = data.LiveRestoreEnabled;
          result.isolation = data.Isolation;
          result.initBinary = data.InitBinary;
          result.productLicense = data.ProductLicense;
          if (callback) {
            callback(result);
          }
          resolve(result);
        });
      });
    });
  };
  var dockerImages = function(all2, callback) {
    if (util.isFunction(all2) && !callback) {
      callback = all2;
      all2 = false;
    }
    if (typeof all2 === "string" && all2 === "true") {
      all2 = true;
    }
    if (typeof all2 !== "boolean" && all2 !== undefined) {
      all2 = false;
    }
    all2 = all2 || false;
    let result = [];
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (!_docker_socket) {
          _docker_socket = new DockerSocket;
        }
        const workload = [];
        _docker_socket.listImages(all2, (data) => {
          let dockerImages2 = {};
          try {
            dockerImages2 = data;
            if (dockerImages2 && Object.prototype.toString.call(dockerImages2) === "[object Array]" && dockerImages2.length > 0) {
              dockerImages2.forEach(function(element) {
                if (element.Names && Object.prototype.toString.call(element.Names) === "[object Array]" && element.Names.length > 0) {
                  element.Name = element.Names[0].replace(/^\/|\/$/g, "");
                }
                workload.push(dockerImagesInspect(element.Id.trim(), element));
              });
              if (workload.length) {
                Promise.all(workload).then((data2) => {
                  if (callback) {
                    callback(data2);
                  }
                  resolve(data2);
                });
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          } catch (err) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    });
  };
  var dockerImagesInspect = function(imageID, payload) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        imageID = imageID || "";
        if (typeof imageID !== "string") {
          return resolve();
        }
        const imageIDSanitized = (util.isPrototypePolluted() ? "" : util.sanitizeShellString(imageID, true)).trim();
        if (imageIDSanitized) {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket;
          }
          _docker_socket.inspectImage(imageIDSanitized.trim(), (data) => {
            try {
              resolve({
                id: payload.Id,
                container: data.Container,
                comment: data.Comment,
                os: data.Os,
                architecture: data.Architecture,
                parent: data.Parent,
                dockerVersion: data.DockerVersion,
                size: data.Size,
                sharedSize: payload.SharedSize,
                virtualSize: data.VirtualSize,
                author: data.Author,
                created: data.Created ? Math.round(new Date(data.Created).getTime() / 1000) : 0,
                containerConfig: data.ContainerConfig ? data.ContainerConfig : {},
                graphDriver: data.GraphDriver ? data.GraphDriver : {},
                repoDigests: data.RepoDigests ? data.RepoDigests : {},
                repoTags: data.RepoTags ? data.RepoTags : {},
                config: data.Config ? data.Config : {},
                rootFS: data.RootFS ? data.RootFS : {}
              });
            } catch (err) {
              resolve();
            }
          });
        } else {
          resolve();
        }
      });
    });
  };
  var dockerContainers = function(all2, callback) {
    function inContainers(containers, id2) {
      let filtered = containers.filter((obj) => {
        return obj.Id && obj.Id === id2;
      });
      return filtered.length > 0;
    }
    if (util.isFunction(all2) && !callback) {
      callback = all2;
      all2 = false;
    }
    if (typeof all2 === "string" && all2 === "true") {
      all2 = true;
    }
    if (typeof all2 !== "boolean" && all2 !== undefined) {
      all2 = false;
    }
    all2 = all2 || false;
    let result = [];
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (!_docker_socket) {
          _docker_socket = new DockerSocket;
        }
        const workload = [];
        _docker_socket.listContainers(all2, (data) => {
          let docker_containers = {};
          try {
            docker_containers = data;
            if (docker_containers && Object.prototype.toString.call(docker_containers) === "[object Array]" && docker_containers.length > 0) {
              for (let key in _docker_container_stats) {
                if ({}.hasOwnProperty.call(_docker_container_stats, key)) {
                  if (!inContainers(docker_containers, key)) {
                    delete _docker_container_stats[key];
                  }
                }
              }
              docker_containers.forEach(function(element) {
                if (element.Names && Object.prototype.toString.call(element.Names) === "[object Array]" && element.Names.length > 0) {
                  element.Name = element.Names[0].replace(/^\/|\/$/g, "");
                }
                workload.push(dockerContainerInspect(element.Id.trim(), element));
              });
              if (workload.length) {
                Promise.all(workload).then((data2) => {
                  if (callback) {
                    callback(data2);
                  }
                  resolve(data2);
                });
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          } catch (err) {
            for (let key in _docker_container_stats) {
              if ({}.hasOwnProperty.call(_docker_container_stats, key)) {
                if (!inContainers(docker_containers, key)) {
                  delete _docker_container_stats[key];
                }
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    });
  };
  var dockerContainerInspect = function(containerID, payload) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        containerID = containerID || "";
        if (typeof containerID !== "string") {
          return resolve();
        }
        const containerIdSanitized = (util.isPrototypePolluted() ? "" : util.sanitizeShellString(containerID, true)).trim();
        if (containerIdSanitized) {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket;
          }
          _docker_socket.getInspect(containerIdSanitized.trim(), (data) => {
            try {
              resolve({
                id: payload.Id,
                name: payload.Name,
                image: payload.Image,
                imageID: payload.ImageID,
                command: payload.Command,
                created: payload.Created,
                started: data.State && data.State.StartedAt ? Math.round(new Date(data.State.StartedAt).getTime() / 1000) : 0,
                finished: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith("0001-01-01") ? Math.round(new Date(data.State.FinishedAt).getTime() / 1000) : 0,
                createdAt: data.Created ? data.Created : "",
                startedAt: data.State && data.State.StartedAt ? data.State.StartedAt : "",
                finishedAt: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith("0001-01-01") ? data.State.FinishedAt : "",
                state: payload.State,
                restartCount: data.RestartCount || 0,
                platform: data.Platform || "",
                driver: data.Driver || "",
                ports: payload.Ports,
                mounts: payload.Mounts
              });
            } catch (err) {
              resolve();
            }
          });
        } else {
          resolve();
        }
      });
    });
  };
  var docker_calcCPUPercent = function(cpu_stats, precpu_stats) {
    if (!_windows) {
      let cpuPercent = 0;
      let cpuDelta = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;
      let systemDelta = cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage;
      if (systemDelta > 0 && cpuDelta > 0) {
        if (precpu_stats.online_cpus) {
          cpuPercent = cpuDelta / systemDelta * precpu_stats.online_cpus * 100;
        } else {
          cpuPercent = cpuDelta / systemDelta * cpu_stats.cpu_usage.percpu_usage.length * 100;
        }
      }
      return cpuPercent;
    } else {
      let nanoSecNow = util.nanoSeconds();
      let cpuPercent = 0;
      if (_docker_last_read > 0) {
        let possIntervals = nanoSecNow - _docker_last_read;
        let intervalsUsed = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;
        if (possIntervals > 0) {
          cpuPercent = 100 * intervalsUsed / possIntervals;
        }
      }
      _docker_last_read = nanoSecNow;
      return cpuPercent;
    }
  };
  var docker_calcNetworkIO = function(networks) {
    let rx;
    let wx;
    for (let key in networks) {
      if (!{}.hasOwnProperty.call(networks, key)) {
        continue;
      }
      let obj = networks[key];
      rx = +obj.rx_bytes;
      wx = +obj.tx_bytes;
    }
    return {
      rx,
      wx
    };
  };
  var docker_calcBlockIO = function(blkio_stats) {
    let result = {
      r: 0,
      w: 0
    };
    if (blkio_stats && blkio_stats.io_service_bytes_recursive && Object.prototype.toString.call(blkio_stats.io_service_bytes_recursive) === "[object Array]" && blkio_stats.io_service_bytes_recursive.length > 0) {
      blkio_stats.io_service_bytes_recursive.forEach(function(element) {
        if (element.op && element.op.toLowerCase() === "read" && element.value) {
          result.r += element.value;
        }
        if (element.op && element.op.toLowerCase() === "write" && element.value) {
          result.w += element.value;
        }
      });
    }
    return result;
  };
  var dockerContainerStats = function(containerIDs, callback) {
    let containerArray = [];
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (util.isFunction(containerIDs) && !callback) {
          callback = containerIDs;
          containerArray = ["*"];
        } else {
          containerIDs = containerIDs || "*";
          if (typeof containerIDs !== "string") {
            if (callback) {
              callback([]);
            }
            return resolve([]);
          }
          let containerIDsSanitized = "";
          containerIDsSanitized.__proto__.toLowerCase = util.stringToLower;
          containerIDsSanitized.__proto__.replace = util.stringReplace;
          containerIDsSanitized.__proto__.trim = util.stringTrim;
          containerIDsSanitized = containerIDs;
          containerIDsSanitized = containerIDsSanitized.trim();
          if (containerIDsSanitized !== "*") {
            containerIDsSanitized = "";
            const s = (util.isPrototypePolluted() ? "" : util.sanitizeShellString(containerIDs, true)).trim();
            const l = util.mathMin(s.length, 2000);
            for (let i = 0;i <= l; i++) {
              if (s[i] !== undefined) {
                s[i].__proto__.toLowerCase = util.stringToLower;
                const sl = s[i].toLowerCase();
                if (sl && sl[0] && !sl[1]) {
                  containerIDsSanitized = containerIDsSanitized + sl[0];
                }
              }
            }
          }
          containerIDsSanitized = containerIDsSanitized.trim().toLowerCase().replace(/,+/g, "|");
          containerArray = containerIDsSanitized.split("|");
        }
        const result = [];
        const workload = [];
        if (containerArray.length && containerArray[0].trim() === "*") {
          containerArray = [];
          dockerContainers().then((allContainers) => {
            for (let container of allContainers) {
              containerArray.push(container.id.substring(0, 12));
            }
            if (containerArray.length) {
              dockerContainerStats(containerArray.join(",")).then((result2) => {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          });
        } else {
          for (let containerID of containerArray) {
            workload.push(dockerContainerStatsSingle(containerID.trim()));
          }
          if (workload.length) {
            Promise.all(workload).then((data) => {
              if (callback) {
                callback(data);
              }
              resolve(data);
            });
          } else {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        }
      });
    });
  };
  var dockerContainerStatsSingle = function(containerID) {
    containerID = containerID || "";
    let result = {
      id: containerID,
      memUsage: 0,
      memLimit: 0,
      memPercent: 0,
      cpuPercent: 0,
      pids: 0,
      netIO: {
        rx: 0,
        wx: 0
      },
      blockIO: {
        r: 0,
        w: 0
      },
      restartCount: 0,
      cpuStats: {},
      precpuStats: {},
      memoryStats: {},
      networks: {}
    };
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (containerID) {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket;
          }
          _docker_socket.getInspect(containerID, (dataInspect) => {
            try {
              _docker_socket.getStats(containerID, (data) => {
                try {
                  let stats = data;
                  if (!stats.message) {
                    if (data.id) {
                      result.id = data.id;
                    }
                    result.memUsage = stats.memory_stats && stats.memory_stats.usage ? stats.memory_stats.usage : 0;
                    result.memLimit = stats.memory_stats && stats.memory_stats.limit ? stats.memory_stats.limit : 0;
                    result.memPercent = stats.memory_stats && stats.memory_stats.usage && stats.memory_stats.limit ? stats.memory_stats.usage / stats.memory_stats.limit * 100 : 0;
                    result.cpuPercent = stats.cpu_stats && stats.precpu_stats ? docker_calcCPUPercent(stats.cpu_stats, stats.precpu_stats) : 0;
                    result.pids = stats.pids_stats && stats.pids_stats.current ? stats.pids_stats.current : 0;
                    result.restartCount = dataInspect.RestartCount ? dataInspect.RestartCount : 0;
                    if (stats.networks) {
                      result.netIO = docker_calcNetworkIO(stats.networks);
                    }
                    if (stats.blkio_stats) {
                      result.blockIO = docker_calcBlockIO(stats.blkio_stats);
                    }
                    result.cpuStats = stats.cpu_stats ? stats.cpu_stats : {};
                    result.precpuStats = stats.precpu_stats ? stats.precpu_stats : {};
                    result.memoryStats = stats.memory_stats ? stats.memory_stats : {};
                    result.networks = stats.networks ? stats.networks : {};
                  }
                } catch (err) {
                  util.noop();
                }
                resolve(result);
              });
            } catch (err) {
              util.noop();
            }
          });
        } else {
          resolve(result);
        }
      });
    });
  };
  var dockerContainerProcesses = function(containerID, callback) {
    let result = [];
    return new Promise((resolve) => {
      process.nextTick(() => {
        containerID = containerID || "";
        if (typeof containerID !== "string") {
          return resolve(result);
        }
        const containerIdSanitized = (util.isPrototypePolluted() ? "" : util.sanitizeShellString(containerID, true)).trim();
        if (containerIdSanitized) {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket;
          }
          _docker_socket.getProcesses(containerIdSanitized, (data) => {
            try {
              if (data && data.Titles && data.Processes) {
                let titles = data.Titles.map(function(value) {
                  return value.toUpperCase();
                });
                let pos_pid = titles.indexOf("PID");
                let pos_ppid = titles.indexOf("PPID");
                let pos_pgid = titles.indexOf("PGID");
                let pos_vsz = titles.indexOf("VSZ");
                let pos_time = titles.indexOf("TIME");
                let pos_elapsed = titles.indexOf("ELAPSED");
                let pos_ni = titles.indexOf("NI");
                let pos_ruser = titles.indexOf("RUSER");
                let pos_user = titles.indexOf("USER");
                let pos_rgroup = titles.indexOf("RGROUP");
                let pos_group = titles.indexOf("GROUP");
                let pos_stat = titles.indexOf("STAT");
                let pos_rss = titles.indexOf("RSS");
                let pos_command = titles.indexOf("COMMAND");
                data.Processes.forEach((process2) => {
                  result.push({
                    pidHost: pos_pid >= 0 ? process2[pos_pid] : "",
                    ppid: pos_ppid >= 0 ? process2[pos_ppid] : "",
                    pgid: pos_pgid >= 0 ? process2[pos_pgid] : "",
                    user: pos_user >= 0 ? process2[pos_user] : "",
                    ruser: pos_ruser >= 0 ? process2[pos_ruser] : "",
                    group: pos_group >= 0 ? process2[pos_group] : "",
                    rgroup: pos_rgroup >= 0 ? process2[pos_rgroup] : "",
                    stat: pos_stat >= 0 ? process2[pos_stat] : "",
                    time: pos_time >= 0 ? process2[pos_time] : "",
                    elapsed: pos_elapsed >= 0 ? process2[pos_elapsed] : "",
                    nice: pos_ni >= 0 ? process2[pos_ni] : "",
                    rss: pos_rss >= 0 ? process2[pos_rss] : "",
                    vsz: pos_vsz >= 0 ? process2[pos_vsz] : "",
                    command: pos_command >= 0 ? process2[pos_command] : ""
                  });
                });
              }
            } catch (err) {
              util.noop();
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        } else {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
      });
    });
  };
  var dockerVolumes = function(callback) {
    let result = [];
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (!_docker_socket) {
          _docker_socket = new DockerSocket;
        }
        _docker_socket.listVolumes((data) => {
          let dockerVolumes2 = {};
          try {
            dockerVolumes2 = data;
            if (dockerVolumes2 && dockerVolumes2.Volumes && Object.prototype.toString.call(dockerVolumes2.Volumes) === "[object Array]" && dockerVolumes2.Volumes.length > 0) {
              dockerVolumes2.Volumes.forEach(function(element) {
                result.push({
                  name: element.Name,
                  driver: element.Driver,
                  labels: element.Labels,
                  mountpoint: element.Mountpoint,
                  options: element.Options,
                  scope: element.Scope,
                  created: element.CreatedAt ? Math.round(new Date(element.CreatedAt).getTime() / 1000) : 0
                });
              });
              if (callback) {
                callback(result);
              }
              resolve(result);
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          } catch (err) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    });
  };
  var dockerAll = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        dockerContainers(true).then((result) => {
          if (result && Object.prototype.toString.call(result) === "[object Array]" && result.length > 0) {
            let l = result.length;
            result.forEach(function(element) {
              dockerContainerStats(element.id).then((res) => {
                element.memUsage = res[0].memUsage;
                element.memLimit = res[0].memLimit;
                element.memPercent = res[0].memPercent;
                element.cpuPercent = res[0].cpuPercent;
                element.pids = res[0].pids;
                element.netIO = res[0].netIO;
                element.blockIO = res[0].blockIO;
                element.cpuStats = res[0].cpuStats;
                element.precpuStats = res[0].precpuStats;
                element.memoryStats = res[0].memoryStats;
                element.networks = res[0].networks;
                dockerContainerProcesses(element.id).then((processes) => {
                  element.processes = processes;
                  l -= 1;
                  if (l === 0) {
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                });
              });
            });
          } else {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    });
  };
  var util = require_util4();
  var DockerSocket = require_dockerSocket();
  var _platform = process.platform;
  var _windows = _platform === "win32";
  var _docker_container_stats = {};
  var _docker_socket;
  var _docker_last_read = 0;
  exports2.dockerInfo = dockerInfo;
  exports2.dockerImages = dockerImages;
  exports2.dockerContainers = dockerContainers;
  exports2.dockerContainerStats = dockerContainerStats;
  exports2.dockerContainerProcesses = dockerContainerProcesses;
  exports2.dockerVolumes = dockerVolumes;
  exports2.dockerAll = dockerAll;
});

// ../../node_modules/systeminformation/lib/virtualbox.js
var require_virtualbox = __commonJS((exports2) => {
  var vboxInfo = function(callback) {
    let result = [];
    return new Promise((resolve) => {
      process.nextTick(() => {
        try {
          exec(util.getVboxmanage() + " list vms --long", function(error, stdout) {
            let parts = (os.EOL + stdout.toString()).split(os.EOL + "Name:");
            parts.shift();
            parts.forEach((part) => {
              const lines = ("Name:" + part).split(os.EOL);
              const state = util.getValue(lines, "State");
              const running = state.startsWith("running");
              const runningSinceString = running ? state.replace("running (since ", "").replace(")", "").trim() : "";
              let runningSince = 0;
              try {
                if (running) {
                  const sinceDateObj = new Date(runningSinceString);
                  const offset = sinceDateObj.getTimezoneOffset();
                  runningSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1000) + offset * 60;
                }
              } catch (e) {
                util.noop();
              }
              const stoppedSinceString = !running ? state.replace("powered off (since", "").replace(")", "").trim() : "";
              let stoppedSince = 0;
              try {
                if (!running) {
                  const sinceDateObj = new Date(stoppedSinceString);
                  const offset = sinceDateObj.getTimezoneOffset();
                  stoppedSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1000) + offset * 60;
                }
              } catch (e) {
                util.noop();
              }
              result.push({
                id: util.getValue(lines, "UUID"),
                name: util.getValue(lines, "Name"),
                running,
                started: runningSinceString,
                runningSince,
                stopped: stoppedSinceString,
                stoppedSince,
                guestOS: util.getValue(lines, "Guest OS"),
                hardwareUUID: util.getValue(lines, "Hardware UUID"),
                memory: parseInt(util.getValue(lines, "Memory size", "     "), 10),
                vram: parseInt(util.getValue(lines, "VRAM size"), 10),
                cpus: parseInt(util.getValue(lines, "Number of CPUs"), 10),
                cpuExepCap: util.getValue(lines, "CPU exec cap"),
                cpuProfile: util.getValue(lines, "CPUProfile"),
                chipset: util.getValue(lines, "Chipset"),
                firmware: util.getValue(lines, "Firmware"),
                pageFusion: util.getValue(lines, "Page Fusion") === "enabled",
                configFile: util.getValue(lines, "Config file"),
                snapshotFolder: util.getValue(lines, "Snapshot folder"),
                logFolder: util.getValue(lines, "Log folder"),
                hpet: util.getValue(lines, "HPET") === "enabled",
                pae: util.getValue(lines, "PAE") === "enabled",
                longMode: util.getValue(lines, "Long Mode") === "enabled",
                tripleFaultReset: util.getValue(lines, "Triple Fault Reset") === "enabled",
                apic: util.getValue(lines, "APIC") === "enabled",
                x2Apic: util.getValue(lines, "X2APIC") === "enabled",
                acpi: util.getValue(lines, "ACPI") === "enabled",
                ioApic: util.getValue(lines, "IOAPIC") === "enabled",
                biosApicMode: util.getValue(lines, "BIOS APIC mode"),
                bootMenuMode: util.getValue(lines, "Boot menu mode"),
                bootDevice1: util.getValue(lines, "Boot Device 1"),
                bootDevice2: util.getValue(lines, "Boot Device 2"),
                bootDevice3: util.getValue(lines, "Boot Device 3"),
                bootDevice4: util.getValue(lines, "Boot Device 4"),
                timeOffset: util.getValue(lines, "Time offset"),
                rtc: util.getValue(lines, "RTC")
              });
            });
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        } catch (e) {
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
      });
    });
  };
  var os = __require("os");
  var exec = __require("child_process").exec;
  var util = require_util4();
  exports2.vboxInfo = vboxInfo;
});

// ../../node_modules/systeminformation/lib/printer.js
var require_printer = __commonJS((exports2) => {
  var parseLinuxCupsHeader = function(lines) {
    const result = {};
    if (lines && lines.length) {
      if (lines[0].indexOf(" CUPS v") > 0) {
        const parts = lines[0].split(" CUPS v");
        result.cupsVersion = parts[1];
      }
    }
    return result;
  };
  var parseLinuxCupsPrinter = function(lines) {
    const result = {};
    const printerId = util.getValue(lines, "PrinterId", " ");
    result.id = printerId ? parseInt(printerId, 10) : null;
    result.name = util.getValue(lines, "Info", " ");
    result.model = lines.length > 0 && lines[0] ? lines[0].split(" ")[0] : "";
    result.uri = util.getValue(lines, "DeviceURI", " ");
    result.uuid = util.getValue(lines, "UUID", " ");
    result.status = util.getValue(lines, "State", " ");
    result.local = util.getValue(lines, "Location", " ").toLowerCase().startsWith("local");
    result.default = null;
    result.shared = util.getValue(lines, "Shared", " ").toLowerCase().startsWith("yes");
    return result;
  };
  var parseLinuxLpstatPrinter = function(lines, id2) {
    const result = {};
    result.id = id2;
    result.name = util.getValue(lines, "Description", ":", true);
    result.model = lines.length > 0 && lines[0] ? lines[0].split(" ")[0] : "";
    result.uri = null;
    result.uuid = null;
    result.status = lines.length > 0 && lines[0] ? lines[0].indexOf(" idle") > 0 ? "idle" : lines[0].indexOf(" printing") > 0 ? "printing" : "unknown" : null;
    result.local = util.getValue(lines, "Location", ":", true).toLowerCase().startsWith("local");
    result.default = null;
    result.shared = util.getValue(lines, "Shared", " ").toLowerCase().startsWith("yes");
    return result;
  };
  var parseDarwinPrinters = function(printerObject, id2) {
    const result = {};
    const uriParts = printerObject.uri.split("/");
    result.id = id2;
    result.name = printerObject._name;
    result.model = uriParts.length ? uriParts[uriParts.length - 1] : "";
    result.uri = printerObject.uri;
    result.uuid = null;
    result.status = printerObject.status;
    result.local = printerObject.printserver === "local";
    result.default = printerObject.default === "yes";
    result.shared = printerObject.shared === "yes";
    return result;
  };
  var parseWindowsPrinters = function(lines, id2) {
    const result = {};
    const status = parseInt(util.getValue(lines, "PrinterStatus", ":"), 10);
    result.id = id2;
    result.name = util.getValue(lines, "name", ":");
    result.model = util.getValue(lines, "DriverName", ":");
    result.uri = null;
    result.uuid = null;
    result.status = winPrinterStatus[status] ? winPrinterStatus[status] : null;
    result.local = util.getValue(lines, "Local", ":").toUpperCase() === "TRUE";
    result.default = util.getValue(lines, "Default", ":").toUpperCase() === "TRUE";
    result.shared = util.getValue(lines, "Shared", ":").toUpperCase() === "TRUE";
    return result;
  };
  var printer = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = [];
        if (_linux || _freebsd || _openbsd || _netbsd) {
          let cmd = "cat /etc/cups/printers.conf 2>/dev/null";
          exec(cmd, function(error, stdout) {
            if (!error) {
              const parts = stdout.toString().split("<Printer ");
              const printerHeader = parseLinuxCupsHeader(parts[0]);
              for (let i = 1;i < parts.length; i++) {
                const printers = parseLinuxCupsPrinter(parts[i].split("\n"));
                if (printers.name) {
                  printers.engine = "CUPS";
                  printers.engineVersion = printerHeader.cupsVersion;
                  result.push(printers);
                }
              }
            }
            if (result.length === 0) {
              if (_linux) {
                cmd = "export LC_ALL=C; lpstat -lp 2>/dev/null; unset LC_ALL";
                exec(cmd, function(error2, stdout2) {
                  const parts = ("\n" + stdout2.toString()).split("\nprinter ");
                  for (let i = 1;i < parts.length; i++) {
                    const printers = parseLinuxLpstatPrinter(parts[i].split("\n"), i);
                    result.push(printers);
                  }
                });
                if (callback) {
                  callback(result);
                }
                resolve(result);
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          });
        }
        if (_darwin) {
          let cmd = "system_profiler SPPrintersDataType -json";
          exec(cmd, function(error, stdout) {
            if (!error) {
              try {
                const outObj = JSON.parse(stdout.toString());
                if (outObj.SPPrintersDataType && outObj.SPPrintersDataType.length) {
                  for (let i = 0;i < outObj.SPPrintersDataType.length; i++) {
                    const printer2 = parseDarwinPrinters(outObj.SPPrintersDataType[i], i);
                    result.push(printer2);
                  }
                }
              } catch (e) {
                util.noop();
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_windows) {
          util.powerShell("Get-CimInstance Win32_Printer | select PrinterStatus,Name,DriverName,Local,Default,Shared | fl").then((stdout, error) => {
            if (!error) {
              const parts = stdout.toString().split(/\n\s*\n/);
              for (let i = 0;i < parts.length; i++) {
                const printer2 = parseWindowsPrinters(parts[i].split("\n"), i);
                if (printer2.name || printer2.model) {
                  result.push(printer2);
                }
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_sunos) {
          resolve(null);
        }
      });
    });
  };
  var exec = __require("child_process").exec;
  var util = require_util4();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  var winPrinterStatus = {
    1: "Other",
    2: "Unknown",
    3: "Idle",
    4: "Printing",
    5: "Warmup",
    6: "Stopped Printing",
    7: "Offline"
  };
  exports2.printer = printer;
});

// ../../node_modules/systeminformation/lib/usb.js
var require_usb = __commonJS((exports2) => {
  var getLinuxUsbType = function(type2, name2) {
    let result = type2;
    const str = (name2 + " " + type2).toLowerCase();
    if (str.indexOf("camera") >= 0) {
      result = "Camera";
    } else if (str.indexOf("hub") >= 0) {
      result = "Hub";
    } else if (str.indexOf("keybrd") >= 0) {
      result = "Keyboard";
    } else if (str.indexOf("keyboard") >= 0) {
      result = "Keyboard";
    } else if (str.indexOf("mouse") >= 0) {
      result = "Mouse";
    } else if (str.indexOf("stora") >= 0) {
      result = "Storage";
    } else if (str.indexOf("mic") >= 0) {
      result = "Microphone";
    } else if (str.indexOf("headset") >= 0) {
      result = "Audio";
    } else if (str.indexOf("audio") >= 0) {
      result = "Audio";
    }
    return result;
  };
  var parseLinuxUsb = function(usb2) {
    const result = {};
    const lines = usb2.split("\n");
    if (lines && lines.length && lines[0].indexOf("Device") >= 0) {
      const parts = lines[0].split(" ");
      result.bus = parseInt(parts[0], 10);
      if (parts[2]) {
        result.deviceId = parseInt(parts[2], 10);
      } else {
        result.deviceId = null;
      }
    } else {
      result.bus = null;
      result.deviceId = null;
    }
    const idVendor = util.getValue(lines, "idVendor", " ", true).trim();
    let vendorParts = idVendor.split(" ");
    vendorParts.shift();
    const vendor = vendorParts.join(" ");
    const idProduct = util.getValue(lines, "idProduct", " ", true).trim();
    let productParts = idProduct.split(" ");
    productParts.shift();
    const product = productParts.join(" ");
    const interfaceClass = util.getValue(lines, "bInterfaceClass", " ", true).trim();
    let interfaceClassParts = interfaceClass.split(" ");
    interfaceClassParts.shift();
    const usbType = interfaceClassParts.join(" ");
    const iManufacturer = util.getValue(lines, "iManufacturer", " ", true).trim();
    let iManufacturerParts = iManufacturer.split(" ");
    iManufacturerParts.shift();
    const manufacturer = iManufacturerParts.join(" ");
    result.id = (idVendor.startsWith("0x") ? idVendor.split(" ")[0].substr(2, 10) : "") + ":" + (idProduct.startsWith("0x") ? idProduct.split(" ")[0].substr(2, 10) : "");
    result.name = product;
    result.type = getLinuxUsbType(usbType, product);
    result.removable = null;
    result.vendor = vendor;
    result.manufacturer = manufacturer;
    result.maxPower = util.getValue(lines, "MaxPower", " ", true);
    result.serialNumber = null;
    return result;
  };
  var getDarwinUsbType = function(name2) {
    let result = "";
    if (name2.indexOf("camera") >= 0) {
      result = "Camera";
    } else if (name2.indexOf("touch bar") >= 0) {
      result = "Touch Bar";
    } else if (name2.indexOf("controller") >= 0) {
      result = "Controller";
    } else if (name2.indexOf("headset") >= 0) {
      result = "Audio";
    } else if (name2.indexOf("keyboard") >= 0) {
      result = "Keyboard";
    } else if (name2.indexOf("trackpad") >= 0) {
      result = "Trackpad";
    } else if (name2.indexOf("sensor") >= 0) {
      result = "Sensor";
    } else if (name2.indexOf("bthusb") >= 0) {
      result = "Bluetooth";
    } else if (name2.indexOf("bth") >= 0) {
      result = "Bluetooth";
    } else if (name2.indexOf("rfcomm") >= 0) {
      result = "Bluetooth";
    } else if (name2.indexOf("usbhub") >= 0) {
      result = "Hub";
    } else if (name2.indexOf(" hub") >= 0) {
      result = "Hub";
    } else if (name2.indexOf("mouse") >= 0) {
      result = "Mouse";
    } else if (name2.indexOf("mic") >= 0) {
      result = "Microphone";
    } else if (name2.indexOf("removable") >= 0) {
      result = "Storage";
    }
    return result;
  };
  var parseDarwinUsb = function(usb2, id2) {
    const result = {};
    result.id = id2;
    usb2 = usb2.replace(/ \|/g, "");
    usb2 = usb2.trim();
    let lines = usb2.split("\n");
    lines.shift();
    try {
      for (let i = 0;i < lines.length; i++) {
        lines[i] = lines[i].trim();
        lines[i] = lines[i].replace(/=/g, ":");
        if (lines[i] !== "{" && lines[i] !== "}" && lines[i + 1] && lines[i + 1].trim() !== "}") {
          lines[i] = lines[i] + ",";
        }
        lines[i] = lines[i].replace(":Yes,", ':"Yes",');
        lines[i] = lines[i].replace(": Yes,", ': "Yes",');
        lines[i] = lines[i].replace(": Yes", ': "Yes"');
        lines[i] = lines[i].replace(":No,", ':"No",');
        lines[i] = lines[i].replace(": No,", ': "No",');
        lines[i] = lines[i].replace(": No", ': "No"');
        lines[i] = lines[i].replace("((", "").replace("))", "");
        const match = /<(\w+)>/.exec(lines[i]);
        if (match) {
          const number = match[0];
          lines[i] = lines[i].replace(number, `"${number}"`);
        }
      }
      const usbObj = JSON.parse(lines.join("\n"));
      const removableDrive = (usbObj["Built-In"] ? usbObj["Built-In"].toLowerCase() !== "yes" : true) && (usbObj["non-removable"] ? usbObj["non-removable"].toLowerCase() === "no" : true);
      result.bus = null;
      result.deviceId = null;
      result.id = usbObj["USB Address"] || null;
      result.name = usbObj["kUSBProductString"] || usbObj["USB Product Name"] || null;
      result.type = getDarwinUsbType((usbObj["kUSBProductString"] || usbObj["USB Product Name"] || "").toLowerCase() + (removableDrive ? " removable" : ""));
      result.removable = usbObj["non-removable"] ? usbObj["non-removable"].toLowerCase() || false : true;
      result.vendor = usbObj["kUSBVendorString"] || usbObj["USB Vendor Name"] || null;
      result.manufacturer = usbObj["kUSBVendorString"] || usbObj["USB Vendor Name"] || null;
      result.maxPower = null;
      result.serialNumber = usbObj["kUSBSerialNumberString"] || null;
      if (result.name) {
        return result;
      } else {
        return null;
      }
    } catch (e) {
      return null;
    }
  };
  var getWindowsUsbTypeCreation = function(creationclass, name2) {
    let result = "";
    if (name2.indexOf("storage") >= 0) {
      result = "Storage";
    } else if (name2.indexOf("speicher") >= 0) {
      result = "Storage";
    } else if (creationclass.indexOf("usbhub") >= 0) {
      result = "Hub";
    } else if (creationclass.indexOf("storage") >= 0) {
      result = "Storage";
    } else if (creationclass.indexOf("usbcontroller") >= 0) {
      result = "Controller";
    } else if (creationclass.indexOf("keyboard") >= 0) {
      result = "Keyboard";
    } else if (creationclass.indexOf("pointing") >= 0) {
      result = "Mouse";
    } else if (creationclass.indexOf("disk") >= 0) {
      result = "Storage";
    }
    return result;
  };
  var parseWindowsUsb = function(lines, id2) {
    const usbType = getWindowsUsbTypeCreation(util.getValue(lines, "CreationClassName", ":").toLowerCase(), util.getValue(lines, "name", ":").toLowerCase());
    if (usbType) {
      const result = {};
      result.bus = null;
      result.deviceId = util.getValue(lines, "deviceid", ":");
      result.id = id2;
      result.name = util.getValue(lines, "name", ":");
      result.type = usbType;
      result.removable = null;
      result.vendor = null;
      result.manufacturer = util.getValue(lines, "Manufacturer", ":");
      result.maxPower = null;
      result.serialNumber = null;
      return result;
    } else {
      return null;
    }
  };
  var usb = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = [];
        if (_linux) {
          const cmd = "export LC_ALL=C; lsusb -v 2>/dev/null; unset LC_ALL";
          exec(cmd, { maxBuffer: 1024 * 1024 * 128 }, function(error, stdout) {
            if (!error) {
              const parts = ("\n\n" + stdout.toString()).split("\n\nBus ");
              for (let i = 1;i < parts.length; i++) {
                const usb2 = parseLinuxUsb(parts[i]);
                result.push(usb2);
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_darwin) {
          let cmd = "ioreg -p IOUSB -c AppleUSBRootHubDevice -w0 -l";
          exec(cmd, { maxBuffer: 1024 * 1024 * 128 }, function(error, stdout) {
            if (!error) {
              const parts = stdout.toString().split(" +-o ");
              for (let i = 1;i < parts.length; i++) {
                const usb2 = parseDarwinUsb(parts[i]);
                if (usb2) {
                  result.push(usb2);
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_windows) {
          util.powerShell('Get-CimInstance CIM_LogicalDevice | where { $_.Description -match "USB"} | select Name,CreationClassName,DeviceId,Manufacturer | fl').then((stdout, error) => {
            if (!error) {
              const parts = stdout.toString().split(/\n\s*\n/);
              for (let i = 0;i < parts.length; i++) {
                const usb2 = parseWindowsUsb(parts[i].split("\n"), i);
                if (usb2) {
                  result.push(usb2);
                }
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_sunos || _freebsd || _openbsd || _netbsd) {
          resolve(null);
        }
      });
    });
  };
  var exec = __require("child_process").exec;
  var util = require_util4();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  exports2.usb = usb;
});

// ../../node_modules/systeminformation/lib/audio.js
var require_audio = __commonJS((exports2) => {
  var parseAudioType = function(str, input, output) {
    str = str.toLowerCase();
    let result = "";
    if (str.indexOf("input") >= 0) {
      result = "Microphone";
    }
    if (str.indexOf("display audio") >= 0) {
      result = "Speaker";
    }
    if (str.indexOf("speak") >= 0) {
      result = "Speaker";
    }
    if (str.indexOf("laut") >= 0) {
      result = "Speaker";
    }
    if (str.indexOf("loud") >= 0) {
      result = "Speaker";
    }
    if (str.indexOf("head") >= 0) {
      result = "Headset";
    }
    if (str.indexOf("mic") >= 0) {
      result = "Microphone";
    }
    if (str.indexOf("mikr") >= 0) {
      result = "Microphone";
    }
    if (str.indexOf("phone") >= 0) {
      result = "Phone";
    }
    if (str.indexOf("controll") >= 0) {
      result = "Controller";
    }
    if (str.indexOf("line o") >= 0) {
      result = "Line Out";
    }
    if (str.indexOf("digital o") >= 0) {
      result = "Digital Out";
    }
    if (str.indexOf("smart sound technology") >= 0) {
      result = "Digital Signal Processor";
    }
    if (str.indexOf("high definition audio") >= 0) {
      result = "Sound Driver";
    }
    if (!result && output) {
      result = "Speaker";
    } else if (!result && input) {
      result = "Microphone";
    }
    return result;
  };
  var getLinuxAudioPci = function() {
    let cmd = "lspci -v 2>/dev/null";
    let result = [];
    try {
      const parts = execSync(cmd).toString().split("\n\n");
      parts.forEach((element) => {
        const lines = element.split("\n");
        if (lines && lines.length && lines[0].toLowerCase().indexOf("audio") >= 0) {
          const audio2 = {};
          audio2.slotId = lines[0].split(" ")[0];
          audio2.driver = util.getValue(lines, "Kernel driver in use", ":", true) || util.getValue(lines, "Kernel modules", ":", true);
          result.push(audio2);
        }
      });
      return result;
    } catch (e) {
      return result;
    }
  };
  var parseLinuxAudioPciMM = function(lines, audioPCI) {
    const result = {};
    const slotId = util.getValue(lines, "Slot");
    const pciMatch = audioPCI.filter(function(item) {
      return item.slotId === slotId;
    });
    result.id = slotId;
    result.name = util.getValue(lines, "SDevice");
    result.manufacturer = util.getValue(lines, "SVendor");
    result.revision = util.getValue(lines, "Rev");
    result.driver = pciMatch && pciMatch.length === 1 && pciMatch[0].driver ? pciMatch[0].driver : "";
    result.default = null;
    result.channel = "PCIe";
    result.type = parseAudioType(result.name, null, null);
    result.in = null;
    result.out = null;
    result.status = "online";
    return result;
  };
  var parseDarwinChannel = function(str) {
    let result = "";
    if (str.indexOf("builtin") >= 0) {
      result = "Built-In";
    }
    if (str.indexOf("extern") >= 0) {
      result = "Audio-Jack";
    }
    if (str.indexOf("hdmi") >= 0) {
      result = "HDMI";
    }
    if (str.indexOf("displayport") >= 0) {
      result = "Display-Port";
    }
    if (str.indexOf("usb") >= 0) {
      result = "USB";
    }
    if (str.indexOf("pci") >= 0) {
      result = "PCIe";
    }
    return result;
  };
  var parseDarwinAudio = function(audioObject, id2) {
    const result = {};
    const channelStr = ((audioObject.coreaudio_device_transport || "") + " " + (audioObject._name || "")).toLowerCase();
    result.id = id2;
    result.name = audioObject._name;
    result.manufacturer = audioObject.coreaudio_device_manufacturer;
    result.revision = null;
    result.driver = null;
    result.default = !!(audioObject.coreaudio_default_audio_input_device || "") || !!(audioObject.coreaudio_default_audio_output_device || "");
    result.channel = parseDarwinChannel(channelStr);
    result.type = parseAudioType(result.name, !!(audioObject.coreaudio_device_input || ""), !!(audioObject.coreaudio_device_output || ""));
    result.in = !!(audioObject.coreaudio_device_input || "");
    result.out = !!(audioObject.coreaudio_device_output || "");
    result.status = "online";
    return result;
  };
  var parseWindowsAudio = function(lines) {
    const result = {};
    const status = util.getValue(lines, "StatusInfo", ":");
    result.id = util.getValue(lines, "DeviceID", ":");
    result.name = util.getValue(lines, "name", ":");
    result.manufacturer = util.getValue(lines, "manufacturer", ":");
    result.revision = null;
    result.driver = null;
    result.default = null;
    result.channel = null;
    result.type = parseAudioType(result.name, null, null);
    result.in = null;
    result.out = null;
    result.status = status;
    return result;
  };
  var audio = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = [];
        if (_linux || _freebsd || _openbsd || _netbsd) {
          let cmd = "lspci -vmm 2>/dev/null";
          exec(cmd, function(error, stdout) {
            if (!error) {
              const audioPCI = getLinuxAudioPci();
              const parts = stdout.toString().split("\n\n");
              parts.forEach((element) => {
                const lines = element.split("\n");
                if (util.getValue(lines, "class", ":", true).toLowerCase().indexOf("audio") >= 0) {
                  const audio2 = parseLinuxAudioPciMM(lines, audioPCI);
                  result.push(audio2);
                }
              });
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_darwin) {
          let cmd = "system_profiler SPAudioDataType -json";
          exec(cmd, function(error, stdout) {
            if (!error) {
              try {
                const outObj = JSON.parse(stdout.toString());
                if (outObj.SPAudioDataType && outObj.SPAudioDataType.length && outObj.SPAudioDataType[0] && outObj.SPAudioDataType[0]["_items"] && outObj.SPAudioDataType[0]["_items"].length) {
                  for (let i = 0;i < outObj.SPAudioDataType[0]["_items"].length; i++) {
                    const audio2 = parseDarwinAudio(outObj.SPAudioDataType[0]["_items"][i], i);
                    result.push(audio2);
                  }
                }
              } catch (e) {
                util.noop();
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_windows) {
          util.powerShell("Get-CimInstance Win32_SoundDevice | select DeviceID,StatusInfo,Name,Manufacturer | fl").then((stdout, error) => {
            if (!error) {
              const parts = stdout.toString().split(/\n\s*\n/);
              parts.forEach((element) => {
                const lines = element.split("\n");
                if (util.getValue(lines, "name", ":")) {
                  result.push(parseWindowsAudio(lines));
                }
              });
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_sunos) {
          resolve(null);
        }
      });
    });
  };
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var util = require_util4();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  exports2.audio = audio;
});

// ../../node_modules/systeminformation/lib/bluetooth.js
var require_bluetooth = __commonJS((exports2) => {
  var parseBluetoothType = function(str) {
    let result = "";
    if (str.indexOf("keyboard") >= 0) {
      result = "Keyboard";
    }
    if (str.indexOf("mouse") >= 0) {
      result = "Mouse";
    }
    if (str.indexOf("trackpad") >= 0) {
      result = "Trackpad";
    }
    if (str.indexOf("speaker") >= 0) {
      result = "Speaker";
    }
    if (str.indexOf("headset") >= 0) {
      result = "Headset";
    }
    if (str.indexOf("phone") >= 0) {
      result = "Phone";
    }
    if (str.indexOf("macbook") >= 0) {
      result = "Computer";
    }
    if (str.indexOf("imac") >= 0) {
      result = "Computer";
    }
    if (str.indexOf("ipad") >= 0) {
      result = "Tablet";
    }
    if (str.indexOf("watch") >= 0) {
      result = "Watch";
    }
    if (str.indexOf("headphone") >= 0) {
      result = "Headset";
    }
    return result;
  };
  var parseBluetoothManufacturer = function(str) {
    let result = str.split(" ")[0];
    str = str.toLowerCase();
    if (str.indexOf("apple") >= 0) {
      result = "Apple";
    }
    if (str.indexOf("ipad") >= 0) {
      result = "Apple";
    }
    if (str.indexOf("imac") >= 0) {
      result = "Apple";
    }
    if (str.indexOf("iphone") >= 0) {
      result = "Apple";
    }
    if (str.indexOf("magic mouse") >= 0) {
      result = "Apple";
    }
    if (str.indexOf("magic track") >= 0) {
      result = "Apple";
    }
    if (str.indexOf("macbook") >= 0) {
      result = "Apple";
    }
    return result;
  };
  var parseLinuxBluetoothInfo = function(lines, macAddr1, macAddr2) {
    const result = {};
    result.device = null;
    result.name = util.getValue(lines, "name", "=");
    result.manufacturer = null;
    result.macDevice = macAddr1;
    result.macHost = macAddr2;
    result.batteryPercent = null;
    result.type = parseBluetoothType(result.name.toLowerCase());
    result.connected = false;
    return result;
  };
  var parseDarwinBluetoothDevices = function(bluetoothObject, macAddr2) {
    const result = {};
    const typeStr = ((bluetoothObject.device_minorClassOfDevice_string || bluetoothObject.device_majorClassOfDevice_string || bluetoothObject.device_minorType || "") + (bluetoothObject.device_name || "")).toLowerCase();
    result.device = bluetoothObject.device_services || "";
    result.name = bluetoothObject.device_name || "";
    result.manufacturer = bluetoothObject.device_manufacturer || parseBluetoothManufacturer(bluetoothObject.device_name || "") || "";
    result.macDevice = (bluetoothObject.device_addr || bluetoothObject.device_address || "").toLowerCase().replace(/-/g, ":");
    result.macHost = macAddr2;
    result.batteryPercent = bluetoothObject.device_batteryPercent || null;
    result.type = parseBluetoothType(typeStr);
    result.connected = bluetoothObject.device_isconnected === "attrib_Yes" || false;
    return result;
  };
  var parseWindowsBluetooth = function(lines) {
    const result = {};
    result.device = null;
    result.name = util.getValue(lines, "name", ":");
    result.manufacturer = util.getValue(lines, "manufacturer", ":");
    result.macDevice = null;
    result.macHost = null;
    result.batteryPercent = null;
    result.type = parseBluetoothType(result.name.toLowerCase());
    result.connected = null;
    return result;
  };
  var bluetoothDevices = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result = [];
        if (_linux) {
          const btFiles = util.getFilesInPath("/var/lib/bluetooth/");
          btFiles.forEach((element) => {
            const filename = path2.basename(element);
            const pathParts = element.split("/");
            const macAddr1 = pathParts.length >= 6 ? pathParts[pathParts.length - 2] : null;
            const macAddr2 = pathParts.length >= 7 ? pathParts[pathParts.length - 3] : null;
            if (filename === "info") {
              const infoFile = fs.readFileSync(element, { encoding: "utf8" }).split("\n");
              result.push(parseLinuxBluetoothInfo(infoFile, macAddr1, macAddr2));
            }
          });
          try {
            const hdicon = execSync("hcitool con").toString().toLowerCase();
            for (let i = 0;i < result.length; i++) {
              if (result[i].macDevice && result[i].macDevice.length > 10 && hdicon.indexOf(result[i].macDevice.toLowerCase()) >= 0) {
                result[i].connected = true;
              }
            }
          } catch (e) {
            util.noop();
          }
          if (callback) {
            callback(result);
          }
          resolve(result);
        }
        if (_darwin) {
          let cmd = "system_profiler SPBluetoothDataType -json";
          exec(cmd, function(error, stdout) {
            if (!error) {
              try {
                const outObj = JSON.parse(stdout.toString());
                if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_title"] && outObj.SPBluetoothDataType[0]["device_title"].length) {
                  let macAddr2 = null;
                  if (outObj.SPBluetoothDataType[0]["local_device_title"] && outObj.SPBluetoothDataType[0].local_device_title.general_address) {
                    macAddr2 = outObj.SPBluetoothDataType[0].local_device_title.general_address.toLowerCase().replace(/-/g, ":");
                  }
                  outObj.SPBluetoothDataType[0]["device_title"].forEach((element) => {
                    const obj = element;
                    const objKey = Object.keys(obj);
                    if (objKey && objKey.length === 1) {
                      const innerObject = obj[objKey[0]];
                      innerObject.device_name = objKey[0];
                      const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                      result.push(bluetoothDevice);
                    }
                  });
                }
                if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_connected"] && outObj.SPBluetoothDataType[0]["device_connected"].length) {
                  const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ":") : null;
                  outObj.SPBluetoothDataType[0]["device_connected"].forEach((element) => {
                    const obj = element;
                    const objKey = Object.keys(obj);
                    if (objKey && objKey.length === 1) {
                      const innerObject = obj[objKey[0]];
                      innerObject.device_name = objKey[0];
                      innerObject.device_isconnected = "attrib_Yes";
                      const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                      result.push(bluetoothDevice);
                    }
                  });
                }
                if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_not_connected"] && outObj.SPBluetoothDataType[0]["device_not_connected"].length) {
                  const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ":") : null;
                  outObj.SPBluetoothDataType[0]["device_not_connected"].forEach((element) => {
                    const obj = element;
                    const objKey = Object.keys(obj);
                    if (objKey && objKey.length === 1) {
                      const innerObject = obj[objKey[0]];
                      innerObject.device_name = objKey[0];
                      innerObject.device_isconnected = "attrib_No";
                      const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                      result.push(bluetoothDevice);
                    }
                  });
                }
              } catch (e) {
                util.noop();
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_windows) {
          util.powerShell("Get-CimInstance Win32_PNPEntity | select PNPClass, Name, Manufacturer | fl").then((stdout, error) => {
            if (!error) {
              const parts = stdout.toString().split(/\n\s*\n/);
              parts.forEach((part) => {
                if (util.getValue(part.split("\n"), "PNPClass", ":") === "Bluetooth") {
                  result.push(parseWindowsBluetooth(part.split("\n")));
                }
              });
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        }
        if (_freebsd || _netbsd || _openbsd || _sunos) {
          resolve(null);
        }
      });
    });
  };
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var path2 = __require("path");
  var util = require_util4();
  var fs = __require("fs");
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  exports2.bluetoothDevices = bluetoothDevices;
});

// ../../node_modules/systeminformation/lib/index.js
var require_lib5 = __commonJS((exports2) => {
  var version3 = function() {
    return lib_version;
  };
  var getStaticData = function(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let data = {};
        data.version = version3();
        Promise.all([
          system.system(),
          system.bios(),
          system.baseboard(),
          system.chassis(),
          osInfo.osInfo(),
          osInfo.uuid(),
          osInfo.versions(),
          cpu.cpu(),
          cpu.cpuFlags(),
          graphics.graphics(),
          network.networkInterfaces(),
          memory.memLayout(),
          filesystem.diskLayout()
        ]).then((res) => {
          data.system = res[0];
          data.bios = res[1];
          data.baseboard = res[2];
          data.chassis = res[3];
          data.os = res[4];
          data.uuid = res[5];
          data.versions = res[6];
          data.cpu = res[7];
          data.cpu.flags = res[8];
          data.graphics = res[9];
          data.net = res[10];
          data.memLayout = res[11];
          data.diskLayout = res[12];
          if (callback) {
            callback(data);
          }
          resolve(data);
        });
      });
    });
  };
  var getDynamicData = function(srv, iface, callback) {
    if (util.isFunction(iface)) {
      callback = iface;
      iface = "";
    }
    if (util.isFunction(srv)) {
      callback = srv;
      srv = "";
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        iface = iface || network.getDefaultNetworkInterface();
        srv = srv || "";
        let functionProcessed = function() {
          let totalFunctions = 15;
          if (_windows) {
            totalFunctions = 13;
          }
          if (_freebsd || _openbsd || _netbsd) {
            totalFunctions = 11;
          }
          if (_sunos) {
            totalFunctions = 6;
          }
          return function() {
            if (--totalFunctions === 0) {
              if (callback) {
                callback(data);
              }
              resolve(data);
            }
          };
        }();
        let data = {};
        data.time = osInfo.time();
        data.node = process.versions.node;
        data.v8 = process.versions.v8;
        cpu.cpuCurrentSpeed().then((res) => {
          data.cpuCurrentSpeed = res;
          functionProcessed();
        });
        users.users().then((res) => {
          data.users = res;
          functionProcessed();
        });
        processes.processes().then((res) => {
          data.processes = res;
          functionProcessed();
        });
        cpu.currentLoad().then((res) => {
          data.currentLoad = res;
          functionProcessed();
        });
        if (!_sunos) {
          cpu.cpuTemperature().then((res) => {
            data.temp = res;
            functionProcessed();
          });
        }
        if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {
          network.networkStats(iface).then((res) => {
            data.networkStats = res;
            functionProcessed();
          });
        }
        if (!_sunos) {
          network.networkConnections().then((res) => {
            data.networkConnections = res;
            functionProcessed();
          });
        }
        memory.mem().then((res) => {
          data.mem = res;
          functionProcessed();
        });
        if (!_sunos) {
          battery().then((res) => {
            data.battery = res;
            functionProcessed();
          });
        }
        if (!_sunos) {
          processes.services(srv).then((res) => {
            data.services = res;
            functionProcessed();
          });
        }
        if (!_sunos) {
          filesystem.fsSize().then((res) => {
            data.fsSize = res;
            functionProcessed();
          });
        }
        if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {
          filesystem.fsStats().then((res) => {
            data.fsStats = res;
            functionProcessed();
          });
        }
        if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {
          filesystem.disksIO().then((res) => {
            data.disksIO = res;
            functionProcessed();
          });
        }
        if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {
          wifi.wifiNetworks().then((res) => {
            data.wifiNetworks = res;
            functionProcessed();
          });
        }
        internet.inetLatency().then((res) => {
          data.inetLatency = res;
          functionProcessed();
        });
      });
    });
  };
  var getAllData = function(srv, iface, callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let data = {};
        if (iface && util.isFunction(iface) && !callback) {
          callback = iface;
          iface = "";
        }
        if (srv && util.isFunction(srv) && !iface && !callback) {
          callback = srv;
          srv = "";
          iface = "";
        }
        getStaticData().then((res) => {
          data = res;
          getDynamicData(srv, iface).then((res2) => {
            for (let key in res2) {
              if ({}.hasOwnProperty.call(res2, key)) {
                data[key] = res2[key];
              }
            }
            if (callback) {
              callback(data);
            }
            resolve(data);
          });
        });
      });
    });
  };
  var get = function(valueObject, callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const allPromises = Object.keys(valueObject).filter((func) => ({}).hasOwnProperty.call(exports2, func)).map((func) => {
          const params2 = valueObject[func].substring(valueObject[func].lastIndexOf("(") + 1, valueObject[func].lastIndexOf(")"));
          let funcWithoutParams = func.indexOf(")") >= 0 ? func.split(")")[1].trim() : func;
          funcWithoutParams = func.indexOf("|") >= 0 ? func.split("|")[0].trim() : funcWithoutParams;
          if (params2) {
            return exports2[funcWithoutParams](params2);
          } else {
            return exports2[funcWithoutParams]("");
          }
        });
        Promise.all(allPromises).then((data) => {
          const result = {};
          let i = 0;
          for (let key in valueObject) {
            if ({}.hasOwnProperty.call(valueObject, key) && {}.hasOwnProperty.call(exports2, key) && data.length > i) {
              if (valueObject[key] === "*" || valueObject[key] === "all") {
                result[key] = data[i];
              } else {
                let keys3 = valueObject[key];
                let filter = "";
                let filterParts = [];
                if (keys3.indexOf(")") >= 0) {
                  keys3 = keys3.split(")")[1].trim();
                }
                if (keys3.indexOf("|") >= 0) {
                  filter = keys3.split("|")[1].trim();
                  filterParts = filter.split(":");
                  keys3 = keys3.split("|")[0].trim();
                }
                keys3 = keys3.replace(/,/g, " ").replace(/ +/g, " ").split(" ");
                if (data[i]) {
                  if (Array.isArray(data[i])) {
                    const partialArray = [];
                    data[i].forEach((element) => {
                      let partialRes = {};
                      if (keys3.length === 1 && (keys3[0] === "*" || keys3[0] === "all")) {
                        partialRes = element;
                      } else {
                        keys3.forEach((k) => {
                          if ({}.hasOwnProperty.call(element, k)) {
                            partialRes[k] = element[k];
                          }
                        });
                      }
                      if (filter && filterParts.length === 2) {
                        if ({}.hasOwnProperty.call(partialRes, filterParts[0].trim())) {
                          const val = partialRes[filterParts[0].trim()];
                          if (typeof val == "number") {
                            if (val === parseFloat(filterParts[1].trim())) {
                              partialArray.push(partialRes);
                            }
                          } else if (typeof val == "string") {
                            if (val.toLowerCase() === filterParts[1].trim().toLowerCase()) {
                              partialArray.push(partialRes);
                            }
                          }
                        }
                      } else {
                        partialArray.push(partialRes);
                      }
                    });
                    result[key] = partialArray;
                  } else {
                    const partialRes = {};
                    keys3.forEach((k) => {
                      if ({}.hasOwnProperty.call(data[i], k)) {
                        partialRes[k] = data[i][k];
                      }
                    });
                    result[key] = partialRes;
                  }
                } else {
                  result[key] = {};
                }
              }
              i++;
            }
          }
          if (callback) {
            callback(result);
          }
          resolve(result);
        });
      });
    });
  };
  var observe = function(valueObject, interval, callback) {
    let _data = null;
    const result = setInterval(() => {
      get(valueObject).then((data) => {
        if (JSON.stringify(_data) !== JSON.stringify(data)) {
          _data = Object.assign({}, data);
          callback(data);
        }
      });
    }, interval);
    return result;
  };
  var lib_version = require_package3().version;
  var util = require_util4();
  var system = require_system();
  var osInfo = require_osinfo();
  var cpu = require_cpu2();
  var memory = require_memory();
  var battery = require_battery();
  var graphics = require_graphics();
  var filesystem = require_filesystem();
  var network = require_network();
  var wifi = require_wifi();
  var processes = require_processes();
  var users = require_users();
  var internet = require_internet();
  var docker = require_docker();
  var vbox = require_virtualbox();
  var printer = require_printer();
  var usb = require_usb();
  var audio = require_audio();
  var bluetooth = require_bluetooth();
  var _platform = process.platform;
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  if (_windows) {
    util.getCodepage();
  }
  exports2.version = version3;
  exports2.system = system.system;
  exports2.bios = system.bios;
  exports2.baseboard = system.baseboard;
  exports2.chassis = system.chassis;
  exports2.time = osInfo.time;
  exports2.osInfo = osInfo.osInfo;
  exports2.versions = osInfo.versions;
  exports2.shell = osInfo.shell;
  exports2.uuid = osInfo.uuid;
  exports2.cpu = cpu.cpu;
  exports2.cpuFlags = cpu.cpuFlags;
  exports2.cpuCache = cpu.cpuCache;
  exports2.cpuCurrentSpeed = cpu.cpuCurrentSpeed;
  exports2.cpuTemperature = cpu.cpuTemperature;
  exports2.currentLoad = cpu.currentLoad;
  exports2.fullLoad = cpu.fullLoad;
  exports2.mem = memory.mem;
  exports2.memLayout = memory.memLayout;
  exports2.battery = battery;
  exports2.graphics = graphics.graphics;
  exports2.fsSize = filesystem.fsSize;
  exports2.fsOpenFiles = filesystem.fsOpenFiles;
  exports2.blockDevices = filesystem.blockDevices;
  exports2.fsStats = filesystem.fsStats;
  exports2.disksIO = filesystem.disksIO;
  exports2.diskLayout = filesystem.diskLayout;
  exports2.networkInterfaceDefault = network.networkInterfaceDefault;
  exports2.networkGatewayDefault = network.networkGatewayDefault;
  exports2.networkInterfaces = network.networkInterfaces;
  exports2.networkStats = network.networkStats;
  exports2.networkConnections = network.networkConnections;
  exports2.wifiNetworks = wifi.wifiNetworks;
  exports2.wifiInterfaces = wifi.wifiInterfaces;
  exports2.wifiConnections = wifi.wifiConnections;
  exports2.services = processes.services;
  exports2.processes = processes.processes;
  exports2.processLoad = processes.processLoad;
  exports2.users = users.users;
  exports2.inetChecksite = internet.inetChecksite;
  exports2.inetLatency = internet.inetLatency;
  exports2.dockerInfo = docker.dockerInfo;
  exports2.dockerImages = docker.dockerImages;
  exports2.dockerContainers = docker.dockerContainers;
  exports2.dockerContainerStats = docker.dockerContainerStats;
  exports2.dockerContainerProcesses = docker.dockerContainerProcesses;
  exports2.dockerVolumes = docker.dockerVolumes;
  exports2.dockerAll = docker.dockerAll;
  exports2.vboxInfo = vbox.vboxInfo;
  exports2.printer = printer.printer;
  exports2.usb = usb.usb;
  exports2.audio = audio.audio;
  exports2.bluetoothDevices = bluetooth.bluetoothDevices;
  exports2.getStaticData = getStaticData;
  exports2.getDynamicData = getDynamicData;
  exports2.getAllData = getAllData;
  exports2.get = get;
  exports2.observe = observe;
  exports2.powerShellStart = util.powerShellStart;
  exports2.powerShellRelease = util.powerShellRelease;
});

// ../../node_modules/pm2-sysmonit/src/psList.js
var require_psList = __commonJS((exports2, module2) => {
  var __dirname = "C:\\Users\\balle\\Documents\\GitHub\\echoesmd\\node_modules\\pm2-sysmonit\\src";
  var util = __require("util");
  var path2 = __require("path");
  var childProcess = __require("child_process");
  var TEN_MEGABYTES = 1000 * 1000 * 10;
  var execFile = util.promisify(childProcess.execFile);
  var windows = async () => {
    const bin = path2.join(__dirname, "fastlist.exe");
    const { stdout } = await execFile(bin, { maxBuffer: TEN_MEGABYTES });
    return stdout.trim().split("\r\n").map((line) => line.split("\t")).map(([name2, pid, ppid]) => ({
      name: name2,
      pid: Number.parseInt(pid, 10),
      ppid: Number.parseInt(ppid, 10)
    }));
  };
  var main2 = async (options2 = {}) => {
    const flags = (options2.all === false ? "" : "a") + "wwxo";
    const ret = {};
    await Promise.all(["comm", "args", "ppid", "uid", "%cpu", "%mem"].map(async (cmd) => {
      const { stdout } = await execFile("ps", [flags, `pid,${cmd}`], { maxBuffer: TEN_MEGABYTES });
      for (let line of stdout.trim().split("\n").slice(1)) {
        line = line.trim();
        const [pid] = line.split(" ", 1);
        const val = line.slice(pid.length + 1).trim();
        if (ret[pid] === undefined) {
          ret[pid] = {};
        }
        ret[pid][cmd] = val;
      }
    }));
    return Object.entries(ret).filter(([, value]) => value.comm && value.args && value.ppid && value.uid && value["%cpu"] && value["%mem"]).map(([key, value]) => ({
      pid: Number.parseInt(key, 10),
      name: path2.basename(value.comm),
      cmd: value.args,
      ppid: Number.parseInt(value.ppid, 10),
      uid: Number.parseInt(value.uid, 10),
      cpu: Number.parseFloat(value["%cpu"]),
      memory: Number.parseFloat(value["%mem"])
    }));
  };
  module2.exports = process.platform === "win32" ? windows : main2;
  module2.exports.default = module2.exports;
});

// ../../node_modules/async/dist/async.js
var require_async = __commonJS((exports2, module2) => {
  (function(global2, factory) {
    typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.async = {}));
  })(exports2, function(exports3) {
    function apply(fn, ...args2) {
      return (...callArgs) => fn(...args2, ...callArgs);
    }
    function initialParams(fn) {
      return function(...args2) {
        var callback = args2.pop();
        return fn.call(this, args2, callback);
      };
    }
    var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return (fn, ...args2) => defer(() => fn(...args2));
    }
    var _defer$1;
    if (hasQueueMicrotask) {
      _defer$1 = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer$1 = setImmediate;
    } else if (hasNextTick) {
      _defer$1 = process.nextTick;
    } else {
      _defer$1 = fallback;
    }
    var setImmediate$1 = wrap(_defer$1);
    function asyncify(func) {
      if (isAsync(func)) {
        return function(...args2) {
          const callback = args2.pop();
          const promise = func.apply(this, args2);
          return handlePromise(promise, callback);
        };
      }
      return initialParams(function(args2, callback) {
        var result;
        try {
          result = func.apply(this, args2);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        setImmediate$1((e) => {
          throw e;
        }, err);
      }
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function")
        throw new Error("expected a function");
      return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
    }
    function awaitify(asyncFn, arity) {
      if (!arity)
        arity = asyncFn.length;
      if (!arity)
        throw new Error("arity is undefined");
      function awaitable(...args2) {
        if (typeof args2[arity - 1] === "function") {
          return asyncFn.apply(this, args2);
        }
        return new Promise((resolve, reject2) => {
          args2[arity - 1] = (err, ...cbArgs) => {
            if (err)
              return reject2(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args2);
        });
      }
      return awaitable;
    }
    function applyEach$1(eachfn) {
      return function applyEach(fns, ...callArgs) {
        const go = awaitify(function(callback) {
          var that = this;
          return eachfn(fns, (fn, cb) => {
            wrapAsync(fn).apply(that, callArgs.concat(cb));
          }, callback);
        });
        return go;
      };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
      arr = arr || [];
      var results = [];
      var counter = 0;
      var _iteratee = wrapAsync(iteratee);
      return eachfn(arr, (value, _, iterCb) => {
        var index2 = counter++;
        _iteratee(value, (err, v) => {
          results[index2] = v;
          iterCb(err);
        });
      }, (err) => {
        callback(err, results);
      });
    }
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    const breakLoop = {};
    var breakLoop$1 = breakLoop;
    function once(fn) {
      function wrapper(...args2) {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args2);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    function getIterator(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done)
          return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        if (key === "__proto__") {
          return next();
        }
        return i < len ? { value: obj[key], key } : null;
      };
    }
    function createIterator2(coll) {
      if (isArrayLike(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = getIterator(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    function onlyOnce(fn) {
      return function(...args2) {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args2);
      };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done)
          return;
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
          if (canceled || done)
            return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled)
          return;
        if (err)
          return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === breakLoop$1 || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled)
          return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    var eachOfLimit$2 = (limit) => {
      return (obj, iteratee, callback) => {
        callback = once(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if (isAsyncGenerator(obj)) {
          return asyncEachOfLimit(obj, limit, iteratee, callback);
        }
        if (isAsyncIterable(obj)) {
          return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = createIterator2(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === breakLoop$1 || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    function eachOfLimit(coll, limit, iteratee, callback) {
      return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
    }
    var eachOfLimit$1 = awaitify(eachOfLimit, 4);
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = once(callback);
      var index2 = 0, completed = 0, { length: length3 } = coll, canceled = false;
      if (length3 === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true)
          return;
        if (err) {
          callback(err);
        } else if (++completed === length3 || value === breakLoop$1) {
          callback(null);
        }
      }
      for (;index2 < length3; index2++) {
        iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return eachOfLimit$1(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, wrapAsync(iteratee), callback);
    }
    var eachOf$1 = awaitify(eachOf, 3);
    function map(coll, iteratee, callback) {
      return _asyncMap(eachOf$1, coll, iteratee, callback);
    }
    var map$1 = awaitify(map, 3);
    var applyEach = applyEach$1(map$1);
    function eachOfSeries(coll, iteratee, callback) {
      return eachOfLimit$1(coll, 1, iteratee, callback);
    }
    var eachOfSeries$1 = awaitify(eachOfSeries, 3);
    function mapSeries(coll, iteratee, callback) {
      return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
    }
    var mapSeries$1 = awaitify(mapSeries, 3);
    var applyEachSeries = applyEach$1(mapSeries$1);
    const PROMISE_SYMBOL = Symbol("promiseCallback");
    function promiseCallback() {
      let resolve, reject2;
      function callback(err, ...args2) {
        if (err)
          return reject2(err);
        resolve(args2.length > 1 ? args2 : args2[0]);
      }
      callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
        resolve = res, reject2 = rej;
      });
      return callback;
    }
    function auto(tasks, concurrency, callback) {
      if (typeof concurrency !== "number") {
        callback = concurrency;
        concurrency = null;
      }
      callback = once(callback || promiseCallback());
      var numTasks = Object.keys(tasks).length;
      if (!numTasks) {
        return callback(null);
      }
      if (!concurrency) {
        concurrency = numTasks;
      }
      var results = {};
      var runningTasks = 0;
      var canceled = false;
      var hasError = false;
      var listeners = Object.create(null);
      var readyTasks = [];
      var readyToCheck = [];
      var uncheckedDependencies = {};
      Object.keys(tasks).forEach((key) => {
        var task = tasks[key];
        if (!Array.isArray(task)) {
          enqueueTask(key, [task]);
          readyToCheck.push(key);
          return;
        }
        var dependencies2 = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies2.length;
        if (remainingDependencies === 0) {
          enqueueTask(key, task);
          readyToCheck.push(key);
          return;
        }
        uncheckedDependencies[key] = remainingDependencies;
        dependencies2.forEach((dependencyName) => {
          if (!tasks[dependencyName]) {
            throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies2.join(", "));
          }
          addListener(dependencyName, () => {
            remainingDependencies--;
            if (remainingDependencies === 0) {
              enqueueTask(key, task);
            }
          });
        });
      });
      checkForDeadlocks();
      processQueue();
      function enqueueTask(key, task) {
        readyTasks.push(() => runTask(key, task));
      }
      function processQueue() {
        if (canceled)
          return;
        if (readyTasks.length === 0 && runningTasks === 0) {
          return callback(null, results);
        }
        while (readyTasks.length && runningTasks < concurrency) {
          var run2 = readyTasks.shift();
          run2();
        }
      }
      function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
          taskListeners = listeners[taskName] = [];
        }
        taskListeners.push(fn);
      }
      function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        taskListeners.forEach((fn) => fn());
        processQueue();
      }
      function runTask(key, task) {
        if (hasError)
          return;
        var taskCallback = onlyOnce((err, ...result) => {
          runningTasks--;
          if (err === false) {
            canceled = true;
            return;
          }
          if (result.length < 2) {
            [result] = result;
          }
          if (err) {
            var safeResults = {};
            Object.keys(results).forEach((rkey) => {
              safeResults[rkey] = results[rkey];
            });
            safeResults[key] = result;
            hasError = true;
            listeners = Object.create(null);
            if (canceled)
              return;
            callback(err, safeResults);
          } else {
            results[key] = result;
            taskComplete(key);
          }
        });
        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length > 1) {
          taskFn(results, taskCallback);
        } else {
          taskFn(taskCallback);
        }
      }
      function checkForDeadlocks() {
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) {
          currentTask = readyToCheck.pop();
          counter++;
          getDependents(currentTask).forEach((dependent) => {
            if (--uncheckedDependencies[dependent] === 0) {
              readyToCheck.push(dependent);
            }
          });
        }
        if (counter !== numTasks) {
          throw new Error("async.auto cannot execute tasks due to a recursive dependency");
        }
      }
      function getDependents(taskName) {
        var result = [];
        Object.keys(tasks).forEach((key) => {
          const task = tasks[key];
          if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
            result.push(key);
          }
        });
        return result;
      }
      return callback[PROMISE_SYMBOL];
    }
    var FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
    var ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /(=.+)?(\s*)$/;
    function stripComments(string) {
      let stripped = "";
      let index2 = 0;
      let endBlockComment = string.indexOf("*/");
      while (index2 < string.length) {
        if (string[index2] === "/" && string[index2 + 1] === "/") {
          let endIndex = string.indexOf("\n", index2);
          index2 = endIndex === -1 ? string.length : endIndex;
        } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
          let endIndex = string.indexOf("*/", index2);
          if (endIndex !== -1) {
            index2 = endIndex + 2;
            endBlockComment = string.indexOf("*/", index2);
          } else {
            stripped += string[index2];
            index2++;
          }
        } else {
          stripped += string[index2];
          index2++;
        }
      }
      return stripped;
    }
    function parseParams(func) {
      const src = stripComments(func.toString());
      let match = src.match(FN_ARGS);
      if (!match) {
        match = src.match(ARROW_FN_ARGS);
      }
      if (!match)
        throw new Error("could not parse args in autoInject\nSource:\n" + src);
      let [, args2] = match;
      return args2.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
    }
    function autoInject(tasks, callback) {
      var newTasks = {};
      Object.keys(tasks).forEach((key) => {
        var taskFn = tasks[key];
        var params2;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
        if (Array.isArray(taskFn)) {
          params2 = [...taskFn];
          taskFn = params2.pop();
          newTasks[key] = params2.concat(params2.length > 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
          newTasks[key] = taskFn;
        } else {
          params2 = parseParams(taskFn);
          if (taskFn.length === 0 && !fnIsAsync && params2.length === 0) {
            throw new Error("autoInject task functions require explicit parameters.");
          }
          if (!fnIsAsync)
            params2.pop();
          newTasks[key] = params2.concat(newTask);
        }
        function newTask(results, taskCb) {
          var newArgs = params2.map((name2) => results[name2]);
          newArgs.push(taskCb);
          wrapAsync(taskFn)(...newArgs);
        }
      });
      return auto(newTasks, callback);
    }

    class DLL {
      constructor() {
        this.head = this.tail = null;
        this.length = 0;
      }
      removeLink(node) {
        if (node.prev)
          node.prev.next = node.next;
        else
          this.head = node.next;
        if (node.next)
          node.next.prev = node.prev;
        else
          this.tail = node.prev;
        node.prev = node.next = null;
        this.length -= 1;
        return node;
      }
      empty() {
        while (this.head)
          this.shift();
        return this;
      }
      insertAfter(node, newNode) {
        newNode.prev = node;
        newNode.next = node.next;
        if (node.next)
          node.next.prev = newNode;
        else
          this.tail = newNode;
        node.next = newNode;
        this.length += 1;
      }
      insertBefore(node, newNode) {
        newNode.prev = node.prev;
        newNode.next = node;
        if (node.prev)
          node.prev.next = newNode;
        else
          this.head = newNode;
        node.prev = newNode;
        this.length += 1;
      }
      unshift(node) {
        if (this.head)
          this.insertBefore(this.head, node);
        else
          setInitial(this, node);
      }
      push(node) {
        if (this.tail)
          this.insertAfter(this.tail, node);
        else
          setInitial(this, node);
      }
      shift() {
        return this.head && this.removeLink(this.head);
      }
      pop() {
        return this.tail && this.removeLink(this.tail);
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        var cur = this.head;
        while (cur) {
          yield cur.data;
          cur = cur.next;
        }
      }
      remove(testFn) {
        var curr = this.head;
        while (curr) {
          var { next } = curr;
          if (testFn(curr)) {
            this.removeLink(curr);
          }
          curr = next;
        }
        return this;
      }
    }
    function setInitial(dll, node) {
      dll.length = 1;
      dll.head = dll.tail = node;
    }
    function queue$1(worker, concurrency, payload) {
      if (concurrency == null) {
        concurrency = 1;
      } else if (concurrency === 0) {
        throw new RangeError("Concurrency must not be zero");
      }
      var _worker = wrapAsync(worker);
      var numRunning = 0;
      var workersList = [];
      const events = {
        error: [],
        drain: [],
        saturated: [],
        unsaturated: [],
        empty: []
      };
      function on(event, handler) {
        events[event].push(handler);
      }
      function once2(event, handler) {
        const handleAndRemove = (...args2) => {
          off(event, handleAndRemove);
          handler(...args2);
        };
        events[event].push(handleAndRemove);
      }
      function off(event, handler) {
        if (!event)
          return Object.keys(events).forEach((ev) => events[ev] = []);
        if (!handler)
          return events[event] = [];
        events[event] = events[event].filter((ev) => ev !== handler);
      }
      function trigger(event, ...args2) {
        events[event].forEach((handler) => handler(...args2));
      }
      var processingScheduled = false;
      function _insert(data, insertAtFront, rejectOnError, callback) {
        if (callback != null && typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        q.started = true;
        var res, rej;
        function promiseCallback2(err, ...args2) {
          if (err)
            return rejectOnError ? rej(err) : res();
          if (args2.length <= 1)
            return res(args2[0]);
          res(args2);
        }
        var item = q._createTaskItem(data, rejectOnError ? promiseCallback2 : callback || promiseCallback2);
        if (insertAtFront) {
          q._tasks.unshift(item);
        } else {
          q._tasks.push(item);
        }
        if (!processingScheduled) {
          processingScheduled = true;
          setImmediate$1(() => {
            processingScheduled = false;
            q.process();
          });
        }
        if (rejectOnError || !callback) {
          return new Promise((resolve, reject2) => {
            res = resolve;
            rej = reject2;
          });
        }
      }
      function _createCB(tasks) {
        return function(err, ...args2) {
          numRunning -= 1;
          for (var i = 0, l = tasks.length;i < l; i++) {
            var task = tasks[i];
            var index2 = workersList.indexOf(task);
            if (index2 === 0) {
              workersList.shift();
            } else if (index2 > 0) {
              workersList.splice(index2, 1);
            }
            task.callback(err, ...args2);
            if (err != null) {
              trigger("error", err, task.data);
            }
          }
          if (numRunning <= q.concurrency - q.buffer) {
            trigger("unsaturated");
          }
          if (q.idle()) {
            trigger("drain");
          }
          q.process();
        };
      }
      function _maybeDrain(data) {
        if (data.length === 0 && q.idle()) {
          setImmediate$1(() => trigger("drain"));
          return true;
        }
        return false;
      }
      const eventMethod = (name2) => (handler) => {
        if (!handler) {
          return new Promise((resolve, reject2) => {
            once2(name2, (err, data) => {
              if (err)
                return reject2(err);
              resolve(data);
            });
          });
        }
        off(name2);
        on(name2, handler);
      };
      var isProcessing = false;
      var q = {
        _tasks: new DLL,
        _createTaskItem(data, callback) {
          return {
            data,
            callback
          };
        },
        *[Symbol.iterator]() {
          yield* q._tasks[Symbol.iterator]();
        },
        concurrency,
        payload,
        buffer: concurrency / 4,
        started: false,
        paused: false,
        push(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, false, false, callback));
          }
          return _insert(data, false, false, callback);
        },
        pushAsync(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, false, true, callback));
          }
          return _insert(data, false, true, callback);
        },
        kill() {
          off();
          q._tasks.empty();
        },
        unshift(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, true, false, callback));
          }
          return _insert(data, true, false, callback);
        },
        unshiftAsync(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, true, true, callback));
          }
          return _insert(data, true, true, callback);
        },
        remove(testFn) {
          q._tasks.remove(testFn);
        },
        process() {
          if (isProcessing) {
            return;
          }
          isProcessing = true;
          while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
            var tasks = [], data = [];
            var l = q._tasks.length;
            if (q.payload)
              l = Math.min(l, q.payload);
            for (var i = 0;i < l; i++) {
              var node = q._tasks.shift();
              tasks.push(node);
              workersList.push(node);
              data.push(node.data);
            }
            numRunning += 1;
            if (q._tasks.length === 0) {
              trigger("empty");
            }
            if (numRunning === q.concurrency) {
              trigger("saturated");
            }
            var cb = onlyOnce(_createCB(tasks));
            _worker(data, cb);
          }
          isProcessing = false;
        },
        length() {
          return q._tasks.length;
        },
        running() {
          return numRunning;
        },
        workersList() {
          return workersList;
        },
        idle() {
          return q._tasks.length + numRunning === 0;
        },
        pause() {
          q.paused = true;
        },
        resume() {
          if (q.paused === false) {
            return;
          }
          q.paused = false;
          setImmediate$1(q.process);
        }
      };
      Object.defineProperties(q, {
        saturated: {
          writable: false,
          value: eventMethod("saturated")
        },
        unsaturated: {
          writable: false,
          value: eventMethod("unsaturated")
        },
        empty: {
          writable: false,
          value: eventMethod("empty")
        },
        drain: {
          writable: false,
          value: eventMethod("drain")
        },
        error: {
          writable: false,
          value: eventMethod("error")
        }
      });
      return q;
    }
    function cargo$1(worker, payload) {
      return queue$1(worker, 1, payload);
    }
    function cargo(worker, concurrency, payload) {
      return queue$1(worker, concurrency, payload);
    }
    function reduce(coll, memo, iteratee, callback) {
      callback = once(callback);
      var _iteratee = wrapAsync(iteratee);
      return eachOfSeries$1(coll, (x, i, iterCb) => {
        _iteratee(memo, x, (err, v) => {
          memo = v;
          iterCb(err);
        });
      }, (err) => callback(err, memo));
    }
    var reduce$1 = awaitify(reduce, 4);
    function seq(...functions) {
      var _functions = functions.map(wrapAsync);
      return function(...args2) {
        var that = this;
        var cb = args2[args2.length - 1];
        if (typeof cb == "function") {
          args2.pop();
        } else {
          cb = promiseCallback();
        }
        reduce$1(_functions, args2, (newargs, fn, iterCb) => {
          fn.apply(that, newargs.concat((err, ...nextargs) => {
            iterCb(err, nextargs);
          }));
        }, (err, results) => cb(err, ...results));
        return cb[PROMISE_SYMBOL];
      };
    }
    function compose(...args2) {
      return seq(...args2.reverse());
    }
    function mapLimit(coll, limit, iteratee, callback) {
      return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var mapLimit$1 = awaitify(mapLimit, 4);
    function concatLimit(coll, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, ...args2) => {
          if (err)
            return iterCb(err);
          return iterCb(err, args2);
        });
      }, (err, mapResults) => {
        var result = [];
        for (var i = 0;i < mapResults.length; i++) {
          if (mapResults[i]) {
            result = result.concat(...mapResults[i]);
          }
        }
        return callback(err, result);
      });
    }
    var concatLimit$1 = awaitify(concatLimit, 4);
    function concat(coll, iteratee, callback) {
      return concatLimit$1(coll, Infinity, iteratee, callback);
    }
    var concat$1 = awaitify(concat, 3);
    function concatSeries(coll, iteratee, callback) {
      return concatLimit$1(coll, 1, iteratee, callback);
    }
    var concatSeries$1 = awaitify(concatSeries, 3);
    function constant$1(...args2) {
      return function(...ignoredArgs) {
        var callback = ignoredArgs.pop();
        return callback(null, ...args2);
      };
    }
    function _createTester(check, getResult) {
      return (eachfn, arr, _iteratee, cb) => {
        var testPassed = false;
        var testResult;
        const iteratee = wrapAsync(_iteratee);
        eachfn(arr, (value, _, callback) => {
          iteratee(value, (err, result) => {
            if (err || err === false)
              return callback(err);
            if (check(result) && !testResult) {
              testPassed = true;
              testResult = getResult(true, value);
              return callback(null, breakLoop$1);
            }
            callback();
          });
        }, (err) => {
          if (err)
            return cb(err);
          cb(null, testPassed ? testResult : getResult(false));
        });
      };
    }
    function detect(coll, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
    }
    var detect$1 = awaitify(detect, 3);
    function detectLimit(coll, limit, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var detectLimit$1 = awaitify(detectLimit, 4);
    function detectSeries(coll, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
    }
    var detectSeries$1 = awaitify(detectSeries, 3);
    function consoleFunc(name2) {
      return (fn, ...args2) => wrapAsync(fn)(...args2, (err, ...resultArgs) => {
        if (typeof console === "object") {
          if (err) {
            if (console.error) {
              console.error(err);
            }
          } else if (console[name2]) {
            resultArgs.forEach((x) => console[name2](x));
          }
        }
      });
    }
    var dir = consoleFunc("dir");
    function doWhilst(iteratee, test, callback) {
      callback = onlyOnce(callback);
      var _fn = wrapAsync(iteratee);
      var _test = wrapAsync(test);
      var results;
      function next(err, ...args2) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        results = args2;
        _test(...args2, check);
      }
      function check(err, truth) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        if (!truth)
          return callback(null, ...results);
        _fn(next);
      }
      return check(null, true);
    }
    var doWhilst$1 = awaitify(doWhilst, 3);
    function doUntil(iteratee, test, callback) {
      const _test = wrapAsync(test);
      return doWhilst$1(iteratee, (...args2) => {
        const cb = args2.pop();
        _test(...args2, (err, truth) => cb(err, !truth));
      }, callback);
    }
    function _withoutIndex(iteratee) {
      return (value, index2, callback) => iteratee(value, callback);
    }
    function eachLimit$2(coll, iteratee, callback) {
      return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var each = awaitify(eachLimit$2, 3);
    function eachLimit(coll, limit, iteratee, callback) {
      return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var eachLimit$1 = awaitify(eachLimit, 4);
    function eachSeries(coll, iteratee, callback) {
      return eachLimit$1(coll, 1, iteratee, callback);
    }
    var eachSeries$1 = awaitify(eachSeries, 3);
    function ensureAsync(fn) {
      if (isAsync(fn))
        return fn;
      return function(...args2) {
        var callback = args2.pop();
        var sync = true;
        args2.push((...innerArgs) => {
          if (sync) {
            setImmediate$1(() => callback(...innerArgs));
          } else {
            callback(...innerArgs);
          }
        });
        fn.apply(this, args2);
        sync = false;
      };
    }
    function every2(coll, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
    }
    var every$1 = awaitify(every2, 3);
    function everyLimit(coll, limit, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var everyLimit$1 = awaitify(everyLimit, 4);
    function everySeries(coll, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var everySeries$1 = awaitify(everySeries, 3);
    function filterArray(eachfn, arr, iteratee, callback) {
      var truthValues = new Array(arr.length);
      eachfn(arr, (x, index2, iterCb) => {
        iteratee(x, (err, v) => {
          truthValues[index2] = !!v;
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        var results = [];
        for (var i = 0;i < arr.length; i++) {
          if (truthValues[i])
            results.push(arr[i]);
        }
        callback(null, results);
      });
    }
    function filterGeneric(eachfn, coll, iteratee, callback) {
      var results = [];
      eachfn(coll, (x, index2, iterCb) => {
        iteratee(x, (err, v) => {
          if (err)
            return iterCb(err);
          if (v) {
            results.push({ index: index2, value: x });
          }
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
      });
    }
    function _filter(eachfn, coll, iteratee, callback) {
      var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
      return filter2(eachfn, coll, wrapAsync(iteratee), callback);
    }
    function filter(coll, iteratee, callback) {
      return _filter(eachOf$1, coll, iteratee, callback);
    }
    var filter$1 = awaitify(filter, 3);
    function filterLimit(coll, limit, iteratee, callback) {
      return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var filterLimit$1 = awaitify(filterLimit, 4);
    function filterSeries(coll, iteratee, callback) {
      return _filter(eachOfSeries$1, coll, iteratee, callback);
    }
    var filterSeries$1 = awaitify(filterSeries, 3);
    function forever(fn, errback) {
      var done = onlyOnce(errback);
      var task = wrapAsync(ensureAsync(fn));
      function next(err) {
        if (err)
          return done(err);
        if (err === false)
          return;
        task(next);
      }
      return next();
    }
    var forever$1 = awaitify(forever, 2);
    function groupByLimit(coll, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, key) => {
          if (err)
            return iterCb(err);
          return iterCb(err, { key, val });
        });
      }, (err, mapResults) => {
        var result = {};
        var { hasOwnProperty } = Object.prototype;
        for (var i = 0;i < mapResults.length; i++) {
          if (mapResults[i]) {
            var { key } = mapResults[i];
            var { val } = mapResults[i];
            if (hasOwnProperty.call(result, key)) {
              result[key].push(val);
            } else {
              result[key] = [val];
            }
          }
        }
        return callback(err, result);
      });
    }
    var groupByLimit$1 = awaitify(groupByLimit, 4);
    function groupBy(coll, iteratee, callback) {
      return groupByLimit$1(coll, Infinity, iteratee, callback);
    }
    function groupBySeries(coll, iteratee, callback) {
      return groupByLimit$1(coll, 1, iteratee, callback);
    }
    var log = consoleFunc("log");
    function mapValuesLimit(obj, limit, iteratee, callback) {
      callback = once(callback);
      var newObj = {};
      var _iteratee = wrapAsync(iteratee);
      return eachOfLimit$2(limit)(obj, (val, key, next) => {
        _iteratee(val, key, (err, result) => {
          if (err)
            return next(err);
          newObj[key] = result;
          next(err);
        });
      }, (err) => callback(err, newObj));
    }
    var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
    function mapValues(obj, iteratee, callback) {
      return mapValuesLimit$1(obj, Infinity, iteratee, callback);
    }
    function mapValuesSeries(obj, iteratee, callback) {
      return mapValuesLimit$1(obj, 1, iteratee, callback);
    }
    function memoize(fn, hasher = (v) => v) {
      var memo = Object.create(null);
      var queues = Object.create(null);
      var _fn = wrapAsync(fn);
      var memoized = initialParams((args2, callback) => {
        var key = hasher(...args2);
        if (key in memo) {
          setImmediate$1(() => callback(null, ...memo[key]));
        } else if (key in queues) {
          queues[key].push(callback);
        } else {
          queues[key] = [callback];
          _fn(...args2, (err, ...resultArgs) => {
            if (!err) {
              memo[key] = resultArgs;
            }
            var q = queues[key];
            delete queues[key];
            for (var i = 0, l = q.length;i < l; i++) {
              q[i](err, ...resultArgs);
            }
          });
        }
      });
      memoized.memo = memo;
      memoized.unmemoized = fn;
      return memoized;
    }
    var _defer;
    if (hasNextTick) {
      _defer = process.nextTick;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else {
      _defer = fallback;
    }
    var nextTick = wrap(_defer);
    var _parallel = awaitify((eachfn, tasks, callback) => {
      var results = isArrayLike(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        wrapAsync(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    function parallel(tasks, callback) {
      return _parallel(eachOf$1, tasks, callback);
    }
    function parallelLimit(tasks, limit, callback) {
      return _parallel(eachOfLimit$2(limit), tasks, callback);
    }
    function queue(worker, concurrency) {
      var _worker = wrapAsync(worker);
      return queue$1((items, cb) => {
        _worker(items[0], cb);
      }, concurrency, 1);
    }

    class Heap {
      constructor() {
        this.heap = [];
        this.pushCount = Number.MIN_SAFE_INTEGER;
      }
      get length() {
        return this.heap.length;
      }
      empty() {
        this.heap = [];
        return this;
      }
      percUp(index2) {
        let p;
        while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
          let t = this.heap[index2];
          this.heap[index2] = this.heap[p];
          this.heap[p] = t;
          index2 = p;
        }
      }
      percDown(index2) {
        let l;
        while ((l = leftChi(index2)) < this.heap.length) {
          if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
            l = l + 1;
          }
          if (smaller(this.heap[index2], this.heap[l])) {
            break;
          }
          let t = this.heap[index2];
          this.heap[index2] = this.heap[l];
          this.heap[l] = t;
          index2 = l;
        }
      }
      push(node) {
        node.pushCount = ++this.pushCount;
        this.heap.push(node);
        this.percUp(this.heap.length - 1);
      }
      unshift(node) {
        return this.heap.push(node);
      }
      shift() {
        let [top] = this.heap;
        this.heap[0] = this.heap[this.heap.length - 1];
        this.heap.pop();
        this.percDown(0);
        return top;
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        for (let i = 0;i < this.heap.length; i++) {
          yield this.heap[i].data;
        }
      }
      remove(testFn) {
        let j = 0;
        for (let i = 0;i < this.heap.length; i++) {
          if (!testFn(this.heap[i])) {
            this.heap[j] = this.heap[i];
            j++;
          }
        }
        this.heap.splice(j);
        for (let i = parent(this.heap.length - 1);i >= 0; i--) {
          this.percDown(i);
        }
        return this;
      }
    }
    function leftChi(i) {
      return (i << 1) + 1;
    }
    function parent(i) {
      return (i + 1 >> 1) - 1;
    }
    function smaller(x, y) {
      if (x.priority !== y.priority) {
        return x.priority < y.priority;
      } else {
        return x.pushCount < y.pushCount;
      }
    }
    function priorityQueue(worker, concurrency) {
      var q = queue(worker, concurrency);
      var {
        push,
        pushAsync
      } = q;
      q._tasks = new Heap;
      q._createTaskItem = ({ data, priority }, callback) => {
        return {
          data,
          priority,
          callback
        };
      };
      function createDataItems(tasks, priority) {
        if (!Array.isArray(tasks)) {
          return { data: tasks, priority };
        }
        return tasks.map((data) => {
          return { data, priority };
        });
      }
      q.push = function(data, priority = 0, callback) {
        return push(createDataItems(data, priority), callback);
      };
      q.pushAsync = function(data, priority = 0, callback) {
        return pushAsync(createDataItems(data, priority), callback);
      };
      delete q.unshift;
      delete q.unshiftAsync;
      return q;
    }
    function race(tasks, callback) {
      callback = once(callback);
      if (!Array.isArray(tasks))
        return callback(new TypeError("First argument to race must be an array of functions"));
      if (!tasks.length)
        return callback();
      for (var i = 0, l = tasks.length;i < l; i++) {
        wrapAsync(tasks[i])(callback);
      }
    }
    var race$1 = awaitify(race, 2);
    function reduceRight(array, memo, iteratee, callback) {
      var reversed = [...array].reverse();
      return reduce$1(reversed, memo, iteratee, callback);
    }
    function reflect(fn) {
      var _fn = wrapAsync(fn);
      return initialParams(function reflectOn(args2, reflectCallback) {
        args2.push((error, ...cbArgs) => {
          let retVal = {};
          if (error) {
            retVal.error = error;
          }
          if (cbArgs.length > 0) {
            var value = cbArgs;
            if (cbArgs.length <= 1) {
              [value] = cbArgs;
            }
            retVal.value = value;
          }
          reflectCallback(null, retVal);
        });
        return _fn.apply(this, args2);
      });
    }
    function reflectAll(tasks) {
      var results;
      if (Array.isArray(tasks)) {
        results = tasks.map(reflect);
      } else {
        results = {};
        Object.keys(tasks).forEach((key) => {
          results[key] = reflect.call(this, tasks[key]);
        });
      }
      return results;
    }
    function reject$2(eachfn, arr, _iteratee, callback) {
      const iteratee = wrapAsync(_iteratee);
      return _filter(eachfn, arr, (value, cb) => {
        iteratee(value, (err, v) => {
          cb(err, !v);
        });
      }, callback);
    }
    function reject(coll, iteratee, callback) {
      return reject$2(eachOf$1, coll, iteratee, callback);
    }
    var reject$1 = awaitify(reject, 3);
    function rejectLimit(coll, limit, iteratee, callback) {
      return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var rejectLimit$1 = awaitify(rejectLimit, 4);
    function rejectSeries(coll, iteratee, callback) {
      return reject$2(eachOfSeries$1, coll, iteratee, callback);
    }
    var rejectSeries$1 = awaitify(rejectSeries, 3);
    function constant(value) {
      return function() {
        return value;
      };
    }
    const DEFAULT_TIMES = 5;
    const DEFAULT_INTERVAL = 0;
    function retry(opts, task, callback) {
      var options2 = {
        times: DEFAULT_TIMES,
        intervalFunc: constant(DEFAULT_INTERVAL)
      };
      if (arguments.length < 3 && typeof opts === "function") {
        callback = task || promiseCallback();
        task = opts;
      } else {
        parseTimes(options2, opts);
        callback = callback || promiseCallback();
      }
      if (typeof task !== "function") {
        throw new Error("Invalid arguments for async.retry");
      }
      var _task = wrapAsync(task);
      var attempt = 1;
      function retryAttempt() {
        _task((err, ...args2) => {
          if (err === false)
            return;
          if (err && attempt++ < options2.times && (typeof options2.errorFilter != "function" || options2.errorFilter(err))) {
            setTimeout(retryAttempt, options2.intervalFunc(attempt - 1));
          } else {
            callback(err, ...args2);
          }
        });
      }
      retryAttempt();
      return callback[PROMISE_SYMBOL];
    }
    function parseTimes(acc, t) {
      if (typeof t === "object") {
        acc.times = +t.times || DEFAULT_TIMES;
        acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);
        acc.errorFilter = t.errorFilter;
      } else if (typeof t === "number" || typeof t === "string") {
        acc.times = +t || DEFAULT_TIMES;
      } else {
        throw new Error("Invalid arguments for async.retry");
      }
    }
    function retryable(opts, task) {
      if (!task) {
        task = opts;
        opts = null;
      }
      let arity = opts && opts.arity || task.length;
      if (isAsync(task)) {
        arity += 1;
      }
      var _task = wrapAsync(task);
      return initialParams((args2, callback) => {
        if (args2.length < arity - 1 || callback == null) {
          args2.push(callback);
          callback = promiseCallback();
        }
        function taskFn(cb) {
          _task(...args2, cb);
        }
        if (opts)
          retry(opts, taskFn, callback);
        else
          retry(taskFn, callback);
        return callback[PROMISE_SYMBOL];
      });
    }
    function series(tasks, callback) {
      return _parallel(eachOfSeries$1, tasks, callback);
    }
    function some2(coll, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
    }
    var some$1 = awaitify(some2, 3);
    function someLimit(coll, limit, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var someLimit$1 = awaitify(someLimit, 4);
    function someSeries(coll, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var someSeries$1 = awaitify(someSeries, 3);
    function sortBy(coll, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return map$1(coll, (x, iterCb) => {
        _iteratee(x, (err, criteria) => {
          if (err)
            return iterCb(err);
          iterCb(err, { value: x, criteria });
        });
      }, (err, results) => {
        if (err)
          return callback(err);
        callback(null, results.sort(comparator).map((v) => v.value));
      });
      function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a < b ? -1 : a > b ? 1 : 0;
      }
    }
    var sortBy$1 = awaitify(sortBy, 3);
    function timeout(asyncFn, milliseconds, info) {
      var fn = wrapAsync(asyncFn);
      return initialParams((args2, callback) => {
        var timedOut = false;
        var timer;
        function timeoutCallback() {
          var name2 = asyncFn.name || "anonymous";
          var error = new Error('Callback function "' + name2 + '" timed out.');
          error.code = "ETIMEDOUT";
          if (info) {
            error.info = info;
          }
          timedOut = true;
          callback(error);
        }
        args2.push((...cbArgs) => {
          if (!timedOut) {
            callback(...cbArgs);
            clearTimeout(timer);
          }
        });
        timer = setTimeout(timeoutCallback, milliseconds);
        fn(...args2);
      });
    }
    function range(size2) {
      var result = Array(size2);
      while (size2--) {
        result[size2] = size2;
      }
      return result;
    }
    function timesLimit(count, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(range(count), limit, _iteratee, callback);
    }
    function times(n, iteratee, callback) {
      return timesLimit(n, Infinity, iteratee, callback);
    }
    function timesSeries(n, iteratee, callback) {
      return timesLimit(n, 1, iteratee, callback);
    }
    function transform(coll, accumulator, iteratee, callback) {
      if (arguments.length <= 3 && typeof accumulator === "function") {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = Array.isArray(coll) ? [] : {};
      }
      callback = once(callback || promiseCallback());
      var _iteratee = wrapAsync(iteratee);
      eachOf$1(coll, (v, k, cb) => {
        _iteratee(accumulator, v, k, cb);
      }, (err) => callback(err, accumulator));
      return callback[PROMISE_SYMBOL];
    }
    function tryEach(tasks, callback) {
      var error = null;
      var result;
      return eachSeries$1(tasks, (task, taskCb) => {
        wrapAsync(task)((err, ...args2) => {
          if (err === false)
            return taskCb(err);
          if (args2.length < 2) {
            [result] = args2;
          } else {
            result = args2;
          }
          error = err;
          taskCb(err ? null : {});
        });
      }, () => callback(error, result));
    }
    var tryEach$1 = awaitify(tryEach);
    function unmemoize(fn) {
      return (...args2) => {
        return (fn.unmemoized || fn)(...args2);
      };
    }
    function whilst(test, iteratee, callback) {
      callback = onlyOnce(callback);
      var _fn = wrapAsync(iteratee);
      var _test = wrapAsync(test);
      var results = [];
      function next(err, ...rest) {
        if (err)
          return callback(err);
        results = rest;
        if (err === false)
          return;
        _test(check);
      }
      function check(err, truth) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        if (!truth)
          return callback(null, ...results);
        _fn(next);
      }
      return _test(check);
    }
    var whilst$1 = awaitify(whilst, 3);
    function until(test, iteratee, callback) {
      const _test = wrapAsync(test);
      return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
    }
    function waterfall(tasks, callback) {
      callback = once(callback);
      if (!Array.isArray(tasks))
        return callback(new Error("First argument to waterfall must be an array of functions"));
      if (!tasks.length)
        return callback();
      var taskIndex = 0;
      function nextTask(args2) {
        var task = wrapAsync(tasks[taskIndex++]);
        task(...args2, onlyOnce(next));
      }
      function next(err, ...args2) {
        if (err === false)
          return;
        if (err || taskIndex === tasks.length) {
          return callback(err, ...args2);
        }
        nextTask(args2);
      }
      nextTask([]);
    }
    var waterfall$1 = awaitify(waterfall);
    var index = {
      apply,
      applyEach,
      applyEachSeries,
      asyncify,
      auto,
      autoInject,
      cargo: cargo$1,
      cargoQueue: cargo,
      compose,
      concat: concat$1,
      concatLimit: concatLimit$1,
      concatSeries: concatSeries$1,
      constant: constant$1,
      detect: detect$1,
      detectLimit: detectLimit$1,
      detectSeries: detectSeries$1,
      dir,
      doUntil,
      doWhilst: doWhilst$1,
      each,
      eachLimit: eachLimit$1,
      eachOf: eachOf$1,
      eachOfLimit: eachOfLimit$1,
      eachOfSeries: eachOfSeries$1,
      eachSeries: eachSeries$1,
      ensureAsync,
      every: every$1,
      everyLimit: everyLimit$1,
      everySeries: everySeries$1,
      filter: filter$1,
      filterLimit: filterLimit$1,
      filterSeries: filterSeries$1,
      forever: forever$1,
      groupBy,
      groupByLimit: groupByLimit$1,
      groupBySeries,
      log,
      map: map$1,
      mapLimit: mapLimit$1,
      mapSeries: mapSeries$1,
      mapValues,
      mapValuesLimit: mapValuesLimit$1,
      mapValuesSeries,
      memoize,
      nextTick,
      parallel,
      parallelLimit,
      priorityQueue,
      queue,
      race: race$1,
      reduce: reduce$1,
      reduceRight,
      reflect,
      reflectAll,
      reject: reject$1,
      rejectLimit: rejectLimit$1,
      rejectSeries: rejectSeries$1,
      retry,
      retryable,
      seq,
      series,
      setImmediate: setImmediate$1,
      some: some$1,
      someLimit: someLimit$1,
      someSeries: someSeries$1,
      sortBy: sortBy$1,
      timeout,
      times,
      timesLimit,
      timesSeries,
      transform,
      tryEach: tryEach$1,
      unmemoize,
      until,
      waterfall: waterfall$1,
      whilst: whilst$1,
      all: every$1,
      allLimit: everyLimit$1,
      allSeries: everySeries$1,
      any: some$1,
      anyLimit: someLimit$1,
      anySeries: someSeries$1,
      find: detect$1,
      findLimit: detectLimit$1,
      findSeries: detectSeries$1,
      flatMap: concat$1,
      flatMapLimit: concatLimit$1,
      flatMapSeries: concatSeries$1,
      forEach: each,
      forEachSeries: eachSeries$1,
      forEachLimit: eachLimit$1,
      forEachOf: eachOf$1,
      forEachOfSeries: eachOfSeries$1,
      forEachOfLimit: eachOfLimit$1,
      inject: reduce$1,
      foldl: reduce$1,
      foldr: reduceRight,
      select: filter$1,
      selectLimit: filterLimit$1,
      selectSeries: filterSeries$1,
      wrapSync: asyncify,
      during: whilst$1,
      doDuring: doWhilst$1
    };
    exports3.all = every$1;
    exports3.allLimit = everyLimit$1;
    exports3.allSeries = everySeries$1;
    exports3.any = some$1;
    exports3.anyLimit = someLimit$1;
    exports3.anySeries = someSeries$1;
    exports3.apply = apply;
    exports3.applyEach = applyEach;
    exports3.applyEachSeries = applyEachSeries;
    exports3.asyncify = asyncify;
    exports3.auto = auto;
    exports3.autoInject = autoInject;
    exports3.cargo = cargo$1;
    exports3.cargoQueue = cargo;
    exports3.compose = compose;
    exports3.concat = concat$1;
    exports3.concatLimit = concatLimit$1;
    exports3.concatSeries = concatSeries$1;
    exports3.constant = constant$1;
    exports3.default = index;
    exports3.detect = detect$1;
    exports3.detectLimit = detectLimit$1;
    exports3.detectSeries = detectSeries$1;
    exports3.dir = dir;
    exports3.doDuring = doWhilst$1;
    exports3.doUntil = doUntil;
    exports3.doWhilst = doWhilst$1;
    exports3.during = whilst$1;
    exports3.each = each;
    exports3.eachLimit = eachLimit$1;
    exports3.eachOf = eachOf$1;
    exports3.eachOfLimit = eachOfLimit$1;
    exports3.eachOfSeries = eachOfSeries$1;
    exports3.eachSeries = eachSeries$1;
    exports3.ensureAsync = ensureAsync;
    exports3.every = every$1;
    exports3.everyLimit = everyLimit$1;
    exports3.everySeries = everySeries$1;
    exports3.filter = filter$1;
    exports3.filterLimit = filterLimit$1;
    exports3.filterSeries = filterSeries$1;
    exports3.find = detect$1;
    exports3.findLimit = detectLimit$1;
    exports3.findSeries = detectSeries$1;
    exports3.flatMap = concat$1;
    exports3.flatMapLimit = concatLimit$1;
    exports3.flatMapSeries = concatSeries$1;
    exports3.foldl = reduce$1;
    exports3.foldr = reduceRight;
    exports3.forEach = each;
    exports3.forEachLimit = eachLimit$1;
    exports3.forEachOf = eachOf$1;
    exports3.forEachOfLimit = eachOfLimit$1;
    exports3.forEachOfSeries = eachOfSeries$1;
    exports3.forEachSeries = eachSeries$1;
    exports3.forever = forever$1;
    exports3.groupBy = groupBy;
    exports3.groupByLimit = groupByLimit$1;
    exports3.groupBySeries = groupBySeries;
    exports3.inject = reduce$1;
    exports3.log = log;
    exports3.map = map$1;
    exports3.mapLimit = mapLimit$1;
    exports3.mapSeries = mapSeries$1;
    exports3.mapValues = mapValues;
    exports3.mapValuesLimit = mapValuesLimit$1;
    exports3.mapValuesSeries = mapValuesSeries;
    exports3.memoize = memoize;
    exports3.nextTick = nextTick;
    exports3.parallel = parallel;
    exports3.parallelLimit = parallelLimit;
    exports3.priorityQueue = priorityQueue;
    exports3.queue = queue;
    exports3.race = race$1;
    exports3.reduce = reduce$1;
    exports3.reduceRight = reduceRight;
    exports3.reflect = reflect;
    exports3.reflectAll = reflectAll;
    exports3.reject = reject$1;
    exports3.rejectLimit = rejectLimit$1;
    exports3.rejectSeries = rejectSeries$1;
    exports3.retry = retry;
    exports3.retryable = retryable;
    exports3.select = filter$1;
    exports3.selectLimit = filterLimit$1;
    exports3.selectSeries = filterSeries$1;
    exports3.seq = seq;
    exports3.series = series;
    exports3.setImmediate = setImmediate$1;
    exports3.some = some$1;
    exports3.someLimit = someLimit$1;
    exports3.someSeries = someSeries$1;
    exports3.sortBy = sortBy$1;
    exports3.timeout = timeout;
    exports3.times = times;
    exports3.timesLimit = timesLimit;
    exports3.timesSeries = timesSeries;
    exports3.transform = transform;
    exports3.tryEach = tryEach$1;
    exports3.unmemoize = unmemoize;
    exports3.until = until;
    exports3.waterfall = waterfall$1;
    exports3.whilst = whilst$1;
    exports3.wrapSync = asyncify;
    Object.defineProperty(exports3, "__esModule", { value: true });
  });
});

// ../../node_modules/pm2-sysmonit/src/MeanCalc.js
var require_MeanCalc = __commonJS((exports2, module2) => {
  class MeanCalc {
    constructor(count) {
      this.metrics = [];
      this.count = count;
    }
    inspect() {
      return this.val();
    }
    add(value) {
      if (this.metrics.length >= this.count) {
        this.metrics.shift();
      }
      this.metrics.push(value);
    }
    val() {
      if (this.metrics.length == 0)
        return 0;
      let sum = this.metrics.reduce((prev, curr) => curr += prev);
      return Math.floor(sum / this.metrics.length * 1000) / 1000;
    }
  }
  module2.exports = MeanCalc;
});

// ../../node_modules/pm2-sysmonit/src/SystemInfos.js
var require_SystemInfos = __commonJS((exports2, module2) => {
  var sysinfo = require_lib5();
  var psList = require_psList();
  var async = require_async();
  var MeanCalc = require_MeanCalc();
  var DEFAULT_CONVERSION = 1024 * 1024;
  var os = __require("os");
  var fs = __require("fs");
  var debug = require_src()("pm2:sysinfos");

  class SystemInfo {
    constructor() {
      this.infos = {
        baseboard: {
          model: null,
          version: null
        },
        cpu: {
          manufacturer: null,
          brand: null,
          speedmax: null,
          cores: null,
          physicalCores: null,
          processors: null,
          temperature: null,
          load: null,
          loads: null
        },
        graphics: {
          model: null,
          driverVersion: null,
          memTotal: null,
          memUsed: null,
          temperature: null
        },
        mem: {
          total: null,
          free: null,
          active: null,
          usage: null
        },
        os: {
          platform: null,
          distro: null,
          release: null,
          codename: null,
          kernel: null,
          arch: null
        },
        fd: {
          opened: null,
          max: null
        },
        storage: {
          io: {
            read: new MeanCalc(15),
            write: new MeanCalc(15)
          },
          physical_disks: [{
            device: null,
            type: null,
            name: null,
            interfaceType: null,
            vendor: null
          }],
          filesystems: [{}]
        },
        connections: ["source_ip:source_port-dest_ip:dest_port-proc_name"],
        default_interface: null,
        network: {},
        containers: [],
        processes: {
          cpu_sorted: null,
          mem_sorted: null
        },
        services: {
          running: null,
          stopped: null
        }
      };
    }
    report() {
      var report = JSON.parse(JSON.stringify(this.infos));
      Object.keys(report.network).forEach((iname) => {
        report.network[iname] = {
          ip4: this.infos.network[iname].ip4,
          ip6: this.infos.network[iname].ip6,
          tx_5: this.infos.network[iname].tx_5.val(),
          rx_5: this.infos.network[iname].rx_5.val(),
          rx_errors_60: this.infos.network[iname].rx_errors_60.val(),
          tx_errors_60: this.infos.network[iname].tx_errors_60.val(),
          rx_dropped_60: this.infos.network[iname].rx_dropped_60.val(),
          tx_dropped_60: this.infos.network[iname].tx_dropped_60.val()
        };
      });
      report.storage.io.read = this.infos.storage.io.read.val();
      report.storage.io.write = this.infos.storage.io.write.val();
      return report;
    }
    query(cb) {
      if (this.process.connected == true) {
        try {
          this.process.send("query");
        } catch (e) {
          return cb(new Error("not ready yet"), null);
        }
      } else
        return cb(new Error("not ready yet"), null);
      var res = (msg) => {
        try {
          msg = JSON.parse(msg);
        } catch (e) {
        }
        if (msg.cmd == "query:res") {
          listener.removeListener("message", res);
          return cb(null, msg.data);
        }
      };
      var listener = this.process.on("message", res);
    }
    startCollection() {
      this.staticInformations();
      var dockerCollection, processCollection, memCollection, servicesCollection, graphicsCollection;
      (dockerCollection = () => {
        this.dockerSummary(() => {
          setTimeout(dockerCollection.bind(this), 5000);
        });
      })();
      (processCollection = () => {
        this.processesSummary(() => {
          setTimeout(processCollection.bind(this), 5000);
        });
      })();
      (graphicsCollection = () => {
        this.graphicsInformations(() => {
          setTimeout(graphicsCollection.bind(this), 20000);
        });
      })();
      (servicesCollection = () => {
        this.servicesSummary(() => {
          setTimeout(servicesCollection.bind(this), 60000);
        });
      })();
      (memCollection = () => {
        this.memStats(() => {
          setTimeout(memCollection.bind(this), 1000);
        });
      })();
      this.disksStatsWorker();
      this.networkStatsWorker();
      this.cpuStatsWorker();
      this.fdStatsWorker();
      process.on("message", (cmd) => {
        if (cmd == "query") {
          try {
            var res = JSON.stringify({
              cmd: "query:res",
              data: this.report()
            });
            process.send(res);
          } catch (e) {
            console.error("Could not retrieve system informations", e);
          }
        } else if (cmd == "pong") {
          clearTimeout(this.ping_timeout);
        }
      });
    }
    staticInformations() {
      var getCPU = () => {
        return sysinfo.cpu().then((data) => {
          this.infos.cpu = {
            brand: data.manufacturer,
            model: data.brand,
            speed: data.speedmax,
            cores: data.cores,
            physicalCores: data.physicalCores
          };
        });
      };
      var getBaseboard = () => {
        return sysinfo.system().then((data) => {
          this.infos.baseboard = {
            manufacturer: data.manufacturer,
            model: data.model,
            version: data.version
          };
        });
      };
      var getDefaultNetInterface = () => {
        return sysinfo.networkInterfaceDefault().then((iface) => {
          this.infos.default_interface = iface;
        });
      };
      var getOsInfo = () => {
        return sysinfo.osInfo().then((data) => {
          this.infos.os = {
            platform: data.platform,
            distro: data.distro,
            release: data.release,
            codename: data.codename,
            kernel: data.kernel,
            arch: data.arch
          };
        });
      };
      var diskLayout = () => {
        this.infos.storage.physical_disks = [];
        return sysinfo.diskLayout().then((disks) => {
          disks.forEach((disk) => {
            this.infos.storage.physical_disks.push({
              device: disk.device,
              type: disk.type,
              name: disk.name,
              interfaceType: disk.interfaceType,
              vendor: disk.vendor
            });
          });
        });
      };
      getBaseboard().then(getCPU).then(getOsInfo).then(diskLayout).then(getDefaultNetInterface).catch((e) => {
        debug(`Error when trying to retrieve static informations`, e);
      });
    }
    dockerSummary(cb = () => {
    }) {
      sysinfo.dockerContainers("all").then((containers) => {
        var non_exited_containers = containers.filter((container) => container.state != "exited");
        var new_containers = [];
        async.forEach(non_exited_containers, (container, next) => {
          sysinfo.dockerContainerStats(container.id).then((stats) => {
            var meta2 = container;
            stats[0].cpu_percent = stats[0].cpu_percent.toFixed(1);
            stats[0].mem_percent = stats[0].mem_percent.toFixed(1);
            stats[0].netIO.tx = (stats[0].netIO.tx / DEFAULT_CONVERSION).toFixed(1);
            stats[0].netIO.rx = (stats[0].netIO.rx / DEFAULT_CONVERSION).toFixed(1);
            stats[0].blockIO.w = (stats[0].blockIO.w / DEFAULT_CONVERSION).toFixed(1);
            stats[0].blockIO.r = (stats[0].blockIO.r / DEFAULT_CONVERSION).toFixed(1);
            meta2.stats = Array.isArray(stats) == true ? stats[0] : null;
            new_containers.push(meta2);
            next();
          }).catch((e) => {
            debug(e);
            next();
          });
        }, (err) => {
          if (err)
            debug(err);
          this.infos.containers = new_containers.sort((a, b) => {
            var textA = a.name.toUpperCase();
            var textB = b.name.toUpperCase();
            return textA < textB ? -1 : textA > textB ? 1 : 0;
          });
          return cb();
        });
      }).catch((e) => {
        debug(e);
        return cb();
      });
    }
    servicesSummary() {
      sysinfo.services("*").then((services) => {
        this.infos.services.running = services.filter((service) => service.running === true);
        this.infos.services.stopped = services.filter((service) => service.running === false);
      }).catch((e) => {
        debug(e);
      });
    }
    processesSummary(cb) {
      psList().then((processes) => {
        this.infos.processes.cpu_sorted = processes.filter((a) => !(a.cmd.includes("SystemInfo") && a.cmd.includes("PM2"))).sort((a, b) => b.cpu - a.cpu).slice(0, 5);
        this.infos.processes.mem_sorted = processes.filter((a) => !(a.cmd.includes("SystemInfo") && a.cmd.includes("PM2"))).sort((a, b) => b.memory - a.memory).slice(0, 5);
        return cb();
      }).catch((e) => {
        console.error(`Error when retrieving process list`, e);
        return cb();
      });
    }
    graphicsInformations(cb) {
      sysinfo.graphics().then((data) => {
        if (!data)
          return cb();
        let cg1 = data.controllers[0];
        if (!cg1)
          return cb();
        this.infos.graphics = {
          model: cg1.model,
          driverVersion: cg1.driverVersion,
          memTotal: cg1.memoryTotal,
          memUsed: cg1.memoryUsed,
          temperature: cg1.temperatureGpu
        };
        return cb();
      }).catch((e) => {
        console.error(`Error while retrieving graphics informations`);
        console.error(e);
        return cb();
      });
    }
    cpuStatsWorker() {
      var cpuTempCollection, cpuLoad;
      (cpuTempCollection = () => {
        sysinfo.cpuTemperature().then((data) => {
          this.infos.cpu.temperature = data.main.toFixed(1);
          setTimeout(cpuTempCollection.bind(this), 5000);
        }).catch((e) => {
          setTimeout(cpuTempCollection.bind(this), 5000);
        });
      })();
      (cpuLoad = () => {
        sysinfo.currentLoad().then((data) => {
          this.infos.cpu.load = data.currentLoad.toFixed(1);
          this.infos.cpu.loads = data.cpus.map((cpu) => Math.floor(cpu.load)).join("|");
          setTimeout(cpuLoad.bind(this), 1000);
        }).catch((e) => {
          setTimeout(cpuLoad.bind(this), 1000);
        });
      })();
    }
    memStats(cb) {
      sysinfo.mem().then((data) => {
        this.infos.mem.total = (data.total / DEFAULT_CONVERSION / 1024).toFixed(2);
        this.infos.mem.free = (data.free / DEFAULT_CONVERSION / 1024).toFixed(2);
        this.infos.mem.active = (data.active / DEFAULT_CONVERSION / 1024).toFixed(2);
        this.infos.mem.available = (data.available / DEFAULT_CONVERSION / 1024).toFixed(2);
        this.infos.mem.usage = (data.active / data.total * 100).toFixed(1);
        return cb();
      }).catch((e) => {
        console.error(`Error while retrieving memory info`);
        console.error(e);
        return cb();
      });
    }
    networkConnectionsWorker() {
      var retrieveConn;
      (retrieveConn = () => {
        sysinfo.networkConnections().then((conns) => {
          this.infos.connections = conns.filter((conn) => conn.localport != "443" && conn.peerport != "443").map((conn) => `${conn.localaddress}:${conn.localport}-${conn.peeraddress}:${conn.peerport}-${conn.proc ? conn.proc : "unknown"}`);
          setTimeout(retrieveConn.bind(this), 10 * 1000);
        }).catch((e) => {
          console.error(`Error while retrieving filesystems info`);
          console.error(e);
          setTimeout(retrieveConn.bind(this), 10 * 1000);
        });
      })();
    }
    disksStatsWorker() {
      var rx = 0;
      var wx = 0;
      var started = false;
      var fsSizeCollection, ioCollection;
      (fsSizeCollection = () => {
        sysinfo.fsSize().then((fss) => {
          var fse = fss.filter((fs2) => fs2.size / (1024 * 1024) > 800 && fs2.mount != "/boot" && !fs2.mount.includes("efi"));
          this.infos.storage.filesystems = fse;
          setTimeout(fsSizeCollection.bind(this), 30 * 1000);
        }).catch((e) => {
          console.error(`Error while retrieving filesystem infos (FSSIZE)`, e);
          setTimeout(fsSizeCollection.bind(this), 10 * 1000);
        });
      })();
      (ioCollection = () => {
        sysinfo.fsStats().then((fs_stats) => {
          var new_rx = fs_stats.rx;
          var new_wx = fs_stats.wx;
          var read = ((new_rx - rx) / DEFAULT_CONVERSION).toFixed(3);
          var write4 = ((new_wx - wx) / DEFAULT_CONVERSION).toFixed(3);
          if (started == true) {
            this.infos.storage.io.read.add(parseFloat(read));
            this.infos.storage.io.write.add(parseFloat(write4));
          }
          rx = new_rx;
          wx = new_wx;
          started = true;
          setTimeout(ioCollection.bind(this), 1000);
        }).catch((e) => {
          console.error(`Error while getting network statistics`, e);
          setTimeout(ioCollection.bind(this), 1000);
        });
      })();
    }
    fdStatsWorker() {
      var getFDOpened = () => {
        sysinfo.fsOpenFiles().then((open_files) => {
          this.infos.fd.opened = open_files.allocated;
          this.infos.fd.max = open_files.max;
        }).catch((e) => {
          console.error(`Could not retrieve fds`);
          console.error(e);
        });
      };
      setInterval(() => {
        getFDOpened();
      }, 5000);
      getFDOpened();
    }
    networkStatsWorker() {
      var latencyCollection, networkStatsCollection;
      var self2 = this;
      function grabStats(inter) {
        let started = false;
        let rx = 0;
        let tx = 0;
        let rx_e = 0;
        let tx_e = 0;
        let rx_d = 0;
        let tx_d = 0;
        let net_interface = inter.iface;
        function networkStatsCollection2(net_interface2) {
          self2.infos.network[net_interface2] = {
            ip4: inter.ip4,
            ip6: inter.ip6,
            latency: new MeanCalc(5),
            tx_5: new MeanCalc(5),
            rx_5: new MeanCalc(5),
            rx_errors_60: new MeanCalc(60),
            tx_errors_60: new MeanCalc(60),
            tx_dropped_60: new MeanCalc(60),
            rx_dropped_60: new MeanCalc(60)
          };
          sysinfo.networkStats(net_interface2).then((net) => {
            let new_rx = (net[0].rx_bytes - rx) / DEFAULT_CONVERSION;
            let new_tx = (net[0].tx_bytes - tx) / DEFAULT_CONVERSION;
            rx = net[0].rx_bytes;
            tx = net[0].tx_bytes;
            let new_rx_e = (net[0].rx_errors - rx_e) / DEFAULT_CONVERSION;
            let new_tx_e = (net[0].tx_errors - tx_e) / DEFAULT_CONVERSION;
            rx_e = net[0].rx_errors;
            tx_e = net[0].tx_errors;
            let new_rx_d = (net[0].rx_dropped - rx_d) / DEFAULT_CONVERSION;
            let new_tx_d = (net[0].tx_dropped - tx_d) / DEFAULT_CONVERSION;
            rx_d = net[0].rx_dropped;
            tx_d = net[0].tx_dropped;
            if (started == true) {
              self2.infos.network[net_interface2].rx_5.add(new_rx);
              self2.infos.network[net_interface2].tx_5.add(new_tx);
              self2.infos.network[net_interface2].rx_errors_60.add(new_rx_e);
              self2.infos.network[net_interface2].tx_errors_60.add(new_tx_e);
              self2.infos.network[net_interface2].rx_dropped_60.add(new_rx_d);
              self2.infos.network[net_interface2].tx_dropped_60.add(new_tx_d);
            }
            started = true;
            setTimeout(() => {
              networkStatsCollection2(net_interface2);
            }, 1000);
          }).catch((e) => {
            console.error(`Error on retrieving network stats`, e);
            setTimeout(() => {
              networkStatsCollection2(net_interface2);
            }, 1000);
          });
        }
        networkStatsCollection2(net_interface);
      }
      sysinfo.networkInterfaces().then((interfaces) => {
        interfaces.forEach((inter) => {
          if (inter.ip4 == "127.0.0.1")
            return;
          grabStats(inter);
        });
      }).catch((e) => {
        console.error(`Cannot retrieve interfaces`);
        console.error(e);
      });
    }
  }
  module2.exports = SystemInfo;
  if (__require.main === module2) {
    sys = new SystemInfo;
    sys.startCollection();
    setInterval(() => {
      console.log(JSON.stringify(sys.report(), null, 2));
    }, 5000);
  }
  var sys;
});

// ../../node_modules/pm2-sysmonit/node_modules/pidusage/lib/bin.js
var require_bin2 = __commonJS((exports2, module2) => {
  var run2 = function(cmd, args2, options2, done) {
    if (typeof options2 === "function") {
      done = options2;
      options2 = undefined;
    }
    var executed = false;
    var ch = spawn(cmd, args2, options2);
    var stdout = "";
    var stderr = "";
    ch.stdout.on("data", function(d) {
      stdout += d.toString();
    });
    ch.stderr.on("data", function(d) {
      stderr += d.toString();
    });
    ch.on("error", function(err) {
      if (executed)
        return;
      executed = true;
      done(new Error(err));
    });
    ch.on("close", function(code, signal) {
      if (executed)
        return;
      executed = true;
      if (stderr) {
        return done(new Error(stderr));
      }
      done(null, stdout, code);
    });
  };
  var spawn = __require("child_process").spawn;
  module2.exports = run2;
});

// ../../node_modules/pm2-sysmonit/node_modules/pidusage/lib/history.js
var require_history2 = __commonJS((exports2, module2) => {
  var get = function(pid, maxage) {
    if (maxage <= 0) {
      return;
    }
    if (history[pid] !== undefined) {
      expiration[pid] = Date.now() + (maxage || DEFAULT_MAXAGE);
    }
    return history[pid];
  };
  var set = function(pid, object, maxage, onExpire) {
    if (object === undefined || maxage <= 0)
      return;
    expiration[pid] = Date.now() + (maxage || DEFAULT_MAXAGE);
    if (history[pid] === undefined) {
      size2++;
      sheduleInvalidator(maxage);
    }
    history[pid] = object;
    if (onExpire) {
      expireListeners[pid] = onExpire;
    }
  };
  var sheduleInvalidator = function(maxage) {
    if (size2 > 0) {
      if (interval === null) {
        interval = setInterval(runInvalidator, (maxage || DEFAULT_MAXAGE) / 2);
        if (typeof interval.unref === "function") {
          interval.unref();
        }
      }
      return;
    }
    if (interval !== null) {
      clearInterval(interval);
      interval = null;
    }
  };
  var runInvalidator = function() {
    var now = Date.now();
    var pids = Object.keys(expiration);
    for (var i = 0;i < pids.length; i++) {
      var pid = pids[i];
      if (expiration[pid] < now) {
        size2--;
        if (expireListeners[pid]) {
          expireListeners[pid](history[pid]);
        }
        delete history[pid];
        delete expiration[pid];
        delete expireListeners[pid];
      }
    }
    sheduleInvalidator();
  };
  var deleteLoop = function(obj) {
    for (const i in obj) {
      delete obj[i];
    }
  };
  var clear = function() {
    if (interval !== null) {
      clearInterval(interval);
      interval = null;
    }
    deleteLoop(history);
    deleteLoop(expiration);
    deleteLoop(expireListeners);
  };
  var DEFAULT_MAXAGE = 60000;
  var expiration = {};
  var history = {};
  var expireListeners = {};
  var size2 = 0;
  var interval = null;
  module2.exports = {
    get,
    set,
    clear
  };
});

// ../../node_modules/pm2-sysmonit/node_modules/pidusage/lib/ps.js
var require_ps2 = __commonJS((exports2, module2) => {
  var parseTime = function(timestr, centisec) {
    var time = 0;
    var tpart = timestr.split(/-|:|\./);
    var i = tpart.length - 1;
    if (i >= 0 && centisec && PLATFORM === "darwin") {
      time += parseInt(tpart[i--], 10) * 10;
    }
    if (i >= 0) {
      time += parseInt(tpart[i--], 10) * 1000;
    }
    if (i >= 0) {
      time += parseInt(tpart[i--], 10) * 60000;
    }
    if (i >= 0) {
      time += parseInt(tpart[i--], 10) * 3600000;
    }
    if (i >= 0) {
      time += parseInt(tpart[i--], 10) * 86400000;
    }
    return time;
  };
  var ps = function(pids, options2, done) {
    var pArg = pids.join(",");
    var args2 = ["-o", "etime,pid,ppid,pcpu,rss,time", "-p", pArg];
    if (PLATFORM === "aix") {
      args2 = ["-o", "etime,pid,ppid,pcpu,rssize,time", "-p", pArg];
    }
    bin("ps", args2, function(err, stdout, code) {
      if (err)
        return done(err);
      if (code === 1) {
        const error = new Error("No matching pid found");
        error.code = "ENOENT";
        return done(error);
      }
      if (code !== 0) {
        return done(new Error("pidusage ps command exited with code " + code));
      }
      var date = Date.now();
      stdout = stdout.split(os.EOL);
      var statistics = {};
      for (var i = 1;i < stdout.length; i++) {
        var line = stdout[i].trim().split(/\s+/);
        if (!line || line.length !== 6) {
          continue;
        }
        var pid = parseInt(line[1], 10);
        var hst = history.get(pid, options2.maxage);
        if (hst === undefined)
          hst = {};
        var ppid = parseInt(line[2], 10);
        var memory = parseInt(line[4], 10) * 1024;
        var etime = parseTime(line[0]);
        var ctime = parseTime(line[5], true);
        var total = ctime - (hst.ctime || 0);
        var seconds = Math.abs(hst.elapsed !== undefined ? etime - hst.elapsed : etime);
        var cpu = seconds > 0 ? total / seconds * 100 : 0;
        statistics[pid] = {
          cpu,
          memory,
          ppid,
          pid,
          ctime,
          elapsed: etime,
          timestamp: date
        };
        history.set(pid, statistics[pid], options2.maxage);
      }
      done(null, statistics);
    });
  };
  var os = __require("os");
  var bin = require_bin2();
  var history = require_history2();
  var PLATFORM = os.platform();
  module2.exports = ps;
});

// ../../node_modules/pm2-sysmonit/node_modules/pidusage/lib/stats.js
var require_stats2 = __commonJS((exports2, module2) => {
  var get = function(pids, options2, callback) {
    var fn = stat;
    if (platform !== "win" && options2.usePs === true) {
      fn = ps;
    }
    if (stat === undefined) {
      return callback(new Error(os.platform() + " is not supported yet, please open an issue (https://github.com/soyuka/pidusage)"));
    }
    var single = false;
    if (!Array.isArray(pids)) {
      single = true;
      pids = [pids];
    }
    if (pids.length === 0) {
      return callback(new TypeError("You must provide at least one pid"));
    }
    for (var i = 0;i < pids.length; i++) {
      pids[i] = parseInt(pids[i], 10);
      if (isNaN(pids[i]) || pids[i] < 0) {
        return callback(new TypeError("One of the pids provided is invalid"));
      }
    }
    fn(pids, options2, function(err, stats) {
      if (err) {
        return callback(err);
      }
      if (single) {
        callback(null, stats[pids[0]]);
      } else {
        callback(null, stats);
      }
    });
  };
  var fs = __require("fs");
  var os = __require("os");
  var platformToMethod = {
    aix: "ps",
    android: "procfile",
    alpine: "procfile",
    darwin: "ps",
    freebsd: "ps",
    linux: "procfile",
    netbsd: "procfile",
    sunos: "ps",
    win: "wmic"
  };
  var ps = require_ps2();
  var platform = os.platform();
  if (fs.existsSync("/etc/alpine-release")) {
    platform = "alpine";
  }
  if (platform.match(/^win/)) {
    platform = "win";
  }
  var stat;
  try {
    stat = __require("./" + platformToMethod[platform]);
  } catch (err) {
  }
  module2.exports = get;
});

// ../../node_modules/pm2-sysmonit/node_modules/pidusage/index.js
var require_pidusage2 = __commonJS((exports2, module2) => {
  var pidusage = function(pids, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    if (options2 === undefined) {
      options2 = {};
    }
    if (typeof callback === "function") {
      stats(pids, options2, callback);
      return;
    }
    return new Promise(function(resolve, reject) {
      stats(pids, options2, function(err, data) {
        if (err)
          return reject(err);
        resolve(data);
      });
    });
  };
  var stats = require_stats2();
  module2.exports = pidusage;
  module2.exports.clear = require_history2().clear;
});

// ../../node_modules/pm2-sysmonit/src/pm2.js
var require_pm2 = __commonJS((exports2, module2) => {
  var fs = __require("fs");
  var path2 = __require("path");
  var pidusage = require_pidusage2();

  class PM2Monitoring {
    constructor() {
      this.pm2_monitoring = { cpu: 0, mem: 0 };
      this.pm2_agent_monitoring = { cpu: 0, mem: 0 };
    }
    startCollection() {
      setInterval(() => {
        this.monitorPM2Agent();
        this.monitorPM2();
      }, 900);
    }
    getDefaultPM2Home() {
      var PM2_ROOT_PATH;
      if (process.env.PM2_HOME)
        PM2_ROOT_PATH = process.env.PM2_HOME;
      else if (process.env.HOME && !process.env.HOMEPATH)
        PM2_ROOT_PATH = path2.resolve(process.env.HOME, ".pm2");
      else if (process.env.HOME || process.env.HOMEPATH)
        PM2_ROOT_PATH = path2.resolve(process.env.HOMEDRIVE, process.env.HOME || process.env.HOMEPATH, ".pm2");
      else {
        console.error("[PM2][Initialization] Environment variable HOME (Linux) or HOMEPATH (Windows) are not set!");
        console.error("[PM2][Initialization] Defaulting to /etc/.pm2");
        PM2_ROOT_PATH = path2.resolve("/etc", ".pm2");
      }
      return PM2_ROOT_PATH;
    }
    report() {
      return {
        pm2: this.pm2_monitoring,
        agent: this.pm2_agent_monitoring
      };
    }
    monitorPM2() {
      let pm2_pid_file = path2.join(this.getDefaultPM2Home(), "pm2.pid");
      fs.readFile(pm2_pid_file, (err, pm2_pid) => {
        if (err)
          return console.error(`Could not read ${pm2_pid_file}`);
        if (!pm2_pid)
          return console.error(`PID is null`);
        pm2_pid = parseInt(pm2_pid);
        pidusage(pm2_pid, (err2, stats) => {
          if (err2)
            return console.error(err2);
          this.pm2_monitoring = {
            cpu: stats.cpu.toFixed(1),
            mem: (stats.memory / 1024 / 1024).toFixed(1)
          };
        });
      });
    }
    monitorPM2Agent() {
      let pm2_agent_pid_file = path2.join(this.getDefaultPM2Home(), "agent.pid");
      fs.readFile(pm2_agent_pid_file, (err, pm2_agent_pid) => {
        if (err)
          return;
        if (!pm2_agent_pid)
          return;
        pidusage(pm2_agent_pid, (err2, stats) => {
          if (err2)
            return;
          this.pm2_agent_monitoring = {
            cpu: stats.cpu.toFixed(1),
            mem: (stats.memory / 1024 / 1024).toFixed(1)
          };
        });
      });
    }
  }
  module2.exports = PM2Monitoring;
});

// ../../node_modules/pm2-sysmonit/index.js
var require_pm2_sysmonit = __commonJS((exports2, module2) => {
  var tx2 = require_tx2();
  var SystemInfos = require_SystemInfos();
  var PM2Infos = require_pm2();

  class SysMonit {
    constructor() {
      this.sysinfos = new SystemInfos;
      this.report = {};
      this.pass = 0;
      this.pm2infos = new PM2Infos;
      this.pm2_report = {};
    }
    start() {
      this.sysinfos.startCollection();
      this.report = this.sysinfos.report();
      this.pm2infos.startCollection();
      this.pm2_report = this.pm2infos.report();
      this.bindActions();
      setInterval(() => {
        if (this.pass++ < 4)
          this.bindMetrics();
        this.report = this.sysinfos.report();
        this.pm2_report = this.pm2infos.report();
        this.processContinuousMetrics();
        if (process.env.VERBOSE) {
          console.log(JSON.stringify(this.report, "", 2));
          console.log(JSON.stringify(this.pm2_report, "", 2));
        }
      }, 1000);
    }
    bindActions() {
      tx2.action("info", (cb) => {
        cb(this.sysinfos.report());
      });
    }
    processContinuousMetrics() {
      let most_used_disk = this.report.storage.filesystems.reduce((p, v) => {
        return p.use < v.use ? p : v;
      });
      tx2.metric(`Disk Usage`, "%", () => most_used_disk.use);
      tx2.metric(`Disk Size`, "gb", () => (most_used_disk.size / 1024 / 1024 / 1024).toFixed(2));
      let tx5 = 0, rx5 = 0;
      Object.keys(this.report.network).forEach((iface) => {
        tx5 += this.report.network[iface].tx_5;
        rx5 += this.report.network[iface].rx_5;
      });
      tx2.metric(`Total TX`, "mb/s", () => tx5);
      tx2.metric(`Total RX`, "mb/s", () => rx5);
    }
    bindMetrics() {
      tx2.metric("PM2 CPU Usage", "%", () => this.pm2_report.pm2.cpu);
      tx2.metric("PM2 Memory Usage", "mb", () => this.pm2_report.pm2.mem);
      tx2.metric("PM2 Agent CPU Usage", "%", () => this.pm2_report.agent.cpu);
      tx2.metric("PM2 Agent Memory Usage", "mb", () => this.pm2_report.agent.mem);
      tx2.metric("CPU Usage", "%", () => this.report.cpu.load);
      tx2.metric("CPUs Usage", () => this.report.cpu.loads);
      tx2.metric("CPU Temperature", "\xB0C", () => this.report.cpu.temperature);
      tx2.metric("RAM Total", "gb", () => this.report.mem.total);
      tx2.metric("RAM Free", "gb", () => this.report.mem.free);
      tx2.metric("RAM Active", "gb", () => this.report.mem.active);
      tx2.metric("RAM Available", "gb", () => this.report.mem.available);
      tx2.metric("RAM Usage", "%", () => this.report.mem.usage);
      tx2.metric("FD Opened", () => this.report.fd.opened);
      tx2.metric("Disk Writes", "mb/s", () => this.report.storage.io.read);
      tx2.metric("Disk Reads", "mb/s", () => this.report.storage.io.write);
      this.report.storage.filesystems.forEach((fss, i) => {
        if (!fss.fs)
          return;
        tx2.metric(`fs:use:${fss.fs}`, "%", () => this.report.storage.filesystems[i].use);
        tx2.metric(`fs:size:${fss.fs}`, "gb", () => (this.report.storage.filesystems[i].size / 1024 / 1024 / 1024).toFixed(2));
      });
      Object.keys(this.report.network).forEach((iface) => {
        tx2.metric(`net:tx_5:${iface}`, "mb/s", () => this.report.network[iface].tx_5);
        tx2.metric(`net:rx_5:${iface}`, "mb/s", () => this.report.network[iface].rx_5);
        tx2.metric(`net:rx_errors_60:${iface}`, "/min", () => this.report.network[iface].rx_errors_60);
        tx2.metric(`net:tx_errors_60:${iface}`, "/min", () => this.report.network[iface].tx_errors_60);
        tx2.metric(`net:rx_dropped_60:${iface}`, "/min", () => this.report.network[iface].rx_dropped_60);
        tx2.metric(`net:tx_dropped_60:${iface}`, "/min", () => this.report.network[iface].tx_dropped_60);
      });
      if (this.report.graphics.memTotal) {
        tx2.metric("graphics:mem:total", "mb", () => this.report.graphics.memTotal);
        tx2.metric("graphics:mem:used", "mb", () => this.report.graphics.memUsed);
        tx2.metric("graphics:temp", "\xB0C", () => this.report.graphics.temperature);
      }
    }
  }
  if (__require.main === module2) {
    let sys = new SysMonit;
    sys.start();
  }
});

// ../../node_modules/pm2/lib/API/Log.js
var require_Log = __commonJS((exports2, module2) => {
  var pad = function(pad2, str, padLeft) {
    if (typeof str === "undefined")
      return pad2;
    if (padLeft) {
      return (pad2 + str).slice(-pad2.length);
    } else {
      return (str + pad2).substring(0, pad2.length);
    }
  };
  var fs = __require("fs");
  var util = __require("util");
  var chalk = require_source();
  var forEachLimit = require_forEachLimit();
  var dayjs = require_dayjs_min();
  var Log = module2.exports = {};
  var DEFAULT_PADDING = "          ";
  Log.tail = function(apps_list, lines, raw, callback) {
    var that = this;
    if (lines === 0 || apps_list.length === 0)
      return callback && callback();
    var count = 0;
    var getLastLines = function(filename, lines2, callback2) {
      var chunk = "";
      var size2 = Math.max(0, fs.statSync(filename).size - lines2 * 200);
      var fd = fs.createReadStream(filename, { start: size2 });
      fd.on("data", function(data) {
        chunk += data.toString();
      });
      fd.on("end", function() {
        chunk = chunk.split("\n").slice(-(lines2 + 1));
        chunk.pop();
        callback2(chunk);
      });
    };
    apps_list.sort(function(a, b) {
      return (fs.existsSync(a.path) ? fs.statSync(a.path).mtime.valueOf() : 0) - (fs.existsSync(b.path) ? fs.statSync(b.path).mtime.valueOf() : 0);
    });
    forEachLimit(apps_list, 1, function(app, next) {
      if (!fs.existsSync(app.path || ""))
        return next();
      getLastLines(app.path, lines, function(output) {
        console.log(chalk.grey("%s last %d lines:"), app.path, lines);
        output.forEach(function(out) {
          if (raw)
            return app.type === "err" ? console.error(out) : console.log(out);
          if (app.type === "out")
            process.stdout.write(chalk.green(pad(DEFAULT_PADDING, app.app_name) + " | "));
          else if (app.type === "err")
            process.stdout.write(chalk.red(pad(DEFAULT_PADDING, app.app_name) + " | "));
          else
            process.stdout.write(chalk.blue(pad(DEFAULT_PADDING, "PM2") + " | "));
          console.log(out);
        });
        if (output.length)
          process.stdout.write("\n");
        next();
      });
    }, function() {
      callback && callback();
    });
  };
  Log.stream = function(Client, id2, raw, timestamp, exclusive, highlight) {
    var that = this;
    Client.launchBus(function(err, bus, socket) {
      socket.on("reconnect attempt", function() {
        if (global._auto_exit === true) {
          if (timestamp)
            process.stdout.write(chalk["dim"](chalk.grey(dayjs().format(timestamp) + " ")));
          process.stdout.write(chalk.blue(pad(DEFAULT_PADDING, "PM2") + " | ") + "[[[ Target PM2 killed. ]]]");
          process.exit(0);
        }
      });
      var min_padding = 3;
      bus.on("log:*", function(type2, packet) {
        var isMatchingProcess = id2 === "all" || packet.process.name == id2 || packet.process.pm_id == id2 || packet.process.namespace == id2;
        if (!isMatchingProcess)
          return;
        if (type2 === "out" && exclusive === "err" || type2 === "err" && exclusive === "out" || type2 === "PM2" && exclusive !== false)
          return;
        var lines;
        if (typeof packet.data === "string")
          lines = (packet.data || "").split("\n");
        else
          return;
        lines.forEach(function(line) {
          if (!line || line.length === 0)
            return;
          if (raw)
            return type2 === "err" ? process.stderr.write(util.format(line) + "\n") : process.stdout.write(util.format(line) + "\n");
          if (timestamp)
            process.stdout.write(chalk["dim"](chalk.grey(dayjs().format(timestamp) + " ")));
          var name2 = packet.process.pm_id + "|" + packet.process.name;
          if (name2.length > min_padding)
            min_padding = name2.length + 1;
          if (type2 === "out")
            process.stdout.write(chalk.green(pad(" ".repeat(min_padding), name2) + " | "));
          else if (type2 === "err")
            process.stdout.write(chalk.red(pad(" ".repeat(min_padding), name2) + " | "));
          else if (!raw && (id2 === "all" || id2 === "PM2"))
            process.stdout.write(chalk.blue(pad(" ".repeat(min_padding), "PM2") + " | "));
          if (highlight)
            process.stdout.write(util.format(line).replace(highlight, chalk.bgBlackBright(highlight)) + "\n");
          else
            process.stdout.write(util.format(line) + "\n");
        });
      });
    });
  };
  Log.devStream = function(Client, id2, raw, timestamp, exclusive) {
    var that = this;
    Client.launchBus(function(err, bus) {
      setTimeout(function() {
        bus.on("process:event", function(packet) {
          if (packet.event == "online")
            console.log(chalk.green("[rundev] App %s restarted"), packet.process.name);
        });
      }, 1000);
      var min_padding = 3;
      bus.on("log:*", function(type2, packet) {
        if (id2 !== "all" && packet.process.name != id2 && packet.process.pm_id != id2)
          return;
        if (type2 === "out" && exclusive === "err" || type2 === "err" && exclusive === "out" || type2 === "PM2" && exclusive !== false)
          return;
        if (type2 === "PM2")
          return;
        var name2 = packet.process.pm_id + "|" + packet.process.name;
        var lines;
        if (typeof packet.data === "string")
          lines = (packet.data || "").split("\n");
        else
          return;
        lines.forEach(function(line) {
          if (!line || line.length === 0)
            return;
          if (raw)
            return process.stdout.write(util.format(line) + "\n");
          if (timestamp)
            process.stdout.write(chalk["dim"](chalk.grey(dayjs().format(timestamp) + " ")));
          var name3 = packet.process.name + "-" + packet.process.pm_id;
          if (name3.length > min_padding)
            min_padding = name3.length + 1;
          if (type2 === "out")
            process.stdout.write(chalk.green(pad(" ".repeat(min_padding), name3) + " | "));
          else if (type2 === "err")
            process.stdout.write(chalk.red(pad(" ".repeat(min_padding), name3) + " | "));
          else if (!raw && (id2 === "all" || id2 === "PM2"))
            process.stdout.write(chalk.blue(pad(" ".repeat(min_padding), "PM2") + " | "));
          process.stdout.write(util.format(line) + "\n");
        });
      });
    });
  };
  Log.jsonStream = function(Client, id2) {
    var that = this;
    Client.launchBus(function(err, bus) {
      if (err)
        console.error(err);
      bus.on("process:event", function(packet) {
        process.stdout.write(JSON.stringify({
          timestamp: dayjs(packet.at),
          type: "process_event",
          status: packet.event,
          app_name: packet.process.name
        }));
        process.stdout.write("\n");
      });
      bus.on("log:*", function(type2, packet) {
        if (id2 !== "all" && packet.process.name != id2 && packet.process.pm_id != id2)
          return;
        if (type2 === "PM2")
          return;
        if (typeof packet.data == "string")
          packet.data = packet.data.replace(/(\r\n|\n|\r)/gm, "");
        process.stdout.write(JSON.stringify({
          message: packet.data,
          timestamp: dayjs(packet.at),
          type: type2,
          process_id: packet.process.pm_id,
          app_name: packet.process.name
        }));
        process.stdout.write("\n");
      });
    });
  };
  Log.formatStream = function(Client, id2, raw, timestamp, exclusive, highlight) {
    var that = this;
    Client.launchBus(function(err, bus) {
      bus.on("log:*", function(type2, packet) {
        if (id2 !== "all" && packet.process.name != id2 && packet.process.pm_id != id2)
          return;
        if (type2 === "out" && exclusive === "err" || type2 === "err" && exclusive === "out" || type2 === "PM2" && exclusive !== false)
          return;
        if (type2 === "PM2" && raw)
          return;
        var name2 = packet.process.name + "-" + packet.process.pm_id;
        var lines;
        if (typeof packet.data === "string")
          lines = (packet.data || "").split("\n");
        else
          return;
        lines.forEach(function(line) {
          if (!line || line.length === 0)
            return;
          if (!raw) {
            if (timestamp)
              process.stdout.write("timestamp=" + dayjs().format(timestamp) + " ");
            if (packet.process.name === "PM2")
              process.stdout.write("app=pm2 ");
            if (packet.process.name !== "PM2")
              process.stdout.write("app=" + packet.process.name + " id=" + packet.process.pm_id + " ");
            if (type2 === "out")
              process.stdout.write("type=out ");
            else if (type2 === "err")
              process.stdout.write("type=error ");
          }
          process.stdout.write("message=");
          if (highlight)
            process.stdout.write(util.format(line).replace(highlight, chalk.bgBlackBright(highlight)) + "\n");
          else
            process.stdout.write(util.format(line) + "\n");
        });
      });
    });
  };
});

// ../../node_modules/ansi-colors/symbols.js
var require_symbols = __commonJS((exports2, module2) => {
  var isHyper = typeof process !== "undefined" && process.env.TERM_PROGRAM === "Hyper";
  var isWindows = typeof process !== "undefined" && process.platform === "win32";
  var isLinux = typeof process !== "undefined" && process.platform === "linux";
  var common2 = {
    ballotDisabled: "\u2612",
    ballotOff: "\u2610",
    ballotOn: "\u2611",
    bullet: "\u2022",
    bulletWhite: "\u25E6",
    fullBlock: "\u2588",
    heart: "\u2764",
    identicalTo: "\u2261",
    line: "\u2500",
    mark: "\u203B",
    middot: "\xB7",
    minus: "\uFF0D",
    multiplication: "\xD7",
    obelus: "\xF7",
    pencilDownRight: "\u270E",
    pencilRight: "\u270F",
    pencilUpRight: "\u2710",
    percent: "%",
    pilcrow2: "\u2761",
    pilcrow: "\xB6",
    plusMinus: "\xB1",
    question: "?",
    section: "\xA7",
    starsOff: "\u2606",
    starsOn: "\u2605",
    upDownArrow: "\u2195"
  };
  var windows = Object.assign({}, common2, {
    check: "\u221A",
    cross: "\xD7",
    ellipsisLarge: "...",
    ellipsis: "...",
    info: "i",
    questionSmall: "?",
    pointer: ">",
    pointerSmall: "\xBB",
    radioOff: "( )",
    radioOn: "(*)",
    warning: "\u203C"
  });
  var other = Object.assign({}, common2, {
    ballotCross: "\u2718",
    check: "\u2714",
    cross: "\u2716",
    ellipsisLarge: "\u22EF",
    ellipsis: "\u2026",
    info: "\u2139",
    questionFull: "\uFF1F",
    questionSmall: "\uFE56",
    pointer: isLinux ? "\u25B8" : "\u276F",
    pointerSmall: isLinux ? "\u2023" : "\u203A",
    radioOff: "\u25EF",
    radioOn: "\u25C9",
    warning: "\u26A0"
  });
  module2.exports = isWindows && !isHyper ? windows : other;
  Reflect.defineProperty(module2.exports, "common", { enumerable: false, value: common2 });
  Reflect.defineProperty(module2.exports, "windows", { enumerable: false, value: windows });
  Reflect.defineProperty(module2.exports, "other", { enumerable: false, value: other });
});

// ../../node_modules/ansi-colors/index.js
var require_ansi_colors = __commonJS((exports2, module2) => {
  var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  var ANSI_REGEX = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;
  var hasColor = () => {
    if (typeof process !== "undefined") {
      return process.env.FORCE_COLOR !== "0";
    }
    return false;
  };
  var create8 = () => {
    const colors = {
      enabled: hasColor(),
      visible: true,
      styles: {},
      keys: {}
    };
    const ansi = (style2) => {
      let open = style2.open = `\x1B[${style2.codes[0]}m`;
      let close = style2.close = `\x1B[${style2.codes[1]}m`;
      let regex = style2.regex = new RegExp(`\\u001b\\[${style2.codes[1]}m`, "g");
      style2.wrap = (input, newline) => {
        if (input.includes(close))
          input = input.replace(regex, close + open);
        let output = open + input + close;
        return newline ? output.replace(/\r*\n/g, `${close}\$&${open}`) : output;
      };
      return style2;
    };
    const wrap = (style2, input, newline) => {
      return typeof style2 === "function" ? style2(input) : style2.wrap(input, newline);
    };
    const style = (input, stack) => {
      if (input === "" || input == null)
        return "";
      if (colors.enabled === false)
        return input;
      if (colors.visible === false)
        return "";
      let str = "" + input;
      let nl = str.includes("\n");
      let n = stack.length;
      if (n > 0 && stack.includes("unstyle")) {
        stack = [...new Set(["unstyle", ...stack])].reverse();
      }
      while (n-- > 0)
        str = wrap(colors.styles[stack[n]], str, nl);
      return str;
    };
    const define2 = (name2, codes, type2) => {
      colors.styles[name2] = ansi({ name: name2, codes });
      let keys3 = colors.keys[type2] || (colors.keys[type2] = []);
      keys3.push(name2);
      Reflect.defineProperty(colors, name2, {
        configurable: true,
        enumerable: true,
        set(value) {
          colors.alias(name2, value);
        },
        get() {
          let color = (input) => style(input, color.stack);
          Reflect.setPrototypeOf(color, colors);
          color.stack = this.stack ? this.stack.concat(name2) : [name2];
          return color;
        }
      });
    };
    define2("reset", [0, 0], "modifier");
    define2("bold", [1, 22], "modifier");
    define2("dim", [2, 22], "modifier");
    define2("italic", [3, 23], "modifier");
    define2("underline", [4, 24], "modifier");
    define2("inverse", [7, 27], "modifier");
    define2("hidden", [8, 28], "modifier");
    define2("strikethrough", [9, 29], "modifier");
    define2("black", [30, 39], "color");
    define2("red", [31, 39], "color");
    define2("green", [32, 39], "color");
    define2("yellow", [33, 39], "color");
    define2("blue", [34, 39], "color");
    define2("magenta", [35, 39], "color");
    define2("cyan", [36, 39], "color");
    define2("white", [37, 39], "color");
    define2("gray", [90, 39], "color");
    define2("grey", [90, 39], "color");
    define2("bgBlack", [40, 49], "bg");
    define2("bgRed", [41, 49], "bg");
    define2("bgGreen", [42, 49], "bg");
    define2("bgYellow", [43, 49], "bg");
    define2("bgBlue", [44, 49], "bg");
    define2("bgMagenta", [45, 49], "bg");
    define2("bgCyan", [46, 49], "bg");
    define2("bgWhite", [47, 49], "bg");
    define2("blackBright", [90, 39], "bright");
    define2("redBright", [91, 39], "bright");
    define2("greenBright", [92, 39], "bright");
    define2("yellowBright", [93, 39], "bright");
    define2("blueBright", [94, 39], "bright");
    define2("magentaBright", [95, 39], "bright");
    define2("cyanBright", [96, 39], "bright");
    define2("whiteBright", [97, 39], "bright");
    define2("bgBlackBright", [100, 49], "bgBright");
    define2("bgRedBright", [101, 49], "bgBright");
    define2("bgGreenBright", [102, 49], "bgBright");
    define2("bgYellowBright", [103, 49], "bgBright");
    define2("bgBlueBright", [104, 49], "bgBright");
    define2("bgMagentaBright", [105, 49], "bgBright");
    define2("bgCyanBright", [106, 49], "bgBright");
    define2("bgWhiteBright", [107, 49], "bgBright");
    colors.ansiRegex = ANSI_REGEX;
    colors.hasColor = colors.hasAnsi = (str) => {
      colors.ansiRegex.lastIndex = 0;
      return typeof str === "string" && str !== "" && colors.ansiRegex.test(str);
    };
    colors.alias = (name2, color) => {
      let fn = typeof color === "string" ? colors[color] : color;
      if (typeof fn !== "function") {
        throw new TypeError("Expected alias to be the name of an existing color (string) or a function");
      }
      if (!fn.stack) {
        Reflect.defineProperty(fn, "name", { value: name2 });
        colors.styles[name2] = fn;
        fn.stack = [name2];
      }
      Reflect.defineProperty(colors, name2, {
        configurable: true,
        enumerable: true,
        set(value) {
          colors.alias(name2, value);
        },
        get() {
          let color2 = (input) => style(input, color2.stack);
          Reflect.setPrototypeOf(color2, colors);
          color2.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
          return color2;
        }
      });
    };
    colors.theme = (custom) => {
      if (!isObject(custom))
        throw new TypeError("Expected theme to be an object");
      for (let name2 of Object.keys(custom)) {
        colors.alias(name2, custom[name2]);
      }
      return colors;
    };
    colors.alias("unstyle", (str) => {
      if (typeof str === "string" && str !== "") {
        colors.ansiRegex.lastIndex = 0;
        return str.replace(colors.ansiRegex, "");
      }
      return "";
    });
    colors.alias("noop", (str) => str);
    colors.none = colors.clear = colors.noop;
    colors.stripColor = colors.unstyle;
    colors.symbols = require_symbols();
    colors.define = define2;
    return colors;
  };
  module2.exports = create8();
  module2.exports.create = create8;
});

// ../../node_modules/enquirer/lib/utils.js
var require_utils5 = __commonJS((exports2) => {
  var toString = Object.prototype.toString;
  var colors = require_ansi_colors();
  var called = false;
  var fns = [];
  var complements = {
    yellow: "blue",
    cyan: "red",
    green: "magenta",
    black: "white",
    blue: "yellow",
    red: "cyan",
    magenta: "green",
    white: "black"
  };
  exports2.longest = (arr, prop) => {
    return arr.reduce((a, v) => Math.max(a, prop ? v[prop].length : v.length), 0);
  };
  exports2.hasColor = (str) => !!str && colors.hasColor(str);
  var isObject = exports2.isObject = (val) => {
    return val !== null && typeof val === "object" && !Array.isArray(val);
  };
  exports2.nativeType = (val) => {
    return toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
  };
  exports2.isAsyncFn = (val) => {
    return exports2.nativeType(val) === "asyncfunction";
  };
  exports2.isPrimitive = (val) => {
    return val != null && typeof val !== "object" && typeof val !== "function";
  };
  exports2.resolve = (context, value, ...rest) => {
    if (typeof value === "function") {
      return value.call(context, ...rest);
    }
    return value;
  };
  exports2.scrollDown = (choices = []) => [...choices.slice(1), choices[0]];
  exports2.scrollUp = (choices = []) => [choices.pop(), ...choices];
  exports2.reorder = (arr = []) => {
    let res = arr.slice();
    res.sort((a, b) => {
      if (a.index > b.index)
        return 1;
      if (a.index < b.index)
        return -1;
      return 0;
    });
    return res;
  };
  exports2.swap = (arr, index, pos) => {
    let len = arr.length;
    let idx = pos === len ? 0 : pos < 0 ? len - 1 : pos;
    let choice = arr[index];
    arr[index] = arr[idx];
    arr[idx] = choice;
  };
  exports2.width = (stream2, fallback = 80) => {
    let columns = stream2 && stream2.columns ? stream2.columns : fallback;
    if (stream2 && typeof stream2.getWindowSize === "function") {
      columns = stream2.getWindowSize()[0];
    }
    if (process.platform === "win32") {
      return columns - 1;
    }
    return columns;
  };
  exports2.height = (stream2, fallback = 20) => {
    let rows = stream2 && stream2.rows ? stream2.rows : fallback;
    if (stream2 && typeof stream2.getWindowSize === "function") {
      rows = stream2.getWindowSize()[1];
    }
    return rows;
  };
  exports2.wordWrap = (str, options2 = {}) => {
    if (!str)
      return str;
    if (typeof options2 === "number") {
      options2 = { width: options2 };
    }
    let { indent = "", newline = "\n" + indent, width = 80 } = options2;
    let spaces = (newline + indent).match(/[^\S\n]/g) || [];
    width -= spaces.length;
    let source = `.{1,${width}}([\\s\\u200B]+|\$)|[^\\s\\u200B]+?([\\s\\u200B]+|\$)`;
    let output = str.trim();
    let regex = new RegExp(source, "g");
    let lines = output.match(regex) || [];
    lines = lines.map((line) => line.replace(/\n$/, ""));
    if (options2.padEnd)
      lines = lines.map((line) => line.padEnd(width, " "));
    if (options2.padStart)
      lines = lines.map((line) => line.padStart(width, " "));
    return indent + lines.join(newline);
  };
  exports2.unmute = (color) => {
    let name2 = color.stack.find((n) => colors.keys.color.includes(n));
    if (name2) {
      return colors[name2];
    }
    let bg = color.stack.find((n) => n.slice(2) === "bg");
    if (bg) {
      return colors[name2.slice(2)];
    }
    return (str) => str;
  };
  exports2.pascal = (str) => str ? str[0].toUpperCase() + str.slice(1) : "";
  exports2.inverse = (color) => {
    if (!color || !color.stack)
      return color;
    let name2 = color.stack.find((n) => colors.keys.color.includes(n));
    if (name2) {
      let col = colors["bg" + exports2.pascal(name2)];
      return col ? col.black : color;
    }
    let bg = color.stack.find((n) => n.slice(0, 2) === "bg");
    if (bg) {
      return colors[bg.slice(2).toLowerCase()] || color;
    }
    return colors.none;
  };
  exports2.complement = (color) => {
    if (!color || !color.stack)
      return color;
    let name2 = color.stack.find((n) => colors.keys.color.includes(n));
    let bg = color.stack.find((n) => n.slice(0, 2) === "bg");
    if (name2 && !bg) {
      return colors[complements[name2] || name2];
    }
    if (bg) {
      let lower = bg.slice(2).toLowerCase();
      let comp = complements[lower];
      if (!comp)
        return color;
      return colors["bg" + exports2.pascal(comp)] || color;
    }
    return colors.none;
  };
  exports2.meridiem = (date) => {
    let hours = date.getHours();
    let minutes = date.getMinutes();
    let ampm = hours >= 12 ? "pm" : "am";
    hours = hours % 12;
    let hrs = hours === 0 ? 12 : hours;
    let min4 = minutes < 10 ? "0" + minutes : minutes;
    return hrs + ":" + min4 + " " + ampm;
  };
  exports2.set = (obj = {}, prop = "", val) => {
    return prop.split(".").reduce((acc, k, i, arr) => {
      let value = arr.length - 1 > i ? acc[k] || {} : val;
      if (!exports2.isObject(value) && i < arr.length - 1)
        value = {};
      return acc[k] = value;
    }, obj);
  };
  exports2.get = (obj = {}, prop = "", fallback) => {
    let value = obj[prop] == null ? prop.split(".").reduce((acc, k) => acc && acc[k], obj) : obj[prop];
    return value == null ? fallback : value;
  };
  exports2.mixin = (target, b) => {
    if (!isObject(target))
      return b;
    if (!isObject(b))
      return target;
    for (let key of Object.keys(b)) {
      let desc = Object.getOwnPropertyDescriptor(b, key);
      if (desc.hasOwnProperty("value")) {
        if (target.hasOwnProperty(key) && isObject(desc.value)) {
          let existing = Object.getOwnPropertyDescriptor(target, key);
          if (isObject(existing.value)) {
            target[key] = exports2.merge({}, target[key], b[key]);
          } else {
            Reflect.defineProperty(target, key, desc);
          }
        } else {
          Reflect.defineProperty(target, key, desc);
        }
      } else {
        Reflect.defineProperty(target, key, desc);
      }
    }
    return target;
  };
  exports2.merge = (...args2) => {
    let target = {};
    for (let ele of args2)
      exports2.mixin(target, ele);
    return target;
  };
  exports2.mixinEmitter = (obj, emitter) => {
    let proto = emitter.constructor.prototype;
    for (let key of Object.keys(proto)) {
      let val = proto[key];
      if (typeof val === "function") {
        exports2.define(obj, key, val.bind(emitter));
      } else {
        exports2.define(obj, key, val);
      }
    }
  };
  exports2.onExit = (callback) => {
    const onExit = (quit, code) => {
      if (called)
        return;
      called = true;
      fns.forEach((fn) => fn());
      if (quit === true) {
        process.exit(128 + code);
      }
    };
    if (fns.length === 0) {
      process.once("SIGTERM", onExit.bind(null, true, 15));
      process.once("SIGINT", onExit.bind(null, true, 2));
      process.once("exit", onExit);
    }
    fns.push(callback);
  };
  exports2.define = (obj, key, value) => {
    Reflect.defineProperty(obj, key, { value });
  };
  exports2.defineExport = (obj, key, fn) => {
    let custom;
    Reflect.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      set(val) {
        custom = val;
      },
      get() {
        return custom ? custom() : fn();
      }
    });
  };
});

// ../../node_modules/enquirer/lib/combos.js
var require_combos = __commonJS((exports2) => {
  exports2.ctrl = {
    a: "first",
    b: "backward",
    c: "cancel",
    d: "deleteForward",
    e: "last",
    f: "forward",
    g: "reset",
    i: "tab",
    k: "cutForward",
    l: "reset",
    n: "newItem",
    m: "cancel",
    j: "submit",
    p: "search",
    r: "remove",
    s: "save",
    u: "undo",
    w: "cutLeft",
    x: "toggleCursor",
    v: "paste"
  };
  exports2.shift = {
    up: "shiftUp",
    down: "shiftDown",
    left: "shiftLeft",
    right: "shiftRight",
    tab: "prev"
  };
  exports2.fn = {
    up: "pageUp",
    down: "pageDown",
    left: "pageLeft",
    right: "pageRight",
    delete: "deleteForward"
  };
  exports2.option = {
    b: "backward",
    f: "forward",
    d: "cutRight",
    left: "cutLeft",
    up: "altUp",
    down: "altDown"
  };
  exports2.keys = {
    pageup: "pageUp",
    pagedown: "pageDown",
    home: "home",
    end: "end",
    cancel: "cancel",
    delete: "deleteForward",
    backspace: "delete",
    down: "down",
    enter: "submit",
    escape: "cancel",
    left: "left",
    space: "space",
    number: "number",
    return: "submit",
    right: "right",
    tab: "next",
    up: "up"
  };
});

// ../../node_modules/enquirer/lib/keypress.js
var require_keypress = __commonJS((exports2, module2) => {
  var isShiftKey = function(code) {
    return ["[a", "[b", "[c", "[d", "[e", "[2$", "[3$", "[5$", "[6$", "[7$", "[8$", "[Z"].includes(code);
  };
  var isCtrlKey = function(code) {
    return ["Oa", "Ob", "Oc", "Od", "Oe", "[2^", "[3^", "[5^", "[6^", "[7^", "[8^"].includes(code);
  };
  var readline = __require("readline");
  var combos = require_combos();
  var metaKeyCodeRe = /^(?:\x1b)([a-zA-Z0-9])$/;
  var fnKeyRe = /^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/;
  var keyName = {
    OP: "f1",
    OQ: "f2",
    OR: "f3",
    OS: "f4",
    "[11~": "f1",
    "[12~": "f2",
    "[13~": "f3",
    "[14~": "f4",
    "[[A": "f1",
    "[[B": "f2",
    "[[C": "f3",
    "[[D": "f4",
    "[[E": "f5",
    "[15~": "f5",
    "[17~": "f6",
    "[18~": "f7",
    "[19~": "f8",
    "[20~": "f9",
    "[21~": "f10",
    "[23~": "f11",
    "[24~": "f12",
    "[A": "up",
    "[B": "down",
    "[C": "right",
    "[D": "left",
    "[E": "clear",
    "[F": "end",
    "[H": "home",
    OA: "up",
    OB: "down",
    OC: "right",
    OD: "left",
    OE: "clear",
    OF: "end",
    OH: "home",
    "[1~": "home",
    "[2~": "insert",
    "[3~": "delete",
    "[4~": "end",
    "[5~": "pageup",
    "[6~": "pagedown",
    "[[5~": "pageup",
    "[[6~": "pagedown",
    "[7~": "home",
    "[8~": "end",
    "[a": "up",
    "[b": "down",
    "[c": "right",
    "[d": "left",
    "[e": "clear",
    "[2$": "insert",
    "[3$": "delete",
    "[5$": "pageup",
    "[6$": "pagedown",
    "[7$": "home",
    "[8$": "end",
    Oa: "up",
    Ob: "down",
    Oc: "right",
    Od: "left",
    Oe: "clear",
    "[2^": "insert",
    "[3^": "delete",
    "[5^": "pageup",
    "[6^": "pagedown",
    "[7^": "home",
    "[8^": "end",
    "[Z": "tab"
  };
  var keypress = (s = "", event = {}) => {
    let parts;
    let key = {
      name: event.name,
      ctrl: false,
      meta: false,
      shift: false,
      option: false,
      sequence: s,
      raw: s,
      ...event
    };
    if (Buffer.isBuffer(s)) {
      if (s[0] > 127 && s[1] === undefined) {
        s[0] -= 128;
        s = "\x1B" + String(s);
      } else {
        s = String(s);
      }
    } else if (s !== undefined && typeof s !== "string") {
      s = String(s);
    } else if (!s) {
      s = key.sequence || "";
    }
    key.sequence = key.sequence || s || key.name;
    if (s === "\r") {
      key.raw = undefined;
      key.name = "return";
    } else if (s === "\n") {
      key.name = "enter";
    } else if (s === "\t") {
      key.name = "tab";
    } else if (s === "\b" || s === "\x7F" || s === "\x1B\x7F" || s === "\x1B\b") {
      key.name = "backspace";
      key.meta = s.charAt(0) === "\x1B";
    } else if (s === "\x1B" || s === "\x1B\x1B") {
      key.name = "escape";
      key.meta = s.length === 2;
    } else if (s === " " || s === "\x1B ") {
      key.name = "space";
      key.meta = s.length === 2;
    } else if (s <= "\x1A") {
      key.name = String.fromCharCode(s.charCodeAt(0) + "a".charCodeAt(0) - 1);
      key.ctrl = true;
    } else if (s.length === 1 && s >= "0" && s <= "9") {
      key.name = "number";
    } else if (s.length === 1 && s >= "a" && s <= "z") {
      key.name = s;
    } else if (s.length === 1 && s >= "A" && s <= "Z") {
      key.name = s.toLowerCase();
      key.shift = true;
    } else if (parts = metaKeyCodeRe.exec(s)) {
      key.meta = true;
      key.shift = /^[A-Z]$/.test(parts[1]);
    } else if (parts = fnKeyRe.exec(s)) {
      let segs = [...s];
      if (segs[0] === "\x1B" && segs[1] === "\x1B") {
        key.option = true;
      }
      let code = [parts[1], parts[2], parts[4], parts[6]].filter(Boolean).join("");
      let modifier = (parts[3] || parts[5] || 1) - 1;
      key.ctrl = !!(modifier & 4);
      key.meta = !!(modifier & 10);
      key.shift = !!(modifier & 1);
      key.code = code;
      key.name = keyName[code];
      key.shift = isShiftKey(code) || key.shift;
      key.ctrl = isCtrlKey(code) || key.ctrl;
    }
    return key;
  };
  keypress.listen = (options2 = {}, onKeypress) => {
    let { stdin } = options2;
    if (!stdin || stdin !== process.stdin && !stdin.isTTY) {
      throw new Error("Invalid stream passed");
    }
    let rl = readline.createInterface({ terminal: true, input: stdin });
    readline.emitKeypressEvents(stdin, rl);
    let on = (buf, key) => onKeypress(buf, keypress(buf, key), rl);
    let isRaw = stdin.isRaw;
    if (stdin.isTTY)
      stdin.setRawMode(true);
    stdin.on("keypress", on);
    rl.resume();
    let off = () => {
      if (stdin.isTTY)
        stdin.setRawMode(isRaw);
      stdin.removeListener("keypress", on);
      rl.pause();
      rl.close();
    };
    return off;
  };
  keypress.action = (buf, key, customActions) => {
    let obj = { ...combos, ...customActions };
    if (key.ctrl) {
      key.action = obj.ctrl[key.name];
      return key;
    }
    if (key.option && obj.option) {
      key.action = obj.option[key.name];
      return key;
    }
    if (key.shift) {
      key.action = obj.shift[key.name];
      return key;
    }
    key.action = obj.keys[key.name];
    return key;
  };
  module2.exports = keypress;
});

// ../../node_modules/enquirer/lib/timer.js
var require_timer = __commonJS((exports2, module2) => {
  var create8 = function(prompt, name2, options2 = {}) {
    let timer = prompt.timers[name2] = { name: name2, start: Date.now(), ms: 0, tick: 0 };
    let ms = options2.interval || 120;
    timer.frames = options2.frames || [];
    timer.loading = true;
    let interval = setInterval(() => {
      timer.ms = Date.now() - timer.start;
      timer.tick++;
      prompt.render();
    }, ms);
    timer.stop = () => {
      timer.loading = false;
      clearInterval(interval);
    };
    Reflect.defineProperty(timer, "interval", { value: interval });
    prompt.once("close", () => timer.stop());
    return timer.stop;
  };
  module2.exports = (prompt) => {
    prompt.timers = prompt.timers || {};
    let timers = prompt.options.timers;
    if (!timers)
      return;
    for (let key of Object.keys(timers)) {
      let opts = timers[key];
      if (typeof opts === "number") {
        opts = { interval: opts };
      }
      create8(prompt, key, opts);
    }
  };
});

// ../../node_modules/enquirer/lib/state.js
var require_state = __commonJS((exports2, module2) => {
  var { define: define2, width } = require_utils5();

  class State {
    constructor(prompt) {
      let options2 = prompt.options;
      define2(this, "_prompt", prompt);
      this.type = prompt.type;
      this.name = prompt.name;
      this.message = "";
      this.header = "";
      this.footer = "";
      this.error = "";
      this.hint = "";
      this.input = "";
      this.cursor = 0;
      this.index = 0;
      this.lines = 0;
      this.tick = 0;
      this.prompt = "";
      this.buffer = "";
      this.width = width(options2.stdout || process.stdout);
      Object.assign(this, options2);
      this.name = this.name || this.message;
      this.message = this.message || this.name;
      this.symbols = prompt.symbols;
      this.styles = prompt.styles;
      this.required = new Set;
      this.cancelled = false;
      this.submitted = false;
    }
    clone() {
      let state = { ...this };
      state.status = this.status;
      state.buffer = Buffer.from(state.buffer);
      delete state.clone;
      return state;
    }
    set color(val) {
      this._color = val;
    }
    get color() {
      let styles = this.prompt.styles;
      if (this.cancelled)
        return styles.cancelled;
      if (this.submitted)
        return styles.submitted;
      let color = this._color || styles[this.status];
      return typeof color === "function" ? color : styles.pending;
    }
    set loading(value) {
      this._loading = value;
    }
    get loading() {
      if (typeof this._loading === "boolean")
        return this._loading;
      if (this.loadingChoices)
        return "choices";
      return false;
    }
    get status() {
      if (this.cancelled)
        return "cancelled";
      if (this.submitted)
        return "submitted";
      return "pending";
    }
  }
  module2.exports = State;
});

// ../../node_modules/enquirer/lib/styles.js
var require_styles = __commonJS((exports2, module2) => {
  var utils = require_utils5();
  var colors = require_ansi_colors();
  var styles = {
    default: colors.noop,
    noop: colors.noop,
    set inverse(custom) {
      this._inverse = custom;
    },
    get inverse() {
      return this._inverse || utils.inverse(this.primary);
    },
    set complement(custom) {
      this._complement = custom;
    },
    get complement() {
      return this._complement || utils.complement(this.primary);
    },
    primary: colors.cyan,
    success: colors.green,
    danger: colors.magenta,
    strong: colors.bold,
    warning: colors.yellow,
    muted: colors.dim,
    disabled: colors.gray,
    dark: colors.dim.gray,
    underline: colors.underline,
    set info(custom) {
      this._info = custom;
    },
    get info() {
      return this._info || this.primary;
    },
    set em(custom) {
      this._em = custom;
    },
    get em() {
      return this._em || this.primary.underline;
    },
    set heading(custom) {
      this._heading = custom;
    },
    get heading() {
      return this._heading || this.muted.underline;
    },
    set pending(custom) {
      this._pending = custom;
    },
    get pending() {
      return this._pending || this.primary;
    },
    set submitted(custom) {
      this._submitted = custom;
    },
    get submitted() {
      return this._submitted || this.success;
    },
    set cancelled(custom) {
      this._cancelled = custom;
    },
    get cancelled() {
      return this._cancelled || this.danger;
    },
    set typing(custom) {
      this._typing = custom;
    },
    get typing() {
      return this._typing || this.dim;
    },
    set placeholder(custom) {
      this._placeholder = custom;
    },
    get placeholder() {
      return this._placeholder || this.primary.dim;
    },
    set highlight(custom) {
      this._highlight = custom;
    },
    get highlight() {
      return this._highlight || this.inverse;
    }
  };
  styles.merge = (options2 = {}) => {
    if (options2.styles && typeof options2.styles.enabled === "boolean") {
      colors.enabled = options2.styles.enabled;
    }
    if (options2.styles && typeof options2.styles.visible === "boolean") {
      colors.visible = options2.styles.visible;
    }
    let result = utils.merge({}, styles, options2.styles);
    delete result.merge;
    for (let key of Object.keys(colors)) {
      if (!result.hasOwnProperty(key)) {
        Reflect.defineProperty(result, key, { get: () => colors[key] });
      }
    }
    for (let key of Object.keys(colors.styles)) {
      if (!result.hasOwnProperty(key)) {
        Reflect.defineProperty(result, key, { get: () => colors[key] });
      }
    }
    return result;
  };
  module2.exports = styles;
});

// ../../node_modules/enquirer/lib/symbols.js
var require_symbols2 = __commonJS((exports2, module2) => {
  var isWindows = process.platform === "win32";
  var colors = require_ansi_colors();
  var utils = require_utils5();
  var symbols = {
    ...colors.symbols,
    upDownDoubleArrow: "\u21D5",
    upDownDoubleArrow2: "\u2B0D",
    upDownArrow: "\u2195",
    asterisk: "*",
    asterism: "\u2042",
    bulletWhite: "\u25E6",
    electricArrow: "\u2301",
    ellipsisLarge: "\u22EF",
    ellipsisSmall: "\u2026",
    fullBlock: "\u2588",
    identicalTo: "\u2261",
    indicator: colors.symbols.check,
    leftAngle: "\u2039",
    mark: "\u203B",
    minus: "\u2212",
    multiplication: "\xD7",
    obelus: "\xF7",
    percent: "%",
    pilcrow: "\xB6",
    pilcrow2: "\u2761",
    pencilUpRight: "\u2710",
    pencilDownRight: "\u270E",
    pencilRight: "\u270F",
    plus: "+",
    plusMinus: "\xB1",
    pointRight: "\u261E",
    rightAngle: "\u203A",
    section: "\xA7",
    hexagon: { off: "\u2B21", on: "\u2B22", disabled: "\u2B22" },
    ballot: { on: "\u2611", off: "\u2610", disabled: "\u2612" },
    stars: { on: "\u2605", off: "\u2606", disabled: "\u2606" },
    folder: { on: "\u25BC", off: "\u25B6", disabled: "\u25B6" },
    prefix: {
      pending: colors.symbols.question,
      submitted: colors.symbols.check,
      cancelled: colors.symbols.cross
    },
    separator: {
      pending: colors.symbols.pointerSmall,
      submitted: colors.symbols.middot,
      cancelled: colors.symbols.middot
    },
    radio: {
      off: isWindows ? "( )" : "\u25EF",
      on: isWindows ? "(*)" : "\u25C9",
      disabled: isWindows ? "(|)" : "\u24BE"
    },
    numbers: ["\u24EA", "\u2460", "\u2461", "\u2462", "\u2463", "\u2464", "\u2465", "\u2466", "\u2467", "\u2468", "\u2469", "\u246A", "\u246B", "\u246C", "\u246D", "\u246E", "\u246F", "\u2470", "\u2471", "\u2472", "\u2473", "\u3251", "\u3252", "\u3253", "\u3254", "\u3255", "\u3256", "\u3257", "\u3258", "\u3259", "\u325A", "\u325B", "\u325C", "\u325D", "\u325E", "\u325F", "\u32B1", "\u32B2", "\u32B3", "\u32B4", "\u32B5", "\u32B6", "\u32B7", "\u32B8", "\u32B9", "\u32BA", "\u32BB", "\u32BC", "\u32BD", "\u32BE", "\u32BF"]
  };
  symbols.merge = (options2) => {
    let result = utils.merge({}, colors.symbols, symbols, options2.symbols);
    delete result.merge;
    return result;
  };
  module2.exports = symbols;
});

// ../../node_modules/enquirer/lib/theme.js
var require_theme = __commonJS((exports2, module2) => {
  var styles = require_styles();
  var symbols = require_symbols2();
  var utils = require_utils5();
  module2.exports = (prompt) => {
    prompt.options = utils.merge({}, prompt.options.theme, prompt.options);
    prompt.symbols = symbols.merge(prompt.options);
    prompt.styles = styles.merge(prompt.options);
  };
});

// ../../node_modules/enquirer/lib/ansi.js
var require_ansi = __commonJS((exports2, module2) => {
  var isTerm = process.env.TERM_PROGRAM === "Apple_Terminal";
  var colors = require_ansi_colors();
  var utils = require_utils5();
  var ansi = module2.exports = exports2;
  var ESC = "\x1B[";
  var BEL = "\x07";
  var hidden = false;
  var code = ansi.code = {
    bell: BEL,
    beep: BEL,
    beginning: `${ESC}G`,
    down: `${ESC}J`,
    esc: ESC,
    getPosition: `${ESC}6n`,
    hide: `${ESC}?25l`,
    line: `${ESC}2K`,
    lineEnd: `${ESC}K`,
    lineStart: `${ESC}1K`,
    restorePosition: ESC + (isTerm ? "8" : "u"),
    savePosition: ESC + (isTerm ? "7" : "s"),
    screen: `${ESC}2J`,
    show: `${ESC}?25h`,
    up: `${ESC}1J`
  };
  var cursor = ansi.cursor = {
    get hidden() {
      return hidden;
    },
    hide() {
      hidden = true;
      return code.hide;
    },
    show() {
      hidden = false;
      return code.show;
    },
    forward: (count = 1) => `${ESC}${count}C`,
    backward: (count = 1) => `${ESC}${count}D`,
    nextLine: (count = 1) => `${ESC}E`.repeat(count),
    prevLine: (count = 1) => `${ESC}F`.repeat(count),
    up: (count = 1) => count ? `${ESC}${count}A` : "",
    down: (count = 1) => count ? `${ESC}${count}B` : "",
    right: (count = 1) => count ? `${ESC}${count}C` : "",
    left: (count = 1) => count ? `${ESC}${count}D` : "",
    to(x, y) {
      return y ? `${ESC}${y + 1};${x + 1}H` : `${ESC}${x + 1}G`;
    },
    move(x = 0, y = 0) {
      let res = "";
      res += x < 0 ? cursor.left(-x) : x > 0 ? cursor.right(x) : "";
      res += y < 0 ? cursor.up(-y) : y > 0 ? cursor.down(y) : "";
      return res;
    },
    restore(state = {}) {
      let { after, cursor: cursor2, initial, input, prompt, size: size2, value } = state;
      initial = utils.isPrimitive(initial) ? String(initial) : "";
      input = utils.isPrimitive(input) ? String(input) : "";
      value = utils.isPrimitive(value) ? String(value) : "";
      if (size2) {
        let codes = ansi.cursor.up(size2) + ansi.cursor.to(prompt.length);
        let diff = input.length - cursor2;
        if (diff > 0) {
          codes += ansi.cursor.left(diff);
        }
        return codes;
      }
      if (value || after) {
        let pos = !input && !!initial ? -initial.length : -input.length + cursor2;
        if (after)
          pos -= after.length;
        if (input === "" && initial && !prompt.includes(initial)) {
          pos += initial.length;
        }
        return ansi.cursor.move(pos);
      }
    }
  };
  var erase = ansi.erase = {
    screen: code.screen,
    up: code.up,
    down: code.down,
    line: code.line,
    lineEnd: code.lineEnd,
    lineStart: code.lineStart,
    lines(n) {
      let str = "";
      for (let i = 0;i < n; i++) {
        str += ansi.erase.line + (i < n - 1 ? ansi.cursor.up(1) : "");
      }
      if (n)
        str += ansi.code.beginning;
      return str;
    }
  };
  ansi.clear = (input = "", columns = process.stdout.columns) => {
    if (!columns)
      return erase.line + cursor.to(0);
    let width = (str) => [...colors.unstyle(str)].length;
    let lines = input.split(/\r?\n/);
    let rows = 0;
    for (let line of lines) {
      rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / columns);
    }
    return (erase.line + cursor.prevLine()).repeat(rows - 1) + erase.line + cursor.to(0);
  };
});

// ../../node_modules/enquirer/lib/prompt.js
var require_prompt = __commonJS((exports2, module2) => {
  var setOptions = function(prompt) {
    let isValidKey = (key) => {
      return prompt[key] === undefined || typeof prompt[key] === "function";
    };
    let ignore = [
      "actions",
      "choices",
      "initial",
      "margin",
      "roles",
      "styles",
      "symbols",
      "theme",
      "timers",
      "value"
    ];
    let ignoreFn = [
      "body",
      "footer",
      "error",
      "header",
      "hint",
      "indicator",
      "message",
      "prefix",
      "separator",
      "skip"
    ];
    for (let key of Object.keys(prompt.options)) {
      if (ignore.includes(key))
        continue;
      if (/^on[A-Z]/.test(key))
        continue;
      let option = prompt.options[key];
      if (typeof option === "function" && isValidKey(key)) {
        if (!ignoreFn.includes(key)) {
          prompt[key] = option.bind(prompt);
        }
      } else if (typeof prompt[key] !== "function") {
        prompt[key] = option;
      }
    }
  };
  var margin = function(value) {
    if (typeof value === "number") {
      value = [value, value, value, value];
    }
    let arr = [].concat(value || []);
    let pad = (i) => i % 2 === 0 ? "\n" : " ";
    let res = [];
    for (let i = 0;i < 4; i++) {
      let char = pad(i);
      if (arr[i]) {
        res.push(char.repeat(arr[i]));
      } else {
        res.push("");
      }
    }
    return res;
  };
  var Events = __require("events");
  var colors = require_ansi_colors();
  var keypress = require_keypress();
  var timer = require_timer();
  var State = require_state();
  var theme = require_theme();
  var utils = require_utils5();
  var ansi = require_ansi();

  class Prompt extends Events {
    constructor(options2 = {}) {
      super();
      this.name = options2.name;
      this.type = options2.type;
      this.options = options2;
      theme(this);
      timer(this);
      this.state = new State(this);
      this.initial = [options2.initial, options2.default].find((v) => v != null);
      this.stdout = options2.stdout || process.stdout;
      this.stdin = options2.stdin || process.stdin;
      this.scale = options2.scale || 1;
      this.term = this.options.term || process.env.TERM_PROGRAM;
      this.margin = margin(this.options.margin);
      this.setMaxListeners(0);
      setOptions(this);
    }
    async keypress(input, event = {}) {
      this.keypressed = true;
      let key = keypress.action(input, keypress(input, event), this.options.actions);
      this.state.keypress = key;
      this.emit("keypress", input, key);
      this.emit("state", this.state.clone());
      let fn = this.options[key.action] || this[key.action] || this.dispatch;
      if (typeof fn === "function") {
        return await fn.call(this, input, key);
      }
      this.alert();
    }
    alert() {
      delete this.state.alert;
      if (this.options.show === false) {
        this.emit("alert");
      } else {
        this.stdout.write(ansi.code.beep);
      }
    }
    cursorHide() {
      this.stdout.write(ansi.cursor.hide());
      utils.onExit(() => this.cursorShow());
    }
    cursorShow() {
      this.stdout.write(ansi.cursor.show());
    }
    write(str) {
      if (!str)
        return;
      if (this.stdout && this.state.show !== false) {
        this.stdout.write(str);
      }
      this.state.buffer += str;
    }
    clear(lines = 0) {
      let buffer = this.state.buffer;
      this.state.buffer = "";
      if (!buffer && !lines || this.options.show === false)
        return;
      this.stdout.write(ansi.cursor.down(lines) + ansi.clear(buffer, this.width));
    }
    restore() {
      if (this.state.closed || this.options.show === false)
        return;
      let { prompt, after, rest } = this.sections();
      let { cursor, initial = "", input = "", value = "" } = this;
      let size2 = this.state.size = rest.length;
      let state = { after, cursor, initial, input, prompt, size: size2, value };
      let codes = ansi.cursor.restore(state);
      if (codes) {
        this.stdout.write(codes);
      }
    }
    sections() {
      let { buffer, input, prompt } = this.state;
      prompt = colors.unstyle(prompt);
      let buf = colors.unstyle(buffer);
      let idx = buf.indexOf(prompt);
      let header = buf.slice(0, idx);
      let rest = buf.slice(idx);
      let lines = rest.split("\n");
      let first = lines[0];
      let last2 = lines[lines.length - 1];
      let promptLine = prompt + (input ? " " + input : "");
      let len = promptLine.length;
      let after = len < first.length ? first.slice(len + 1) : "";
      return { header, prompt: first, after, rest: lines.slice(1), last: last2 };
    }
    async submit() {
      this.state.submitted = true;
      this.state.validating = true;
      if (this.options.onSubmit) {
        await this.options.onSubmit.call(this, this.name, this.value, this);
      }
      let result = this.state.error || await this.validate(this.value, this.state);
      if (result !== true) {
        let error = "\n" + this.symbols.pointer + " ";
        if (typeof result === "string") {
          error += result.trim();
        } else {
          error += "Invalid input";
        }
        this.state.error = "\n" + this.styles.danger(error);
        this.state.submitted = false;
        await this.render();
        await this.alert();
        this.state.validating = false;
        this.state.error = undefined;
        return;
      }
      this.state.validating = false;
      await this.render();
      await this.close();
      this.value = await this.result(this.value);
      this.emit("submit", this.value);
    }
    async cancel(err) {
      this.state.cancelled = this.state.submitted = true;
      await this.render();
      await this.close();
      if (typeof this.options.onCancel === "function") {
        await this.options.onCancel.call(this, this.name, this.value, this);
      }
      this.emit("cancel", await this.error(err));
    }
    async close() {
      this.state.closed = true;
      try {
        let sections = this.sections();
        let lines = Math.ceil(sections.prompt.length / this.width);
        if (sections.rest) {
          this.write(ansi.cursor.down(sections.rest.length));
        }
        this.write("\n".repeat(lines));
      } catch (err) {
      }
      this.emit("close");
    }
    start() {
      if (!this.stop && this.options.show !== false) {
        this.stop = keypress.listen(this, this.keypress.bind(this));
        this.once("close", this.stop);
      }
    }
    async skip() {
      this.skipped = this.options.skip === true;
      if (typeof this.options.skip === "function") {
        this.skipped = await this.options.skip.call(this, this.name, this.value);
      }
      return this.skipped;
    }
    async initialize() {
      let { format, options: options2, result } = this;
      this.format = () => format.call(this, this.value);
      this.result = () => result.call(this, this.value);
      if (typeof options2.initial === "function") {
        this.initial = await options2.initial.call(this, this);
      }
      if (typeof options2.onRun === "function") {
        await options2.onRun.call(this, this);
      }
      if (typeof options2.onSubmit === "function") {
        let onSubmit = options2.onSubmit.bind(this);
        let submit = this.submit.bind(this);
        delete this.options.onSubmit;
        this.submit = async () => {
          await onSubmit(this.name, this.value, this);
          return submit();
        };
      }
      await this.start();
      await this.render();
    }
    render() {
      throw new Error("expected prompt to have a custom render method");
    }
    run() {
      return new Promise(async (resolve, reject) => {
        this.once("submit", resolve);
        this.once("cancel", reject);
        if (await this.skip()) {
          this.render = () => {
          };
          return this.submit();
        }
        await this.initialize();
        this.emit("run");
      });
    }
    async element(name2, choice, i) {
      let { options: options2, state, symbols, timers } = this;
      let timer2 = timers && timers[name2];
      state.timer = timer2;
      let value = options2[name2] || state[name2] || symbols[name2];
      let val = choice && choice[name2] != null ? choice[name2] : await value;
      if (val === "")
        return val;
      let res = await this.resolve(val, state, choice, i);
      if (!res && choice && choice[name2]) {
        return this.resolve(value, state, choice, i);
      }
      return res;
    }
    async prefix() {
      let element = await this.element("prefix") || this.symbols;
      let timer2 = this.timers && this.timers.prefix;
      let state = this.state;
      state.timer = timer2;
      if (utils.isObject(element))
        element = element[state.status] || element.pending;
      if (!utils.hasColor(element)) {
        let style = this.styles[state.status] || this.styles.pending;
        return style(element);
      }
      return element;
    }
    async message() {
      let message = await this.element("message");
      if (!utils.hasColor(message)) {
        return this.styles.strong(message);
      }
      return message;
    }
    async separator() {
      let element = await this.element("separator") || this.symbols;
      let timer2 = this.timers && this.timers.separator;
      let state = this.state;
      state.timer = timer2;
      let value = element[state.status] || element.pending || state.separator;
      let ele = await this.resolve(value, state);
      if (utils.isObject(ele))
        ele = ele[state.status] || ele.pending;
      if (!utils.hasColor(ele)) {
        return this.styles.muted(ele);
      }
      return ele;
    }
    async pointer(choice, i) {
      let val = await this.element("pointer", choice, i);
      if (typeof val === "string" && utils.hasColor(val)) {
        return val;
      }
      if (val) {
        let styles = this.styles;
        let focused = this.index === i;
        let style = focused ? styles.primary : (val2) => val2;
        let ele = await this.resolve(val[focused ? "on" : "off"] || val, this.state);
        let styled = !utils.hasColor(ele) ? style(ele) : ele;
        return focused ? styled : " ".repeat(ele.length);
      }
    }
    async indicator(choice, i) {
      let val = await this.element("indicator", choice, i);
      if (typeof val === "string" && utils.hasColor(val)) {
        return val;
      }
      if (val) {
        let styles = this.styles;
        let enabled = choice.enabled === true;
        let style = enabled ? styles.success : styles.dark;
        let ele = val[enabled ? "on" : "off"] || val;
        return !utils.hasColor(ele) ? style(ele) : ele;
      }
      return "";
    }
    body() {
      return null;
    }
    footer() {
      if (this.state.status === "pending") {
        return this.element("footer");
      }
    }
    header() {
      if (this.state.status === "pending") {
        return this.element("header");
      }
    }
    async hint() {
      if (this.state.status === "pending" && !this.isValue(this.state.input)) {
        let hint = await this.element("hint");
        if (!utils.hasColor(hint)) {
          return this.styles.muted(hint);
        }
        return hint;
      }
    }
    error(err) {
      return !this.state.submitted ? err || this.state.error : "";
    }
    format(value) {
      return value;
    }
    result(value) {
      return value;
    }
    validate(value) {
      if (this.options.required === true) {
        return this.isValue(value);
      }
      return true;
    }
    isValue(value) {
      return value != null && value !== "";
    }
    resolve(value, ...args2) {
      return utils.resolve(this, value, ...args2);
    }
    get base() {
      return Prompt.prototype;
    }
    get style() {
      return this.styles[this.state.status];
    }
    get height() {
      return this.options.rows || utils.height(this.stdout, 25);
    }
    get width() {
      return this.options.columns || utils.width(this.stdout, 80);
    }
    get size() {
      return { width: this.width, height: this.height };
    }
    set cursor(value) {
      this.state.cursor = value;
    }
    get cursor() {
      return this.state.cursor;
    }
    set input(value) {
      this.state.input = value;
    }
    get input() {
      return this.state.input;
    }
    set value(value) {
      this.state.value = value;
    }
    get value() {
      let { input, value } = this.state;
      let result = [value, input].find(this.isValue.bind(this));
      return this.isValue(result) ? result : this.initial;
    }
    static get prompt() {
      return (options2) => new this(options2).run();
    }
  }
  module2.exports = Prompt;
});

// ../../node_modules/enquirer/lib/roles.js
var require_roles = __commonJS((exports2, module2) => {
  var utils = require_utils5();
  var roles = {
    default(prompt, choice) {
      return choice;
    },
    checkbox(prompt, choice) {
      throw new Error("checkbox role is not implemented yet");
    },
    editable(prompt, choice) {
      throw new Error("editable role is not implemented yet");
    },
    expandable(prompt, choice) {
      throw new Error("expandable role is not implemented yet");
    },
    heading(prompt, choice) {
      choice.disabled = "";
      choice.indicator = [choice.indicator, " "].find((v) => v != null);
      choice.message = choice.message || "";
      return choice;
    },
    input(prompt, choice) {
      throw new Error("input role is not implemented yet");
    },
    option(prompt, choice) {
      return roles.default(prompt, choice);
    },
    radio(prompt, choice) {
      throw new Error("radio role is not implemented yet");
    },
    separator(prompt, choice) {
      choice.disabled = "";
      choice.indicator = [choice.indicator, " "].find((v) => v != null);
      choice.message = choice.message || prompt.symbols.line.repeat(5);
      return choice;
    },
    spacer(prompt, choice) {
      return choice;
    }
  };
  module2.exports = (name2, options2 = {}) => {
    let role = utils.merge({}, roles, options2.roles);
    return role[name2] || role.default;
  };
});

// ../../node_modules/enquirer/lib/types/array.js
var require_array = __commonJS((exports2, module2) => {
  var reset = function(prompt, choices) {
    if (choices instanceof Promise)
      return choices;
    if (typeof choices === "function") {
      if (utils.isAsyncFn(choices))
        return choices;
      choices = choices.call(prompt, prompt);
    }
    for (let choice of choices) {
      if (Array.isArray(choice.choices)) {
        let items = choice.choices.filter((ch) => !prompt.isDisabled(ch));
        choice.enabled = items.every((ch) => ch.enabled === true);
      }
      if (prompt.isDisabled(choice) === true) {
        delete choice.enabled;
      }
    }
    return choices;
  };
  var colors = require_ansi_colors();
  var Prompt = require_prompt();
  var roles = require_roles();
  var utils = require_utils5();
  var { reorder, scrollUp, scrollDown, isObject, swap } = utils;

  class ArrayPrompt extends Prompt {
    constructor(options2) {
      super(options2);
      this.cursorHide();
      this.maxSelected = options2.maxSelected || Infinity;
      this.multiple = options2.multiple || false;
      this.initial = options2.initial || 0;
      this.delay = options2.delay || 0;
      this.longest = 0;
      this.num = "";
    }
    async initialize() {
      if (typeof this.options.initial === "function") {
        this.initial = await this.options.initial.call(this);
      }
      await this.reset(true);
      await super.initialize();
    }
    async reset() {
      let { choices, initial, autofocus, suggest } = this.options;
      this.state._choices = [];
      this.state.choices = [];
      this.choices = await Promise.all(await this.toChoices(choices));
      this.choices.forEach((ch) => ch.enabled = false);
      if (typeof suggest !== "function" && this.selectable.length === 0) {
        throw new Error("At least one choice must be selectable");
      }
      if (isObject(initial))
        initial = Object.keys(initial);
      if (Array.isArray(initial)) {
        if (autofocus != null)
          this.index = this.findIndex(autofocus);
        initial.forEach((v) => this.enable(this.find(v)));
        await this.render();
      } else {
        if (autofocus != null)
          initial = autofocus;
        if (typeof initial === "string")
          initial = this.findIndex(initial);
        if (typeof initial === "number" && initial > -1) {
          this.index = Math.max(0, Math.min(initial, this.choices.length));
          this.enable(this.find(this.index));
        }
      }
      if (this.isDisabled(this.focused)) {
        await this.down();
      }
    }
    async toChoices(value, parent) {
      this.state.loadingChoices = true;
      let choices = [];
      let index = 0;
      let toChoices = async (items, parent2) => {
        if (typeof items === "function")
          items = await items.call(this);
        if (items instanceof Promise)
          items = await items;
        for (let i = 0;i < items.length; i++) {
          let choice = items[i] = await this.toChoice(items[i], index++, parent2);
          choices.push(choice);
          if (choice.choices) {
            await toChoices(choice.choices, choice);
          }
        }
        return choices;
      };
      return toChoices(value, parent).then((choices2) => {
        this.state.loadingChoices = false;
        return choices2;
      });
    }
    async toChoice(ele, i, parent) {
      if (typeof ele === "function")
        ele = await ele.call(this, this);
      if (ele instanceof Promise)
        ele = await ele;
      if (typeof ele === "string")
        ele = { name: ele };
      if (ele.normalized)
        return ele;
      ele.normalized = true;
      let origVal = ele.value;
      let role = roles(ele.role, this.options);
      ele = role(this, ele);
      if (typeof ele.disabled === "string" && !ele.hint) {
        ele.hint = ele.disabled;
        ele.disabled = true;
      }
      if (ele.disabled === true && ele.hint == null) {
        ele.hint = "(disabled)";
      }
      if (ele.index != null)
        return ele;
      ele.name = ele.name || ele.key || ele.title || ele.value || ele.message;
      ele.message = ele.message || ele.name || "";
      ele.value = [ele.value, ele.name].find(this.isValue.bind(this));
      ele.input = "";
      ele.index = i;
      ele.cursor = 0;
      utils.define(ele, "parent", parent);
      ele.level = parent ? parent.level + 1 : 1;
      if (ele.indent == null) {
        ele.indent = parent ? parent.indent + "  " : ele.indent || "";
      }
      ele.path = parent ? parent.path + "." + ele.name : ele.name;
      ele.enabled = !!(this.multiple && !this.isDisabled(ele) && (ele.enabled || this.isSelected(ele)));
      if (!this.isDisabled(ele)) {
        this.longest = Math.max(this.longest, colors.unstyle(ele.message).length);
      }
      let choice = { ...ele };
      ele.reset = (input = choice.input, value = choice.value) => {
        for (let key of Object.keys(choice))
          ele[key] = choice[key];
        ele.input = input;
        ele.value = value;
      };
      if (origVal == null && typeof ele.initial === "function") {
        ele.input = await ele.initial.call(this, this.state, ele, i);
      }
      return ele;
    }
    async onChoice(choice, i) {
      this.emit("choice", choice, i, this);
      if (typeof choice.onChoice === "function") {
        await choice.onChoice.call(this, this.state, choice, i);
      }
    }
    async addChoice(ele, i, parent) {
      let choice = await this.toChoice(ele, i, parent);
      this.choices.push(choice);
      this.index = this.choices.length - 1;
      this.limit = this.choices.length;
      return choice;
    }
    async newItem(item, i, parent) {
      let ele = { name: "New choice name?", editable: true, newChoice: true, ...item };
      let choice = await this.addChoice(ele, i, parent);
      choice.updateChoice = () => {
        delete choice.newChoice;
        choice.name = choice.message = choice.input;
        choice.input = "";
        choice.cursor = 0;
      };
      return this.render();
    }
    indent(choice) {
      if (choice.indent == null) {
        return choice.level > 1 ? "  ".repeat(choice.level - 1) : "";
      }
      return choice.indent;
    }
    dispatch(s, key) {
      if (this.multiple && this[key.name])
        return this[key.name]();
      this.alert();
    }
    focus(choice, enabled) {
      if (typeof enabled !== "boolean")
        enabled = choice.enabled;
      if (enabled && !choice.enabled && this.selected.length >= this.maxSelected) {
        return this.alert();
      }
      this.index = choice.index;
      choice.enabled = enabled && !this.isDisabled(choice);
      return choice;
    }
    space() {
      if (!this.multiple)
        return this.alert();
      this.toggle(this.focused);
      return this.render();
    }
    a() {
      if (this.maxSelected < this.choices.length)
        return this.alert();
      let enabled = this.selectable.every((ch) => ch.enabled);
      this.choices.forEach((ch) => ch.enabled = !enabled);
      return this.render();
    }
    i() {
      if (this.choices.length - this.selected.length > this.maxSelected) {
        return this.alert();
      }
      this.choices.forEach((ch) => ch.enabled = !ch.enabled);
      return this.render();
    }
    g(choice = this.focused) {
      if (!this.choices.some((ch) => !!ch.parent))
        return this.a();
      this.toggle(choice.parent && !choice.choices ? choice.parent : choice);
      return this.render();
    }
    toggle(choice, enabled) {
      if (!choice.enabled && this.selected.length >= this.maxSelected) {
        return this.alert();
      }
      if (typeof enabled !== "boolean")
        enabled = !choice.enabled;
      choice.enabled = enabled;
      if (choice.choices) {
        choice.choices.forEach((ch) => this.toggle(ch, enabled));
      }
      let parent = choice.parent;
      while (parent) {
        let choices = parent.choices.filter((ch) => this.isDisabled(ch));
        parent.enabled = choices.every((ch) => ch.enabled === true);
        parent = parent.parent;
      }
      reset(this, this.choices);
      this.emit("toggle", choice, this);
      return choice;
    }
    enable(choice) {
      if (this.selected.length >= this.maxSelected)
        return this.alert();
      choice.enabled = !this.isDisabled(choice);
      choice.choices && choice.choices.forEach(this.enable.bind(this));
      return choice;
    }
    disable(choice) {
      choice.enabled = false;
      choice.choices && choice.choices.forEach(this.disable.bind(this));
      return choice;
    }
    number(n) {
      this.num += n;
      let number = (num) => {
        let i = Number(num);
        if (i > this.choices.length - 1)
          return this.alert();
        let focused = this.focused;
        let choice = this.choices.find((ch) => i === ch.index);
        if (!choice.enabled && this.selected.length >= this.maxSelected) {
          return this.alert();
        }
        if (this.visible.indexOf(choice) === -1) {
          let choices = reorder(this.choices);
          let actualIdx = choices.indexOf(choice);
          if (focused.index > actualIdx) {
            let start = choices.slice(actualIdx, actualIdx + this.limit);
            let end = choices.filter((ch) => !start.includes(ch));
            this.choices = start.concat(end);
          } else {
            let pos = actualIdx - this.limit + 1;
            this.choices = choices.slice(pos).concat(choices.slice(0, pos));
          }
        }
        this.index = this.choices.indexOf(choice);
        this.toggle(this.focused);
        return this.render();
      };
      clearTimeout(this.numberTimeout);
      return new Promise((resolve) => {
        let len = this.choices.length;
        let num = this.num;
        let handle = (val = false, res) => {
          clearTimeout(this.numberTimeout);
          if (val)
            res = number(num);
          this.num = "";
          resolve(res);
        };
        if (num === "0" || num.length === 1 && Number(num + "0") > len) {
          return handle(true);
        }
        if (Number(num) > len) {
          return handle(false, this.alert());
        }
        this.numberTimeout = setTimeout(() => handle(true), this.delay);
      });
    }
    home() {
      this.choices = reorder(this.choices);
      this.index = 0;
      return this.render();
    }
    end() {
      let pos = this.choices.length - this.limit;
      let choices = reorder(this.choices);
      this.choices = choices.slice(pos).concat(choices.slice(0, pos));
      this.index = this.limit - 1;
      return this.render();
    }
    first() {
      this.index = 0;
      return this.render();
    }
    last() {
      this.index = this.visible.length - 1;
      return this.render();
    }
    prev() {
      if (this.visible.length <= 1)
        return this.alert();
      return this.up();
    }
    next() {
      if (this.visible.length <= 1)
        return this.alert();
      return this.down();
    }
    right() {
      if (this.cursor >= this.input.length)
        return this.alert();
      this.cursor++;
      return this.render();
    }
    left() {
      if (this.cursor <= 0)
        return this.alert();
      this.cursor--;
      return this.render();
    }
    up() {
      let len = this.choices.length;
      let vis = this.visible.length;
      let idx = this.index;
      if (this.options.scroll === false && idx === 0) {
        return this.alert();
      }
      if (len > vis && idx === 0) {
        return this.scrollUp();
      }
      this.index = (idx - 1 % len + len) % len;
      if (this.isDisabled()) {
        return this.up();
      }
      return this.render();
    }
    down() {
      let len = this.choices.length;
      let vis = this.visible.length;
      let idx = this.index;
      if (this.options.scroll === false && idx === vis - 1) {
        return this.alert();
      }
      if (len > vis && idx === vis - 1) {
        return this.scrollDown();
      }
      this.index = (idx + 1) % len;
      if (this.isDisabled()) {
        return this.down();
      }
      return this.render();
    }
    scrollUp(i = 0) {
      this.choices = scrollUp(this.choices);
      this.index = i;
      if (this.isDisabled()) {
        return this.up();
      }
      return this.render();
    }
    scrollDown(i = this.visible.length - 1) {
      this.choices = scrollDown(this.choices);
      this.index = i;
      if (this.isDisabled()) {
        return this.down();
      }
      return this.render();
    }
    async shiftUp() {
      if (this.options.sort === true) {
        this.sorting = true;
        this.swap(this.index - 1);
        await this.up();
        this.sorting = false;
        return;
      }
      return this.scrollUp(this.index);
    }
    async shiftDown() {
      if (this.options.sort === true) {
        this.sorting = true;
        this.swap(this.index + 1);
        await this.down();
        this.sorting = false;
        return;
      }
      return this.scrollDown(this.index);
    }
    pageUp() {
      if (this.visible.length <= 1)
        return this.alert();
      this.limit = Math.max(this.limit - 1, 0);
      this.index = Math.min(this.limit - 1, this.index);
      this._limit = this.limit;
      if (this.isDisabled()) {
        return this.up();
      }
      return this.render();
    }
    pageDown() {
      if (this.visible.length >= this.choices.length)
        return this.alert();
      this.index = Math.max(0, this.index);
      this.limit = Math.min(this.limit + 1, this.choices.length);
      this._limit = this.limit;
      if (this.isDisabled()) {
        return this.down();
      }
      return this.render();
    }
    swap(pos) {
      swap(this.choices, this.index, pos);
    }
    isDisabled(choice = this.focused) {
      let keys3 = ["disabled", "collapsed", "hidden", "completing", "readonly"];
      if (choice && keys3.some((key) => choice[key] === true)) {
        return true;
      }
      return choice && choice.role === "heading";
    }
    isEnabled(choice = this.focused) {
      if (Array.isArray(choice))
        return choice.every((ch) => this.isEnabled(ch));
      if (choice.choices) {
        let choices = choice.choices.filter((ch) => !this.isDisabled(ch));
        return choice.enabled && choices.every((ch) => this.isEnabled(ch));
      }
      return choice.enabled && !this.isDisabled(choice);
    }
    isChoice(choice, value) {
      return choice.name === value || choice.index === Number(value);
    }
    isSelected(choice) {
      if (Array.isArray(this.initial)) {
        return this.initial.some((value) => this.isChoice(choice, value));
      }
      return this.isChoice(choice, this.initial);
    }
    map(names = [], prop = "value") {
      return [].concat(names || []).reduce((acc, name2) => {
        acc[name2] = this.find(name2, prop);
        return acc;
      }, {});
    }
    filter(value, prop) {
      let isChoice = (ele, i) => [ele.name, i].includes(value);
      let fn = typeof value === "function" ? value : isChoice;
      let choices = this.options.multiple ? this.state._choices : this.choices;
      let result = choices.filter(fn);
      if (prop) {
        return result.map((ch) => ch[prop]);
      }
      return result;
    }
    find(value, prop) {
      if (isObject(value))
        return prop ? value[prop] : value;
      let isChoice = (ele, i) => [ele.name, i].includes(value);
      let fn = typeof value === "function" ? value : isChoice;
      let choice = this.choices.find(fn);
      if (choice) {
        return prop ? choice[prop] : choice;
      }
    }
    findIndex(value) {
      return this.choices.indexOf(this.find(value));
    }
    async submit() {
      let choice = this.focused;
      if (!choice)
        return this.alert();
      if (choice.newChoice) {
        if (!choice.input)
          return this.alert();
        choice.updateChoice();
        return this.render();
      }
      if (this.choices.some((ch) => ch.newChoice)) {
        return this.alert();
      }
      let { reorder: reorder2, sort } = this.options;
      let multi = this.multiple === true;
      let value = this.selected;
      if (value === undefined) {
        return this.alert();
      }
      if (Array.isArray(value) && reorder2 !== false && sort !== true) {
        value = utils.reorder(value);
      }
      this.value = multi ? value.map((ch) => ch.name) : value.name;
      return super.submit();
    }
    set choices(choices = []) {
      this.state._choices = this.state._choices || [];
      this.state.choices = choices;
      for (let choice of choices) {
        if (!this.state._choices.some((ch) => ch.name === choice.name)) {
          this.state._choices.push(choice);
        }
      }
      if (!this._initial && this.options.initial) {
        this._initial = true;
        let init2 = this.initial;
        if (typeof init2 === "string" || typeof init2 === "number") {
          let choice = this.find(init2);
          if (choice) {
            this.initial = choice.index;
            this.focus(choice, true);
          }
        }
      }
    }
    get choices() {
      return reset(this, this.state.choices || []);
    }
    set visible(visible) {
      this.state.visible = visible;
    }
    get visible() {
      return (this.state.visible || this.choices).slice(0, this.limit);
    }
    set limit(num) {
      this.state.limit = num;
    }
    get limit() {
      let { state, options: options2, choices } = this;
      let limit = state.limit || this._limit || options2.limit || choices.length;
      return Math.min(limit, this.height);
    }
    set value(value) {
      super.value = value;
    }
    get value() {
      if (typeof super.value !== "string" && super.value === this.initial) {
        return this.input;
      }
      return super.value;
    }
    set index(i) {
      this.state.index = i;
    }
    get index() {
      return Math.max(0, this.state ? this.state.index : 0);
    }
    get enabled() {
      return this.filter(this.isEnabled.bind(this));
    }
    get focused() {
      let choice = this.choices[this.index];
      if (choice && this.state.submitted && this.multiple !== true) {
        choice.enabled = true;
      }
      return choice;
    }
    get selectable() {
      return this.choices.filter((choice) => !this.isDisabled(choice));
    }
    get selected() {
      return this.multiple ? this.enabled : this.focused;
    }
  }
  module2.exports = ArrayPrompt;
});

// ../../node_modules/enquirer/lib/prompts/select.js
var require_select = __commonJS((exports2, module2) => {
  var ArrayPrompt = require_array();
  var utils = require_utils5();

  class SelectPrompt extends ArrayPrompt {
    constructor(options2) {
      super(options2);
      this.emptyError = this.options.emptyError || "No items were selected";
    }
    async dispatch(s, key) {
      if (this.multiple) {
        return this[key.name] ? await this[key.name](s, key) : await super.dispatch(s, key);
      }
      this.alert();
    }
    separator() {
      if (this.options.separator)
        return super.separator();
      let sep = this.styles.muted(this.symbols.ellipsis);
      return this.state.submitted ? super.separator() : sep;
    }
    pointer(choice, i) {
      return !this.multiple || this.options.pointer ? super.pointer(choice, i) : "";
    }
    indicator(choice, i) {
      return this.multiple ? super.indicator(choice, i) : "";
    }
    choiceMessage(choice, i) {
      let message = this.resolve(choice.message, this.state, choice, i);
      if (choice.role === "heading" && !utils.hasColor(message)) {
        message = this.styles.strong(message);
      }
      return this.resolve(message, this.state, choice, i);
    }
    choiceSeparator() {
      return ":";
    }
    async renderChoice(choice, i) {
      await this.onChoice(choice, i);
      let focused = this.index === i;
      let pointer = await this.pointer(choice, i);
      let check = await this.indicator(choice, i) + (choice.pad || "");
      let hint = await this.resolve(choice.hint, this.state, choice, i);
      if (hint && !utils.hasColor(hint)) {
        hint = this.styles.muted(hint);
      }
      let ind = this.indent(choice);
      let msg = await this.choiceMessage(choice, i);
      let line = () => [this.margin[3], ind + pointer + check, msg, this.margin[1], hint].filter(Boolean).join(" ");
      if (choice.role === "heading") {
        return line();
      }
      if (choice.disabled) {
        if (!utils.hasColor(msg)) {
          msg = this.styles.disabled(msg);
        }
        return line();
      }
      if (focused) {
        msg = this.styles.em(msg);
      }
      return line();
    }
    async renderChoices() {
      if (this.state.loading === "choices") {
        return this.styles.warning("Loading choices");
      }
      if (this.state.submitted)
        return "";
      let choices = this.visible.map(async (ch, i) => await this.renderChoice(ch, i));
      let visible = await Promise.all(choices);
      if (!visible.length)
        visible.push(this.styles.danger("No matching choices"));
      let result = this.margin[0] + visible.join("\n");
      let header;
      if (this.options.choicesHeader) {
        header = await this.resolve(this.options.choicesHeader, this.state);
      }
      return [header, result].filter(Boolean).join("\n");
    }
    format() {
      if (!this.state.submitted || this.state.cancelled)
        return "";
      if (Array.isArray(this.selected)) {
        return this.selected.map((choice) => this.styles.primary(choice.name)).join(", ");
      }
      return this.styles.primary(this.selected.name);
    }
    async render() {
      let { submitted, size: size2 } = this.state;
      let prompt = "";
      let header = await this.header();
      let prefix = await this.prefix();
      let separator = await this.separator();
      let message = await this.message();
      if (this.options.promptLine !== false) {
        prompt = [prefix, message, separator, ""].join(" ");
        this.state.prompt = prompt;
      }
      let output = await this.format();
      let help = await this.error() || await this.hint();
      let body = await this.renderChoices();
      let footer = await this.footer();
      if (output)
        prompt += output;
      if (help && !prompt.includes(help))
        prompt += " " + help;
      if (submitted && !output && !body.trim() && this.multiple && this.emptyError != null) {
        prompt += this.styles.danger(this.emptyError);
      }
      this.clear(size2);
      this.write([header, prompt, body, footer].filter(Boolean).join("\n"));
      this.write(this.margin[2]);
      this.restore();
    }
  }
  module2.exports = SelectPrompt;
});

// ../../node_modules/enquirer/lib/prompts/autocomplete.js
var require_autocomplete = __commonJS((exports2, module2) => {
  var Select = require_select();
  var highlight = (input, color) => {
    let val = input.toLowerCase();
    return (str) => {
      let s = str.toLowerCase();
      let i = s.indexOf(val);
      let colored = color(str.slice(i, i + val.length));
      return i >= 0 ? str.slice(0, i) + colored + str.slice(i + val.length) : str;
    };
  };

  class AutoComplete extends Select {
    constructor(options2) {
      super(options2);
      this.cursorShow();
    }
    moveCursor(n) {
      this.state.cursor += n;
    }
    dispatch(ch) {
      return this.append(ch);
    }
    space(ch) {
      return this.options.multiple ? super.space(ch) : this.append(ch);
    }
    append(ch) {
      let { cursor, input } = this.state;
      this.input = input.slice(0, cursor) + ch + input.slice(cursor);
      this.moveCursor(1);
      return this.complete();
    }
    delete() {
      let { cursor, input } = this.state;
      if (!input)
        return this.alert();
      this.input = input.slice(0, cursor - 1) + input.slice(cursor);
      this.moveCursor(-1);
      return this.complete();
    }
    deleteForward() {
      let { cursor, input } = this.state;
      if (input[cursor] === undefined)
        return this.alert();
      this.input = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
      return this.complete();
    }
    number(ch) {
      return this.append(ch);
    }
    async complete() {
      this.completing = true;
      this.choices = await this.suggest(this.input, this.state._choices);
      this.state.limit = undefined;
      this.index = Math.min(Math.max(this.visible.length - 1, 0), this.index);
      await this.render();
      this.completing = false;
    }
    suggest(input = this.input, choices = this.state._choices) {
      if (typeof this.options.suggest === "function") {
        return this.options.suggest.call(this, input, choices);
      }
      let str = input.toLowerCase();
      return choices.filter((ch) => ch.message.toLowerCase().includes(str));
    }
    pointer() {
      return "";
    }
    format() {
      if (!this.focused)
        return this.input;
      if (this.options.multiple && this.state.submitted) {
        return this.selected.map((ch) => this.styles.primary(ch.message)).join(", ");
      }
      if (this.state.submitted) {
        let value = this.value = this.input = this.focused.value;
        return this.styles.primary(value);
      }
      return this.input;
    }
    async render() {
      if (this.state.status !== "pending")
        return super.render();
      let style = this.options.highlight ? this.options.highlight.bind(this) : this.styles.placeholder;
      let color = highlight(this.input, style);
      let choices = this.choices;
      this.choices = choices.map((ch) => ({ ...ch, message: color(ch.message) }));
      await super.render();
      this.choices = choices;
    }
    submit() {
      if (this.options.multiple) {
        this.value = this.selected.map((ch) => ch.name);
      }
      return super.submit();
    }
  }
  module2.exports = AutoComplete;
});

// ../../node_modules/enquirer/lib/placeholder.js
var require_placeholder = __commonJS((exports2, module2) => {
  var utils = require_utils5();
  module2.exports = (prompt, options2 = {}) => {
    prompt.cursorHide();
    let { input = "", initial = "", pos, showCursor = true, color } = options2;
    let style = color || prompt.styles.placeholder;
    let inverse = utils.inverse(prompt.styles.primary);
    let blinker = (str) => inverse(prompt.styles.black(str));
    let output = input;
    let char = " ";
    let reverse = blinker(char);
    if (prompt.blink && prompt.blink.off === true) {
      blinker = (str) => str;
      reverse = "";
    }
    if (showCursor && pos === 0 && initial === "" && input === "") {
      return blinker(char);
    }
    if (showCursor && pos === 0 && (input === initial || input === "")) {
      return blinker(initial[0]) + style(initial.slice(1));
    }
    initial = utils.isPrimitive(initial) ? `${initial}` : "";
    input = utils.isPrimitive(input) ? `${input}` : "";
    let placeholder = initial && initial.startsWith(input) && initial !== input;
    let cursor = placeholder ? blinker(initial[input.length]) : reverse;
    if (pos !== input.length && showCursor === true) {
      output = input.slice(0, pos) + blinker(input[pos]) + input.slice(pos + 1);
      cursor = "";
    }
    if (showCursor === false) {
      cursor = "";
    }
    if (placeholder) {
      let raw = prompt.styles.unstyle(output + cursor);
      return output + cursor + style(initial.slice(raw.length));
    }
    return output + cursor;
  };
});

// ../../node_modules/enquirer/lib/prompts/form.js
var require_form = __commonJS((exports2, module2) => {
  var colors = require_ansi_colors();
  var SelectPrompt = require_select();
  var placeholder = require_placeholder();

  class FormPrompt extends SelectPrompt {
    constructor(options2) {
      super({ ...options2, multiple: true });
      this.type = "form";
      this.initial = this.options.initial;
      this.align = [this.options.align, "right"].find((v) => v != null);
      this.emptyError = "";
      this.values = {};
    }
    async reset(first) {
      await super.reset();
      if (first === true)
        this._index = this.index;
      this.index = this._index;
      this.values = {};
      this.choices.forEach((choice) => choice.reset && choice.reset());
      return this.render();
    }
    dispatch(char) {
      return !!char && this.append(char);
    }
    append(char) {
      let choice = this.focused;
      if (!choice)
        return this.alert();
      let { cursor, input } = choice;
      choice.value = choice.input = input.slice(0, cursor) + char + input.slice(cursor);
      choice.cursor++;
      return this.render();
    }
    delete() {
      let choice = this.focused;
      if (!choice || choice.cursor <= 0)
        return this.alert();
      let { cursor, input } = choice;
      choice.value = choice.input = input.slice(0, cursor - 1) + input.slice(cursor);
      choice.cursor--;
      return this.render();
    }
    deleteForward() {
      let choice = this.focused;
      if (!choice)
        return this.alert();
      let { cursor, input } = choice;
      if (input[cursor] === undefined)
        return this.alert();
      let str = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
      choice.value = choice.input = str;
      return this.render();
    }
    right() {
      let choice = this.focused;
      if (!choice)
        return this.alert();
      if (choice.cursor >= choice.input.length)
        return this.alert();
      choice.cursor++;
      return this.render();
    }
    left() {
      let choice = this.focused;
      if (!choice)
        return this.alert();
      if (choice.cursor <= 0)
        return this.alert();
      choice.cursor--;
      return this.render();
    }
    space(ch, key) {
      return this.dispatch(ch, key);
    }
    number(ch, key) {
      return this.dispatch(ch, key);
    }
    next() {
      let ch = this.focused;
      if (!ch)
        return this.alert();
      let { initial, input } = ch;
      if (initial && initial.startsWith(input) && input !== initial) {
        ch.value = ch.input = initial;
        ch.cursor = ch.value.length;
        return this.render();
      }
      return super.next();
    }
    prev() {
      let ch = this.focused;
      if (!ch)
        return this.alert();
      if (ch.cursor === 0)
        return super.prev();
      ch.value = ch.input = "";
      ch.cursor = 0;
      return this.render();
    }
    separator() {
      return "";
    }
    format(value) {
      return !this.state.submitted ? super.format(value) : "";
    }
    pointer() {
      return "";
    }
    indicator(choice) {
      return choice.input ? "\u29BF" : "\u2299";
    }
    async choiceSeparator(choice, i) {
      let sep = await this.resolve(choice.separator, this.state, choice, i) || ":";
      return sep ? " " + this.styles.disabled(sep) : "";
    }
    async renderChoice(choice, i) {
      await this.onChoice(choice, i);
      let { state, styles } = this;
      let { cursor, initial = "", name: name2, hint, input = "" } = choice;
      let { muted, submitted, primary, danger } = styles;
      let help = hint;
      let focused = this.index === i;
      let validate2 = choice.validate || (() => true);
      let sep = await this.choiceSeparator(choice, i);
      let msg = choice.message;
      if (this.align === "right")
        msg = msg.padStart(this.longest + 1, " ");
      if (this.align === "left")
        msg = msg.padEnd(this.longest + 1, " ");
      let value = this.values[name2] = input || initial;
      let color = input ? "success" : "dark";
      if (await validate2.call(choice, value, this.state) !== true) {
        color = "danger";
      }
      let style = styles[color];
      let indicator = style(await this.indicator(choice, i)) + (choice.pad || "");
      let indent = this.indent(choice);
      let line = () => [indent, indicator, msg + sep, input, help].filter(Boolean).join(" ");
      if (state.submitted) {
        msg = colors.unstyle(msg);
        input = submitted(input);
        help = "";
        return line();
      }
      if (choice.format) {
        input = await choice.format.call(this, input, choice, i);
      } else {
        let color2 = this.styles.muted;
        let options2 = { input, initial, pos: cursor, showCursor: focused, color: color2 };
        input = placeholder(this, options2);
      }
      if (!this.isValue(input)) {
        input = this.styles.muted(this.symbols.ellipsis);
      }
      if (choice.result) {
        this.values[name2] = await choice.result.call(this, value, choice, i);
      }
      if (focused) {
        msg = primary(msg);
      }
      if (choice.error) {
        input += (input ? " " : "") + danger(choice.error.trim());
      } else if (choice.hint) {
        input += (input ? " " : "") + muted(choice.hint.trim());
      }
      return line();
    }
    async submit() {
      this.value = this.values;
      return super.base.submit.call(this);
    }
  }
  module2.exports = FormPrompt;
});

// ../../node_modules/enquirer/lib/types/auth.js
var require_auth2 = __commonJS((exports2, module2) => {
  var FormPrompt = require_form();
  var defaultAuthenticate = () => {
    throw new Error("expected prompt to have a custom authenticate method");
  };
  var factory = (authenticate = defaultAuthenticate) => {

    class AuthPrompt extends FormPrompt {
      constructor(options2) {
        super(options2);
      }
      async submit() {
        this.value = await authenticate.call(this, this.values, this.state);
        super.base.submit.call(this);
      }
      static create(authenticate2) {
        return factory(authenticate2);
      }
    }
    return AuthPrompt;
  };
  module2.exports = factory();
});

// ../../node_modules/enquirer/lib/prompts/basicauth.js
var require_basicauth = __commonJS((exports2, module2) => {
  var defaultAuthenticate = function(value, state) {
    if (value.username === this.options.username && value.password === this.options.password) {
      return true;
    }
    return false;
  };
  var AuthPrompt = require_auth2();
  var factory = (authenticate = defaultAuthenticate) => {
    const choices = [
      { name: "username", message: "username" },
      {
        name: "password",
        message: "password",
        format(input) {
          if (this.options.showPassword) {
            return input;
          }
          let color = this.state.submitted ? this.styles.primary : this.styles.muted;
          return color(this.symbols.asterisk.repeat(input.length));
        }
      }
    ];

    class BasicAuthPrompt extends AuthPrompt.create(authenticate) {
      constructor(options2) {
        super({ ...options2, choices });
      }
      static create(authenticate2) {
        return factory(authenticate2);
      }
    }
    return BasicAuthPrompt;
  };
  module2.exports = factory();
});

// ../../node_modules/enquirer/lib/types/boolean.js
var require_boolean = __commonJS((exports2, module2) => {
  var Prompt = require_prompt();
  var { isPrimitive, hasColor } = require_utils5();

  class BooleanPrompt extends Prompt {
    constructor(options2) {
      super(options2);
      this.cursorHide();
    }
    async initialize() {
      let initial = await this.resolve(this.initial, this.state);
      this.input = await this.cast(initial);
      await super.initialize();
    }
    dispatch(ch) {
      if (!this.isValue(ch))
        return this.alert();
      this.input = ch;
      return this.submit();
    }
    format(value) {
      let { styles, state } = this;
      return !state.submitted ? styles.primary(value) : styles.success(value);
    }
    cast(input) {
      return this.isTrue(input);
    }
    isTrue(input) {
      return /^[ty1]/i.test(input);
    }
    isFalse(input) {
      return /^[fn0]/i.test(input);
    }
    isValue(value) {
      return isPrimitive(value) && (this.isTrue(value) || this.isFalse(value));
    }
    async hint() {
      if (this.state.status === "pending") {
        let hint = await this.element("hint");
        if (!hasColor(hint)) {
          return this.styles.muted(hint);
        }
        return hint;
      }
    }
    async render() {
      let { input, size: size2 } = this.state;
      let prefix = await this.prefix();
      let sep = await this.separator();
      let msg = await this.message();
      let hint = this.styles.muted(this.default);
      let promptLine = [prefix, msg, hint, sep].filter(Boolean).join(" ");
      this.state.prompt = promptLine;
      let header = await this.header();
      let value = this.value = this.cast(input);
      let output = await this.format(value);
      let help = await this.error() || await this.hint();
      let footer = await this.footer();
      if (help && !promptLine.includes(help))
        output += " " + help;
      promptLine += " " + output;
      this.clear(size2);
      this.write([header, promptLine, footer].filter(Boolean).join("\n"));
      this.restore();
    }
    set value(value) {
      super.value = value;
    }
    get value() {
      return this.cast(super.value);
    }
  }
  module2.exports = BooleanPrompt;
});

// ../../node_modules/enquirer/lib/prompts/confirm.js
var require_confirm = __commonJS((exports2, module2) => {
  var BooleanPrompt = require_boolean();

  class ConfirmPrompt extends BooleanPrompt {
    constructor(options2) {
      super(options2);
      this.default = this.options.default || (this.initial ? "(Y/n)" : "(y/N)");
    }
  }
  module2.exports = ConfirmPrompt;
});

// ../../node_modules/enquirer/lib/prompts/editable.js
var require_editable = __commonJS((exports2, module2) => {
  var Select = require_select();
  var Form = require_form();
  var form = Form.prototype;

  class Editable extends Select {
    constructor(options2) {
      super({ ...options2, multiple: true });
      this.align = [this.options.align, "left"].find((v) => v != null);
      this.emptyError = "";
      this.values = {};
    }
    dispatch(char, key) {
      let choice = this.focused;
      let parent = choice.parent || {};
      if (!choice.editable && !parent.editable) {
        if (char === "a" || char === "i")
          return super[char]();
      }
      return form.dispatch.call(this, char, key);
    }
    append(char, key) {
      return form.append.call(this, char, key);
    }
    delete(char, key) {
      return form.delete.call(this, char, key);
    }
    space(char) {
      return this.focused.editable ? this.append(char) : super.space();
    }
    number(char) {
      return this.focused.editable ? this.append(char) : super.number(char);
    }
    next() {
      return this.focused.editable ? form.next.call(this) : super.next();
    }
    prev() {
      return this.focused.editable ? form.prev.call(this) : super.prev();
    }
    async indicator(choice, i) {
      let symbol = choice.indicator || "";
      let value = choice.editable ? symbol : super.indicator(choice, i);
      return await this.resolve(value, this.state, choice, i) || "";
    }
    indent(choice) {
      return choice.role === "heading" ? "" : choice.editable ? " " : "  ";
    }
    async renderChoice(choice, i) {
      choice.indent = "";
      if (choice.editable)
        return form.renderChoice.call(this, choice, i);
      return super.renderChoice(choice, i);
    }
    error() {
      return "";
    }
    footer() {
      return this.state.error;
    }
    async validate() {
      let result = true;
      for (let choice of this.choices) {
        if (typeof choice.validate !== "function") {
          continue;
        }
        if (choice.role === "heading") {
          continue;
        }
        let val = choice.parent ? this.value[choice.parent.name] : this.value;
        if (choice.editable) {
          val = choice.value === choice.name ? choice.initial || "" : choice.value;
        } else if (!this.isDisabled(choice)) {
          val = choice.enabled === true;
        }
        result = await choice.validate(val, this.state);
        if (result !== true) {
          break;
        }
      }
      if (result !== true) {
        this.state.error = typeof result === "string" ? result : "Invalid Input";
      }
      return result;
    }
    submit() {
      if (this.focused.newChoice === true)
        return super.submit();
      if (this.choices.some((ch) => ch.newChoice)) {
        return this.alert();
      }
      this.value = {};
      for (let choice of this.choices) {
        let val = choice.parent ? this.value[choice.parent.name] : this.value;
        if (choice.role === "heading") {
          this.value[choice.name] = {};
          continue;
        }
        if (choice.editable) {
          val[choice.name] = choice.value === choice.name ? choice.initial || "" : choice.value;
        } else if (!this.isDisabled(choice)) {
          val[choice.name] = choice.enabled === true;
        }
      }
      return this.base.submit.call(this);
    }
  }
  module2.exports = Editable;
});

// ../../node_modules/enquirer/lib/types/string.js
var require_string = __commonJS((exports2, module2) => {
  var Prompt = require_prompt();
  var placeholder = require_placeholder();
  var { isPrimitive } = require_utils5();

  class StringPrompt extends Prompt {
    constructor(options2) {
      super(options2);
      this.initial = isPrimitive(this.initial) ? String(this.initial) : "";
      if (this.initial)
        this.cursorHide();
      this.state.prevCursor = 0;
      this.state.clipboard = [];
    }
    async keypress(input, key = {}) {
      let prev = this.state.prevKeypress;
      this.state.prevKeypress = key;
      if (this.options.multiline === true && key.name === "return") {
        if (!prev || prev.name !== "return") {
          return this.append("\n", key);
        }
      }
      return super.keypress(input, key);
    }
    moveCursor(n) {
      this.cursor += n;
    }
    reset() {
      this.input = this.value = "";
      this.cursor = 0;
      return this.render();
    }
    dispatch(ch, key) {
      if (!ch || key.ctrl || key.code)
        return this.alert();
      this.append(ch);
    }
    append(ch) {
      let { cursor, input } = this.state;
      this.input = `${input}`.slice(0, cursor) + ch + `${input}`.slice(cursor);
      this.moveCursor(String(ch).length);
      this.render();
    }
    insert(str) {
      this.append(str);
    }
    delete() {
      let { cursor, input } = this.state;
      if (cursor <= 0)
        return this.alert();
      this.input = `${input}`.slice(0, cursor - 1) + `${input}`.slice(cursor);
      this.moveCursor(-1);
      this.render();
    }
    deleteForward() {
      let { cursor, input } = this.state;
      if (input[cursor] === undefined)
        return this.alert();
      this.input = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
      this.render();
    }
    cutForward() {
      let pos = this.cursor;
      if (this.input.length <= pos)
        return this.alert();
      this.state.clipboard.push(this.input.slice(pos));
      this.input = this.input.slice(0, pos);
      this.render();
    }
    cutLeft() {
      let pos = this.cursor;
      if (pos === 0)
        return this.alert();
      let before = this.input.slice(0, pos);
      let after = this.input.slice(pos);
      let words = before.split(" ");
      this.state.clipboard.push(words.pop());
      this.input = words.join(" ");
      this.cursor = this.input.length;
      this.input += after;
      this.render();
    }
    paste() {
      if (!this.state.clipboard.length)
        return this.alert();
      this.insert(this.state.clipboard.pop());
      this.render();
    }
    toggleCursor() {
      if (this.state.prevCursor) {
        this.cursor = this.state.prevCursor;
        this.state.prevCursor = 0;
      } else {
        this.state.prevCursor = this.cursor;
        this.cursor = 0;
      }
      this.render();
    }
    first() {
      this.cursor = 0;
      this.render();
    }
    last() {
      this.cursor = this.input.length - 1;
      this.render();
    }
    next() {
      let init2 = this.initial != null ? String(this.initial) : "";
      if (!init2 || !init2.startsWith(this.input))
        return this.alert();
      this.input = this.initial;
      this.cursor = this.initial.length;
      this.render();
    }
    prev() {
      if (!this.input)
        return this.alert();
      this.reset();
    }
    backward() {
      return this.left();
    }
    forward() {
      return this.right();
    }
    right() {
      if (this.cursor >= this.input.length)
        return this.alert();
      this.moveCursor(1);
      return this.render();
    }
    left() {
      if (this.cursor <= 0)
        return this.alert();
      this.moveCursor(-1);
      return this.render();
    }
    isValue(value) {
      return !!value;
    }
    async format(input = this.value) {
      let initial = await this.resolve(this.initial, this.state);
      if (!this.state.submitted) {
        return placeholder(this, { input, initial, pos: this.cursor });
      }
      return this.styles.submitted(input || initial);
    }
    async render() {
      let size2 = this.state.size;
      let prefix = await this.prefix();
      let separator = await this.separator();
      let message = await this.message();
      let prompt = [prefix, message, separator].filter(Boolean).join(" ");
      this.state.prompt = prompt;
      let header = await this.header();
      let output = await this.format();
      let help = await this.error() || await this.hint();
      let footer = await this.footer();
      if (help && !output.includes(help))
        output += " " + help;
      prompt += " " + output;
      this.clear(size2);
      this.write([header, prompt, footer].filter(Boolean).join("\n"));
      this.restore();
    }
  }
  module2.exports = StringPrompt;
});

// ../../node_modules/enquirer/lib/completer.js
var require_completer = __commonJS((exports2, module2) => {
  var unique = (arr) => arr.filter((v, i) => arr.lastIndexOf(v) === i);
  var compact = (arr) => unique(arr).filter(Boolean);
  module2.exports = (action, data = {}, value = "") => {
    let { past = [], present = "" } = data;
    let rest, prev;
    switch (action) {
      case "prev":
      case "undo":
        rest = past.slice(0, past.length - 1);
        prev = past[past.length - 1] || "";
        return {
          past: compact([value, ...rest]),
          present: prev
        };
      case "next":
      case "redo":
        rest = past.slice(1);
        prev = past[0] || "";
        return {
          past: compact([...rest, value]),
          present: prev
        };
      case "save":
        return {
          past: compact([...past, value]),
          present: ""
        };
      case "remove":
        prev = compact(past.filter((v) => v !== value));
        present = "";
        if (prev.length) {
          present = prev.pop();
        }
        return {
          past: prev,
          present
        };
      default: {
        throw new Error(`Invalid action: "${action}"`);
      }
    }
  };
});

// ../../node_modules/enquirer/lib/prompts/input.js
var require_input = __commonJS((exports2, module2) => {
  var Prompt = require_string();
  var completer = require_completer();

  class Input extends Prompt {
    constructor(options2) {
      super(options2);
      let history = this.options.history;
      if (history && history.store) {
        let initial = history.values || this.initial;
        this.autosave = !!history.autosave;
        this.store = history.store;
        this.data = this.store.get("values") || { past: [], present: initial };
        this.initial = this.data.present || this.data.past[this.data.past.length - 1];
      }
    }
    completion(action) {
      if (!this.store)
        return this.alert();
      this.data = completer(action, this.data, this.input);
      if (!this.data.present)
        return this.alert();
      this.input = this.data.present;
      this.cursor = this.input.length;
      return this.render();
    }
    altUp() {
      return this.completion("prev");
    }
    altDown() {
      return this.completion("next");
    }
    prev() {
      this.save();
      return super.prev();
    }
    save() {
      if (!this.store)
        return;
      this.data = completer("save", this.data, this.input);
      this.store.set("values", this.data);
    }
    submit() {
      if (this.store && this.autosave === true) {
        this.save();
      }
      return super.submit();
    }
  }
  module2.exports = Input;
});

// ../../node_modules/enquirer/lib/prompts/invisible.js
var require_invisible = __commonJS((exports2, module2) => {
  var StringPrompt = require_string();

  class InvisiblePrompt extends StringPrompt {
    format() {
      return "";
    }
  }
  module2.exports = InvisiblePrompt;
});

// ../../node_modules/enquirer/lib/prompts/list.js
var require_list = __commonJS((exports2, module2) => {
  var StringPrompt = require_string();

  class ListPrompt extends StringPrompt {
    constructor(options2 = {}) {
      super(options2);
      this.sep = this.options.separator || /, */;
      this.initial = options2.initial || "";
    }
    split(input = this.value) {
      return input ? String(input).split(this.sep) : [];
    }
    format() {
      let style = this.state.submitted ? this.styles.primary : (val) => val;
      return this.list.map(style).join(", ");
    }
    async submit(value) {
      let result = this.state.error || await this.validate(this.list, this.state);
      if (result !== true) {
        this.state.error = result;
        return super.submit();
      }
      this.value = this.list;
      return super.submit();
    }
    get list() {
      return this.split();
    }
  }
  module2.exports = ListPrompt;
});

// ../../node_modules/enquirer/lib/prompts/multiselect.js
var require_multiselect = __commonJS((exports2, module2) => {
  var Select = require_select();

  class MultiSelect extends Select {
    constructor(options2) {
      super({ ...options2, multiple: true });
    }
  }
  module2.exports = MultiSelect;
});

// ../../node_modules/enquirer/lib/types/number.js
var require_number = __commonJS((exports2, module2) => {
  var StringPrompt = require_string();

  class NumberPrompt extends StringPrompt {
    constructor(options2 = {}) {
      super({ style: "number", ...options2 });
      this.min = this.isValue(options2.min) ? this.toNumber(options2.min) : -Infinity;
      this.max = this.isValue(options2.max) ? this.toNumber(options2.max) : Infinity;
      this.delay = options2.delay != null ? options2.delay : 1000;
      this.float = options2.float !== false;
      this.round = options2.round === true || options2.float === false;
      this.major = options2.major || 10;
      this.minor = options2.minor || 1;
      this.initial = options2.initial != null ? options2.initial : "";
      this.input = String(this.initial);
      this.cursor = this.input.length;
      this.cursorShow();
    }
    append(ch) {
      if (!/[-+.]/.test(ch) || ch === "." && this.input.includes(".")) {
        return this.alert("invalid number");
      }
      return super.append(ch);
    }
    number(ch) {
      return super.append(ch);
    }
    next() {
      if (this.input && this.input !== this.initial)
        return this.alert();
      if (!this.isValue(this.initial))
        return this.alert();
      this.input = this.initial;
      this.cursor = String(this.initial).length;
      return this.render();
    }
    up(number) {
      let step = number || this.minor;
      let num = this.toNumber(this.input);
      if (num > this.max + step)
        return this.alert();
      this.input = `${num + step}`;
      return this.render();
    }
    down(number) {
      let step = number || this.minor;
      let num = this.toNumber(this.input);
      if (num < this.min - step)
        return this.alert();
      this.input = `${num - step}`;
      return this.render();
    }
    shiftDown() {
      return this.down(this.major);
    }
    shiftUp() {
      return this.up(this.major);
    }
    format(input = this.input) {
      if (typeof this.options.format === "function") {
        return this.options.format.call(this, input);
      }
      return this.styles.info(input);
    }
    toNumber(value = "") {
      return this.float ? +value : Math.round(+value);
    }
    isValue(value) {
      return /^[-+]?[0-9]+((\.)|(\.[0-9]+))?$/.test(value);
    }
    submit() {
      let value = [this.input, this.initial].find((v) => this.isValue(v));
      this.value = this.toNumber(value || 0);
      return super.submit();
    }
  }
  module2.exports = NumberPrompt;
});

// ../../node_modules/enquirer/lib/prompts/password.js
var require_password = __commonJS((exports2, module2) => {
  var StringPrompt = require_string();

  class PasswordPrompt extends StringPrompt {
    constructor(options2) {
      super(options2);
      this.cursorShow();
    }
    format(input = this.input) {
      if (!this.keypressed)
        return "";
      let color = this.state.submitted ? this.styles.primary : this.styles.muted;
      return color(this.symbols.asterisk.repeat(input.length));
    }
  }
  module2.exports = PasswordPrompt;
});

// ../../node_modules/enquirer/lib/prompts/scale.js
var require_scale = __commonJS((exports2, module2) => {
  var colors = require_ansi_colors();
  var ArrayPrompt = require_array();
  var utils = require_utils5();

  class LikertScale extends ArrayPrompt {
    constructor(options2 = {}) {
      super(options2);
      this.widths = [].concat(options2.messageWidth || 50);
      this.align = [].concat(options2.align || "left");
      this.linebreak = options2.linebreak || false;
      this.edgeLength = options2.edgeLength || 3;
      this.newline = options2.newline || "\n   ";
      let start = options2.startNumber || 1;
      if (typeof this.scale === "number") {
        this.scaleKey = false;
        this.scale = Array(this.scale).fill(0).map((v, i) => ({ name: i + start }));
      }
    }
    async reset() {
      this.tableized = false;
      await super.reset();
      return this.render();
    }
    tableize() {
      if (this.tableized === true)
        return;
      this.tableized = true;
      let longest = 0;
      for (let ch of this.choices) {
        longest = Math.max(longest, ch.message.length);
        ch.scaleIndex = ch.initial || 2;
        ch.scale = [];
        for (let i = 0;i < this.scale.length; i++) {
          ch.scale.push({ index: i });
        }
      }
      this.widths[0] = Math.min(this.widths[0], longest + 3);
    }
    async dispatch(s, key) {
      if (this.multiple) {
        return this[key.name] ? await this[key.name](s, key) : await super.dispatch(s, key);
      }
      this.alert();
    }
    heading(msg, item, i) {
      return this.styles.strong(msg);
    }
    separator() {
      return this.styles.muted(this.symbols.ellipsis);
    }
    right() {
      let choice = this.focused;
      if (choice.scaleIndex >= this.scale.length - 1)
        return this.alert();
      choice.scaleIndex++;
      return this.render();
    }
    left() {
      let choice = this.focused;
      if (choice.scaleIndex <= 0)
        return this.alert();
      choice.scaleIndex--;
      return this.render();
    }
    indent() {
      return "";
    }
    format() {
      if (this.state.submitted) {
        let values = this.choices.map((ch) => this.styles.info(ch.index));
        return values.join(", ");
      }
      return "";
    }
    pointer() {
      return "";
    }
    renderScaleKey() {
      if (this.scaleKey === false)
        return "";
      if (this.state.submitted)
        return "";
      let scale = this.scale.map((item) => `   ${item.name} - ${item.message}`);
      let key = ["", ...scale].map((item) => this.styles.muted(item));
      return key.join("\n");
    }
    renderScaleHeading(max4) {
      let keys3 = this.scale.map((ele) => ele.name);
      if (typeof this.options.renderScaleHeading === "function") {
        keys3 = this.options.renderScaleHeading.call(this, max4);
      }
      let diff = this.scaleLength - keys3.join("").length;
      let spacing = Math.round(diff / (keys3.length - 1));
      let names = keys3.map((key) => this.styles.strong(key));
      let headings = names.join(" ".repeat(spacing));
      let padding = " ".repeat(this.widths[0]);
      return this.margin[3] + padding + this.margin[1] + headings;
    }
    scaleIndicator(choice, item, i) {
      if (typeof this.options.scaleIndicator === "function") {
        return this.options.scaleIndicator.call(this, choice, item, i);
      }
      let enabled = choice.scaleIndex === item.index;
      if (item.disabled)
        return this.styles.hint(this.symbols.radio.disabled);
      if (enabled)
        return this.styles.success(this.symbols.radio.on);
      return this.symbols.radio.off;
    }
    renderScale(choice, i) {
      let scale = choice.scale.map((item) => this.scaleIndicator(choice, item, i));
      let padding = this.term === "Hyper" ? "" : " ";
      return scale.join(padding + this.symbols.line.repeat(this.edgeLength));
    }
    async renderChoice(choice, i) {
      await this.onChoice(choice, i);
      let focused = this.index === i;
      let pointer = await this.pointer(choice, i);
      let hint = await choice.hint;
      if (hint && !utils.hasColor(hint)) {
        hint = this.styles.muted(hint);
      }
      let pad = (str) => this.margin[3] + str.replace(/\s+$/, "").padEnd(this.widths[0], " ");
      let newline = this.newline;
      let ind = this.indent(choice);
      let message = await this.resolve(choice.message, this.state, choice, i);
      let scale = await this.renderScale(choice, i);
      let margin = this.margin[1] + this.margin[3];
      this.scaleLength = colors.unstyle(scale).length;
      this.widths[0] = Math.min(this.widths[0], this.width - this.scaleLength - margin.length);
      let msg = utils.wordWrap(message, { width: this.widths[0], newline });
      let lines = msg.split("\n").map((line) => pad(line) + this.margin[1]);
      if (focused) {
        scale = this.styles.info(scale);
        lines = lines.map((line) => this.styles.info(line));
      }
      lines[0] += scale;
      if (this.linebreak)
        lines.push("");
      return [ind + pointer, lines.join("\n")].filter(Boolean);
    }
    async renderChoices() {
      if (this.state.submitted)
        return "";
      this.tableize();
      let choices = this.visible.map(async (ch, i) => await this.renderChoice(ch, i));
      let visible = await Promise.all(choices);
      let heading = await this.renderScaleHeading();
      return this.margin[0] + [heading, ...visible.map((v) => v.join(" "))].join("\n");
    }
    async render() {
      let { submitted, size: size2 } = this.state;
      let prefix = await this.prefix();
      let separator = await this.separator();
      let message = await this.message();
      let prompt = "";
      if (this.options.promptLine !== false) {
        prompt = [prefix, message, separator, ""].join(" ");
        this.state.prompt = prompt;
      }
      let header = await this.header();
      let output = await this.format();
      let key = await this.renderScaleKey();
      let help = await this.error() || await this.hint();
      let body = await this.renderChoices();
      let footer = await this.footer();
      let err = this.emptyError;
      if (output)
        prompt += output;
      if (help && !prompt.includes(help))
        prompt += " " + help;
      if (submitted && !output && !body.trim() && this.multiple && err != null) {
        prompt += this.styles.danger(err);
      }
      this.clear(size2);
      this.write([header, prompt, key, body, footer].filter(Boolean).join("\n"));
      if (!this.state.submitted) {
        this.write(this.margin[2]);
      }
      this.restore();
    }
    submit() {
      this.value = {};
      for (let choice of this.choices) {
        this.value[choice.name] = choice.scaleIndex;
      }
      return this.base.submit.call(this);
    }
  }
  module2.exports = LikertScale;
});

// ../../node_modules/enquirer/lib/interpolate.js
var require_interpolate = __commonJS((exports2, module2) => {
  var createFn = function(prop, prompt, options2, fallback) {
    return (value, state, item, index) => {
      if (typeof item.field[prop] === "function") {
        return item.field[prop].call(prompt, value, state, item, index);
      }
      return [fallback, value].find((v) => prompt.isValue(v));
    };
  };
  var colors = require_ansi_colors();
  var clean = (str = "") => {
    return typeof str === "string" ? str.replace(/^['"]|['"]$/g, "") : "";
  };

  class Item2 {
    constructor(token) {
      this.name = token.key;
      this.field = token.field || {};
      this.value = clean(token.initial || this.field.initial || "");
      this.message = token.message || this.name;
      this.cursor = 0;
      this.input = "";
      this.lines = [];
    }
  }
  var tokenize = async (options2 = {}, defaults = {}, fn = (token) => token) => {
    let unique = new Set;
    let fields = options2.fields || [];
    let input = options2.template;
    let tabstops = [];
    let items = [];
    let keys3 = [];
    let line = 1;
    if (typeof input === "function") {
      input = await input();
    }
    let i = -1;
    let next = () => input[++i];
    let peek = () => input[i + 1];
    let push = (token) => {
      token.line = line;
      tabstops.push(token);
    };
    push({ type: "bos", value: "" });
    while (i < input.length - 1) {
      let value = next();
      if (/^[^\S\n ]$/.test(value)) {
        push({ type: "text", value });
        continue;
      }
      if (value === "\n") {
        push({ type: "newline", value });
        line++;
        continue;
      }
      if (value === "\\") {
        value += next();
        push({ type: "text", value });
        continue;
      }
      if ((value === "$" || value === "#" || value === "{") && peek() === "{") {
        let n = next();
        value += n;
        let token = { type: "template", open: value, inner: "", close: "", value };
        let ch;
        while (ch = next()) {
          if (ch === "}") {
            if (peek() === "}")
              ch += next();
            token.value += ch;
            token.close = ch;
            break;
          }
          if (ch === ":") {
            token.initial = "";
            token.key = token.inner;
          } else if (token.initial !== undefined) {
            token.initial += ch;
          }
          token.value += ch;
          token.inner += ch;
        }
        token.template = token.open + (token.initial || token.inner) + token.close;
        token.key = token.key || token.inner;
        if (defaults.hasOwnProperty(token.key)) {
          token.initial = defaults[token.key];
        }
        token = fn(token);
        push(token);
        keys3.push(token.key);
        unique.add(token.key);
        let item = items.find((item2) => item2.name === token.key);
        token.field = fields.find((ch2) => ch2.name === token.key);
        if (!item) {
          item = new Item2(token);
          items.push(item);
        }
        item.lines.push(token.line - 1);
        continue;
      }
      let last2 = tabstops[tabstops.length - 1];
      if (last2.type === "text" && last2.line === line) {
        last2.value += value;
      } else {
        push({ type: "text", value });
      }
    }
    push({ type: "eos", value: "" });
    return { input, tabstops, unique, keys: keys3, items };
  };
  module2.exports = async (prompt) => {
    let options2 = prompt.options;
    let required = new Set(options2.required === true ? [] : options2.required || []);
    let defaults = { ...options2.values, ...options2.initial };
    let { tabstops, items, keys: keys3 } = await tokenize(options2, defaults);
    let result = createFn("result", prompt, options2);
    let format = createFn("format", prompt, options2);
    let isValid = createFn("validate", prompt, options2, true);
    let isVal = prompt.isValue.bind(prompt);
    return async (state = {}, submitted = false) => {
      let index = 0;
      state.required = required;
      state.items = items;
      state.keys = keys3;
      state.output = "";
      let validate2 = async (value, state2, item, index2) => {
        let error = await isValid(value, state2, item, index2);
        if (error === false) {
          return "Invalid field " + item.name;
        }
        return error;
      };
      for (let token of tabstops) {
        let value = token.value;
        let key = token.key;
        if (token.type !== "template") {
          if (value)
            state.output += value;
          continue;
        }
        if (token.type === "template") {
          let item = items.find((ch) => ch.name === key);
          if (options2.required === true) {
            state.required.add(item.name);
          }
          let val = [item.input, state.values[item.value], item.value, value].find(isVal);
          let field = item.field || {};
          let message = field.message || token.inner;
          if (submitted) {
            let error = await validate2(state.values[key], state, item, index);
            if (error && typeof error === "string" || error === false) {
              state.invalid.set(key, error);
              continue;
            }
            state.invalid.delete(key);
            let res = await result(state.values[key], state, item, index);
            state.output += colors.unstyle(res);
            continue;
          }
          item.placeholder = false;
          let before = value;
          value = await format(value, state, item, index);
          if (val !== value) {
            state.values[key] = val;
            value = prompt.styles.typing(val);
            state.missing.delete(message);
          } else {
            state.values[key] = undefined;
            val = `<${message}>`;
            value = prompt.styles.primary(val);
            item.placeholder = true;
            if (state.required.has(key)) {
              state.missing.add(message);
            }
          }
          if (state.missing.has(message) && state.validating) {
            value = prompt.styles.warning(val);
          }
          if (state.invalid.has(key) && state.validating) {
            value = prompt.styles.danger(val);
          }
          if (index === state.index) {
            if (before !== value) {
              value = prompt.styles.underline(value);
            } else {
              value = prompt.styles.heading(colors.unstyle(value));
            }
          }
          index++;
        }
        if (value) {
          state.output += value;
        }
      }
      let lines = state.output.split("\n").map((l) => " " + l);
      let len = items.length;
      let done = 0;
      for (let item of items) {
        if (state.invalid.has(item.name)) {
          item.lines.forEach((i) => {
            if (lines[i][0] !== " ")
              return;
            lines[i] = state.styles.danger(state.symbols.bullet) + lines[i].slice(1);
          });
        }
        if (prompt.isValue(state.values[item.name])) {
          done++;
        }
      }
      state.completed = (done / len * 100).toFixed(0);
      state.output = lines.join("\n");
      return state.output;
    };
  };
});

// ../../node_modules/enquirer/lib/prompts/snippet.js
var require_snippet2 = __commonJS((exports2, module2) => {
  var colors = require_ansi_colors();
  var interpolate = require_interpolate();
  var Prompt = require_prompt();

  class SnippetPrompt extends Prompt {
    constructor(options2) {
      super(options2);
      this.cursorHide();
      this.reset(true);
    }
    async initialize() {
      this.interpolate = await interpolate(this);
      await super.initialize();
    }
    async reset(first) {
      this.state.keys = [];
      this.state.invalid = new Map;
      this.state.missing = new Set;
      this.state.completed = 0;
      this.state.values = {};
      if (first !== true) {
        await this.initialize();
        await this.render();
      }
    }
    moveCursor(n) {
      let item = this.getItem();
      this.cursor += n;
      item.cursor += n;
    }
    dispatch(ch, key) {
      if (!key.code && !key.ctrl && ch != null && this.getItem()) {
        this.append(ch, key);
        return;
      }
      this.alert();
    }
    append(ch, key) {
      let item = this.getItem();
      let prefix = item.input.slice(0, this.cursor);
      let suffix = item.input.slice(this.cursor);
      this.input = item.input = `${prefix}${ch}${suffix}`;
      this.moveCursor(1);
      this.render();
    }
    delete() {
      let item = this.getItem();
      if (this.cursor <= 0 || !item.input)
        return this.alert();
      let suffix = item.input.slice(this.cursor);
      let prefix = item.input.slice(0, this.cursor - 1);
      this.input = item.input = `${prefix}${suffix}`;
      this.moveCursor(-1);
      this.render();
    }
    increment(i) {
      return i >= this.state.keys.length - 1 ? 0 : i + 1;
    }
    decrement(i) {
      return i <= 0 ? this.state.keys.length - 1 : i - 1;
    }
    first() {
      this.state.index = 0;
      this.render();
    }
    last() {
      this.state.index = this.state.keys.length - 1;
      this.render();
    }
    right() {
      if (this.cursor >= this.input.length)
        return this.alert();
      this.moveCursor(1);
      this.render();
    }
    left() {
      if (this.cursor <= 0)
        return this.alert();
      this.moveCursor(-1);
      this.render();
    }
    prev() {
      this.state.index = this.decrement(this.state.index);
      this.getItem();
      this.render();
    }
    next() {
      this.state.index = this.increment(this.state.index);
      this.getItem();
      this.render();
    }
    up() {
      this.prev();
    }
    down() {
      this.next();
    }
    format(value) {
      let color = this.state.completed < 100 ? this.styles.warning : this.styles.success;
      if (this.state.submitted === true && this.state.completed !== 100) {
        color = this.styles.danger;
      }
      return color(`${this.state.completed}% completed`);
    }
    async render() {
      let { index, keys: keys3 = [], submitted, size: size2 } = this.state;
      let newline = [this.options.newline, "\n"].find((v) => v != null);
      let prefix = await this.prefix();
      let separator = await this.separator();
      let message = await this.message();
      let prompt = [prefix, message, separator].filter(Boolean).join(" ");
      this.state.prompt = prompt;
      let header = await this.header();
      let error = await this.error() || "";
      let hint = await this.hint() || "";
      let body = submitted ? "" : await this.interpolate(this.state);
      let key = this.state.key = keys3[index] || "";
      let input = await this.format(key);
      let footer = await this.footer();
      if (input)
        prompt += " " + input;
      if (hint && !input && this.state.completed === 0)
        prompt += " " + hint;
      this.clear(size2);
      let lines = [header, prompt, body, footer, error.trim()];
      this.write(lines.filter(Boolean).join(newline));
      this.restore();
    }
    getItem(name2) {
      let { items, keys: keys3, index } = this.state;
      let item = items.find((ch) => ch.name === keys3[index]);
      if (item && item.input != null) {
        this.input = item.input;
        this.cursor = item.cursor;
      }
      return item;
    }
    async submit() {
      if (typeof this.interpolate !== "function")
        await this.initialize();
      await this.interpolate(this.state, true);
      let { invalid, missing, output, values } = this.state;
      if (invalid.size) {
        let err = "";
        for (let [key, value] of invalid)
          err += `Invalid ${key}: ${value}\n`;
        this.state.error = err;
        return super.submit();
      }
      if (missing.size) {
        this.state.error = "Required: " + [...missing.keys()].join(", ");
        return super.submit();
      }
      let lines = colors.unstyle(output).split("\n");
      let result = lines.map((v) => v.slice(1)).join("\n");
      this.value = { values, result };
      return super.submit();
    }
  }
  module2.exports = SnippetPrompt;
});

// ../../node_modules/enquirer/lib/prompts/sort.js
var require_sort2 = __commonJS((exports2, module2) => {
  var hint = "(Use <shift>+<up/down> to sort)";
  var Prompt = require_select();

  class Sort extends Prompt {
    constructor(options2) {
      super({ ...options2, reorder: false, sort: true, multiple: true });
      this.state.hint = [this.options.hint, hint].find(this.isValue.bind(this));
    }
    indicator() {
      return "";
    }
    async renderChoice(choice, i) {
      let str = await super.renderChoice(choice, i);
      let sym = this.symbols.identicalTo + " ";
      let pre = this.index === i && this.sorting ? this.styles.muted(sym) : "  ";
      if (this.options.drag === false)
        pre = "";
      if (this.options.numbered === true) {
        return pre + `${i + 1} - ` + str;
      }
      return pre + str;
    }
    get selected() {
      return this.choices;
    }
    submit() {
      this.value = this.choices.map((choice) => choice.value);
      return super.submit();
    }
  }
  module2.exports = Sort;
});

// ../../node_modules/enquirer/lib/prompts/survey.js
var require_survey = __commonJS((exports2, module2) => {
  var createScale = function(n, options2 = {}) {
    if (Array.isArray(options2.scale)) {
      return options2.scale.map((ele) => ({ ...ele }));
    }
    let scale = [];
    for (let i = 1;i < n + 1; i++)
      scale.push({ i, selected: false });
    return scale;
  };
  var ArrayPrompt = require_array();

  class Survey extends ArrayPrompt {
    constructor(options2 = {}) {
      super(options2);
      this.emptyError = options2.emptyError || "No items were selected";
      this.term = process.env.TERM_PROGRAM;
      if (!this.options.header) {
        let header = ["", "4 - Strongly Agree", "3 - Agree", "2 - Neutral", "1 - Disagree", "0 - Strongly Disagree", ""];
        header = header.map((ele) => this.styles.muted(ele));
        this.state.header = header.join("\n   ");
      }
    }
    async toChoices(...args2) {
      if (this.createdScales)
        return false;
      this.createdScales = true;
      let choices = await super.toChoices(...args2);
      for (let choice of choices) {
        choice.scale = createScale(5, this.options);
        choice.scaleIdx = 2;
      }
      return choices;
    }
    dispatch() {
      this.alert();
    }
    space() {
      let choice = this.focused;
      let ele = choice.scale[choice.scaleIdx];
      let selected = ele.selected;
      choice.scale.forEach((e) => e.selected = false);
      ele.selected = !selected;
      return this.render();
    }
    indicator() {
      return "";
    }
    pointer() {
      return "";
    }
    separator() {
      return this.styles.muted(this.symbols.ellipsis);
    }
    right() {
      let choice = this.focused;
      if (choice.scaleIdx >= choice.scale.length - 1)
        return this.alert();
      choice.scaleIdx++;
      return this.render();
    }
    left() {
      let choice = this.focused;
      if (choice.scaleIdx <= 0)
        return this.alert();
      choice.scaleIdx--;
      return this.render();
    }
    indent() {
      return "   ";
    }
    async renderChoice(item, i) {
      await this.onChoice(item, i);
      let focused = this.index === i;
      let isHyper = this.term === "Hyper";
      let n = !isHyper ? 8 : 9;
      let s = !isHyper ? " " : "";
      let ln = this.symbols.line.repeat(n);
      let sp = " ".repeat(n + (isHyper ? 0 : 1));
      let dot = (enabled) => (enabled ? this.styles.success("\u25C9") : "\u25EF") + s;
      let num = i + 1 + ".";
      let color = focused ? this.styles.heading : this.styles.noop;
      let msg = await this.resolve(item.message, this.state, item, i);
      let indent = this.indent(item);
      let scale = indent + item.scale.map((e, i2) => dot(i2 === item.scaleIdx)).join(ln);
      let val = (i2) => i2 === item.scaleIdx ? color(i2) : i2;
      let next = indent + item.scale.map((e, i2) => val(i2)).join(sp);
      let line = () => [num, msg].filter(Boolean).join(" ");
      let lines = () => [line(), scale, next, " "].filter(Boolean).join("\n");
      if (focused) {
        scale = this.styles.cyan(scale);
        next = this.styles.cyan(next);
      }
      return lines();
    }
    async renderChoices() {
      if (this.state.submitted)
        return "";
      let choices = this.visible.map(async (ch, i) => await this.renderChoice(ch, i));
      let visible = await Promise.all(choices);
      if (!visible.length)
        visible.push(this.styles.danger("No matching choices"));
      return visible.join("\n");
    }
    format() {
      if (this.state.submitted) {
        let values = this.choices.map((ch) => this.styles.info(ch.scaleIdx));
        return values.join(", ");
      }
      return "";
    }
    async render() {
      let { submitted, size: size2 } = this.state;
      let prefix = await this.prefix();
      let separator = await this.separator();
      let message = await this.message();
      let prompt = [prefix, message, separator].filter(Boolean).join(" ");
      this.state.prompt = prompt;
      let header = await this.header();
      let output = await this.format();
      let help = await this.error() || await this.hint();
      let body = await this.renderChoices();
      let footer = await this.footer();
      if (output || !help)
        prompt += " " + output;
      if (help && !prompt.includes(help))
        prompt += " " + help;
      if (submitted && !output && !body && this.multiple && this.type !== "form") {
        prompt += this.styles.danger(this.emptyError);
      }
      this.clear(size2);
      this.write([prompt, header, body, footer].filter(Boolean).join("\n"));
      this.restore();
    }
    submit() {
      this.value = {};
      for (let choice of this.choices) {
        this.value[choice.name] = choice.scaleIdx;
      }
      return this.base.submit.call(this);
    }
  }
  module2.exports = Survey;
});

// ../../node_modules/enquirer/lib/prompts/toggle.js
var require_toggle = __commonJS((exports2, module2) => {
  var BooleanPrompt = require_boolean();

  class TogglePrompt extends BooleanPrompt {
    async initialize() {
      await super.initialize();
      this.value = this.initial = !!this.options.initial;
      this.disabled = this.options.disabled || "no";
      this.enabled = this.options.enabled || "yes";
      await this.render();
    }
    reset() {
      this.value = this.initial;
      this.render();
    }
    delete() {
      this.alert();
    }
    toggle() {
      this.value = !this.value;
      this.render();
    }
    enable() {
      if (this.value === true)
        return this.alert();
      this.value = true;
      this.render();
    }
    disable() {
      if (this.value === false)
        return this.alert();
      this.value = false;
      this.render();
    }
    up() {
      this.toggle();
    }
    down() {
      this.toggle();
    }
    right() {
      this.toggle();
    }
    left() {
      this.toggle();
    }
    next() {
      this.toggle();
    }
    prev() {
      this.toggle();
    }
    dispatch(ch = "", key) {
      switch (ch.toLowerCase()) {
        case " ":
          return this.toggle();
        case "1":
        case "y":
        case "t":
          return this.enable();
        case "0":
        case "n":
        case "f":
          return this.disable();
        default: {
          return this.alert();
        }
      }
    }
    format() {
      let active = (str) => this.styles.primary.underline(str);
      let value = [
        this.value ? this.disabled : active(this.disabled),
        this.value ? active(this.enabled) : this.enabled
      ];
      return value.join(this.styles.muted(" / "));
    }
    async render() {
      let { size: size2 } = this.state;
      let header = await this.header();
      let prefix = await this.prefix();
      let separator = await this.separator();
      let message = await this.message();
      let output = await this.format();
      let help = await this.error() || await this.hint();
      let footer = await this.footer();
      let prompt = [prefix, message, separator, output].join(" ");
      this.state.prompt = prompt;
      if (help && !prompt.includes(help))
        prompt += " " + help;
      this.clear(size2);
      this.write([header, prompt, footer].filter(Boolean).join("\n"));
      this.write(this.margin[2]);
      this.restore();
    }
  }
  module2.exports = TogglePrompt;
});

// ../../node_modules/enquirer/lib/prompts/quiz.js
var require_quiz = __commonJS((exports2, module2) => {
  var SelectPrompt = require_select();

  class Quiz extends SelectPrompt {
    constructor(options2) {
      super(options2);
      if (typeof this.options.correctChoice !== "number" || this.options.correctChoice < 0) {
        throw new Error("Please specify the index of the correct answer from the list of choices");
      }
    }
    async toChoices(value, parent) {
      let choices = await super.toChoices(value, parent);
      if (choices.length < 2) {
        throw new Error("Please give at least two choices to the user");
      }
      if (this.options.correctChoice > choices.length) {
        throw new Error("Please specify the index of the correct answer from the list of choices");
      }
      return choices;
    }
    check(state) {
      return state.index === this.options.correctChoice;
    }
    async result(selected) {
      return {
        selectedAnswer: selected,
        correctAnswer: this.options.choices[this.options.correctChoice].value,
        correct: await this.check(this.state)
      };
    }
  }
  module2.exports = Quiz;
});

// ../../node_modules/enquirer/lib/prompts/index.js
var require_prompts = __commonJS((exports2) => {
  var utils = require_utils5();
  var define2 = (key, fn) => {
    utils.defineExport(exports2, key, fn);
    utils.defineExport(exports2, key.toLowerCase(), fn);
  };
  define2("AutoComplete", () => require_autocomplete());
  define2("BasicAuth", () => require_basicauth());
  define2("Confirm", () => require_confirm());
  define2("Editable", () => require_editable());
  define2("Form", () => require_form());
  define2("Input", () => require_input());
  define2("Invisible", () => require_invisible());
  define2("List", () => require_list());
  define2("MultiSelect", () => require_multiselect());
  define2("Numeral", () => require_number());
  define2("Password", () => require_password());
  define2("Scale", () => require_scale());
  define2("Select", () => require_select());
  define2("Snippet", () => require_snippet2());
  define2("Sort", () => require_sort2());
  define2("Survey", () => require_survey());
  define2("Text", () => require_input());
  define2("Toggle", () => require_toggle());
  define2("Quiz", () => require_quiz());
});

// ../../node_modules/enquirer/lib/types/index.js
var require_types = __commonJS((exports2, module2) => {
  module2.exports = {
    ArrayPrompt: require_array(),
    AuthPrompt: require_auth2(),
    BooleanPrompt: require_boolean(),
    NumberPrompt: require_number(),
    StringPrompt: require_string()
  };
});

// ../../node_modules/enquirer/index.js
var require_enquirer = __commonJS((exports2, module2) => {
  var assert = __require("assert");
  var Events = __require("events");
  var utils = require_utils5();

  class Enquirer extends Events {
    constructor(options2, answers) {
      super();
      this.options = utils.merge({}, options2);
      this.answers = { ...answers };
    }
    register(type2, fn) {
      if (utils.isObject(type2)) {
        for (let key of Object.keys(type2))
          this.register(key, type2[key]);
        return this;
      }
      assert.equal(typeof fn, "function", "expected a function");
      let name2 = type2.toLowerCase();
      if (fn.prototype instanceof this.Prompt) {
        this.prompts[name2] = fn;
      } else {
        this.prompts[name2] = fn(this.Prompt, this);
      }
      return this;
    }
    async prompt(questions = []) {
      for (let question of [].concat(questions)) {
        try {
          if (typeof question === "function")
            question = await question.call(this);
          await this.ask(utils.merge({}, this.options, question));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      return this.answers;
    }
    async ask(question) {
      if (typeof question === "function") {
        question = await question.call(this);
      }
      let opts = utils.merge({}, this.options, question);
      let { type: type2, name: name2 } = question;
      let { set, get } = utils;
      if (typeof type2 === "function") {
        type2 = await type2.call(this, question, this.answers);
      }
      if (!type2)
        return this.answers[name2];
      assert(this.prompts[type2], `Prompt "${type2}" is not registered`);
      let prompt = new this.prompts[type2](opts);
      let value = get(this.answers, name2);
      prompt.state.answers = this.answers;
      prompt.enquirer = this;
      if (name2) {
        prompt.on("submit", (value2) => {
          this.emit("answer", name2, value2, prompt);
          set(this.answers, name2, value2);
        });
      }
      let emit = prompt.emit.bind(prompt);
      prompt.emit = (...args2) => {
        this.emit.call(this, ...args2);
        return emit(...args2);
      };
      this.emit("prompt", prompt, this);
      if (opts.autofill && value != null) {
        prompt.value = prompt.input = value;
        if (opts.autofill === "show") {
          await prompt.submit();
        }
      } else {
        value = prompt.value = await prompt.run();
      }
      return value;
    }
    use(plugin) {
      plugin.call(this, this);
      return this;
    }
    set Prompt(value) {
      this._Prompt = value;
    }
    get Prompt() {
      return this._Prompt || this.constructor.Prompt;
    }
    get prompts() {
      return this.constructor.prompts;
    }
    static set Prompt(value) {
      this._Prompt = value;
    }
    static get Prompt() {
      return this._Prompt || require_prompt();
    }
    static get prompts() {
      return require_prompts();
    }
    static get types() {
      return require_types();
    }
    static get prompt() {
      const fn = (questions, ...rest) => {
        let enquirer = new this(...rest);
        let emit = enquirer.emit.bind(enquirer);
        enquirer.emit = (...args2) => {
          fn.emit(...args2);
          return emit(...args2);
        };
        return enquirer.prompt(questions);
      };
      utils.mixinEmitter(fn, new Events);
      return fn;
    }
  }
  utils.mixinEmitter(Enquirer, new Events);
  var prompts = Enquirer.prompts;
  for (let name2 of Object.keys(prompts)) {
    let key = name2.toLowerCase();
    let run2 = (options2) => new prompts[name2](options2).run();
    Enquirer.prompt[key] = run2;
    Enquirer[key] = run2;
    if (!Enquirer[name2]) {
      Reflect.defineProperty(Enquirer, name2, { get: () => prompts[name2] });
    }
  }
  var exp = (name2) => {
    utils.defineExport(Enquirer, name2, () => Enquirer.types[name2]);
  };
  exp("ArrayPrompt");
  exp("AuthPrompt");
  exp("BooleanPrompt");
  exp("NumberPrompt");
  exp("StringPrompt");
  module2.exports = Enquirer;
});

// ../../node_modules/blessed/lib/alias.js
var require_alias = __commonJS((exports2) => {
  var alias = exports2;
  alias.bools = {
    auto_left_margin: ["bw", "bw"],
    auto_right_margin: ["am", "am"],
    back_color_erase: ["bce", "ut"],
    can_change: ["ccc", "cc"],
    ceol_standout_glitch: ["xhp", "xs"],
    col_addr_glitch: ["xhpa", "YA"],
    cpi_changes_res: ["cpix", "YF"],
    cr_cancels_micro_mode: ["crxm", "YB"],
    dest_tabs_magic_smso: ["xt", "xt"],
    eat_newline_glitch: ["xenl", "xn"],
    erase_overstrike: ["eo", "eo"],
    generic_type: ["gn", "gn"],
    hard_copy: ["hc", "hc"],
    hard_cursor: ["chts", "HC"],
    has_meta_key: ["km", "km"],
    has_print_wheel: ["daisy", "YC"],
    has_status_line: ["hs", "hs"],
    hue_lightness_saturation: ["hls", "hl"],
    insert_null_glitch: ["in", "in"],
    lpi_changes_res: ["lpix", "YG"],
    memory_above: ["da", "da"],
    memory_below: ["db", "db"],
    move_insert_mode: ["mir", "mi"],
    move_standout_mode: ["msgr", "ms"],
    needs_xon_xoff: ["nxon", "nx"],
    no_esc_ctlc: ["xsb", "xb"],
    no_pad_char: ["npc", "NP"],
    non_dest_scroll_region: ["ndscr", "ND"],
    non_rev_rmcup: ["nrrmc", "NR"],
    over_strike: ["os", "os"],
    prtr_silent: ["mc5i", "5i"],
    row_addr_glitch: ["xvpa", "YD"],
    semi_auto_right_margin: ["sam", "YE"],
    status_line_esc_ok: ["eslok", "es"],
    tilde_glitch: ["hz", "hz"],
    transparent_underline: ["ul", "ul"],
    xon_xoff: ["xon", "xo"]
  };
  alias.numbers = {
    columns: ["cols", "co"],
    init_tabs: ["it", "it"],
    label_height: ["lh", "lh"],
    label_width: ["lw", "lw"],
    lines: ["lines", "li"],
    lines_of_memory: ["lm", "lm"],
    magic_cookie_glitch: ["xmc", "sg"],
    max_attributes: ["ma", "ma"],
    max_colors: ["colors", "Co"],
    max_pairs: ["pairs", "pa"],
    maximum_windows: ["wnum", "MW"],
    no_color_video: ["ncv", "NC"],
    num_labels: ["nlab", "Nl"],
    padding_baud_rate: ["pb", "pb"],
    virtual_terminal: ["vt", "vt"],
    width_status_line: ["wsl", "ws"],
    bit_image_entwining: ["bitwin", "Yo"],
    bit_image_type: ["bitype", "Yp"],
    buffer_capacity: ["bufsz", "Ya"],
    buttons: ["btns", "BT"],
    dot_horz_spacing: ["spinh", "Yc"],
    dot_vert_spacing: ["spinv", "Yb"],
    max_micro_address: ["maddr", "Yd"],
    max_micro_jump: ["mjump", "Ye"],
    micro_col_size: ["mcs", "Yf"],
    micro_line_size: ["mls", "Yg"],
    number_of_pins: ["npins", "Yh"],
    output_res_char: ["orc", "Yi"],
    output_res_horz_inch: ["orhi", "Yk"],
    output_res_line: ["orl", "Yj"],
    output_res_vert_inch: ["orvi", "Yl"],
    print_rate: ["cps", "Ym"],
    wide_char_size: ["widcs", "Yn"]
  };
  alias.strings = {
    acs_chars: ["acsc", "ac"],
    back_tab: ["cbt", "bt"],
    bell: ["bel", "bl"],
    carriage_return: ["cr", "cr"],
    change_char_pitch: ["cpi", "ZA"],
    change_line_pitch: ["lpi", "ZB"],
    change_res_horz: ["chr", "ZC"],
    change_res_vert: ["cvr", "ZD"],
    change_scroll_region: ["csr", "cs"],
    char_padding: ["rmp", "rP"],
    clear_all_tabs: ["tbc", "ct"],
    clear_margins: ["mgc", "MC"],
    clear_screen: ["clear", "cl"],
    clr_bol: ["el1", "cb"],
    clr_eol: ["el", "ce"],
    clr_eos: ["ed", "cd"],
    column_address: ["hpa", "ch"],
    command_character: ["cmdch", "CC"],
    create_window: ["cwin", "CW"],
    cursor_address: ["cup", "cm"],
    cursor_down: ["cud1", "do"],
    cursor_home: ["home", "ho"],
    cursor_invisible: ["civis", "vi"],
    cursor_left: ["cub1", "le"],
    cursor_mem_address: ["mrcup", "CM"],
    cursor_normal: ["cnorm", "ve"],
    cursor_right: ["cuf1", "nd"],
    cursor_to_ll: ["ll", "ll"],
    cursor_up: ["cuu1", "up"],
    cursor_visible: ["cvvis", "vs"],
    define_char: ["defc", "ZE"],
    delete_character: ["dch1", "dc"],
    delete_line: ["dl1", "dl"],
    dial_phone: ["dial", "DI"],
    dis_status_line: ["dsl", "ds"],
    display_clock: ["dclk", "DK"],
    down_half_line: ["hd", "hd"],
    ena_acs: ["enacs", "eA"],
    enter_alt_charset_mode: ["smacs", "as"],
    enter_am_mode: ["smam", "SA"],
    enter_blink_mode: ["blink", "mb"],
    enter_bold_mode: ["bold", "md"],
    enter_ca_mode: ["smcup", "ti"],
    enter_delete_mode: ["smdc", "dm"],
    enter_dim_mode: ["dim", "mh"],
    enter_doublewide_mode: ["swidm", "ZF"],
    enter_draft_quality: ["sdrfq", "ZG"],
    enter_insert_mode: ["smir", "im"],
    enter_italics_mode: ["sitm", "ZH"],
    enter_leftward_mode: ["slm", "ZI"],
    enter_micro_mode: ["smicm", "ZJ"],
    enter_near_letter_quality: ["snlq", "ZK"],
    enter_normal_quality: ["snrmq", "ZL"],
    enter_protected_mode: ["prot", "mp"],
    enter_reverse_mode: ["rev", "mr"],
    enter_secure_mode: ["invis", "mk"],
    enter_shadow_mode: ["sshm", "ZM"],
    enter_standout_mode: ["smso", "so"],
    enter_subscript_mode: ["ssubm", "ZN"],
    enter_superscript_mode: ["ssupm", "ZO"],
    enter_underline_mode: ["smul", "us"],
    enter_upward_mode: ["sum", "ZP"],
    enter_xon_mode: ["smxon", "SX"],
    erase_chars: ["ech", "ec"],
    exit_alt_charset_mode: ["rmacs", "ae"],
    exit_am_mode: ["rmam", "RA"],
    exit_attribute_mode: ["sgr0", "me"],
    exit_ca_mode: ["rmcup", "te"],
    exit_delete_mode: ["rmdc", "ed"],
    exit_doublewide_mode: ["rwidm", "ZQ"],
    exit_insert_mode: ["rmir", "ei"],
    exit_italics_mode: ["ritm", "ZR"],
    exit_leftward_mode: ["rlm", "ZS"],
    exit_micro_mode: ["rmicm", "ZT"],
    exit_shadow_mode: ["rshm", "ZU"],
    exit_standout_mode: ["rmso", "se"],
    exit_subscript_mode: ["rsubm", "ZV"],
    exit_superscript_mode: ["rsupm", "ZW"],
    exit_underline_mode: ["rmul", "ue"],
    exit_upward_mode: ["rum", "ZX"],
    exit_xon_mode: ["rmxon", "RX"],
    fixed_pause: ["pause", "PA"],
    flash_hook: ["hook", "fh"],
    flash_screen: ["flash", "vb"],
    form_feed: ["ff", "ff"],
    from_status_line: ["fsl", "fs"],
    goto_window: ["wingo", "WG"],
    hangup: ["hup", "HU"],
    init_1string: ["is1", "i1"],
    init_2string: ["is2", "is"],
    init_3string: ["is3", "i3"],
    init_file: ["if", "if"],
    init_prog: ["iprog", "iP"],
    initialize_color: ["initc", "Ic"],
    initialize_pair: ["initp", "Ip"],
    insert_character: ["ich1", "ic"],
    insert_line: ["il1", "al"],
    insert_padding: ["ip", "ip"],
    key_a1: ["ka1", "K1"],
    key_a3: ["ka3", "K3"],
    key_b2: ["kb2", "K2"],
    key_backspace: ["kbs", "kb"],
    key_beg: ["kbeg", "@1"],
    key_btab: ["kcbt", "kB"],
    key_c1: ["kc1", "K4"],
    key_c3: ["kc3", "K5"],
    key_cancel: ["kcan", "@2"],
    key_catab: ["ktbc", "ka"],
    key_clear: ["kclr", "kC"],
    key_close: ["kclo", "@3"],
    key_command: ["kcmd", "@4"],
    key_copy: ["kcpy", "@5"],
    key_create: ["kcrt", "@6"],
    key_ctab: ["kctab", "kt"],
    key_dc: ["kdch1", "kD"],
    key_dl: ["kdl1", "kL"],
    key_down: ["kcud1", "kd"],
    key_eic: ["krmir", "kM"],
    key_end: ["kend", "@7"],
    key_enter: ["kent", "@8"],
    key_eol: ["kel", "kE"],
    key_eos: ["ked", "kS"],
    key_exit: ["kext", "@9"],
    key_f0: ["kf0", "k0"],
    key_f1: ["kf1", "k1"],
    key_f10: ["kf10", "k;"],
    key_f11: ["kf11", "F1"],
    key_f12: ["kf12", "F2"],
    key_f13: ["kf13", "F3"],
    key_f14: ["kf14", "F4"],
    key_f15: ["kf15", "F5"],
    key_f16: ["kf16", "F6"],
    key_f17: ["kf17", "F7"],
    key_f18: ["kf18", "F8"],
    key_f19: ["kf19", "F9"],
    key_f2: ["kf2", "k2"],
    key_f20: ["kf20", "FA"],
    key_f21: ["kf21", "FB"],
    key_f22: ["kf22", "FC"],
    key_f23: ["kf23", "FD"],
    key_f24: ["kf24", "FE"],
    key_f25: ["kf25", "FF"],
    key_f26: ["kf26", "FG"],
    key_f27: ["kf27", "FH"],
    key_f28: ["kf28", "FI"],
    key_f29: ["kf29", "FJ"],
    key_f3: ["kf3", "k3"],
    key_f30: ["kf30", "FK"],
    key_f31: ["kf31", "FL"],
    key_f32: ["kf32", "FM"],
    key_f33: ["kf33", "FN"],
    key_f34: ["kf34", "FO"],
    key_f35: ["kf35", "FP"],
    key_f36: ["kf36", "FQ"],
    key_f37: ["kf37", "FR"],
    key_f38: ["kf38", "FS"],
    key_f39: ["kf39", "FT"],
    key_f4: ["kf4", "k4"],
    key_f40: ["kf40", "FU"],
    key_f41: ["kf41", "FV"],
    key_f42: ["kf42", "FW"],
    key_f43: ["kf43", "FX"],
    key_f44: ["kf44", "FY"],
    key_f45: ["kf45", "FZ"],
    key_f46: ["kf46", "Fa"],
    key_f47: ["kf47", "Fb"],
    key_f48: ["kf48", "Fc"],
    key_f49: ["kf49", "Fd"],
    key_f5: ["kf5", "k5"],
    key_f50: ["kf50", "Fe"],
    key_f51: ["kf51", "Ff"],
    key_f52: ["kf52", "Fg"],
    key_f53: ["kf53", "Fh"],
    key_f54: ["kf54", "Fi"],
    key_f55: ["kf55", "Fj"],
    key_f56: ["kf56", "Fk"],
    key_f57: ["kf57", "Fl"],
    key_f58: ["kf58", "Fm"],
    key_f59: ["kf59", "Fn"],
    key_f6: ["kf6", "k6"],
    key_f60: ["kf60", "Fo"],
    key_f61: ["kf61", "Fp"],
    key_f62: ["kf62", "Fq"],
    key_f63: ["kf63", "Fr"],
    key_f7: ["kf7", "k7"],
    key_f8: ["kf8", "k8"],
    key_f9: ["kf9", "k9"],
    key_find: ["kfnd", "@0"],
    key_help: ["khlp", "%1"],
    key_home: ["khome", "kh"],
    key_ic: ["kich1", "kI"],
    key_il: ["kil1", "kA"],
    key_left: ["kcub1", "kl"],
    key_ll: ["kll", "kH"],
    key_mark: ["kmrk", "%2"],
    key_message: ["kmsg", "%3"],
    key_move: ["kmov", "%4"],
    key_next: ["knxt", "%5"],
    key_npage: ["knp", "kN"],
    key_open: ["kopn", "%6"],
    key_options: ["kopt", "%7"],
    key_ppage: ["kpp", "kP"],
    key_previous: ["kprv", "%8"],
    key_print: ["kprt", "%9"],
    key_redo: ["krdo", "%0"],
    key_reference: ["kref", "&1"],
    key_refresh: ["krfr", "&2"],
    key_replace: ["krpl", "&3"],
    key_restart: ["krst", "&4"],
    key_resume: ["kres", "&5"],
    key_right: ["kcuf1", "kr"],
    key_save: ["ksav", "&6"],
    key_sbeg: ["kBEG", "&9"],
    key_scancel: ["kCAN", "&0"],
    key_scommand: ["kCMD", "*1"],
    key_scopy: ["kCPY", "*2"],
    key_screate: ["kCRT", "*3"],
    key_sdc: ["kDC", "*4"],
    key_sdl: ["kDL", "*5"],
    key_select: ["kslt", "*6"],
    key_send: ["kEND", "*7"],
    key_seol: ["kEOL", "*8"],
    key_sexit: ["kEXT", "*9"],
    key_sf: ["kind", "kF"],
    key_sfind: ["kFND", "*0"],
    key_shelp: ["kHLP", "#1"],
    key_shome: ["kHOM", "#2"],
    key_sic: ["kIC", "#3"],
    key_sleft: ["kLFT", "#4"],
    key_smessage: ["kMSG", "%a"],
    key_smove: ["kMOV", "%b"],
    key_snext: ["kNXT", "%c"],
    key_soptions: ["kOPT", "%d"],
    key_sprevious: ["kPRV", "%e"],
    key_sprint: ["kPRT", "%f"],
    key_sr: ["kri", "kR"],
    key_sredo: ["kRDO", "%g"],
    key_sreplace: ["kRPL", "%h"],
    key_sright: ["kRIT", "%i"],
    key_srsume: ["kRES", "%j"],
    key_ssave: ["kSAV", "!1"],
    key_ssuspend: ["kSPD", "!2"],
    key_stab: ["khts", "kT"],
    key_sundo: ["kUND", "!3"],
    key_suspend: ["kspd", "&7"],
    key_undo: ["kund", "&8"],
    key_up: ["kcuu1", "ku"],
    keypad_local: ["rmkx", "ke"],
    keypad_xmit: ["smkx", "ks"],
    lab_f0: ["lf0", "l0"],
    lab_f1: ["lf1", "l1"],
    lab_f10: ["lf10", "la"],
    lab_f2: ["lf2", "l2"],
    lab_f3: ["lf3", "l3"],
    lab_f4: ["lf4", "l4"],
    lab_f5: ["lf5", "l5"],
    lab_f6: ["lf6", "l6"],
    lab_f7: ["lf7", "l7"],
    lab_f8: ["lf8", "l8"],
    lab_f9: ["lf9", "l9"],
    label_format: ["fln", "Lf"],
    label_off: ["rmln", "LF"],
    label_on: ["smln", "LO"],
    meta_off: ["rmm", "mo"],
    meta_on: ["smm", "mm"],
    micro_column_address: ["mhpa", "ZY"],
    micro_down: ["mcud1", "ZZ"],
    micro_left: ["mcub1", "Za"],
    micro_right: ["mcuf1", "Zb"],
    micro_row_address: ["mvpa", "Zc"],
    micro_up: ["mcuu1", "Zd"],
    newline: ["nel", "nw"],
    order_of_pins: ["porder", "Ze"],
    orig_colors: ["oc", "oc"],
    orig_pair: ["op", "op"],
    pad_char: ["pad", "pc"],
    parm_dch: ["dch", "DC"],
    parm_delete_line: ["dl", "DL"],
    parm_down_cursor: ["cud", "DO"],
    parm_down_micro: ["mcud", "Zf"],
    parm_ich: ["ich", "IC"],
    parm_index: ["indn", "SF"],
    parm_insert_line: ["il", "AL"],
    parm_left_cursor: ["cub", "LE"],
    parm_left_micro: ["mcub", "Zg"],
    parm_right_cursor: ["cuf", "RI"],
    parm_right_micro: ["mcuf", "Zh"],
    parm_rindex: ["rin", "SR"],
    parm_up_cursor: ["cuu", "UP"],
    parm_up_micro: ["mcuu", "Zi"],
    pkey_key: ["pfkey", "pk"],
    pkey_local: ["pfloc", "pl"],
    pkey_xmit: ["pfx", "px"],
    plab_norm: ["pln", "pn"],
    print_screen: ["mc0", "ps"],
    prtr_non: ["mc5p", "pO"],
    prtr_off: ["mc4", "pf"],
    prtr_on: ["mc5", "po"],
    pulse: ["pulse", "PU"],
    quick_dial: ["qdial", "QD"],
    remove_clock: ["rmclk", "RC"],
    repeat_char: ["rep", "rp"],
    req_for_input: ["rfi", "RF"],
    reset_1string: ["rs1", "r1"],
    reset_2string: ["rs2", "r2"],
    reset_3string: ["rs3", "r3"],
    reset_file: ["rf", "rf"],
    restore_cursor: ["rc", "rc"],
    row_address: ["vpa", "cv"],
    save_cursor: ["sc", "sc"],
    scroll_forward: ["ind", "sf"],
    scroll_reverse: ["ri", "sr"],
    select_char_set: ["scs", "Zj"],
    set_attributes: ["sgr", "sa"],
    set_background: ["setb", "Sb"],
    set_bottom_margin: ["smgb", "Zk"],
    set_bottom_margin_parm: ["smgbp", "Zl"],
    set_clock: ["sclk", "SC"],
    set_color_pair: ["scp", "sp"],
    set_foreground: ["setf", "Sf"],
    set_left_margin: ["smgl", "ML"],
    set_left_margin_parm: ["smglp", "Zm"],
    set_right_margin: ["smgr", "MR"],
    set_right_margin_parm: ["smgrp", "Zn"],
    set_tab: ["hts", "st"],
    set_top_margin: ["smgt", "Zo"],
    set_top_margin_parm: ["smgtp", "Zp"],
    set_window: ["wind", "wi"],
    start_bit_image: ["sbim", "Zq"],
    start_char_set_def: ["scsd", "Zr"],
    stop_bit_image: ["rbim", "Zs"],
    stop_char_set_def: ["rcsd", "Zt"],
    subscript_characters: ["subcs", "Zu"],
    superscript_characters: ["supcs", "Zv"],
    tab: ["ht", "ta"],
    these_cause_cr: ["docr", "Zw"],
    to_status_line: ["tsl", "ts"],
    tone: ["tone", "TO"],
    underline_char: ["uc", "uc"],
    up_half_line: ["hu", "hu"],
    user0: ["u0", "u0"],
    user1: ["u1", "u1"],
    user2: ["u2", "u2"],
    user3: ["u3", "u3"],
    user4: ["u4", "u4"],
    user5: ["u5", "u5"],
    user6: ["u6", "u6"],
    user7: ["u7", "u7"],
    user8: ["u8", "u8"],
    user9: ["u9", "u9"],
    wait_tone: ["wait", "WA"],
    xoff_character: ["xoffc", "XF"],
    xon_character: ["xonc", "XN"],
    zero_motion: ["zerom", "Zx"],
    alt_scancode_esc: ["scesa", "S8"],
    bit_image_carriage_return: ["bicr", "Yv"],
    bit_image_newline: ["binel", "Zz"],
    bit_image_repeat: ["birep", "Xy"],
    char_set_names: ["csnm", "Zy"],
    code_set_init: ["csin", "ci"],
    color_names: ["colornm", "Yw"],
    define_bit_image_region: ["defbi", "Yx"],
    device_type: ["devt", "dv"],
    display_pc_char: ["dispc", "S1"],
    end_bit_image_region: ["endbi", "Yy"],
    enter_pc_charset_mode: ["smpch", "S2"],
    enter_scancode_mode: ["smsc", "S4"],
    exit_pc_charset_mode: ["rmpch", "S3"],
    exit_scancode_mode: ["rmsc", "S5"],
    get_mouse: ["getm", "Gm"],
    key_mouse: ["kmous", "Km"],
    mouse_info: ["minfo", "Mi"],
    pc_term_options: ["pctrm", "S6"],
    pkey_plab: ["pfxl", "xl"],
    req_mouse_pos: ["reqmp", "RQ"],
    scancode_escape: ["scesc", "S7"],
    set0_des_seq: ["s0ds", "s0"],
    set1_des_seq: ["s1ds", "s1"],
    set2_des_seq: ["s2ds", "s2"],
    set3_des_seq: ["s3ds", "s3"],
    set_a_background: ["setab", "AB"],
    set_a_foreground: ["setaf", "AF"],
    set_color_band: ["setcolor", "Yz"],
    set_lr_margin: ["smglr", "ML"],
    set_page_length: ["slines", "YZ"],
    set_tb_margin: ["smgtb", "MT"],
    enter_horizontal_hl_mode: ["ehhlm", "Xh"],
    enter_left_hl_mode: ["elhlm", "Xl"],
    enter_low_hl_mode: ["elohlm", "Xo"],
    enter_right_hl_mode: ["erhlm", "Xr"],
    enter_top_hl_mode: ["ethlm", "Xt"],
    enter_vertical_hl_mode: ["evhlm", "Xv"],
    set_a_attributes: ["sgr1", "sA"],
    set_pglen_inch: ["slength", "sL"]
  };
});

// ../../node_modules/blessed/lib/tput.js
var require_tput = __commonJS((exports2, module2) => {
  var Tput = function(options2) {
    if (!(this instanceof Tput)) {
      return new Tput(options2);
    }
    options2 = options2 || {};
    if (typeof options2 === "string") {
      options2 = { terminal: options2 };
    }
    this.options = options2;
    this.terminal = options2.terminal || options2.term || process.env.TERM || (process.platform === "win32" ? "windows-ansi" : "xterm");
    this.terminal = this.terminal.toLowerCase();
    this.debug = options2.debug;
    this.padding = options2.padding;
    this.extended = options2.extended;
    this.printf = options2.printf;
    this.termcap = options2.termcap;
    this.error = null;
    this.terminfoPrefix = options2.terminfoPrefix;
    this.terminfoFile = options2.terminfoFile;
    this.termcapFile = options2.termcapFile;
    if (options2.terminal || options2.term) {
      this.setup();
    }
  };
  var noop = function() {
    return "";
  };
  var merge = function(a, b) {
    Object.keys(b).forEach(function(key) {
      a[key] = b[key];
    });
    return a;
  };
  var write4 = function(data) {
    return process.stdout.write(data);
  };
  var tryRead = function(file) {
    if (Array.isArray(file)) {
      for (var i = 0;i < file.length; i++) {
        var data = tryRead(file[i]);
        if (data)
          return data;
      }
      return "";
    }
    if (!file)
      return "";
    file = path2.resolve.apply(path2, arguments);
    try {
      return fs.readFileSync(file, "utf8");
    } catch (e) {
      return "";
    }
  };
  var sprintf = function(src) {
    var params2 = Array.prototype.slice.call(arguments, 1), rule = /%([\-+# ]{1,4})?(\d+(?:\.\d+)?)?([doxXsc])/g, i = 0;
    return src.replace(rule, function(_, flag, width, type2) {
      var flags = (flag || "").split(""), param = params2[i] != null ? params2[i] : "", initial = param, opt = {}, pre = "";
      i++;
      switch (type2) {
        case "d":
          param = (+param).toString(10);
          break;
        case "o":
          param = (+param).toString(8);
          break;
        case "x":
          param = (+param).toString(16);
          break;
        case "X":
          param = (+param).toString(16).toUppercase();
          break;
        case "s":
          break;
        case "c":
          param = isFinite(param) ? String.fromCharCode(param || 128) : "";
          break;
      }
      flags.forEach(function(flag2) {
        switch (flag2) {
          case "-":
            opt.left = true;
            break;
          case "+":
            opt.signs = true;
            break;
          case "#":
            opt.hexpoint = true;
            break;
          case " ":
            opt.space = true;
            break;
        }
      });
      width = +width.split(".")[0];
      if (width && !opt.left) {
        param = param + "";
        while (param.length < width) {
          param = "0" + param;
        }
      }
      if (opt.signs) {
        if (+initial >= 0) {
          pre += "+";
        }
      }
      if (opt.space) {
        if (!opt.signs && +initial >= 0) {
          pre += " ";
        }
      }
      if (opt.hexpoint) {
        switch (type2) {
          case "o":
            pre += "0";
            break;
          case "x":
            pre += "0x";
            break;
          case "X":
            pre += "0X";
            break;
        }
      }
      if (opt.left) {
        if (width > pre.length + param.length) {
          width -= pre.length + param.length;
          pre = Array(width + 1).join(" ") + pre;
        }
      }
      return pre + param;
    });
  };
  var __dirname = "C:\\Users\\balle\\Documents\\GitHub\\echoesmd\\node_modules\\blessed\\lib";
  var assert = __require("assert");
  var path2 = __require("path");
  var fs = __require("fs");
  var cp = __require("child_process");
  Tput.prototype.setup = function() {
    this.error = null;
    try {
      if (this.termcap) {
        try {
          this.injectTermcap();
        } catch (e) {
          if (this.debug)
            throw e;
          this.error = new Error("Termcap parse error.");
          this._useInternalCap(this.terminal);
        }
      } else {
        try {
          this.injectTerminfo();
        } catch (e) {
          if (this.debug)
            throw e;
          this.error = new Error("Terminfo parse error.");
          this._useInternalInfo(this.terminal);
        }
      }
    } catch (e) {
      if (this.debug)
        throw e;
      this.error = new Error("Terminfo not found.");
      this._useXtermInfo();
    }
  };
  Tput.prototype.term = function(is) {
    return this.terminal.indexOf(is) === 0;
  };
  Tput.prototype._debug = function() {
    if (!this.debug)
      return;
    return console.log.apply(console, arguments);
  };
  Tput.prototype._useVt102Cap = function() {
    return this.injectTermcap("vt102");
  };
  Tput.prototype._useXtermCap = function() {
    return this.injectTermcap(__dirname + "/../usr/xterm.termcap");
  };
  Tput.prototype._useXtermInfo = function() {
    return this.injectTerminfo(__dirname + "/../usr/xterm");
  };
  Tput.prototype._useInternalInfo = function(name2) {
    name2 = path2.basename(name2);
    return this.injectTerminfo(__dirname + "/../usr/" + name2);
  };
  Tput.prototype._useInternalCap = function(name2) {
    name2 = path2.basename(name2);
    return this.injectTermcap(__dirname + "/../usr/" + name2 + ".termcap");
  };
  Tput.ipaths = [
    process.env.TERMINFO || "",
    (process.env.TERMINFO_DIRS || "").split(":"),
    (process.env.HOME || "") + "/.terminfo",
    "/usr/share/terminfo",
    "/usr/share/lib/terminfo",
    "/usr/lib/terminfo",
    "/usr/local/share/terminfo",
    "/usr/local/share/lib/terminfo",
    "/usr/local/lib/terminfo",
    "/usr/local/ncurses/lib/terminfo",
    "/lib/terminfo"
  ];
  Tput.prototype.readTerminfo = function(term) {
    var data, file, info;
    term = term || this.terminal;
    file = path2.normalize(this._prefix(term));
    data = fs.readFileSync(file);
    info = this.parseTerminfo(data, file);
    if (this.debug) {
      this._terminfo = info;
    }
    return info;
  };
  Tput._prefix = Tput.prototype._prefix = function(term) {
    if (term) {
      if (~term.indexOf(path2.sep)) {
        return term;
      }
      if (this.terminfoFile) {
        return this.terminfoFile;
      }
    }
    var paths = Tput.ipaths.slice(), file;
    if (this.terminfoPrefix) {
      paths.unshift(this.terminfoPrefix);
    }
    file = this._tprefix(paths, term);
    if (file)
      return file;
    file = this._tprefix(paths, term, true);
    if (file)
      return file;
    throw new Error("Terminfo directory not found.");
  };
  Tput._tprefix = Tput.prototype._tprefix = function(prefix, term, soft) {
    if (!prefix)
      return;
    var file, dir, i, sdiff, sfile, list;
    if (Array.isArray(prefix)) {
      for (i = 0;i < prefix.length; i++) {
        file = this._tprefix(prefix[i], term, soft);
        if (file)
          return file;
      }
      return;
    }
    var find2 = function(word) {
      var file2, ch;
      file2 = path2.resolve(prefix, word[0]);
      try {
        fs.statSync(file2);
        return file2;
      } catch (e) {
      }
      ch = word[0].charCodeAt(0).toString(16);
      if (ch.length < 2)
        ch = "0" + ch;
      file2 = path2.resolve(prefix, ch);
      try {
        fs.statSync(file2);
        return file2;
      } catch (e) {
      }
    };
    if (!term) {
      try {
        dir = fs.readdirSync(prefix).filter(function(file2) {
          return file2.length !== 1 && !/^[0-9a-fA-F]{2}$/.test(file2);
        });
        if (!dir.length) {
          return prefix;
        }
      } catch (e) {
      }
      return;
    }
    term = path2.basename(term);
    dir = find2(term);
    if (!dir)
      return;
    if (soft) {
      try {
        list = fs.readdirSync(dir);
      } catch (e) {
        return;
      }
      list.forEach(function(file2) {
        if (file2.indexOf(term) === 0) {
          var diff = file2.length - term.length;
          if (!sfile || diff < sdiff) {
            sdiff = diff;
            sfile = file2;
          }
        }
      });
      return sfile && (soft || sdiff === 0) ? path2.resolve(dir, sfile) : null;
    }
    file = path2.resolve(dir, term);
    try {
      fs.statSync(file);
      return file;
    } catch (e) {
    }
  };
  Tput.prototype.parseTerminfo = function(data, file) {
    var info = {}, extended, l = data.length, i = 0, v, o;
    var h = info.header = {
      dataSize: data.length,
      headerSize: 12,
      magicNumber: data[1] << 8 | data[0],
      namesSize: data[3] << 8 | data[2],
      boolCount: data[5] << 8 | data[4],
      numCount: data[7] << 8 | data[6],
      strCount: data[9] << 8 | data[8],
      strTableSize: data[11] << 8 | data[10]
    };
    h.total = h.headerSize + h.namesSize + h.boolCount + h.numCount * 2 + h.strCount * 2 + h.strTableSize;
    i += h.headerSize;
    var names = data.toString("ascii", i, i + h.namesSize - 1), parts = names.split("|"), name2 = parts[0], desc = parts.pop();
    info.name = name2;
    info.names = parts;
    info.desc = desc;
    info.dir = path2.resolve(file, "..", "..");
    info.file = file;
    i += h.namesSize - 1;
    assert.equal(data[i], 0);
    i++;
    info.bools = {};
    l = i + h.boolCount;
    o = 0;
    for (;i < l; i++) {
      v = Tput.bools[o++];
      info.bools[v] = data[i] === 1;
    }
    if (i % 2) {
      assert.equal(data[i], 0);
      i++;
    }
    info.numbers = {};
    l = i + h.numCount * 2;
    o = 0;
    for (;i < l; i += 2) {
      v = Tput.numbers[o++];
      if (data[i + 1] === 255 && data[i] === 255) {
        info.numbers[v] = -1;
      } else {
        info.numbers[v] = data[i + 1] << 8 | data[i];
      }
    }
    info.strings = {};
    l = i + h.strCount * 2;
    o = 0;
    for (;i < l; i += 2) {
      v = Tput.strings[o++];
      if (data[i + 1] === 255 && data[i] === 255) {
        info.strings[v] = -1;
      } else {
        info.strings[v] = data[i + 1] << 8 | data[i];
      }
    }
    Object.keys(info.strings).forEach(function(key) {
      if (info.strings[key] === -1) {
        delete info.strings[key];
        return;
      }
      if (info.strings[key] === 65534) {
        delete info.strings[key];
        return;
      }
      var s = i + info.strings[key], j = s;
      while (data[j])
        j++;
      assert(j < data.length);
      info.strings[key] = data.toString("ascii", s, j);
    });
    if (this.extended !== false) {
      i--;
      i += h.strTableSize;
      if (i % 2) {
        assert.equal(data[i], 0);
        i++;
      }
      l = data.length;
      if (i < l - 1) {
        try {
          extended = this.parseExtended(data.slice(i));
        } catch (e) {
          if (this.debug) {
            throw e;
          }
          return info;
        }
        info.header.extended = extended.header;
        ["bools", "numbers", "strings"].forEach(function(key) {
          merge(info[key], extended[key]);
        });
      }
    }
    return info;
  };
  Tput.prototype.parseExtended = function(data) {
    var info = {}, l = data.length, i = 0;
    var h = info.header = {
      dataSize: data.length,
      headerSize: 10,
      boolCount: data[i + 1] << 8 | data[i + 0],
      numCount: data[i + 3] << 8 | data[i + 2],
      strCount: data[i + 5] << 8 | data[i + 4],
      strTableSize: data[i + 7] << 8 | data[i + 6],
      lastStrTableOffset: data[i + 9] << 8 | data[i + 8]
    };
    h.total = h.headerSize + h.boolCount + h.numCount * 2 + h.strCount * 2 + h.strTableSize;
    i += h.headerSize;
    var _bools = [];
    l = i + h.boolCount;
    for (;i < l; i++) {
      _bools.push(data[i] === 1);
    }
    if (i % 2) {
      assert.equal(data[i], 0);
      i++;
    }
    var _numbers = [];
    l = i + h.numCount * 2;
    for (;i < l; i += 2) {
      if (data[i + 1] === 255 && data[i] === 255) {
        _numbers.push(-1);
      } else {
        _numbers.push(data[i + 1] << 8 | data[i]);
      }
    }
    var _strings = [];
    l = i + h.strCount * 2;
    for (;i < l; i += 2) {
      if (data[i + 1] === 255 && data[i] === 255) {
        _strings.push(-1);
      } else {
        _strings.push(data[i + 1] << 8 | data[i]);
      }
    }
    i = data.length - h.lastStrTableOffset;
    var high = 0;
    _strings.forEach(function(offset, k) {
      if (offset === -1) {
        _strings[k] = "";
        return;
      }
      var s = i + offset, j2 = s;
      while (data[j2])
        j2++;
      assert(j2 < data.length);
      if (high < j2 - i) {
        high = j2 - i;
      }
      _strings[k] = data.toString("ascii", s, j2);
    });
    i += high + 1;
    l = data.length;
    var sym = [], j;
    for (;i < l; i++) {
      j = i;
      while (data[j])
        j++;
      sym.push(data.toString("ascii", i, j));
      i = j;
    }
    j = 0;
    info.bools = {};
    _bools.forEach(function(bool) {
      info.bools[sym[j++]] = bool;
    });
    info.numbers = {};
    _numbers.forEach(function(number) {
      info.numbers[sym[j++]] = number;
    });
    info.strings = {};
    _strings.forEach(function(string) {
      info.strings[sym[j++]] = string;
    });
    assert.equal(i, data.length);
    return info;
  };
  Tput.prototype.compileTerminfo = function(term) {
    return this.compile(this.readTerminfo(term));
  };
  Tput.prototype.injectTerminfo = function(term) {
    return this.inject(this.compileTerminfo(term));
  };
  Tput.prototype.compile = function(info) {
    var self2 = this;
    if (!info) {
      throw new Error("Terminal not found.");
    }
    this.detectFeatures(info);
    this._debug(info);
    info.all = {};
    info.methods = {};
    ["bools", "numbers", "strings"].forEach(function(type2) {
      Object.keys(info[type2]).forEach(function(key) {
        info.all[key] = info[type2][key];
        info.methods[key] = self2._compile(info, key, info.all[key]);
      });
    });
    Tput.bools.forEach(function(key) {
      if (info.methods[key] == null)
        info.methods[key] = false;
    });
    Tput.numbers.forEach(function(key) {
      if (info.methods[key] == null)
        info.methods[key] = -1;
    });
    Tput.strings.forEach(function(key) {
      if (!info.methods[key])
        info.methods[key] = noop;
    });
    Object.keys(info.methods).forEach(function(key) {
      if (!Tput.alias[key])
        return;
      Tput.alias[key].forEach(function(alias) {
        info.methods[alias] = info.methods[key];
      });
    });
    return info;
  };
  Tput.prototype.inject = function(info) {
    var self2 = this, methods = info.methods || info;
    Object.keys(methods).forEach(function(key) {
      if (typeof methods[key] !== "function") {
        self2[key] = methods[key];
        return;
      }
      self2[key] = function() {
        var args2 = Array.prototype.slice.call(arguments);
        return methods[key].call(self2, args2);
      };
    });
    this.info = info;
    this.all = info.all;
    this.methods = info.methods;
    this.bools = info.bools;
    this.numbers = info.numbers;
    this.strings = info.strings;
    if (!~info.names.indexOf(this.terminal)) {
      this.terminal = info.name;
    }
    this.features = info.features;
    Object.keys(info.features).forEach(function(key) {
      if (key === "padding") {
        if (!info.features.padding && self2.options.padding !== true) {
          self2.padding = false;
        }
        return;
      }
      self2[key] = info.features[key];
    });
  };
  Tput.prototype._compile = function(info, key, str) {
    var v;
    this._debug("Compiling %s: %s", key, JSON.stringify(str));
    switch (typeof str) {
      case "boolean":
        return str;
      case "number":
        return str;
      case "string":
        break;
      default:
        return noop;
    }
    if (!str) {
      return noop;
    }
    if (key === "init_file" || key === "reset_file") {
      try {
        str = fs.readFileSync(str, "utf8");
        if (this.debug) {
          v = ("return " + JSON.stringify(str) + ";").replace(/\x1b/g, "\\x1b").replace(/\r/g, "\\r").replace(/\n/g, "\\n");
          process.stdout.write(v + "\n");
        }
        return function() {
          return str;
        };
      } catch (e) {
        return noop;
      }
    }
    var tkey = info.name + "." + key, header = "var v, dyn = {}, stat = {}, stack = [], out = [];", footer = ';return out.join("");', code = header, val = str, buff = "", cap, ch, fi, then, els, end;
    function read(regex, no) {
      cap = regex.exec(val);
      if (!cap)
        return;
      val = val.substring(cap[0].length);
      ch = cap[1];
      if (!no)
        clear();
      return cap;
    }
    function stmt(c) {
      if (code[code.length - 1] === ",") {
        code = code.slice(0, -1);
      }
      code += c;
    }
    function expr(c) {
      code += c + ",";
    }
    function echo(c) {
      if (c === '""')
        return;
      expr("out.push(" + c + ")");
    }
    function print2(c) {
      buff += c;
    }
    function clear() {
      if (buff) {
        echo(JSON.stringify(buff).replace(/\\u00([0-9a-fA-F]{2})/g, "\\x$1"));
        buff = "";
      }
    }
    while (val) {
      if (read(/^\n /, true)) {
        continue;
      }
      if (read(/^\^(.)/i, true)) {
        if (!(ch >= " " && ch <= "~")) {
          this._debug("%s: bad caret char.", tkey);
          print2(cap[0]);
          continue;
        }
        if (ch === "?") {
          ch = "\x7F";
        } else {
          ch = ch.charCodeAt(0) & 31;
          if (ch === 0)
            ch = 128;
          ch = String.fromCharCode(ch);
        }
        print2(ch);
        continue;
      }
      if (read(/^\\([0-7]{3})/, true)) {
        print2(String.fromCharCode(parseInt(ch, 8)));
        continue;
      }
      if (read(/^\\([eEnlrtbfs\^\\,:0]|.)/, true)) {
        switch (ch) {
          case "e":
          case "E":
            ch = "\x1B";
            break;
          case "n":
            ch = "\n";
            break;
          case "l":
            ch = "\x85";
            break;
          case "r":
            ch = "\r";
            break;
          case "t":
            ch = "\t";
            break;
          case "b":
            ch = "\b";
            break;
          case "f":
            ch = "\f";
            break;
          case "s":
            ch = " ";
            break;
          case "^":
            ch = "^";
            break;
          case "\\":
            ch = "\\";
            break;
          case ",":
            ch = ",";
            break;
          case ":":
            ch = ":";
            break;
          case "0":
            ch = "\x80";
            break;
          case "a":
            ch = "\x07";
            break;
          default:
            this._debug("%s: bad backslash char.", tkey);
            ch = cap[0];
            break;
        }
        print2(ch);
        continue;
      }
      if (read(/^\$<(\d+)([*\/]{0,2})>/, true)) {
        if (this.padding)
          print2(cap[0]);
        continue;
      }
      if (read(/^%%/, true)) {
        print2("%");
        continue;
      }
      if (read(/^%((?::-|[+# ]){1,4})?(\d+(?:\.\d+)?)?([doxXsc])/)) {
        if (this.printf || cap[1] || cap[2] || ~"oxX".indexOf(cap[3])) {
          echo('sprintf("' + cap[0].replace(":-", "-") + '", stack.pop())');
        } else if (cap[3] === "c") {
          echo("(v = stack.pop(), isFinite(v) " + '? String.fromCharCode(v || 0200) : "")');
        } else {
          echo("stack.pop()");
        }
        continue;
      }
      if (read(/^%p([1-9])/)) {
        expr("(stack.push(v = params[" + (ch - 1) + "]), v)");
        continue;
      }
      if (read(/^%P([a-z])/)) {
        expr("dyn." + ch + " = stack.pop()");
        continue;
      }
      if (read(/^%g([a-z])/)) {
        expr("(stack.push(dyn." + ch + "), dyn." + ch + ")");
        continue;
      }
      if (read(/^%P([A-Z])/)) {
        expr("stat." + ch + " = stack.pop()");
        continue;
      }
      if (read(/^%g([A-Z])/)) {
        expr("(stack.push(v = stat." + ch + "), v)");
        continue;
      }
      if (read(/^%'(.)'/)) {
        expr("(stack.push(v = " + ch.charCodeAt(0) + "), v)");
        continue;
      }
      if (read(/^%\{(\d+)\}/)) {
        expr("(stack.push(v = " + ch + "), v)");
        continue;
      }
      if (read(/^%l/)) {
        expr('(stack.push(v = (stack.pop() || "").length || 0), v)');
        continue;
      }
      if (read(/^%([+\-*\/m&|\^=><])/)) {
        if (ch === "=")
          ch = "===";
        else if (ch === "m")
          ch = "%";
        expr("(v = stack.pop()," + " stack.push(v = (stack.pop() " + ch + " v) || 0)," + " v)");
        continue;
      }
      if (read(/^%([AO])/)) {
        expr("(stack.push(v = (stack.pop() " + (ch === "A" ? "&&" : "||") + " stack.pop())), v)");
        continue;
      }
      if (read(/^%([!~])/)) {
        expr("(stack.push(v = " + ch + "stack.pop()), v)");
        continue;
      }
      if (read(/^%i/)) {
        expr("(params[0]++, params[1]++)");
        continue;
      }
      if (read(/^%\?/)) {
        end = -1;
        stmt(";if (");
        continue;
      }
      if (read(/^%t/)) {
        end = -1;
        stmt(") {");
        continue;
      }
      if (read(/^%e/)) {
        fi = val.indexOf("%?");
        then = val.indexOf("%t");
        els = val.indexOf("%e");
        end = val.indexOf("%;");
        if (end === -1)
          end = Infinity;
        if (then !== -1 && then < end && (fi === -1 || then < fi) && (els === -1 || then < els)) {
          stmt("} else if (");
        } else {
          stmt("} else {");
        }
        continue;
      }
      if (read(/^%;/)) {
        end = null;
        stmt("}");
        continue;
      }
      buff += val[0];
      val = val.substring(1);
    }
    clear();
    if (end != null) {
      stmt("}");
    }
    stmt(footer);
    v = code.slice(header.length, -footer.length);
    if (!v.length) {
      code = 'return "";';
    } else if (v = /^out\.push\(("(?:[^"]|\\")+")\)$/.exec(v)) {
      code = "return " + v[1] + ";";
    } else {
      code = code.replace(/\(stack\.push\(v = params\[(\d+)\]\), v\),out\.push\(stack\.pop\(\)\)/g, "out.push(params[$1])");
      v = code.slice(header.length, -footer.length);
      if (!~v.indexOf("v = "))
        code = code.replace("v, ", "");
      if (!~v.indexOf("dyn"))
        code = code.replace("dyn = {}, ", "");
      if (!~v.indexOf("stat"))
        code = code.replace("stat = {}, ", "");
      if (!~v.indexOf("stack"))
        code = code.replace("stack = [], ", "");
      code = code.replace(/out = \[\];out\.push\(("(?:[^"]|\\")+")\),/, "out = [$1];");
    }
    if (str === "\x1B%?") {
      code = 'return "\\x1b";';
    }
    if (this.debug) {
      v = code.replace(/\x1b/g, "\\x1b").replace(/\r/g, "\\r").replace(/\n/g, "\\n");
      process.stdout.write(v + "\n");
    }
    try {
      if (this.options.stringify && code.indexOf("return ") === 0) {
        return new Function("", code)();
      }
      return this.printf || ~code.indexOf("sprintf(") ? new Function("sprintf, params", code).bind(null, sprintf) : new Function("params", code);
    } catch (e) {
      console.error("");
      console.error("Error on %s:", tkey);
      console.error(JSON.stringify(str));
      console.error("");
      console.error(code.replace(/(,|;)/g, "$1\n"));
      e.stack = e.stack.replace(/\x1b/g, "\\x1b");
      throw e;
    }
  };
  Tput.prototype._print = function(code, print2, done) {
    var xon = !this.bools.needs_xon_xoff || this.bools.xon_xoff;
    print2 = print2 || write4;
    done = done || noop;
    if (!this.padding) {
      print2(code);
      return done();
    }
    var parts = code.split(/(?=\$<[\d.]+[*\/]{0,2}>)/), i = 0;
    (function next() {
      if (i === parts.length) {
        return done();
      }
      var part = parts[i++], padding = /^\$<([\d.]+)([*\/]{0,2})>/.exec(part), amount, suffix;
      if (!padding) {
        print2(part);
        return next();
      }
      part = part.substring(padding[0].length);
      amount = +padding[1];
      suffix = padding[2];
      if (xon && !~suffix.indexOf("/")) {
        print2(part);
        return next();
      }
      if (~suffix.indexOf("*")) {
        amount = amount;
      }
      return setTimeout(function() {
        print2(part);
        return next();
      }, amount);
    })();
  };
  Tput.print = function() {
    var fake = {
      padding: true,
      bools: { needs_xon_xoff: true, xon_xoff: false }
    };
    return Tput.prototype._print.apply(fake, arguments);
  };
  Tput.cpaths = [
    process.env.TERMCAP || "",
    (process.env.TERMPATH || "").split(/[: ]/),
    (process.env.HOME || "") + "/.termcap",
    "/usr/share/misc/termcap",
    "/etc/termcap"
  ];
  Tput.prototype.readTermcap = function(term) {
    var self2 = this, terms, term_, root, paths;
    term = term || this.terminal;
    if (~term.indexOf(path2.sep) && (terms = this._tryCap(path2.resolve(term)))) {
      term_ = path2.basename(term).split(".")[0];
      if (terms[process.env.TERM]) {
        term = process.env.TERM;
      } else if (terms[term_]) {
        term = term_;
      } else {
        term = Object.keys(terms)[0];
      }
    } else {
      paths = Tput.cpaths.slice();
      if (this.termcapFile) {
        paths.unshift(this.termcapFile);
      }
      paths.push(Tput.termcap);
      terms = this._tryCap(paths, term);
    }
    if (!terms) {
      throw new Error("Cannot find termcap for: " + term);
    }
    root = terms[term];
    if (this.debug) {
      this._termcap = terms;
    }
    (function tc(term2) {
      if (term2 && term2.strings.tc) {
        root.inherits = root.inherits || [];
        root.inherits.push(term2.strings.tc);
        var names = terms[term2.strings.tc] ? terms[term2.strings.tc].names : [term2.strings.tc];
        self2._debug("%s inherits from %s.", term2.names.join("/"), names.join("/"));
        var inherit = tc(terms[term2.strings.tc]);
        if (inherit) {
          ["bools", "numbers", "strings"].forEach(function(type2) {
            merge(term2[type2], inherit[type2]);
          });
        }
      }
      return term2;
    })(root);
    root = this.translateTermcap(root);
    return root;
  };
  Tput.prototype._tryCap = function(file, term) {
    if (!file)
      return;
    var terms, data, i;
    if (Array.isArray(file)) {
      for (i = 0;i < file.length; i++) {
        data = this._tryCap(file[i], term);
        if (data)
          return data;
      }
      return;
    }
    data = file[0] === "/" ? tryRead(file) : file;
    if (!data)
      return;
    terms = this.parseTermcap(data, file);
    if (term && !terms[term]) {
      return;
    }
    return terms;
  };
  Tput.prototype.parseTermcap = function(data, file) {
    var terms = {}, parts, term, entries, fields, field, names, i, j, k;
    data = data.replace(/\\\n[ \t]*/g, "");
    data = data.replace(/^#[^\n]+/gm, "");
    entries = data.trim().split(/\n+/);
    for (i = 0;i < entries.length; i++) {
      fields = entries[i].split(/:+/);
      for (j = 0;j < fields.length; j++) {
        field = fields[j].trim();
        if (!field)
          continue;
        if (j === 0) {
          names = field.split("|");
          term = {
            name: names[0],
            names,
            desc: names.pop(),
            file: ~file.indexOf(path2.sep) ? path2.resolve(file) : file,
            termcap: true
          };
          for (k = 0;k < names.length; k++) {
            terms[names[k]] = term;
          }
          term.bools = {};
          term.numbers = {};
          term.strings = {};
          continue;
        }
        if (~field.indexOf("=")) {
          parts = field.split("=");
          term.strings[parts[0]] = parts.slice(1).join("=");
        } else if (~field.indexOf("#")) {
          parts = field.split("#");
          term.numbers[parts[0]] = +parts.slice(1).join("#");
        } else {
          term.bools[field] = true;
        }
      }
    }
    return terms;
  };
  Tput.prototype.translateTermcap = function(info) {
    var self2 = this, out = {};
    if (!info)
      return;
    this._debug(info);
    ["name", "names", "desc", "file", "termcap"].forEach(function(key) {
      out[key] = info[key];
    });
    var map = function() {
      var out2 = {};
      Object.keys(Tput.alias).forEach(function(key) {
        var aliases = Tput.alias[key];
        out2[aliases.termcap] = key;
      });
      return out2;
    }();
    ["bools", "numbers", "strings"].forEach(function(key) {
      out[key] = {};
      Object.keys(info[key]).forEach(function(cap) {
        if (key === "strings") {
          info.strings[cap] = self2._captoinfo(cap, info.strings[cap], 1);
        }
        if (map[cap]) {
          out[key][map[cap]] = info[key][cap];
        } else {
          out[key][cap] = info[key][cap];
        }
      });
    });
    return out;
  };
  Tput.prototype.compileTermcap = function(term) {
    return this.compile(this.readTermcap(term));
  };
  Tput.prototype.injectTermcap = function(term) {
    return this.inject(this.compileTermcap(term));
  };
  Tput.prototype._captoinfo = function(cap, s, parameterized) {
    var self2 = this;
    var capstart;
    if (parameterized == null) {
      parameterized = 0;
    }
    var MAX_PUSHED = 16, stack = [];
    var stackptr = 0, onstack = 0, seenm = 0, seenn = 0, seenr = 0, param = 1, i = 0, out = "";
    function warn2() {
      var args2 = Array.prototype.slice.call(arguments);
      args2[0] = "captoinfo: " + (args2[0] || "");
      return self2._debug.apply(self2, args2);
    }
    function isdigit(ch) {
      return ch >= "0" && ch <= "9";
    }
    function isgraph(ch) {
      return ch > " " && ch <= "~";
    }
    function cvtchar(sp) {
      var c = "\0", len;
      var j = i;
      switch (sp[j]) {
        case "\\":
          switch (sp[++j]) {
            case "\'":
            case "$":
            case "\\":
            case "%":
              c = sp[j];
              len = 2;
              break;
            case "\0":
              c = "\\";
              len = 1;
              break;
            case "0":
            case "1":
            case "2":
            case "3":
              len = 1;
              while (isdigit(sp[j])) {
                c = String.fromCharCode(8 * c.charCodeAt(0) + (sp[j++].charCodeAt(0) - "0".charCodeAt(0)));
                len++;
              }
              break;
            default:
              c = sp[j];
              len = 2;
              break;
          }
          break;
        case "^":
          c = String.fromCharCode(sp[++j].charCodeAt(0) & 31);
          len = 2;
          break;
        default:
          c = sp[j];
          len = 1;
      }
      if (isgraph(c) && c !== "," && c !== "\'" && c !== "\\" && c !== ":") {
        out += "%\'";
        out += c;
        out += "\'";
      } else {
        out += "%{";
        if (c.charCodeAt(0) > 99) {
          out += String.fromCharCode((c.charCodeAt(0) / 100 | 0) + "0".charCodeAt(0));
        }
        if (c.charCodeAt(0) > 9) {
          out += String.fromCharCode((c.charCodeAt(0) / 10 | 0) % 10 + "0".charCodeAt(0));
        }
        out += String.fromCharCode(c.charCodeAt(0) % 10 + "0".charCodeAt(0));
        out += "}";
      }
      return len;
    }
    function getparm(parm, n) {
      if (seenr) {
        if (parm === 1) {
          parm = 2;
        } else if (parm === 2) {
          parm = 1;
        }
      }
      if (onstack === parm) {
        if (n > 1) {
          warn2("string may not be optimal");
          out += "%Pa";
          while (n--) {
            out += "%ga";
          }
        }
        return;
      }
      if (onstack !== 0) {
        push();
      }
      onstack = parm;
      while (n--) {
        out += "%p";
        out += String.fromCharCode("0".charCodeAt(0) + parm);
      }
      if (seenn && parm < 3) {
        out += "%{96}%^";
      }
      if (seenm && parm < 3) {
        out += "%{127}%^";
      }
    }
    function push() {
      if (stackptr >= MAX_PUSHED) {
        warn2("string too complex to convert");
      } else {
        stack[stackptr++] = onstack;
      }
    }
    function pop() {
      if (stackptr === 0) {
        if (onstack === 0) {
          warn2("I\'m confused");
        } else {
          onstack = 0;
        }
      } else {
        onstack = stack[--stackptr];
      }
      param++;
    }
    function see03() {
      getparm(param, 1);
      out += "%3d";
      pop();
    }
    function invalid() {
      out += "%";
      i--;
      warn2("unknown %% code %s (%#x) in %s", JSON.stringify(s[i]), s[i].charCodeAt(0), cap);
    }
    capstart = null;
    if (s == null)
      s = "";
    if (parameterized >= 0 && isdigit(s[i])) {
      for (capstart = i;; i++) {
        if (!(isdigit(s[i]) || s[i] === "*" || s[i] === ".")) {
          break;
        }
      }
    }
    while (s[i]) {
      switch (s[i]) {
        case "%":
          i++;
          if (parameterized < 1) {
            out += "%";
            break;
          }
          switch (s[i++]) {
            case "%":
              out += "%";
              break;
            case "r":
              if (seenr++ === 1) {
                warn2("saw %%r twice in %s", cap);
              }
              break;
            case "m":
              if (seenm++ === 1) {
                warn2("saw %%m twice in %s", cap);
              }
              break;
            case "n":
              if (seenn++ === 1) {
                warn2("saw %%n twice in %s", cap);
              }
              break;
            case "i":
              out += "%i";
              break;
            case "6":
            case "B":
              getparm(param, 1);
              out += "%{10}%/%{16}%*";
              getparm(param, 1);
              out += "%{10}%m%+";
              break;
            case "8":
            case "D":
              getparm(param, 2);
              out += "%{2}%*%-";
              break;
            case ">":
              getparm(param, 2);
              out += "%?";
              i += cvtchar(s);
              out += "%>%t";
              i += cvtchar(s);
              out += "%+%;";
              break;
            case "a":
              if ((s[i] === "=" || s[i] === "+" || s[i] === "-" || s[i] === "*" || s[i] === "/") && (s[i + 1] === "p" || s[i + 1] === "c") && s[i + 2] !== "\0" && s[i + 2]) {
                var l;
                l = 2;
                if (s[i] !== "=") {
                  getparm(param, 1);
                }
                if (s[i + 1] === "p") {
                  getparm(param + s[i + 2].charCodeAt(0) - "@".charCodeAt(0), 1);
                  if (param !== onstack) {
                    pop();
                    param--;
                  }
                  l++;
                } else {
                  i += 2, l += cvtchar(s), i -= 2;
                }
                switch (s[i]) {
                  case "+":
                    out += "%+";
                    break;
                  case "-":
                    out += "%-";
                    break;
                  case "*":
                    out += "%*";
                    break;
                  case "/":
                    out += "%/";
                    break;
                  case "=":
                    if (seenr) {
                      if (param === 1) {
                        onstack = 2;
                      } else if (param === 2) {
                        onstack = 1;
                      } else {
                        onstack = param;
                      }
                    } else {
                      onstack = param;
                    }
                    break;
                }
                i += l;
                break;
              }
              getparm(param, 1);
              i += cvtchar(s);
              out += "%+";
              break;
            case "+":
              getparm(param, 1);
              i += cvtchar(s);
              out += "%+%c";
              pop();
              break;
            case "s":
              getparm(param, 1);
              out += "%s";
              pop();
              break;
            case "-":
              i += cvtchar(s);
              getparm(param, 1);
              out += "%-%c";
              pop();
              break;
            case ".":
              getparm(param, 1);
              out += "%c";
              pop();
              break;
            case "0":
              if (s[i] === "3") {
                see03();
                break;
              } else if (s[i] !== "2") {
                invalid();
                break;
              }
            case "2":
              getparm(param, 1);
              out += "%2d";
              pop();
              break;
            case "3":
              see03();
              break;
            case "d":
              getparm(param, 1);
              out += "%d";
              pop();
              break;
            case "f":
              param++;
              break;
            case "b":
              param--;
              break;
            case "\\":
              out += "%\\";
              break;
            default:
              invalid();
              break;
          }
          break;
        default:
          out += s[i++];
          break;
      }
    }
    if (capstart != null) {
      out += "$<";
      for (i = capstart;; i++) {
        if (isdigit(s[i]) || s[i] === "*" || s[i] === ".") {
          out += s[i];
        } else {
          break;
        }
      }
      out += "/>";
    }
    if (s !== out) {
      warn2("Translating %s from %s to %s.", cap, JSON.stringify(s), JSON.stringify(out));
    }
    return out;
  };
  Tput.prototype.getAll = function() {
    var dir = this._prefix(), list = asort(fs.readdirSync(dir)), infos = [];
    list.forEach(function(letter) {
      var terms = asort(fs.readdirSync(path2.resolve(dir, letter)));
      infos.push.apply(infos, terms);
    });
    function asort(obj) {
      return obj.sort(function(a, b) {
        a = a.toLowerCase().charCodeAt(0);
        b = b.toLowerCase().charCodeAt(0);
        return a - b;
      });
    }
    return infos;
  };
  Tput.prototype.compileAll = function(start) {
    var self2 = this, all2 = {};
    this.getAll().forEach(function(name2) {
      if (start && name2 !== start) {
        return;
      } else {
        start = null;
      }
      all2[name2] = self2.compileTerminfo(name2);
    });
    return all2;
  };
  Tput.prototype.detectFeatures = function(info) {
    var data = this.parseACS(info);
    info.features = {
      unicode: this.detectUnicode(info),
      brokenACS: this.detectBrokenACS(info),
      PCRomSet: this.detectPCRomSet(info),
      magicCookie: this.detectMagicCookie(info),
      padding: this.detectPadding(info),
      setbuf: this.detectSetbuf(info),
      acsc: data.acsc,
      acscr: data.acscr
    };
    return info.features;
  };
  Tput.prototype.detectUnicode = function() {
    if (this.options.forceUnicode != null) {
      return this.options.forceUnicode;
    }
    var LANG = process.env.LANG + ":" + process.env.LANGUAGE + ":" + process.env.LC_ALL + ":" + process.env.LC_CTYPE;
    return /utf-?8/i.test(LANG) || this.GetConsoleCP() === 65001;
  };
  Tput.prototype.detectBrokenACS = function(info) {
    if (process.env.NCURSES_NO_UTF8_ACS != null) {
      return !!+process.env.NCURSES_NO_UTF8_ACS;
    }
    if (info.numbers.U8 >= 0) {
      return !!info.numbers.U8;
    }
    if (info.name === "linux") {
      return true;
    }
    if (this.detectPCRomSet(info)) {
      return true;
    }
    if (this.termcap && info.name.indexOf("screen") === 0 && process.env.TERMCAP && ~process.env.TERMCAP.indexOf("screen") && ~process.env.TERMCAP.indexOf("hhII00")) {
      if (~info.strings.enter_alt_charset_mode.indexOf("\x0E") || ~info.strings.enter_alt_charset_mode.indexOf("\x0F") || ~info.strings.set_attributes.indexOf("\x0E") || ~info.strings.set_attributes.indexOf("\x0F")) {
        return true;
      }
    }
    return false;
  };
  Tput.prototype.detectPCRomSet = function(info) {
    var s = info.strings;
    if (s.enter_pc_charset_mode && s.enter_alt_charset_mode && s.enter_pc_charset_mode === s.enter_alt_charset_mode && s.exit_pc_charset_mode === s.exit_alt_charset_mode) {
      return true;
    }
    return false;
  };
  Tput.prototype.detectMagicCookie = function() {
    return process.env.NCURSES_NO_MAGIC_COOKIE == null;
  };
  Tput.prototype.detectPadding = function() {
    return process.env.NCURSES_NO_PADDING == null;
  };
  Tput.prototype.detectSetbuf = function() {
    return process.env.NCURSES_NO_SETBUF == null;
  };
  Tput.prototype.parseACS = function(info) {
    var data = {};
    data.acsc = {};
    data.acscr = {};
    if (this.detectPCRomSet(info)) {
      return data;
    }
    Object.keys(Tput.acsc).forEach(function(ch) {
      var acs_chars = info.strings.acs_chars || "", i = acs_chars.indexOf(ch), next = acs_chars[i + 1];
      if (!next || i === -1 || !Tput.acsc[next]) {
        return;
      }
      data.acsc[ch] = Tput.acsc[next];
      data.acscr[Tput.acsc[next]] = ch;
    });
    return data;
  };
  Tput.prototype.GetConsoleCP = function() {
    var ccp;
    if (process.platform !== "win32") {
      return -1;
    }
    if (+process.env.NCURSES_UNICODE !== 0) {
      return 65001;
    }
    try {
      ccp = cp.execFileSync(process.env.WINDIR + "\\system32\\chcp.com", [], {
        stdio: ["ignore", "pipe", "ignore"],
        encoding: "ascii",
        timeout: 1500
      });
    } catch (e) {
    }
    ccp = /\d+/.exec(ccp);
    if (!ccp) {
      return -1;
    }
    ccp = +ccp[0];
    return ccp;
  };
  noop.unsupported = true;
  Tput._alias = require_alias();
  Tput.alias = {};
  ["bools", "numbers", "strings"].forEach(function(type2) {
    Object.keys(Tput._alias[type2]).forEach(function(key) {
      var aliases = Tput._alias[type2][key];
      Tput.alias[key] = [aliases[0]];
      Tput.alias[key].terminfo = aliases[0];
      Tput.alias[key].termcap = aliases[1];
    });
  });
  Tput.alias.no_esc_ctlc.push("beehive_glitch");
  Tput.alias.dest_tabs_magic_smso.push("teleray_glitch");
  Tput.alias.micro_col_size.push("micro_char_size");
  Tput.aliasMap = {};
  Object.keys(Tput.alias).forEach(function(key) {
    Tput.aliasMap[key] = key;
    Tput.alias[key].forEach(function(k) {
      Tput.aliasMap[k] = key;
    });
  });
  Tput.prototype.has = function(name2) {
    name2 = Tput.aliasMap[name2];
    var val = this.all[name2];
    if (!name2)
      return false;
    if (typeof val === "number") {
      return val !== -1;
    }
    return !!val;
  };
  Tput.termcap = "" + "vt102|dec vt102:" + ":do=^J:co#80:li#24:cl=50\\E[;H\\E[2J:" + ":le=^H:bs:cm=5\\E[%i%d;%dH:nd=2\\E[C:up=2\\E[A:" + ":ce=3\\E[K:cd=50\\E[J:so=2\\E[7m:se=2\\E[m:us=2\\E[4m:ue=2\\E[m:" + ":md=2\\E[1m:mr=2\\E[7m:mb=2\\E[5m:me=2\\E[m:is=\\E[1;24r\\E[24;1H:" + ":rs=\\E>\\E[?3l\\E[?4l\\E[?5l\\E[?7h\\E[?8h:ks=\\E[?1h\\E=:ke=\\E[?1l\\E>:" + ":ku=\\EOA:kd=\\EOB:kr=\\EOC:kl=\\EOD:kb=^H:\\\n" + ":ho=\\E[H:k1=\\EOP:k2=\\EOQ:k3=\\EOR:k4=\\EOS:pt:sr=5\\EM:vt#3:" + ":sc=\\E7:rc=\\E8:cs=\\E[%i%d;%dr:vs=\\E[?7l:ve=\\E[?7h:" + ":mi:al=\\E[L:dc=\\E[P:dl=\\E[M:ei=\\E[4l:im=\\E[4h:";
  Tput.bools = [
    "auto_left_margin",
    "auto_right_margin",
    "no_esc_ctlc",
    "ceol_standout_glitch",
    "eat_newline_glitch",
    "erase_overstrike",
    "generic_type",
    "hard_copy",
    "has_meta_key",
    "has_status_line",
    "insert_null_glitch",
    "memory_above",
    "memory_below",
    "move_insert_mode",
    "move_standout_mode",
    "over_strike",
    "status_line_esc_ok",
    "dest_tabs_magic_smso",
    "tilde_glitch",
    "transparent_underline",
    "xon_xoff",
    "needs_xon_xoff",
    "prtr_silent",
    "hard_cursor",
    "non_rev_rmcup",
    "no_pad_char",
    "non_dest_scroll_region",
    "can_change",
    "back_color_erase",
    "hue_lightness_saturation",
    "col_addr_glitch",
    "cr_cancels_micro_mode",
    "has_print_wheel",
    "row_addr_glitch",
    "semi_auto_right_margin",
    "cpi_changes_res",
    "lpi_changes_res",
    "backspaces_with_bs",
    "crt_no_scrolling",
    "no_correctly_working_cr",
    "gnu_has_meta_key",
    "linefeed_is_newline",
    "has_hardware_tabs",
    "return_does_clr_eol"
  ];
  Tput.numbers = [
    "columns",
    "init_tabs",
    "lines",
    "lines_of_memory",
    "magic_cookie_glitch",
    "padding_baud_rate",
    "virtual_terminal",
    "width_status_line",
    "num_labels",
    "label_height",
    "label_width",
    "max_attributes",
    "maximum_windows",
    "max_colors",
    "max_pairs",
    "no_color_video",
    "buffer_capacity",
    "dot_vert_spacing",
    "dot_horz_spacing",
    "max_micro_address",
    "max_micro_jump",
    "micro_col_size",
    "micro_line_size",
    "number_of_pins",
    "output_res_char",
    "output_res_line",
    "output_res_horz_inch",
    "output_res_vert_inch",
    "print_rate",
    "wide_char_size",
    "buttons",
    "bit_image_entwining",
    "bit_image_type",
    "magic_cookie_glitch_ul",
    "carriage_return_delay",
    "new_line_delay",
    "backspace_delay",
    "horizontal_tab_delay",
    "number_of_function_keys"
  ];
  Tput.strings = [
    "back_tab",
    "bell",
    "carriage_return",
    "change_scroll_region",
    "clear_all_tabs",
    "clear_screen",
    "clr_eol",
    "clr_eos",
    "column_address",
    "command_character",
    "cursor_address",
    "cursor_down",
    "cursor_home",
    "cursor_invisible",
    "cursor_left",
    "cursor_mem_address",
    "cursor_normal",
    "cursor_right",
    "cursor_to_ll",
    "cursor_up",
    "cursor_visible",
    "delete_character",
    "delete_line",
    "dis_status_line",
    "down_half_line",
    "enter_alt_charset_mode",
    "enter_blink_mode",
    "enter_bold_mode",
    "enter_ca_mode",
    "enter_delete_mode",
    "enter_dim_mode",
    "enter_insert_mode",
    "enter_secure_mode",
    "enter_protected_mode",
    "enter_reverse_mode",
    "enter_standout_mode",
    "enter_underline_mode",
    "erase_chars",
    "exit_alt_charset_mode",
    "exit_attribute_mode",
    "exit_ca_mode",
    "exit_delete_mode",
    "exit_insert_mode",
    "exit_standout_mode",
    "exit_underline_mode",
    "flash_screen",
    "form_feed",
    "from_status_line",
    "init_1string",
    "init_2string",
    "init_3string",
    "init_file",
    "insert_character",
    "insert_line",
    "insert_padding",
    "key_backspace",
    "key_catab",
    "key_clear",
    "key_ctab",
    "key_dc",
    "key_dl",
    "key_down",
    "key_eic",
    "key_eol",
    "key_eos",
    "key_f0",
    "key_f1",
    "key_f10",
    "key_f2",
    "key_f3",
    "key_f4",
    "key_f5",
    "key_f6",
    "key_f7",
    "key_f8",
    "key_f9",
    "key_home",
    "key_ic",
    "key_il",
    "key_left",
    "key_ll",
    "key_npage",
    "key_ppage",
    "key_right",
    "key_sf",
    "key_sr",
    "key_stab",
    "key_up",
    "keypad_local",
    "keypad_xmit",
    "lab_f0",
    "lab_f1",
    "lab_f10",
    "lab_f2",
    "lab_f3",
    "lab_f4",
    "lab_f5",
    "lab_f6",
    "lab_f7",
    "lab_f8",
    "lab_f9",
    "meta_off",
    "meta_on",
    "newline",
    "pad_char",
    "parm_dch",
    "parm_delete_line",
    "parm_down_cursor",
    "parm_ich",
    "parm_index",
    "parm_insert_line",
    "parm_left_cursor",
    "parm_right_cursor",
    "parm_rindex",
    "parm_up_cursor",
    "pkey_key",
    "pkey_local",
    "pkey_xmit",
    "print_screen",
    "prtr_off",
    "prtr_on",
    "repeat_char",
    "reset_1string",
    "reset_2string",
    "reset_3string",
    "reset_file",
    "restore_cursor",
    "row_address",
    "save_cursor",
    "scroll_forward",
    "scroll_reverse",
    "set_attributes",
    "set_tab",
    "set_window",
    "tab",
    "to_status_line",
    "underline_char",
    "up_half_line",
    "init_prog",
    "key_a1",
    "key_a3",
    "key_b2",
    "key_c1",
    "key_c3",
    "prtr_non",
    "char_padding",
    "acs_chars",
    "plab_norm",
    "key_btab",
    "enter_xon_mode",
    "exit_xon_mode",
    "enter_am_mode",
    "exit_am_mode",
    "xon_character",
    "xoff_character",
    "ena_acs",
    "label_on",
    "label_off",
    "key_beg",
    "key_cancel",
    "key_close",
    "key_command",
    "key_copy",
    "key_create",
    "key_end",
    "key_enter",
    "key_exit",
    "key_find",
    "key_help",
    "key_mark",
    "key_message",
    "key_move",
    "key_next",
    "key_open",
    "key_options",
    "key_previous",
    "key_print",
    "key_redo",
    "key_reference",
    "key_refresh",
    "key_replace",
    "key_restart",
    "key_resume",
    "key_save",
    "key_suspend",
    "key_undo",
    "key_sbeg",
    "key_scancel",
    "key_scommand",
    "key_scopy",
    "key_screate",
    "key_sdc",
    "key_sdl",
    "key_select",
    "key_send",
    "key_seol",
    "key_sexit",
    "key_sfind",
    "key_shelp",
    "key_shome",
    "key_sic",
    "key_sleft",
    "key_smessage",
    "key_smove",
    "key_snext",
    "key_soptions",
    "key_sprevious",
    "key_sprint",
    "key_sredo",
    "key_sreplace",
    "key_sright",
    "key_srsume",
    "key_ssave",
    "key_ssuspend",
    "key_sundo",
    "req_for_input",
    "key_f11",
    "key_f12",
    "key_f13",
    "key_f14",
    "key_f15",
    "key_f16",
    "key_f17",
    "key_f18",
    "key_f19",
    "key_f20",
    "key_f21",
    "key_f22",
    "key_f23",
    "key_f24",
    "key_f25",
    "key_f26",
    "key_f27",
    "key_f28",
    "key_f29",
    "key_f30",
    "key_f31",
    "key_f32",
    "key_f33",
    "key_f34",
    "key_f35",
    "key_f36",
    "key_f37",
    "key_f38",
    "key_f39",
    "key_f40",
    "key_f41",
    "key_f42",
    "key_f43",
    "key_f44",
    "key_f45",
    "key_f46",
    "key_f47",
    "key_f48",
    "key_f49",
    "key_f50",
    "key_f51",
    "key_f52",
    "key_f53",
    "key_f54",
    "key_f55",
    "key_f56",
    "key_f57",
    "key_f58",
    "key_f59",
    "key_f60",
    "key_f61",
    "key_f62",
    "key_f63",
    "clr_bol",
    "clear_margins",
    "set_left_margin",
    "set_right_margin",
    "label_format",
    "set_clock",
    "display_clock",
    "remove_clock",
    "create_window",
    "goto_window",
    "hangup",
    "dial_phone",
    "quick_dial",
    "tone",
    "pulse",
    "flash_hook",
    "fixed_pause",
    "wait_tone",
    "user0",
    "user1",
    "user2",
    "user3",
    "user4",
    "user5",
    "user6",
    "user7",
    "user8",
    "user9",
    "orig_pair",
    "orig_colors",
    "initialize_color",
    "initialize_pair",
    "set_color_pair",
    "set_foreground",
    "set_background",
    "change_char_pitch",
    "change_line_pitch",
    "change_res_horz",
    "change_res_vert",
    "define_char",
    "enter_doublewide_mode",
    "enter_draft_quality",
    "enter_italics_mode",
    "enter_leftward_mode",
    "enter_micro_mode",
    "enter_near_letter_quality",
    "enter_normal_quality",
    "enter_shadow_mode",
    "enter_subscript_mode",
    "enter_superscript_mode",
    "enter_upward_mode",
    "exit_doublewide_mode",
    "exit_italics_mode",
    "exit_leftward_mode",
    "exit_micro_mode",
    "exit_shadow_mode",
    "exit_subscript_mode",
    "exit_superscript_mode",
    "exit_upward_mode",
    "micro_column_address",
    "micro_down",
    "micro_left",
    "micro_right",
    "micro_row_address",
    "micro_up",
    "order_of_pins",
    "parm_down_micro",
    "parm_left_micro",
    "parm_right_micro",
    "parm_up_micro",
    "select_char_set",
    "set_bottom_margin",
    "set_bottom_margin_parm",
    "set_left_margin_parm",
    "set_right_margin_parm",
    "set_top_margin",
    "set_top_margin_parm",
    "start_bit_image",
    "start_char_set_def",
    "stop_bit_image",
    "stop_char_set_def",
    "subscript_characters",
    "superscript_characters",
    "these_cause_cr",
    "zero_motion",
    "char_set_names",
    "key_mouse",
    "mouse_info",
    "req_mouse_pos",
    "get_mouse",
    "set_a_foreground",
    "set_a_background",
    "pkey_plab",
    "device_type",
    "code_set_init",
    "set0_des_seq",
    "set1_des_seq",
    "set2_des_seq",
    "set3_des_seq",
    "set_lr_margin",
    "set_tb_margin",
    "bit_image_repeat",
    "bit_image_newline",
    "bit_image_carriage_return",
    "color_names",
    "define_bit_image_region",
    "end_bit_image_region",
    "set_color_band",
    "set_page_length",
    "display_pc_char",
    "enter_pc_charset_mode",
    "exit_pc_charset_mode",
    "enter_scancode_mode",
    "exit_scancode_mode",
    "pc_term_options",
    "scancode_escape",
    "alt_scancode_esc",
    "enter_horizontal_hl_mode",
    "enter_left_hl_mode",
    "enter_low_hl_mode",
    "enter_right_hl_mode",
    "enter_top_hl_mode",
    "enter_vertical_hl_mode",
    "set_a_attributes",
    "set_pglen_inch",
    "termcap_init2",
    "termcap_reset",
    "linefeed_if_not_lf",
    "backspace_if_not_bs",
    "other_non_function_keys",
    "arrow_key_map",
    "acs_ulcorner",
    "acs_llcorner",
    "acs_urcorner",
    "acs_lrcorner",
    "acs_ltee",
    "acs_rtee",
    "acs_btee",
    "acs_ttee",
    "acs_hline",
    "acs_vline",
    "acs_plus",
    "memory_lock",
    "memory_unlock",
    "box_chars_1"
  ];
  Tput.acsc = {
    "`": "\u25C6",
    a: "\u2592",
    b: "\t",
    c: "\f",
    d: `\r`,
    e: `
`,
    f: "\xB0",
    g: "\xB1",
    h: "\u2424",
    i: "\v",
    j: "\u2518",
    k: "\u2510",
    l: "\u250C",
    m: "\u2514",
    n: "\u253C",
    o: "\u23BA",
    p: "\u23BB",
    q: "\u2500",
    r: "\u23BC",
    s: "\u23BD",
    t: "\u251C",
    u: "\u2524",
    v: "\u2534",
    w: "\u252C",
    x: "\u2502",
    y: "\u2264",
    z: "\u2265",
    "{": "\u03C0",
    "|": "\u2260",
    "}": "\xA3",
    "~": "\xB7"
  };
  Tput.utoa = Tput.prototype.utoa = {
    "\u25C6": "*",
    "\u2592": " ",
    "\xB0": "*",
    "\xB1": "+",
    "\u2424": "\n",
    "\u2518": "+",
    "\u2510": "+",
    "\u250C": "+",
    "\u2514": "+",
    "\u253C": "+",
    "\u23BA": "-",
    "\u23BB": "-",
    "\u2500": "-",
    "\u23BC": "-",
    "\u23BD": "_",
    "\u251C": "+",
    "\u2524": "+",
    "\u2534": "+",
    "\u252C": "+",
    "\u2502": "|",
    "\u2264": "<",
    "\u2265": ">",
    "\u03C0": "?",
    "\u2260": "=",
    "\xA3": "?",
    "\xB7": "*"
  };
  exports2 = Tput;
  exports2.sprintf = sprintf;
  exports2.tryRead = tryRead;
  module2.exports = exports2;
});

// ../../node_modules/blessed/lib/colors.js
var require_colors = __commonJS((exports2) => {
  var colorDistance = function(r1, g1, b1, r2, g2, b2) {
    return Math.pow(30 * (r1 - r2), 2) + Math.pow(59 * (g1 - g2), 2) + Math.pow(11 * (b1 - b2), 2);
  };
  exports2.match = function(r1, g1, b1) {
    if (typeof r1 === "string") {
      var hex = r1;
      if (hex[0] !== "#") {
        return -1;
      }
      hex = exports2.hexToRGB(hex);
      r1 = hex[0], g1 = hex[1], b1 = hex[2];
    } else if (Array.isArray(r1)) {
      b1 = r1[2], g1 = r1[1], r1 = r1[0];
    }
    var hash = r1 << 16 | g1 << 8 | b1;
    if (exports2._cache[hash] != null) {
      return exports2._cache[hash];
    }
    var ldiff = Infinity, li = -1, i = 0, c, r2, g2, b2, diff;
    for (;i < exports2.vcolors.length; i++) {
      c = exports2.vcolors[i];
      r2 = c[0];
      g2 = c[1];
      b2 = c[2];
      diff = colorDistance(r1, g1, b1, r2, g2, b2);
      if (diff === 0) {
        li = i;
        break;
      }
      if (diff < ldiff) {
        ldiff = diff;
        li = i;
      }
    }
    return exports2._cache[hash] = li;
  };
  exports2.RGBToHex = function(r, g, b) {
    if (Array.isArray(r)) {
      b = r[2], g = r[1], r = r[0];
    }
    function hex(n) {
      n = n.toString(16);
      if (n.length < 2)
        n = "0" + n;
      return n;
    }
    return "#" + hex(r) + hex(g) + hex(b);
  };
  exports2.hexToRGB = function(hex) {
    if (hex.length === 4) {
      hex = hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
    }
    var col = parseInt(hex.substring(1), 16), r = col >> 16 & 255, g = col >> 8 & 255, b = col & 255;
    return [r, g, b];
  };
  exports2.mixColors = function(c1, c2, alpha) {
    if (c1 === 511)
      c1 = 0;
    if (c2 === 511)
      c2 = 0;
    if (alpha == null)
      alpha = 0.5;
    c1 = exports2.vcolors[c1];
    var r1 = c1[0];
    var g1 = c1[1];
    var b1 = c1[2];
    c2 = exports2.vcolors[c2];
    var r2 = c2[0];
    var g2 = c2[1];
    var b2 = c2[2];
    r1 += (r2 - r1) * alpha | 0;
    g1 += (g2 - g1) * alpha | 0;
    b1 += (b2 - b1) * alpha | 0;
    return exports2.match([r1, g1, b1]);
  };
  exports2.blend = function blend(attr, attr2, alpha) {
    var name2, i, c, nc;
    var bg = attr & 511;
    if (attr2 != null) {
      var bg2 = attr2 & 511;
      if (bg === 511)
        bg = 0;
      if (bg2 === 511)
        bg2 = 0;
      bg = exports2.mixColors(bg, bg2, alpha);
    } else {
      if (blend._cache[bg] != null) {
        bg = blend._cache[bg];
      } else if (bg >= 8 && bg <= 15) {
        bg -= 8;
      } else {
        name2 = exports2.ncolors[bg];
        if (name2) {
          for (i = 0;i < exports2.ncolors.length; i++) {
            if (name2 === exports2.ncolors[i] && i !== bg) {
              c = exports2.vcolors[bg];
              nc = exports2.vcolors[i];
              if (nc[0] + nc[1] + nc[2] < c[0] + c[1] + c[2]) {
                blend._cache[bg] = i;
                bg = i;
                break;
              }
            }
          }
        }
      }
    }
    attr &= ~511;
    attr |= bg;
    var fg = attr >> 9 & 511;
    if (attr2 != null) {
      var fg2 = attr2 >> 9 & 511;
      if (fg === 511) {
        fg = 248;
      } else {
        if (fg === 511)
          fg = 7;
        if (fg2 === 511)
          fg2 = 7;
        fg = exports2.mixColors(fg, fg2, alpha);
      }
    } else {
      if (blend._cache[fg] != null) {
        fg = blend._cache[fg];
      } else if (fg >= 8 && fg <= 15) {
        fg -= 8;
      } else {
        name2 = exports2.ncolors[fg];
        if (name2) {
          for (i = 0;i < exports2.ncolors.length; i++) {
            if (name2 === exports2.ncolors[i] && i !== fg) {
              c = exports2.vcolors[fg];
              nc = exports2.vcolors[i];
              if (nc[0] + nc[1] + nc[2] < c[0] + c[1] + c[2]) {
                blend._cache[fg] = i;
                fg = i;
                break;
              }
            }
          }
        }
      }
    }
    attr &= ~(511 << 9);
    attr |= fg << 9;
    return attr;
  };
  exports2.blend._cache = {};
  exports2._cache = {};
  exports2.reduce = function(color, total) {
    if (color >= 16 && total <= 16) {
      color = exports2.ccolors[color];
    } else if (color >= 8 && total <= 8) {
      color -= 8;
    } else if (color >= 2 && total <= 2) {
      color %= 2;
    }
    return color;
  };
  exports2.xterm = [
    "#000000",
    "#cd0000",
    "#00cd00",
    "#cdcd00",
    "#0000ee",
    "#cd00cd",
    "#00cdcd",
    "#e5e5e5",
    "#7f7f7f",
    "#ff0000",
    "#00ff00",
    "#ffff00",
    "#5c5cff",
    "#ff00ff",
    "#00ffff",
    "#ffffff"
  ];
  exports2.colors = function() {
    var cols = exports2.colors = [], _cols = exports2.vcolors = [], r, g, b, i, l;
    function hex(n) {
      n = n.toString(16);
      if (n.length < 2)
        n = "0" + n;
      return n;
    }
    function push(i2, r2, g2, b2) {
      cols[i2] = "#" + hex(r2) + hex(g2) + hex(b2);
      _cols[i2] = [r2, g2, b2];
    }
    exports2.xterm.forEach(function(c, i2) {
      c = parseInt(c.substring(1), 16);
      push(i2, c >> 16 & 255, c >> 8 & 255, c & 255);
    });
    for (r = 0;r < 6; r++) {
      for (g = 0;g < 6; g++) {
        for (b = 0;b < 6; b++) {
          i = 16 + r * 36 + g * 6 + b;
          push(i, r ? r * 40 + 55 : 0, g ? g * 40 + 55 : 0, b ? b * 40 + 55 : 0);
        }
      }
    }
    for (g = 0;g < 24; g++) {
      l = g * 10 + 8;
      i = 232 + g;
      push(i, l, l, l);
    }
    return cols;
  }();
  exports2.ccolors = function() {
    var _cols = exports2.vcolors.slice(), cols = exports2.colors.slice(), out;
    exports2.vcolors = exports2.vcolors.slice(0, 8);
    exports2.colors = exports2.colors.slice(0, 8);
    out = cols.map(exports2.match);
    exports2.colors = cols;
    exports2.vcolors = _cols;
    exports2.ccolors = out;
    return out;
  }();
  var colorNames = exports2.colorNames = {
    default: -1,
    normal: -1,
    bg: -1,
    fg: -1,
    black: 0,
    red: 1,
    green: 2,
    yellow: 3,
    blue: 4,
    magenta: 5,
    cyan: 6,
    white: 7,
    lightblack: 8,
    lightred: 9,
    lightgreen: 10,
    lightyellow: 11,
    lightblue: 12,
    lightmagenta: 13,
    lightcyan: 14,
    lightwhite: 15,
    brightblack: 8,
    brightred: 9,
    brightgreen: 10,
    brightyellow: 11,
    brightblue: 12,
    brightmagenta: 13,
    brightcyan: 14,
    brightwhite: 15,
    grey: 8,
    gray: 8,
    lightgrey: 7,
    lightgray: 7,
    brightgrey: 7,
    brightgray: 7
  };
  exports2.convert = function(color) {
    if (typeof color === "number") {
    } else if (typeof color === "string") {
      color = color.replace(/[\- ]/g, "");
      if (colorNames[color] != null) {
        color = colorNames[color];
      } else {
        color = exports2.match(color);
      }
    } else if (Array.isArray(color)) {
      color = exports2.match(color);
    } else {
      color = -1;
    }
    return color !== -1 ? color : 511;
  };
  exports2.ccolors = {
    blue: [
      4,
      12,
      [17, 21],
      [24, 27],
      [31, 33],
      [38, 39],
      45,
      [54, 57],
      [60, 63],
      [67, 69],
      [74, 75],
      81,
      [91, 93],
      [97, 99],
      [103, 105],
      [110, 111],
      117,
      [128, 129],
      [134, 135],
      [140, 141],
      [146, 147],
      153,
      165,
      171,
      177,
      183,
      189
    ],
    green: [
      2,
      10,
      22,
      [28, 29],
      [34, 36],
      [40, 43],
      [46, 50],
      [64, 65],
      [70, 72],
      [76, 79],
      [82, 86],
      [106, 108],
      [112, 115],
      [118, 122],
      [148, 151],
      [154, 158],
      [190, 194]
    ],
    cyan: [
      6,
      14,
      23,
      30,
      37,
      44,
      51,
      66,
      73,
      80,
      87,
      109,
      116,
      123,
      152,
      159,
      195
    ],
    red: [
      1,
      9,
      52,
      [88, 89],
      [94, 95],
      [124, 126],
      [130, 132],
      [136, 138],
      [160, 163],
      [166, 169],
      [172, 175],
      [178, 181],
      [196, 200],
      [202, 206],
      [208, 212],
      [214, 218],
      [220, 224]
    ],
    magenta: [
      5,
      13,
      53,
      90,
      96,
      127,
      133,
      139,
      164,
      170,
      176,
      182,
      201,
      207,
      213,
      219,
      225
    ],
    yellow: [
      3,
      11,
      58,
      [100, 101],
      [142, 144],
      [184, 187],
      [226, 230]
    ],
    black: [
      0,
      8,
      16,
      59,
      102,
      [232, 243]
    ],
    white: [
      7,
      15,
      145,
      188,
      231,
      [244, 255]
    ]
  };
  exports2.ncolors = [];
  Object.keys(exports2.ccolors).forEach(function(name2) {
    exports2.ccolors[name2].forEach(function(offset) {
      if (typeof offset === "number") {
        exports2.ncolors[offset] = name2;
        exports2.ccolors[offset] = exports2.colorNames[name2];
        return;
      }
      for (var i = offset[0], l = offset[1];i <= l; i++) {
        exports2.ncolors[i] = name2;
        exports2.ccolors[i] = exports2.colorNames[name2];
      }
    });
    delete exports2.ccolors[name2];
  });
});

// ../../node_modules/blessed/lib/keys.js
var require_keys2 = __commonJS((exports2) => {
  var listenerCount = function(stream2, event) {
    return EventEmitter.listenerCount ? EventEmitter.listenerCount(stream2, event) : stream2.listeners(event).length;
  };
  var emitKeypressEvents = function(stream2) {
    if (stream2._keypressDecoder)
      return;
    var StringDecoder2 = __require("string_decoder").StringDecoder;
    stream2._keypressDecoder = new StringDecoder2("utf8");
    function onData(b) {
      if (listenerCount(stream2, "keypress") > 0) {
        var r = stream2._keypressDecoder.write(b);
        if (r)
          emitKeys(stream2, r);
      } else {
        stream2.removeListener("data", onData);
        stream2.on("newListener", onNewListener);
      }
    }
    function onNewListener(event) {
      if (event === "keypress") {
        stream2.on("data", onData);
        stream2.removeListener("newListener", onNewListener);
      }
    }
    if (listenerCount(stream2, "keypress") > 0) {
      stream2.on("data", onData);
    } else {
      stream2.on("newListener", onNewListener);
    }
  };
  var emitKeys = function(stream2, s) {
    if (Buffer.isBuffer(s)) {
      if (s[0] > 127 && s[1] === undefined) {
        s[0] -= 128;
        s = "\x1B" + s.toString(stream2.encoding || "utf-8");
      } else {
        s = s.toString(stream2.encoding || "utf-8");
      }
    }
    if (isMouse(s))
      return;
    var buffer = [];
    var match;
    while (match = escapeCodeReAnywhere.exec(s)) {
      buffer = buffer.concat(s.slice(0, match.index).split(""));
      buffer.push(match[0]);
      s = s.slice(match.index + match[0].length);
    }
    buffer = buffer.concat(s.split(""));
    buffer.forEach(function(s2) {
      var ch, key = {
        sequence: s2,
        name: undefined,
        ctrl: false,
        meta: false,
        shift: false
      }, parts;
      if (s2 === "\r") {
        key.name = "return";
      } else if (s2 === "\n") {
        key.name = "enter";
      } else if (s2 === "\t") {
        key.name = "tab";
      } else if (s2 === "\b" || s2 === "\x7F" || s2 === "\x1B\x7F" || s2 === "\x1B\b") {
        key.name = "backspace";
        key.meta = s2.charAt(0) === "\x1B";
      } else if (s2 === "\x1B" || s2 === "\x1B\x1B") {
        key.name = "escape";
        key.meta = s2.length === 2;
      } else if (s2 === " " || s2 === "\x1B ") {
        key.name = "space";
        key.meta = s2.length === 2;
      } else if (s2.length === 1 && s2 <= "\x1A") {
        key.name = String.fromCharCode(s2.charCodeAt(0) + "a".charCodeAt(0) - 1);
        key.ctrl = true;
      } else if (s2.length === 1 && s2 >= "a" && s2 <= "z") {
        key.name = s2;
      } else if (s2.length === 1 && s2 >= "A" && s2 <= "Z") {
        key.name = s2.toLowerCase();
        key.shift = true;
      } else if (parts = metaKeyCodeRe.exec(s2)) {
        key.name = parts[1].toLowerCase();
        key.meta = true;
        key.shift = /^[A-Z]$/.test(parts[1]);
      } else if (parts = functionKeyCodeRe.exec(s2)) {
        var code = (parts[1] || "") + (parts[2] || "") + (parts[4] || "") + (parts[9] || ""), modifier = (parts[3] || parts[8] || 1) - 1;
        key.ctrl = !!(modifier & 4);
        key.meta = !!(modifier & 10);
        key.shift = !!(modifier & 1);
        key.code = code;
        switch (code) {
          case "OP":
            key.name = "f1";
            break;
          case "OQ":
            key.name = "f2";
            break;
          case "OR":
            key.name = "f3";
            break;
          case "OS":
            key.name = "f4";
            break;
          case "[11~":
            key.name = "f1";
            break;
          case "[12~":
            key.name = "f2";
            break;
          case "[13~":
            key.name = "f3";
            break;
          case "[14~":
            key.name = "f4";
            break;
          case "[[A":
            key.name = "f1";
            break;
          case "[[B":
            key.name = "f2";
            break;
          case "[[C":
            key.name = "f3";
            break;
          case "[[D":
            key.name = "f4";
            break;
          case "[[E":
            key.name = "f5";
            break;
          case "[15~":
            key.name = "f5";
            break;
          case "[17~":
            key.name = "f6";
            break;
          case "[18~":
            key.name = "f7";
            break;
          case "[19~":
            key.name = "f8";
            break;
          case "[20~":
            key.name = "f9";
            break;
          case "[21~":
            key.name = "f10";
            break;
          case "[23~":
            key.name = "f11";
            break;
          case "[24~":
            key.name = "f12";
            break;
          case "[A":
            key.name = "up";
            break;
          case "[B":
            key.name = "down";
            break;
          case "[C":
            key.name = "right";
            break;
          case "[D":
            key.name = "left";
            break;
          case "[E":
            key.name = "clear";
            break;
          case "[F":
            key.name = "end";
            break;
          case "[H":
            key.name = "home";
            break;
          case "OA":
            key.name = "up";
            break;
          case "OB":
            key.name = "down";
            break;
          case "OC":
            key.name = "right";
            break;
          case "OD":
            key.name = "left";
            break;
          case "OE":
            key.name = "clear";
            break;
          case "OF":
            key.name = "end";
            break;
          case "OH":
            key.name = "home";
            break;
          case "[1~":
            key.name = "home";
            break;
          case "[2~":
            key.name = "insert";
            break;
          case "[3~":
            key.name = "delete";
            break;
          case "[4~":
            key.name = "end";
            break;
          case "[5~":
            key.name = "pageup";
            break;
          case "[6~":
            key.name = "pagedown";
            break;
          case "[[5~":
            key.name = "pageup";
            break;
          case "[[6~":
            key.name = "pagedown";
            break;
          case "[7~":
            key.name = "home";
            break;
          case "[8~":
            key.name = "end";
            break;
          case "[a":
            key.name = "up";
            key.shift = true;
            break;
          case "[b":
            key.name = "down";
            key.shift = true;
            break;
          case "[c":
            key.name = "right";
            key.shift = true;
            break;
          case "[d":
            key.name = "left";
            key.shift = true;
            break;
          case "[e":
            key.name = "clear";
            key.shift = true;
            break;
          case "[2$":
            key.name = "insert";
            key.shift = true;
            break;
          case "[3$":
            key.name = "delete";
            key.shift = true;
            break;
          case "[5$":
            key.name = "pageup";
            key.shift = true;
            break;
          case "[6$":
            key.name = "pagedown";
            key.shift = true;
            break;
          case "[7$":
            key.name = "home";
            key.shift = true;
            break;
          case "[8$":
            key.name = "end";
            key.shift = true;
            break;
          case "Oa":
            key.name = "up";
            key.ctrl = true;
            break;
          case "Ob":
            key.name = "down";
            key.ctrl = true;
            break;
          case "Oc":
            key.name = "right";
            key.ctrl = true;
            break;
          case "Od":
            key.name = "left";
            key.ctrl = true;
            break;
          case "Oe":
            key.name = "clear";
            key.ctrl = true;
            break;
          case "[2^":
            key.name = "insert";
            key.ctrl = true;
            break;
          case "[3^":
            key.name = "delete";
            key.ctrl = true;
            break;
          case "[5^":
            key.name = "pageup";
            key.ctrl = true;
            break;
          case "[6^":
            key.name = "pagedown";
            key.ctrl = true;
            break;
          case "[7^":
            key.name = "home";
            key.ctrl = true;
            break;
          case "[8^":
            key.name = "end";
            key.ctrl = true;
            break;
          case "[Z":
            key.name = "tab";
            key.shift = true;
            break;
          default:
            key.name = "undefined";
            break;
        }
      }
      if (key.name === undefined) {
        key = undefined;
      }
      if (s2.length === 1) {
        ch = s2;
      }
      if (key || ch) {
        stream2.emit("keypress", ch, key);
      }
    });
  };
  var isMouse = function(s) {
    return /\x1b\[M/.test(s) || /\x1b\[M([\x00\u0020-\uffff]{3})/.test(s) || /\x1b\[(\d+;\d+;\d+)M/.test(s) || /\x1b\[<(\d+;\d+;\d+)([mM])/.test(s) || /\x1b\[<(\d+;\d+;\d+;\d+)&w/.test(s) || /\x1b\[24([0135])~\[(\d+),(\d+)\]\r/.test(s) || /\x1b\[(O|I)/.test(s);
  };
  var EventEmitter = __require("events").EventEmitter;
  exports2.emitKeypressEvents = emitKeypressEvents;
  var metaKeyCodeReAnywhere = /(?:\x1b)([a-zA-Z0-9])/;
  var metaKeyCodeRe = new RegExp("^" + metaKeyCodeReAnywhere.source + "$");
  var functionKeyCodeReAnywhere = new RegExp("(?:\x1B+)(O|N|\\[|\\[\\[)(?:" + [
    "(\\d+)(?:;(\\d+))?([~^$])",
    "(?:M([@ #!a`])(.)(.))",
    "(?:1;)?(\\d+)?([a-zA-Z])"
  ].join("|") + ")");
  var functionKeyCodeRe = new RegExp("^" + functionKeyCodeReAnywhere.source);
  var escapeCodeReAnywhere = new RegExp([
    functionKeyCodeReAnywhere.source,
    metaKeyCodeReAnywhere.source,
    /\x1b./.source
  ].join("|"));
});

// ../../node_modules/blessed/lib/gpmclient.js
var require_gpmclient = __commonJS((exports2, module2) => {
  var send_config = function(socket, Gpm_Connect, callback) {
    var buffer;
    if (GPM_USE_MAGIC) {
      buffer = new Buffer(20);
      buffer.writeUInt32LE(GPM_MAGIC, 0);
      buffer.writeUInt16LE(Gpm_Connect.eventMask, 4);
      buffer.writeUInt16LE(Gpm_Connect.defaultMask, 6);
      buffer.writeUInt16LE(Gpm_Connect.minMod, 8);
      buffer.writeUInt16LE(Gpm_Connect.maxMod, 10);
      buffer.writeInt16LE(process.pid, 12);
      buffer.writeInt16LE(Gpm_Connect.vc, 16);
    } else {
      buffer = new Buffer(16);
      buffer.writeUInt16LE(Gpm_Connect.eventMask, 0);
      buffer.writeUInt16LE(Gpm_Connect.defaultMask, 2);
      buffer.writeUInt16LE(Gpm_Connect.minMod, 4);
      buffer.writeUInt16LE(Gpm_Connect.maxMod, 6);
      buffer.writeInt16LE(Gpm_Connect.pid, 8);
      buffer.writeInt16LE(Gpm_Connect.vc, 12);
    }
    socket.write(buffer, function() {
      if (callback)
        callback();
    });
  };
  var parseEvent = function(raw) {
    var evnt = {};
    evnt.buttons = raw[0];
    evnt.modifiers = raw[1];
    evnt.vc = raw.readUInt16LE(2);
    evnt.dx = raw.readInt16LE(4);
    evnt.dy = raw.readInt16LE(6);
    evnt.x = raw.readInt16LE(8);
    evnt.y = raw.readInt16LE(10);
    evnt.type = raw.readInt16LE(12);
    evnt.clicks = raw.readInt32LE(16);
    evnt.margin = raw.readInt32LE(20);
    evnt.wdx = raw.readInt16LE(24);
    evnt.wdy = raw.readInt16LE(26);
    return evnt;
  };
  var GpmClient = function(options2) {
    if (!(this instanceof GpmClient)) {
      return new GpmClient(options2);
    }
    EventEmitter.call(this);
    var pid = process.pid;
    var path2;
    try {
      path2 = fs.readlinkSync("/proc/" + pid + "/fd/0");
    } catch (e) {
    }
    var tty = /tty[0-9]+$/.exec(path2);
    if (tty === null) {
    }
    var vc;
    if (tty) {
      tty = tty[0];
      vc = +/[0-9]+$/.exec(tty)[0];
    }
    var self2 = this;
    if (tty) {
      fs.stat(GPM_SOCKET, function(err, stat) {
        if (err || !stat.isSocket()) {
          return;
        }
        var conf2 = {
          eventMask: 65535,
          defaultMask: GPM_MOVE | GPM_HARD,
          minMod: 0,
          maxMod: 65535,
          pid,
          vc
        };
        var gpm = net.createConnection(GPM_SOCKET);
        this.gpm = gpm;
        gpm.on("connect", function() {
          send_config(gpm, conf2, function() {
            conf2.pid = 0;
            conf2.vc = GPM_REQ_NOPASTE;
          });
        });
        gpm.on("data", function(packet) {
          var evnt = parseEvent(packet);
          switch (evnt.type & 15) {
            case GPM_MOVE:
              if (evnt.dx || evnt.dy) {
                self2.emit("move", evnt.buttons, evnt.modifiers, evnt.x, evnt.y);
              }
              if (evnt.wdx || evnt.wdy) {
                self2.emit("mousewheel", evnt.buttons, evnt.modifiers, evnt.x, evnt.y, evnt.wdx, evnt.wdy);
              }
              break;
            case GPM_DRAG:
              if (evnt.dx || evnt.dy) {
                self2.emit("drag", evnt.buttons, evnt.modifiers, evnt.x, evnt.y);
              }
              if (evnt.wdx || evnt.wdy) {
                self2.emit("mousewheel", evnt.buttons, evnt.modifiers, evnt.x, evnt.y, evnt.wdx, evnt.wdy);
              }
              break;
            case GPM_DOWN:
              self2.emit("btndown", evnt.buttons, evnt.modifiers, evnt.x, evnt.y);
              if (evnt.type & GPM_DOUBLE) {
                self2.emit("dblclick", evnt.buttons, evnt.modifiers, evnt.x, evnt.y);
              }
              break;
            case GPM_UP:
              self2.emit("btnup", evnt.buttons, evnt.modifiers, evnt.x, evnt.y);
              if (!(evnt.type & GPM_MFLAG)) {
                self2.emit("click", evnt.buttons, evnt.modifiers, evnt.x, evnt.y);
              }
              break;
          }
        });
        gpm.on("error", function() {
          self2.stop();
        });
      });
    }
  };
  var net = __require("net");
  var fs = __require("fs");
  var EventEmitter = __require("events").EventEmitter;
  var GPM_USE_MAGIC = false;
  var GPM_MOVE = 1;
  var GPM_DRAG = 2;
  var GPM_DOWN = 4;
  var GPM_UP = 8;
  var GPM_DOUBLE = 32;
  var GPM_MFLAG = 128;
  var GPM_REQ_NOPASTE = 3;
  var GPM_HARD = 256;
  var GPM_MAGIC = 1198550348;
  var GPM_SOCKET = "/dev/gpmctl";
  GpmClient.prototype.__proto__ = EventEmitter.prototype;
  GpmClient.prototype.stop = function() {
    if (this.gpm) {
      this.gpm.end();
    }
    delete this.gpm;
  };
  GpmClient.prototype.ButtonName = function(btn) {
    if (btn & 4)
      return "left";
    if (btn & 2)
      return "middle";
    if (btn & 1)
      return "right";
    return "";
  };
  GpmClient.prototype.hasShiftKey = function(mod) {
    return mod & 1 ? true : false;
  };
  GpmClient.prototype.hasCtrlKey = function(mod) {
    return mod & 4 ? true : false;
  };
  GpmClient.prototype.hasMetaKey = function(mod) {
    return mod & 8 ? true : false;
  };
  module2.exports = GpmClient;
});

// ../../node_modules/blessed/lib/program.js
var require_program = __commonJS((exports2, module2) => {
  var Program = function(options2) {
    var self2 = this;
    if (!(this instanceof Program)) {
      return new Program(options2);
    }
    Program.bind(this);
    EventEmitter.call(this);
    if (!options2 || options2.__proto__ !== Object.prototype) {
      options2 = {
        input: arguments[0],
        output: arguments[1]
      };
    }
    this.options = options2;
    this.input = options2.input || process.stdin;
    this.output = options2.output || process.stdout;
    options2.log = options2.log || options2.dump;
    if (options2.log) {
      this._logger = fs.createWriteStream(options2.log);
      if (options2.dump)
        this.setupDump();
    }
    this.zero = options2.zero !== false;
    this.useBuffer = options2.buffer;
    this.x = 0;
    this.y = 0;
    this.savedX = 0;
    this.savedY = 0;
    this.cols = this.output.columns || 1;
    this.rows = this.output.rows || 1;
    this.scrollTop = 0;
    this.scrollBottom = this.rows - 1;
    this._terminal = options2.terminal || options2.term || process.env.TERM || (process.platform === "win32" ? "windows-ansi" : "xterm");
    this._terminal = this._terminal.toLowerCase();
    this.isOSXTerm = process.env.TERM_PROGRAM === "Apple_Terminal";
    this.isiTerm2 = process.env.TERM_PROGRAM === "iTerm.app" || !!process.env.ITERM_SESSION_ID;
    this.isXFCE = /xfce/i.test(process.env.COLORTERM);
    this.isTerminator = !!process.env.TERMINATOR_UUID;
    this.isLXDE = false;
    this.isVTE = !!process.env.VTE_VERSION || this.isXFCE || this.isTerminator || this.isLXDE;
    this.isRxvt = /rxvt/i.test(process.env.COLORTERM);
    this.isXterm = false;
    this.tmux = !!process.env.TMUX;
    this.tmuxVersion = function() {
      if (!self2.tmux)
        return 2;
      try {
        var version3 = cp.execFileSync("tmux", ["-V"], { encoding: "utf8" });
        return +/^tmux ([\d.]+)/i.exec(version3.trim().split("\n")[0])[1];
      } catch (e) {
        return 2;
      }
    }();
    this._buf = "";
    this._flush = this.flush.bind(this);
    if (options2.tput !== false) {
      this.setupTput();
    }
    this.listen();
  };
  var unshiftEvent = function(obj, event, listener) {
    var listeners = obj.listeners(event);
    obj.removeAllListeners(event);
    obj.on(event, listener);
    listeners.forEach(function(listener2) {
      obj.on(event, listener2);
    });
  };
  var merge = function(out) {
    slice.call(arguments, 1).forEach(function(obj) {
      Object.keys(obj).forEach(function(key) {
        out[key] = obj[key];
      });
    });
    return out;
  };
  var EventEmitter = __require("events").EventEmitter;
  var StringDecoder2 = __require("string_decoder").StringDecoder;
  var cp = __require("child_process");
  var util = __require("util");
  var fs = __require("fs");
  var Tput = require_tput();
  var colors = require_colors();
  var slice = Array.prototype.slice;
  var nextTick = global.setImmediate || process.nextTick.bind(process);
  Program.global = null;
  Program.total = 0;
  Program.instances = [];
  Program.bind = function(program) {
    if (!Program.global) {
      Program.global = program;
    }
    if (!~Program.instances.indexOf(program)) {
      Program.instances.push(program);
      program.index = Program.total;
      Program.total++;
    }
    if (Program._bound)
      return;
    Program._bound = true;
    unshiftEvent(process, "exit", Program._exitHandler = function() {
      Program.instances.forEach(function(program2) {
        program2.flush();
        program2._exiting = true;
      });
    });
  };
  Program.prototype.__proto__ = EventEmitter.prototype;
  Program.prototype.type = "program";
  Program.prototype.log = function() {
    return this._log("LOG", util.format.apply(util, arguments));
  };
  Program.prototype.debug = function() {
    if (!this.options.debug)
      return;
    return this._log("DEBUG", util.format.apply(util, arguments));
  };
  Program.prototype._log = function(pre, msg) {
    if (!this._logger)
      return;
    return this._logger.write(pre + ": " + msg + "\n-\n");
  };
  Program.prototype.setupDump = function() {
    var self2 = this, write4 = this.output.write, decoder = new StringDecoder2("utf8");
    function stringify2(data) {
      return caret(data.replace(/\r/g, "\\r").replace(/\n/g, "\\n").replace(/\t/g, "\\t")).replace(/[^ -~]/g, function(ch) {
        if (ch.charCodeAt(0) > 255)
          return ch;
        ch = ch.charCodeAt(0).toString(16);
        if (ch.length > 2) {
          if (ch.length < 4)
            ch = "0" + ch;
          return "\\u" + ch;
        }
        if (ch.length < 2)
          ch = "0" + ch;
        return "\\x" + ch;
      });
    }
    function caret(data) {
      return data.replace(/[\0\x80\x1b-\x1f\x7f\x01-\x1a]/g, function(ch) {
        switch (ch) {
          case "\0":
          case "\x80":
            ch = "@";
            break;
          case "\x1B":
            ch = "[";
            break;
          case "\x1C":
            ch = "\\";
            break;
          case "\x1D":
            ch = "]";
            break;
          case "\x1E":
            ch = "^";
            break;
          case "\x1F":
            ch = "_";
            break;
          case "\x7F":
            ch = "?";
            break;
          default:
            ch = ch.charCodeAt(0);
            if (ch >= 1 && ch <= 26) {
              ch = String.fromCharCode(ch + 64);
            } else {
              return String.fromCharCode(ch);
            }
            break;
        }
        return "^" + ch;
      });
    }
    this.input.on("data", function(data) {
      self2._log("IN", stringify2(decoder.write(data)));
    });
    this.output.write = function(data) {
      self2._log("OUT", stringify2(data));
      return write4.apply(this, arguments);
    };
  };
  Program.prototype.setupTput = function() {
    if (this._tputSetup)
      return;
    this._tputSetup = true;
    var self2 = this, options2 = this.options, write4 = this._write.bind(this);
    var tput = this.tput = new Tput({
      terminal: this.terminal,
      padding: options2.padding,
      extended: options2.extended,
      printf: options2.printf,
      termcap: options2.termcap,
      forceUnicode: options2.forceUnicode
    });
    if (tput.error) {
      nextTick(function() {
        self2.emit("warning", tput.error.message);
      });
    }
    if (tput.padding) {
      nextTick(function() {
        self2.emit("warning", "Terminfo padding has been enabled.");
      });
    }
    this.put = function() {
      var args2 = slice.call(arguments), cap = args2.shift();
      if (tput[cap]) {
        return this._write(tput[cap].apply(tput, args2));
      }
    };
    Object.keys(tput).forEach(function(key) {
      if (self2[key] == null) {
        self2[key] = tput[key];
      }
      if (typeof tput[key] !== "function") {
        self2.put[key] = tput[key];
        return;
      }
      if (tput.padding) {
        self2.put[key] = function() {
          return tput._print(tput[key].apply(tput, arguments), write4);
        };
      } else {
        self2.put[key] = function() {
          return self2._write(tput[key].apply(tput, arguments));
        };
      }
    });
  };
  Program.prototype.__defineGetter__("terminal", function() {
    return this._terminal;
  });
  Program.prototype.__defineSetter__("terminal", function(terminal) {
    this.setTerminal(terminal);
    return this.terminal;
  });
  Program.prototype.setTerminal = function(terminal) {
    this._terminal = terminal.toLowerCase();
    delete this._tputSetup;
    this.setupTput();
  };
  Program.prototype.has = function(name2) {
    return this.tput ? this.tput.has(name2) : false;
  };
  Program.prototype.term = function(is) {
    return this.terminal.indexOf(is) === 0;
  };
  Program.prototype.listen = function() {
    var self2 = this;
    if (!this.input._blessedInput) {
      this.input._blessedInput = 1;
      this._listenInput();
    } else {
      this.input._blessedInput++;
    }
    this.on("newListener", this._newHandler = function fn(type2) {
      if (type2 === "keypress" || type2 === "mouse") {
        self2.removeListener("newListener", fn);
        if (self2.input.setRawMode && !self2.input.isRaw) {
          self2.input.setRawMode(true);
          self2.input.resume();
        }
      }
    });
    this.on("newListener", function fn(type2) {
      if (type2 === "mouse") {
        self2.removeListener("newListener", fn);
        self2.bindMouse();
      }
    });
    if (!this.output._blessedOutput) {
      this.output._blessedOutput = 1;
      this._listenOutput();
    } else {
      this.output._blessedOutput++;
    }
  };
  Program.prototype._listenInput = function() {
    var keys3 = require_keys2(), self2 = this;
    this.input.on("keypress", this.input._keypressHandler = function(ch, key) {
      key = key || { ch };
      if (key.name === "undefined" && (key.code === "[M" || key.code === "[I" || key.code === "[O")) {
        return;
      }
      if (key.name === "undefined") {
        return;
      }
      if (key.name === "enter" && key.sequence === "\n") {
        key.name = "linefeed";
      }
      if (key.name === "return" && key.sequence === "\r") {
        self2.input.emit("keypress", ch, merge({}, key, { name: "enter" }));
      }
      var name2 = (key.ctrl ? "C-" : "") + (key.meta ? "M-" : "") + (key.shift && key.name ? "S-" : "") + (key.name || ch);
      key.full = name2;
      Program.instances.forEach(function(program) {
        if (program.input !== self2.input)
          return;
        program.emit("keypress", ch, key);
        program.emit("key " + name2, ch, key);
      });
    });
    this.input.on("data", this.input._dataHandler = function(data) {
      Program.instances.forEach(function(program) {
        if (program.input !== self2.input)
          return;
        program.emit("data", data);
      });
    });
    keys3.emitKeypressEvents(this.input);
  };
  Program.prototype._listenOutput = function() {
    var self2 = this;
    if (!this.output.isTTY) {
      nextTick(function() {
        self2.emit("warning", "Output is not a TTY");
      });
    }
    function resize() {
      Program.instances.forEach(function(program) {
        if (program.output !== self2.output)
          return;
        program.cols = program.output.columns;
        program.rows = program.output.rows;
        program.emit("resize");
      });
    }
    this.output.on("resize", this.output._resizeHandler = function() {
      Program.instances.forEach(function(program) {
        if (program.output !== self2.output)
          return;
        if (!program.options.resizeTimeout) {
          return resize();
        }
        if (program._resizeTimer) {
          clearTimeout(program._resizeTimer);
          delete program._resizeTimer;
        }
        var time = typeof program.options.resizeTimeout === "number" ? program.options.resizeTimeout : 300;
        program._resizeTimer = setTimeout(resize, time);
      });
    });
  };
  Program.prototype.destroy = function() {
    var index = Program.instances.indexOf(this);
    if (~index) {
      Program.instances.splice(index, 1);
      Program.total--;
      this.flush();
      this._exiting = true;
      Program.global = Program.instances[0];
      if (Program.total === 0) {
        Program.global = null;
        process.removeListener("exit", Program._exitHandler);
        delete Program._exitHandler;
        delete Program._bound;
      }
      this.input._blessedInput--;
      this.output._blessedOutput--;
      if (this.input._blessedInput === 0) {
        this.input.removeListener("keypress", this.input._keypressHandler);
        this.input.removeListener("data", this.input._dataHandler);
        delete this.input._keypressHandler;
        delete this.input._dataHandler;
        if (this.input.setRawMode) {
          if (this.input.isRaw) {
            this.input.setRawMode(false);
          }
          if (!this.input.destroyed) {
            this.input.pause();
          }
        }
      }
      if (this.output._blessedOutput === 0) {
        this.output.removeListener("resize", this.output._resizeHandler);
        delete this.output._resizeHandler;
      }
      this.removeListener("newListener", this._newHandler);
      delete this._newHandler;
      this.destroyed = true;
      this.emit("destroy");
    }
  };
  Program.prototype.key = function(key, listener) {
    if (typeof key === "string")
      key = key.split(/\s*,\s*/);
    key.forEach(function(key2) {
      return this.on("key " + key2, listener);
    }, this);
  };
  Program.prototype.onceKey = function(key, listener) {
    if (typeof key === "string")
      key = key.split(/\s*,\s*/);
    key.forEach(function(key2) {
      return this.once("key " + key2, listener);
    }, this);
  };
  Program.prototype.unkey = Program.prototype.removeKey = function(key, listener) {
    if (typeof key === "string")
      key = key.split(/\s*,\s*/);
    key.forEach(function(key2) {
      return this.removeListener("key " + key2, listener);
    }, this);
  };
  Program.prototype.bindMouse = function() {
    if (this._boundMouse)
      return;
    this._boundMouse = true;
    var decoder = new StringDecoder2("utf8"), self2 = this;
    this.on("data", function(data) {
      var text = decoder.write(data);
      if (!text)
        return;
      self2._bindMouse(text, data);
    });
  };
  Program.prototype._bindMouse = function(s, buf) {
    var self2 = this, key, parts, b, x, y, mod, params2, down, page, button;
    key = {
      name: undefined,
      ctrl: false,
      meta: false,
      shift: false
    };
    if (Buffer.isBuffer(s)) {
      if (s[0] > 127 && s[1] === undefined) {
        s[0] -= 128;
        s = "\x1B" + s.toString("utf-8");
      } else {
        s = s.toString("utf-8");
      }
    }
    var bx = s.charCodeAt(4);
    var by = s.charCodeAt(5);
    if (buf[0] === 27 && buf[1] === 91 && buf[2] === 77 && (this.isVTE || bx >= 65533 || by >= 65533 || bx > 0 && bx < 32 || by > 0 && by < 32 || buf[4] > 223 && buf[4] < 248 && buf.length === 6 || buf[5] > 223 && buf[5] < 248 && buf.length === 6)) {
      b = buf[3];
      x = buf[4];
      y = buf[5];
      if (x < 32)
        x += 255;
      if (y < 32)
        y += 255;
      s = "\x1B[M" + String.fromCharCode(b) + String.fromCharCode(x) + String.fromCharCode(y);
    }
    if (parts = /^\x1b\[M([\x00\u0020-\uffff]{3})/.exec(s)) {
      b = parts[1].charCodeAt(0);
      x = parts[1].charCodeAt(1);
      y = parts[1].charCodeAt(2);
      key.name = "mouse";
      key.type = "X10";
      key.raw = [b, x, y, parts[0]];
      key.buf = buf;
      key.x = x - 32;
      key.y = y - 32;
      if (this.zero)
        key.x--, key.y--;
      if (x === 0)
        key.x = 255;
      if (y === 0)
        key.y = 255;
      mod = b >> 2;
      key.shift = !!(mod & 1);
      key.meta = !!(mod >> 1 & 1);
      key.ctrl = !!(mod >> 2 & 1);
      b -= 32;
      if (b >> 6 & 1) {
        key.action = b & 1 ? "wheeldown" : "wheelup";
        key.button = "middle";
      } else if (b === 3) {
        key.action = "mouseup";
        key.button = this._lastButton || "unknown";
        delete this._lastButton;
      } else {
        key.action = "mousedown";
        button = b & 3;
        key.button = button === 0 ? "left" : button === 1 ? "middle" : button === 2 ? "right" : "unknown";
        this._lastButton = key.button;
      }
      if (b === 35 || b === 39 || b === 51 || b === 43 || this.isVTE && (b === 32 || b === 36 || b === 48 || b === 40)) {
        delete key.button;
        key.action = "mousemove";
      }
      self2.emit("mouse", key);
      return;
    }
    if (parts = /^\x1b\[(\d+;\d+;\d+)M/.exec(s)) {
      params2 = parts[1].split(";");
      b = +params2[0];
      x = +params2[1];
      y = +params2[2];
      key.name = "mouse";
      key.type = "urxvt";
      key.raw = [b, x, y, parts[0]];
      key.buf = buf;
      key.x = x;
      key.y = y;
      if (this.zero)
        key.x--, key.y--;
      mod = b >> 2;
      key.shift = !!(mod & 1);
      key.meta = !!(mod >> 1 & 1);
      key.ctrl = !!(mod >> 2 & 1);
      if (b === 128 || b === 129) {
        b = 67;
      }
      b -= 32;
      if (b >> 6 & 1) {
        key.action = b & 1 ? "wheeldown" : "wheelup";
        key.button = "middle";
      } else if (b === 3) {
        key.action = "mouseup";
        key.button = this._lastButton || "unknown";
        delete this._lastButton;
      } else {
        key.action = "mousedown";
        button = b & 3;
        key.button = button === 0 ? "left" : button === 1 ? "middle" : button === 2 ? "right" : "unknown";
        this._lastButton = key.button;
      }
      if (b === 35 || b === 39 || b === 51 || b === 43 || this.isVTE && (b === 32 || b === 36 || b === 48 || b === 40)) {
        delete key.button;
        key.action = "mousemove";
      }
      self2.emit("mouse", key);
      return;
    }
    if (parts = /^\x1b\[<(\d+;\d+;\d+)([mM])/.exec(s)) {
      down = parts[2] === "M";
      params2 = parts[1].split(";");
      b = +params2[0];
      x = +params2[1];
      y = +params2[2];
      key.name = "mouse";
      key.type = "sgr";
      key.raw = [b, x, y, parts[0]];
      key.buf = buf;
      key.x = x;
      key.y = y;
      if (this.zero)
        key.x--, key.y--;
      mod = b >> 2;
      key.shift = !!(mod & 1);
      key.meta = !!(mod >> 1 & 1);
      key.ctrl = !!(mod >> 2 & 1);
      if (b >> 6 & 1) {
        key.action = b & 1 ? "wheeldown" : "wheelup";
        key.button = "middle";
      } else {
        key.action = down ? "mousedown" : "mouseup";
        button = b & 3;
        key.button = button === 0 ? "left" : button === 1 ? "middle" : button === 2 ? "right" : "unknown";
      }
      if (b === 35 || b === 39 || b === 51 || b === 43 || this.isVTE && (b === 32 || b === 36 || b === 48 || b === 40)) {
        delete key.button;
        key.action = "mousemove";
      }
      self2.emit("mouse", key);
      return;
    }
    if (parts = /^\x1b\[<(\d+;\d+;\d+;\d+)&w/.exec(s)) {
      params2 = parts[1].split(";");
      b = +params2[0];
      x = +params2[1];
      y = +params2[2];
      page = +params2[3];
      key.name = "mouse";
      key.type = "dec";
      key.raw = [b, x, y, parts[0]];
      key.buf = buf;
      key.x = x;
      key.y = y;
      key.page = page;
      if (this.zero)
        key.x--, key.y--;
      key.action = b === 3 ? "mouseup" : "mousedown";
      key.button = b === 2 ? "left" : b === 4 ? "middle" : b === 6 ? "right" : "unknown";
      self2.emit("mouse", key);
      return;
    }
    if (parts = /^\x1b\[24([0135])~\[(\d+),(\d+)\]\r/.exec(s)) {
      b = +parts[1];
      x = +parts[2];
      y = +parts[3];
      key.name = "mouse";
      key.type = "vt300";
      key.raw = [b, x, y, parts[0]];
      key.buf = buf;
      key.x = x;
      key.y = y;
      if (this.zero)
        key.x--, key.y--;
      key.action = "mousedown";
      key.button = b === 1 ? "left" : b === 2 ? "middle" : b === 5 ? "right" : "unknown";
      self2.emit("mouse", key);
      return;
    }
    if (parts = /^\x1b\[(O|I)/.exec(s)) {
      key.action = parts[1] === "I" ? "focus" : "blur";
      self2.emit("mouse", key);
      self2.emit(key.action);
      return;
    }
  };
  Program.prototype.enableGpm = function() {
    var self2 = this;
    var gpmclient = require_gpmclient();
    if (this.gpm)
      return;
    this.gpm = gpmclient();
    this.gpm.on("btndown", function(btn, modifier, x, y) {
      x--, y--;
      var key = {
        name: "mouse",
        type: "GPM",
        action: "mousedown",
        button: self2.gpm.ButtonName(btn),
        raw: [btn, modifier, x, y],
        x,
        y,
        shift: self2.gpm.hasShiftKey(modifier),
        meta: self2.gpm.hasMetaKey(modifier),
        ctrl: self2.gpm.hasCtrlKey(modifier)
      };
      self2.emit("mouse", key);
    });
    this.gpm.on("btnup", function(btn, modifier, x, y) {
      x--, y--;
      var key = {
        name: "mouse",
        type: "GPM",
        action: "mouseup",
        button: self2.gpm.ButtonName(btn),
        raw: [btn, modifier, x, y],
        x,
        y,
        shift: self2.gpm.hasShiftKey(modifier),
        meta: self2.gpm.hasMetaKey(modifier),
        ctrl: self2.gpm.hasCtrlKey(modifier)
      };
      self2.emit("mouse", key);
    });
    this.gpm.on("move", function(btn, modifier, x, y) {
      x--, y--;
      var key = {
        name: "mouse",
        type: "GPM",
        action: "mousemove",
        button: self2.gpm.ButtonName(btn),
        raw: [btn, modifier, x, y],
        x,
        y,
        shift: self2.gpm.hasShiftKey(modifier),
        meta: self2.gpm.hasMetaKey(modifier),
        ctrl: self2.gpm.hasCtrlKey(modifier)
      };
      self2.emit("mouse", key);
    });
    this.gpm.on("drag", function(btn, modifier, x, y) {
      x--, y--;
      var key = {
        name: "mouse",
        type: "GPM",
        action: "mousemove",
        button: self2.gpm.ButtonName(btn),
        raw: [btn, modifier, x, y],
        x,
        y,
        shift: self2.gpm.hasShiftKey(modifier),
        meta: self2.gpm.hasMetaKey(modifier),
        ctrl: self2.gpm.hasCtrlKey(modifier)
      };
      self2.emit("mouse", key);
    });
    this.gpm.on("mousewheel", function(btn, modifier, x, y, dx, dy) {
      var key = {
        name: "mouse",
        type: "GPM",
        action: dy > 0 ? "wheelup" : "wheeldown",
        button: self2.gpm.ButtonName(btn),
        raw: [btn, modifier, x, y, dx, dy],
        x,
        y,
        shift: self2.gpm.hasShiftKey(modifier),
        meta: self2.gpm.hasMetaKey(modifier),
        ctrl: self2.gpm.hasCtrlKey(modifier)
      };
      self2.emit("mouse", key);
    });
  };
  Program.prototype.disableGpm = function() {
    if (this.gpm) {
      this.gpm.stop();
      delete this.gpm;
    }
  };
  Program.prototype.bindResponse = function() {
    if (this._boundResponse)
      return;
    this._boundResponse = true;
    var decoder = new StringDecoder2("utf8"), self2 = this;
    this.on("data", function(data) {
      data = decoder.write(data);
      if (!data)
        return;
      self2._bindResponse(data);
    });
  };
  Program.prototype._bindResponse = function(s) {
    var out = {}, parts;
    if (Buffer.isBuffer(s)) {
      if (s[0] > 127 && s[1] === undefined) {
        s[0] -= 128;
        s = "\x1B" + s.toString("utf-8");
      } else {
        s = s.toString("utf-8");
      }
    }
    if (parts = /^\x1b\[(\?|>)(\d*(?:;\d*)*)c/.exec(s)) {
      parts = parts[2].split(";").map(function(ch) {
        return +ch || 0;
      });
      out.event = "device-attributes";
      out.code = "DA";
      if (parts[1] === "?") {
        out.type = "primary-attribute";
        if (parts[0] === 1 && parts[2] === 2) {
          out.term = "vt100";
          out.advancedVideo = true;
        } else if (parts[0] === 1 && parts[2] === 0) {
          out.term = "vt101";
        } else if (parts[0] === 6) {
          out.term = "vt102";
        } else if (parts[0] === 60 && parts[1] === 1 && parts[2] === 2 && parts[3] === 6 && parts[4] === 8 && parts[5] === 9 && parts[6] === 15) {
          out.term = "vt220";
        } else {
          parts.forEach(function(attr) {
            switch (attr) {
              case 1:
                out.cols132 = true;
                break;
              case 2:
                out.printer = true;
                break;
              case 6:
                out.selectiveErase = true;
                break;
              case 8:
                out.userDefinedKeys = true;
                break;
              case 9:
                out.nationalReplacementCharsets = true;
                break;
              case 15:
                out.technicalCharacters = true;
                break;
              case 18:
                out.userWindows = true;
                break;
              case 21:
                out.horizontalScrolling = true;
                break;
              case 22:
                out.ansiColor = true;
                break;
              case 29:
                out.ansiTextLocator = true;
                break;
            }
          });
        }
      } else {
        out.type = "secondary-attribute";
        switch (parts[0]) {
          case 0:
            out.term = "vt100";
            break;
          case 1:
            out.term = "vt220";
            break;
          case 2:
            out.term = "vt240";
            break;
          case 18:
            out.term = "vt330";
            break;
          case 19:
            out.term = "vt340";
            break;
          case 24:
            out.term = "vt320";
            break;
          case 41:
            out.term = "vt420";
            break;
          case 61:
            out.term = "vt510";
            break;
          case 64:
            out.term = "vt520";
            break;
          case 65:
            out.term = "vt525";
            break;
        }
        out.firmwareVersion = parts[1];
        out.romCartridgeRegistrationNumber = parts[2];
      }
      out.deviceAttributes = out;
      this.emit("response", out);
      this.emit("response " + out.event, out);
      return;
    }
    if (parts = /^\x1b\[(\?)?(\d+)(?:;(\d+);(\d+);(\d+))?n/.exec(s)) {
      out.event = "device-status";
      out.code = "DSR";
      if (!parts[1] && parts[2] === "0" && !parts[3]) {
        out.type = "device-status";
        out.status = "OK";
        out.deviceStatus = out.status;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] && (parts[2] === "10" || parts[2] === "11") && !parts[3]) {
        out.type = "printer-status";
        out.status = parts[2] === "10" ? "ready" : "not ready";
        out.printerStatus = out.status;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] && (parts[2] === "20" || parts[2] === "21") && !parts[3]) {
        out.type = "udk-status";
        out.status = parts[2] === "20" ? "unlocked" : "locked";
        out.UDKStatus = out.status;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] && parts[2] === "27" && parts[3] === "1" && parts[4] === "0" && parts[5] === "0") {
        out.type = "keyboard-status";
        out.status = "OK";
        out.keyboardStatus = out.status;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] && (parts[2] === "53" || parts[2] === "50") && !parts[3]) {
        out.type = "locator-status";
        out.status = parts[2] === "53" ? "available" : "unavailable";
        out.locator = out.status;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      out.type = "error";
      out.text = "Unhandled: " + JSON.stringify(parts);
      out.error = out.text;
      this.emit("response", out);
      this.emit("response " + out.event, out);
      return;
    }
    if (parts = /^\x1b\[(\?)?(\d+);(\d+)R/.exec(s)) {
      out.event = "device-status";
      out.code = "DSR";
      out.type = "cursor-status";
      out.status = {
        x: +parts[3],
        y: +parts[2],
        page: !parts[1] ? undefined : 0
      };
      out.x = out.status.x;
      out.y = out.status.y;
      out.page = out.status.page;
      out.cursor = out.status;
      this.emit("response", out);
      this.emit("response " + out.event, out);
      return;
    }
    if (parts = /^\x1b\[(\d+)(?:;(\d+);(\d+))?t/.exec(s)) {
      out.event = "window-manipulation";
      out.code = "";
      if ((parts[1] === "1" || parts[1] === "2") && !parts[2]) {
        out.type = "window-state";
        out.state = parts[1] === "1" ? "non-iconified" : "iconified";
        out.windowState = out.state;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] === "3" && parts[2]) {
        out.type = "window-position";
        out.position = {
          x: +parts[2],
          y: +parts[3]
        };
        out.x = out.position.x;
        out.y = out.position.y;
        out.windowPosition = out.position;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] === "4" && parts[2]) {
        out.type = "window-size-pixels";
        out.size = {
          height: +parts[2],
          width: +parts[3]
        };
        out.height = out.size.height;
        out.width = out.size.width;
        out.windowSizePixels = out.size;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] === "8" && parts[2]) {
        out.type = "textarea-size";
        out.size = {
          height: +parts[2],
          width: +parts[3]
        };
        out.height = out.size.height;
        out.width = out.size.width;
        out.textAreaSizeCharacters = out.size;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] === "9" && parts[2]) {
        out.type = "screen-size";
        out.size = {
          height: +parts[2],
          width: +parts[3]
        };
        out.height = out.size.height;
        out.width = out.size.width;
        out.screenSizeCharacters = out.size;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      out.type = "error";
      out.text = "Unhandled: " + JSON.stringify(parts);
      out.error = out.text;
      this.emit("response", out);
      this.emit("response " + out.event, out);
      return;
    }
    if (parts = /^\x1b\](l|L)([^\x07\x1b]*)$/.exec(s)) {
      parts[2] = "rxvt";
      s = "\x1B]" + parts[1] + parts[2] + "\x1B\\";
    }
    if (parts = /^\x1b\](l|L)([^\x07\x1b]*)(?:\x07|\x1b\\)/.exec(s)) {
      out.event = "window-manipulation";
      out.code = "";
      if (parts[1] === "L") {
        out.type = "window-icon-label";
        out.text = parts[2];
        out.windowIconLabel = out.text;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      if (parts[1] === "l") {
        out.type = "window-title";
        out.text = parts[2];
        out.windowTitle = out.text;
        this.emit("response", out);
        this.emit("response " + out.event, out);
        return;
      }
      out.type = "error";
      out.text = "Unhandled: " + JSON.stringify(parts);
      out.error = out.text;
      this.emit("response", out);
      this.emit("response " + out.event, out);
      return;
    }
    if (parts = /^\x1b\[(\d+(?:;\d+){4})&w/.exec(s)) {
      parts = parts[1].split(";").map(function(ch) {
        return +ch;
      });
      out.event = "locator-position";
      out.code = "DECRQLP";
      switch (parts[0]) {
        case 0:
          out.status = "locator-unavailable";
          break;
        case 1:
          out.status = "request";
          break;
        case 2:
          out.status = "left-button-down";
          break;
        case 3:
          out.status = "left-button-up";
          break;
        case 4:
          out.status = "middle-button-down";
          break;
        case 5:
          out.status = "middle-button-up";
          break;
        case 6:
          out.status = "right-button-down";
          break;
        case 7:
          out.status = "right-button-up";
          break;
        case 8:
          out.status = "m4-button-down";
          break;
        case 9:
          out.status = "m4-button-up";
          break;
        case 10:
          out.status = "locator-outside";
          break;
      }
      out.mask = parts[1];
      out.row = parts[2];
      out.col = parts[3];
      out.page = parts[4];
      out.locatorPosition = out;
      this.emit("response", out);
      this.emit("response " + out.event, out);
      return;
    }
    if (parts = /^\x1b\](\d+);([^\x07\x1b]+)(?:\x07|\x1b\\)/.exec(s)) {
      out.event = "text-params";
      out.code = "Set Text Parameters";
      out.ps = +s[1];
      out.pt = s[2];
      this.emit("response", out);
      this.emit("response " + out.event, out);
    }
  };
  Program.prototype.response = function(name2, text, callback, noBypass) {
    var self2 = this;
    if (arguments.length === 2) {
      callback = text;
      text = name2;
      name2 = null;
    }
    if (!callback) {
      callback = function() {
      };
    }
    this.bindResponse();
    name2 = name2 ? "response " + name2 : "response";
    var onresponse;
    this.once(name2, onresponse = function(event) {
      if (timeout)
        clearTimeout(timeout);
      if (event.type === "error") {
        return callback(new Error(event.event + ": " + event.text));
      }
      return callback(null, event);
    });
    var timeout = setTimeout(function() {
      self2.removeListener(name2, onresponse);
      return callback(new Error("Timeout."));
    }, 2000);
    return noBypass ? this._write(text) : this._twrite(text);
  };
  Program.prototype._owrite = Program.prototype.write = function(text) {
    if (!this.output.writable)
      return;
    return this.output.write(text);
  };
  Program.prototype._buffer = function(text) {
    if (this._exiting) {
      this.flush();
      this._owrite(text);
      return;
    }
    if (this._buf) {
      this._buf += text;
      return;
    }
    this._buf = text;
    nextTick(this._flush);
    return true;
  };
  Program.prototype.flush = function() {
    if (!this._buf)
      return;
    this._owrite(this._buf);
    this._buf = "";
  };
  Program.prototype._write = function(text) {
    if (this.ret)
      return text;
    if (this.useBuffer) {
      return this._buffer(text);
    }
    return this._owrite(text);
  };
  Program.prototype._twrite = function(data) {
    var self2 = this, iterations = 0, timer;
    if (this.tmux) {
      data = data.replace(/\x1b\\/g, "\x07");
      data = "\x1BPtmux;\x1B" + data + "\x1B\\";
      if (this.output.bytesWritten === 0) {
        timer = setInterval(function() {
          if (self2.output.bytesWritten > 0 || ++iterations === 50) {
            clearInterval(timer);
            self2.flush();
            self2._owrite(data);
          }
        }, 100);
        return true;
      }
      this.flush();
      return this._owrite(data);
    }
    return this._write(data);
  };
  Program.prototype.echo = Program.prototype.print = function(text, attr) {
    return attr ? this._write(this.text(text, attr)) : this._write(text);
  };
  Program.prototype._ncoords = function() {
    if (this.x < 0)
      this.x = 0;
    else if (this.x >= this.cols)
      this.x = this.cols - 1;
    if (this.y < 0)
      this.y = 0;
    else if (this.y >= this.rows)
      this.y = this.rows - 1;
  };
  Program.prototype.setx = function(x) {
    return this.cursorCharAbsolute(x);
  };
  Program.prototype.sety = function(y) {
    return this.linePosAbsolute(y);
  };
  Program.prototype.move = function(x, y) {
    return this.cursorPos(y, x);
  };
  Program.prototype.omove = function(x, y) {
    if (!this.zero) {
      x = (x || 1) - 1;
      y = (y || 1) - 1;
    } else {
      x = x || 0;
      y = y || 0;
    }
    if (y === this.y && x === this.x) {
      return;
    }
    if (y === this.y) {
      if (x > this.x) {
        this.cuf(x - this.x);
      } else if (x < this.x) {
        this.cub(this.x - x);
      }
    } else if (x === this.x) {
      if (y > this.y) {
        this.cud(y - this.y);
      } else if (y < this.y) {
        this.cuu(this.y - y);
      }
    } else {
      if (!this.zero)
        x++, y++;
      this.cup(y, x);
    }
  };
  Program.prototype.rsetx = function(x) {
    if (!x)
      return;
    return x > 0 ? this.forward(x) : this.back(-x);
  };
  Program.prototype.rsety = function(y) {
    if (!y)
      return;
    return y > 0 ? this.up(y) : this.down(-y);
  };
  Program.prototype.rmove = function(x, y) {
    this.rsetx(x);
    this.rsety(y);
  };
  Program.prototype.simpleInsert = function(ch, i, attr) {
    return this._write(this.repeat(ch, i), attr);
  };
  Program.prototype.repeat = function(ch, i) {
    if (!i || i < 0)
      i = 0;
    return Array(i + 1).join(ch);
  };
  Program.prototype.__defineGetter__("title", function() {
    return this._title;
  });
  Program.prototype.__defineSetter__("title", function(title) {
    this.setTitle(title);
    return this._title;
  });
  Program.prototype.copyToClipboard = function(text) {
    if (this.isiTerm2) {
      this._twrite("\x1B]50;CopyToCliboard=" + text + "\x07");
      return true;
    }
    return false;
  };
  Program.prototype.cursorShape = function(shape, blink) {
    if (this.isiTerm2) {
      switch (shape) {
        case "block":
          if (!blink) {
            this._twrite("\x1B]50;CursorShape=0;BlinkingCursorEnabled=0\x07");
          } else {
            this._twrite("\x1B]50;CursorShape=0;BlinkingCursorEnabled=1\x07");
          }
          break;
        case "underline":
          if (!blink) {
          } else {
          }
          break;
        case "line":
          if (!blink) {
            this._twrite("\x1B]50;CursorShape=1;BlinkingCursorEnabled=0\x07");
          } else {
            this._twrite("\x1B]50;CursorShape=1;BlinkingCursorEnabled=1\x07");
          }
          break;
      }
      return true;
    } else if (this.term("xterm") || this.term("screen")) {
      switch (shape) {
        case "block":
          if (!blink) {
            this._twrite("\x1B[0 q");
          } else {
            this._twrite("\x1B[1 q");
          }
          break;
        case "underline":
          if (!blink) {
            this._twrite("\x1B[2 q");
          } else {
            this._twrite("\x1B[3 q");
          }
          break;
        case "line":
          if (!blink) {
            this._twrite("\x1B[4 q");
          } else {
            this._twrite("\x1B[5 q");
          }
          break;
      }
      return true;
    }
    return false;
  };
  Program.prototype.cursorColor = function(color) {
    if (this.term("xterm") || this.term("rxvt") || this.term("screen")) {
      this._twrite("\x1B]12;" + color + "\x07");
      return true;
    }
    return false;
  };
  Program.prototype.cursorReset = Program.prototype.resetCursor = function() {
    if (this.term("xterm") || this.term("rxvt") || this.term("screen")) {
      this._twrite("\x1B[0 q");
      this._twrite("\x1B]112\x07");
      this._twrite("\x1B]12;white\x07");
      return true;
    }
    return false;
  };
  Program.prototype.getTextParams = function(param, callback) {
    return this.response("text-params", "\x1B]" + param + ";?\x07", function(err, data) {
      if (err)
        return callback(err);
      return callback(null, data.pt);
    });
  };
  Program.prototype.getCursorColor = function(callback) {
    return this.getTextParams(12, callback);
  };
  Program.prototype.nul = function() {
    return this._write("\x80");
  };
  Program.prototype.bel = Program.prototype.bell = function() {
    if (this.has("bel"))
      return this.put.bel();
    return this._write("\x07");
  };
  Program.prototype.vtab = function() {
    this.y++;
    this._ncoords();
    return this._write("\v");
  };
  Program.prototype.ff = Program.prototype.form = function() {
    if (this.has("ff"))
      return this.put.ff();
    return this._write("\f");
  };
  Program.prototype.kbs = Program.prototype.backspace = function() {
    this.x--;
    this._ncoords();
    if (this.has("kbs"))
      return this.put.kbs();
    return this._write("\b");
  };
  Program.prototype.ht = Program.prototype.tab = function() {
    this.x += 8;
    this._ncoords();
    if (this.has("ht"))
      return this.put.ht();
    return this._write("\t");
  };
  Program.prototype.shiftOut = function() {
    return this._write("\x0E");
  };
  Program.prototype.shiftIn = function() {
    return this._write("\x0F");
  };
  Program.prototype.cr = Program.prototype.return = function() {
    this.x = 0;
    if (this.has("cr"))
      return this.put.cr();
    return this._write("\r");
  };
  Program.prototype.nel = Program.prototype.newline = Program.prototype.feed = function() {
    if (this.tput && this.tput.bools.eat_newline_glitch && this.x >= this.cols) {
      return;
    }
    this.x = 0;
    this.y++;
    this._ncoords();
    if (this.has("nel"))
      return this.put.nel();
    return this._write("\n");
  };
  Program.prototype.ind = Program.prototype.index = function() {
    this.y++;
    this._ncoords();
    if (this.tput)
      return this.put.ind();
    return this._write("\x1BD");
  };
  Program.prototype.ri = Program.prototype.reverse = Program.prototype.reverseIndex = function() {
    this.y--;
    this._ncoords();
    if (this.tput)
      return this.put.ri();
    return this._write("\x1BM");
  };
  Program.prototype.nextLine = function() {
    this.y++;
    this.x = 0;
    this._ncoords();
    if (this.has("nel"))
      return this.put.nel();
    return this._write("\x1BE");
  };
  Program.prototype.reset = function() {
    this.x = this.y = 0;
    if (this.has("rs1") || this.has("ris")) {
      return this.has("rs1") ? this.put.rs1() : this.put.ris();
    }
    return this._write("\x1Bc");
  };
  Program.prototype.tabSet = function() {
    if (this.tput)
      return this.put.hts();
    return this._write("\x1BH");
  };
  Program.prototype.sc = Program.prototype.saveCursor = function(key) {
    if (key)
      return this.lsaveCursor(key);
    this.savedX = this.x || 0;
    this.savedY = this.y || 0;
    if (this.tput)
      return this.put.sc();
    return this._write("\x1B7");
  };
  Program.prototype.rc = Program.prototype.restoreCursor = function(key, hide) {
    if (key)
      return this.lrestoreCursor(key, hide);
    this.x = this.savedX || 0;
    this.y = this.savedY || 0;
    if (this.tput)
      return this.put.rc();
    return this._write("\x1B8");
  };
  Program.prototype.lsaveCursor = function(key) {
    key = key || "local";
    this._saved = this._saved || {};
    this._saved[key] = this._saved[key] || {};
    this._saved[key].x = this.x;
    this._saved[key].y = this.y;
    this._saved[key].hidden = this.cursorHidden;
  };
  Program.prototype.lrestoreCursor = function(key, hide) {
    var pos;
    key = key || "local";
    if (!this._saved || !this._saved[key])
      return;
    pos = this._saved[key];
    this.cup(pos.y, pos.x);
    if (hide && pos.hidden !== this.cursorHidden) {
      if (pos.hidden) {
        this.hideCursor();
      } else {
        this.showCursor();
      }
    }
  };
  Program.prototype.lineHeight = function() {
    return this._write("\x1B#");
  };
  Program.prototype.charset = function(val, level) {
    level = level || 0;
    switch (level) {
      case 0:
        level = "(";
        break;
      case 1:
        level = ")";
        break;
      case 2:
        level = "*";
        break;
      case 3:
        level = "+";
        break;
    }
    var name2 = typeof val === "string" ? val.toLowerCase() : val;
    switch (name2) {
      case "acs":
      case "scld":
        if (this.tput)
          return this.put.smacs();
        val = "0";
        break;
      case "uk":
        val = "A";
        break;
      case "us":
      case "usascii":
      case "ascii":
        if (this.tput)
          return this.put.rmacs();
        val = "B";
        break;
      case "dutch":
        val = "4";
        break;
      case "finnish":
        val = "C";
        val = "5";
        break;
      case "french":
        val = "R";
        break;
      case "frenchcanadian":
        val = "Q";
        break;
      case "german":
        val = "K";
        break;
      case "italian":
        val = "Y";
        break;
      case "norwegiandanish":
        val = "E";
        val = "6";
        break;
      case "spanish":
        val = "Z";
        break;
      case "swedish":
        val = "H";
        val = "7";
        break;
      case "swiss":
        val = "=";
        break;
      case "isolatin":
        val = "/A";
        break;
      default:
        if (this.tput)
          return this.put.rmacs();
        val = "B";
        break;
    }
    return this._write("\x1B(" + val);
  };
  Program.prototype.enter_alt_charset_mode = Program.prototype.as = Program.prototype.smacs = function() {
    return this.charset("acs");
  };
  Program.prototype.exit_alt_charset_mode = Program.prototype.ae = Program.prototype.rmacs = function() {
    return this.charset("ascii");
  };
  Program.prototype.setG = function(val) {
    switch (val) {
      case 1:
        val = "~";
        break;
      case 2:
        val = "n";
        val = "}";
        val = "N";
        break;
      case 3:
        val = "o";
        val = "|";
        val = "O";
        break;
    }
    return this._write("\x1B" + val);
  };
  Program.prototype.setTitle = function(title) {
    this._title = title;
    return this._twrite("\x1B]0;" + title + "\x07");
  };
  Program.prototype.resetColors = function(param) {
    if (this.has("Cr")) {
      return this.put.Cr(param);
    }
    return this._twrite("\x1B]112\x07");
  };
  Program.prototype.dynamicColors = function(param) {
    if (this.has("Cs")) {
      return this.put.Cs(param);
    }
    return this._twrite("\x1B]12;" + param + "\x07");
  };
  Program.prototype.selData = function(a, b) {
    if (this.has("Ms")) {
      return this.put.Ms(a, b);
    }
    return this._twrite("\x1B]52;" + a + ";" + b + "\x07");
  };
  Program.prototype.cuu = Program.prototype.up = Program.prototype.cursorUp = function(param) {
    this.y -= param || 1;
    this._ncoords();
    if (this.tput) {
      if (!this.tput.strings.parm_up_cursor) {
        return this._write(this.repeat(this.tput.cuu1(), param));
      }
      return this.put.cuu(param);
    }
    return this._write("\x1B[" + (param || "") + "A");
  };
  Program.prototype.cud = Program.prototype.down = Program.prototype.cursorDown = function(param) {
    this.y += param || 1;
    this._ncoords();
    if (this.tput) {
      if (!this.tput.strings.parm_down_cursor) {
        return this._write(this.repeat(this.tput.cud1(), param));
      }
      return this.put.cud(param);
    }
    return this._write("\x1B[" + (param || "") + "B");
  };
  Program.prototype.cuf = Program.prototype.right = Program.prototype.forward = Program.prototype.cursorForward = function(param) {
    this.x += param || 1;
    this._ncoords();
    if (this.tput) {
      if (!this.tput.strings.parm_right_cursor) {
        return this._write(this.repeat(this.tput.cuf1(), param));
      }
      return this.put.cuf(param);
    }
    return this._write("\x1B[" + (param || "") + "C");
  };
  Program.prototype.cub = Program.prototype.left = Program.prototype.back = Program.prototype.cursorBackward = function(param) {
    this.x -= param || 1;
    this._ncoords();
    if (this.tput) {
      if (!this.tput.strings.parm_left_cursor) {
        return this._write(this.repeat(this.tput.cub1(), param));
      }
      return this.put.cub(param);
    }
    return this._write("\x1B[" + (param || "") + "D");
  };
  Program.prototype.cup = Program.prototype.pos = Program.prototype.cursorPos = function(row, col) {
    if (!this.zero) {
      row = (row || 1) - 1;
      col = (col || 1) - 1;
    } else {
      row = row || 0;
      col = col || 0;
    }
    this.x = col;
    this.y = row;
    this._ncoords();
    if (this.tput)
      return this.put.cup(row, col);
    return this._write("\x1B[" + (row + 1) + ";" + (col + 1) + "H");
  };
  Program.prototype.ed = Program.prototype.eraseInDisplay = function(param) {
    if (this.tput) {
      switch (param) {
        case "above":
          param = 1;
          break;
        case "all":
          param = 2;
          break;
        case "saved":
          param = 3;
          break;
        case "below":
        default:
          param = 0;
          break;
      }
      return this.put.ed(param);
    }
    switch (param) {
      case "above":
        return this._write("X1b[1J");
      case "all":
        return this._write("\x1B[2J");
      case "saved":
        return this._write("\x1B[3J");
      case "below":
      default:
        return this._write("\x1B[J");
    }
  };
  Program.prototype.clear = function() {
    this.x = 0;
    this.y = 0;
    if (this.tput)
      return this.put.clear();
    return this._write("\x1B[H\x1B[J");
  };
  Program.prototype.el = Program.prototype.eraseInLine = function(param) {
    if (this.tput) {
      switch (param) {
        case "left":
          param = 1;
          break;
        case "all":
          param = 2;
          break;
        case "right":
        default:
          param = 0;
          break;
      }
      return this.put.el(param);
    }
    switch (param) {
      case "left":
        return this._write("\x1B[1K");
      case "all":
        return this._write("\x1B[2K");
      case "right":
      default:
        return this._write("\x1B[K");
    }
  };
  Program.prototype.sgr = Program.prototype.attr = Program.prototype.charAttributes = function(param, val) {
    return this._write(this._attr(param, val));
  };
  Program.prototype.text = function(text, attr) {
    return this._attr(attr, true) + text + this._attr(attr, false);
  };
  Program.prototype._attr = function(param, val) {
    var self2 = this, parts, color, m;
    if (Array.isArray(param)) {
      parts = param;
      param = parts[0] || "normal";
    } else {
      param = param || "normal";
      parts = param.split(/\s*[,;]\s*/);
    }
    if (parts.length > 1) {
      var used = {}, out = [];
      parts.forEach(function(part) {
        part = self2._attr(part, val).slice(2, -1);
        if (part === "")
          return;
        if (used[part])
          return;
        used[part] = true;
        out.push(part);
      });
      return "\x1B[" + out.join(";") + "m";
    }
    if (param.indexOf("no ") === 0) {
      param = param.substring(3);
      val = false;
    } else if (param.indexOf("!") === 0) {
      param = param.substring(1);
      val = false;
    }
    switch (param) {
      case "normal":
      case "default":
        if (val === false)
          return "";
        return "\x1B[m";
      case "bold":
        return val === false ? "\x1B[22m" : "\x1B[1m";
      case "ul":
      case "underline":
      case "underlined":
        return val === false ? "\x1B[24m" : "\x1B[4m";
      case "blink":
        return val === false ? "\x1B[25m" : "\x1B[5m";
      case "inverse":
        return val === false ? "\x1B[27m" : "\x1B[7m";
      case "invisible":
        return val === false ? "\x1B[28m" : "\x1B[8m";
      case "black fg":
        return val === false ? "\x1B[39m" : "\x1B[30m";
      case "red fg":
        return val === false ? "\x1B[39m" : "\x1B[31m";
      case "green fg":
        return val === false ? "\x1B[39m" : "\x1B[32m";
      case "yellow fg":
        return val === false ? "\x1B[39m" : "\x1B[33m";
      case "blue fg":
        return val === false ? "\x1B[39m" : "\x1B[34m";
      case "magenta fg":
        return val === false ? "\x1B[39m" : "\x1B[35m";
      case "cyan fg":
        return val === false ? "\x1B[39m" : "\x1B[36m";
      case "white fg":
      case "light grey fg":
      case "light gray fg":
      case "bright grey fg":
      case "bright gray fg":
        return val === false ? "\x1B[39m" : "\x1B[37m";
      case "default fg":
        if (val === false)
          return "";
        return "\x1B[39m";
      case "black bg":
        return val === false ? "\x1B[49m" : "\x1B[40m";
      case "red bg":
        return val === false ? "\x1B[49m" : "\x1B[41m";
      case "green bg":
        return val === false ? "\x1B[49m" : "\x1B[42m";
      case "yellow bg":
        return val === false ? "\x1B[49m" : "\x1B[43m";
      case "blue bg":
        return val === false ? "\x1B[49m" : "\x1B[44m";
      case "magenta bg":
        return val === false ? "\x1B[49m" : "\x1B[45m";
      case "cyan bg":
        return val === false ? "\x1B[49m" : "\x1B[46m";
      case "white bg":
      case "light grey bg":
      case "light gray bg":
      case "bright grey bg":
      case "bright gray bg":
        return val === false ? "\x1B[49m" : "\x1B[47m";
      case "default bg":
        if (val === false)
          return "";
        return "\x1B[49m";
      case "light black fg":
      case "bright black fg":
      case "grey fg":
      case "gray fg":
        return val === false ? "\x1B[39m" : "\x1B[90m";
      case "light red fg":
      case "bright red fg":
        return val === false ? "\x1B[39m" : "\x1B[91m";
      case "light green fg":
      case "bright green fg":
        return val === false ? "\x1B[39m" : "\x1B[92m";
      case "light yellow fg":
      case "bright yellow fg":
        return val === false ? "\x1B[39m" : "\x1B[93m";
      case "light blue fg":
      case "bright blue fg":
        return val === false ? "\x1B[39m" : "\x1B[94m";
      case "light magenta fg":
      case "bright magenta fg":
        return val === false ? "\x1B[39m" : "\x1B[95m";
      case "light cyan fg":
      case "bright cyan fg":
        return val === false ? "\x1B[39m" : "\x1B[96m";
      case "light white fg":
      case "bright white fg":
        return val === false ? "\x1B[39m" : "\x1B[97m";
      case "light black bg":
      case "bright black bg":
      case "grey bg":
      case "gray bg":
        return val === false ? "\x1B[49m" : "\x1B[100m";
      case "light red bg":
      case "bright red bg":
        return val === false ? "\x1B[49m" : "\x1B[101m";
      case "light green bg":
      case "bright green bg":
        return val === false ? "\x1B[49m" : "\x1B[102m";
      case "light yellow bg":
      case "bright yellow bg":
        return val === false ? "\x1B[49m" : "\x1B[103m";
      case "light blue bg":
      case "bright blue bg":
        return val === false ? "\x1B[49m" : "\x1B[104m";
      case "light magenta bg":
      case "bright magenta bg":
        return val === false ? "\x1B[49m" : "\x1B[105m";
      case "light cyan bg":
      case "bright cyan bg":
        return val === false ? "\x1B[49m" : "\x1B[106m";
      case "light white bg":
      case "bright white bg":
        return val === false ? "\x1B[49m" : "\x1B[107m";
      case "default fg bg":
        if (val === false)
          return "";
        return this.term("rxvt") ? "\x1B[100m" : "\x1B[39;49m";
      default:
        if (param[0] === "#") {
          param = param.replace(/#(?:[0-9a-f]{3}){1,2}/i, colors.match);
        }
        m = /^(-?\d+) (fg|bg)$/.exec(param);
        if (m) {
          color = +m[1];
          if (val === false || color === -1) {
            return this._attr("default " + m[2]);
          }
          color = colors.reduce(color, this.tput.colors);
          if (color < 16 || this.tput && this.tput.colors <= 16) {
            if (m[2] === "fg") {
              if (color < 8) {
                color += 30;
              } else if (color < 16) {
                color -= 8;
                color += 90;
              }
            } else if (m[2] === "bg") {
              if (color < 8) {
                color += 40;
              } else if (color < 16) {
                color -= 8;
                color += 100;
              }
            }
            return "\x1B[" + color + "m";
          }
          if (m[2] === "fg") {
            return "\x1B[38;5;" + color + "m";
          }
          if (m[2] === "bg") {
            return "\x1B[48;5;" + color + "m";
          }
        }
        if (/^[\d;]*$/.test(param)) {
          return "\x1B[" + param + "m";
        }
        return null;
    }
  };
  Program.prototype.fg = Program.prototype.setForeground = function(color, val) {
    color = color.split(/\s*[,;]\s*/).join(" fg, ") + " fg";
    return this.attr(color, val);
  };
  Program.prototype.bg = Program.prototype.setBackground = function(color, val) {
    color = color.split(/\s*[,;]\s*/).join(" bg, ") + " bg";
    return this.attr(color, val);
  };
  Program.prototype.dsr = Program.prototype.deviceStatus = function(param, callback, dec, noBypass) {
    if (dec) {
      return this.response("device-status", "\x1B[?" + (param || "0") + "n", callback, noBypass);
    }
    return this.response("device-status", "\x1B[" + (param || "0") + "n", callback, noBypass);
  };
  Program.prototype.getCursor = function(callback) {
    return this.deviceStatus(6, callback, false, true);
  };
  Program.prototype.saveReportedCursor = function(callback) {
    var self2 = this;
    if (this.tput.strings.user7 === "\x1B[6n" || this.term("screen")) {
      return this.getCursor(function(err, data) {
        if (data) {
          self2._rx = data.status.x;
          self2._ry = data.status.y;
        }
        if (!callback)
          return;
        return callback(err);
      });
    }
    if (!callback)
      return;
    return callback();
  };
  Program.prototype.restoreReportedCursor = function() {
    if (this._rx == null)
      return;
    return this.cup(this._ry, this._rx);
  };
  Program.prototype.ich = Program.prototype.insertChars = function(param) {
    this.x += param || 1;
    this._ncoords();
    if (this.tput)
      return this.put.ich(param);
    return this._write("\x1B[" + (param || 1) + "@");
  };
  Program.prototype.cnl = Program.prototype.cursorNextLine = function(param) {
    this.y += param || 1;
    this._ncoords();
    return this._write("\x1B[" + (param || "") + "E");
  };
  Program.prototype.cpl = Program.prototype.cursorPrecedingLine = function(param) {
    this.y -= param || 1;
    this._ncoords();
    return this._write("\x1B[" + (param || "") + "F");
  };
  Program.prototype.cha = Program.prototype.cursorCharAbsolute = function(param) {
    if (!this.zero) {
      param = (param || 1) - 1;
    } else {
      param = param || 0;
    }
    this.x = param;
    this.y = 0;
    this._ncoords();
    if (this.tput)
      return this.put.hpa(param);
    return this._write("\x1B[" + (param + 1) + "G");
  };
  Program.prototype.il = Program.prototype.insertLines = function(param) {
    if (this.tput)
      return this.put.il(param);
    return this._write("\x1B[" + (param || "") + "L");
  };
  Program.prototype.dl = Program.prototype.deleteLines = function(param) {
    if (this.tput)
      return this.put.dl(param);
    return this._write("\x1B[" + (param || "") + "M");
  };
  Program.prototype.dch = Program.prototype.deleteChars = function(param) {
    if (this.tput)
      return this.put.dch(param);
    return this._write("\x1B[" + (param || "") + "P");
  };
  Program.prototype.ech = Program.prototype.eraseChars = function(param) {
    if (this.tput)
      return this.put.ech(param);
    return this._write("\x1B[" + (param || "") + "X");
  };
  Program.prototype.hpa = Program.prototype.charPosAbsolute = function(param) {
    this.x = param || 0;
    this._ncoords();
    if (this.tput) {
      return this.put.hpa.apply(this.put, arguments);
    }
    param = slice.call(arguments).join(";");
    return this._write("\x1B[" + (param || "") + "`");
  };
  Program.prototype.hpr = Program.prototype.HPositionRelative = function(param) {
    if (this.tput)
      return this.cuf(param);
    this.x += param || 1;
    this._ncoords();
    return this._write("\x1B[" + (param || "") + "a");
  };
  Program.prototype.da = Program.prototype.sendDeviceAttributes = function(param, callback) {
    return this.response("device-attributes", "\x1B[" + (param || "") + "c", callback);
  };
  Program.prototype.vpa = Program.prototype.linePosAbsolute = function(param) {
    this.y = param || 1;
    this._ncoords();
    if (this.tput) {
      return this.put.vpa.apply(this.put, arguments);
    }
    param = slice.call(arguments).join(";");
    return this._write("\x1B[" + (param || "") + "d");
  };
  Program.prototype.vpr = Program.prototype.VPositionRelative = function(param) {
    if (this.tput)
      return this.cud(param);
    this.y += param || 1;
    this._ncoords();
    return this._write("\x1B[" + (param || "") + "e");
  };
  Program.prototype.hvp = Program.prototype.HVPosition = function(row, col) {
    if (!this.zero) {
      row = (row || 1) - 1;
      col = (col || 1) - 1;
    } else {
      row = row || 0;
      col = col || 0;
    }
    this.y = row;
    this.x = col;
    this._ncoords();
    if (this.tput)
      return this.put.cup(row, col);
    return this._write("\x1B[" + (row + 1) + ";" + (col + 1) + "f");
  };
  Program.prototype.sm = Program.prototype.setMode = function() {
    var param = slice.call(arguments).join(";");
    return this._write("\x1B[" + (param || "") + "h");
  };
  Program.prototype.decset = function() {
    var param = slice.call(arguments).join(";");
    return this.setMode("?" + param);
  };
  Program.prototype.dectcem = Program.prototype.cnorm = Program.prototype.cvvis = Program.prototype.showCursor = function() {
    this.cursorHidden = false;
    if (this.tput)
      return this.put.cnorm();
    return this.setMode("?25");
  };
  Program.prototype.alternate = Program.prototype.smcup = Program.prototype.alternateBuffer = function() {
    this.isAlt = true;
    if (this.tput)
      return this.put.smcup();
    if (this.term("vt") || this.term("linux"))
      return;
    this.setMode("?47");
    return this.setMode("?1049");
  };
  Program.prototype.rm = Program.prototype.resetMode = function() {
    var param = slice.call(arguments).join(";");
    return this._write("\x1B[" + (param || "") + "l");
  };
  Program.prototype.decrst = function() {
    var param = slice.call(arguments).join(";");
    return this.resetMode("?" + param);
  };
  Program.prototype.dectcemh = Program.prototype.cursor_invisible = Program.prototype.vi = Program.prototype.civis = Program.prototype.hideCursor = function() {
    this.cursorHidden = true;
    if (this.tput)
      return this.put.civis();
    return this.resetMode("?25");
  };
  Program.prototype.rmcup = Program.prototype.normalBuffer = function() {
    this.isAlt = false;
    if (this.tput)
      return this.put.rmcup();
    this.resetMode("?47");
    return this.resetMode("?1049");
  };
  Program.prototype.enableMouse = function() {
    if (process.env.BLESSED_FORCE_MODES) {
      var modes = process.env.BLESSED_FORCE_MODES.split(",");
      var options2 = {};
      for (var n = 0;n < modes.length; ++n) {
        var pair = modes[n].split("=");
        var v = pair[1] !== "0";
        switch (pair[0].toUpperCase()) {
          case "SGRMOUSE":
            options2.sgrMouse = v;
            break;
          case "UTFMOUSE":
            options2.utfMouse = v;
            break;
          case "VT200MOUSE":
            options2.vt200Mouse = v;
            break;
          case "URXVTMOUSE":
            options2.urxvtMouse = v;
            break;
          case "X10MOUSE":
            options2.x10Mouse = v;
            break;
          case "DECMOUSE":
            options2.decMouse = v;
            break;
          case "PTERMMOUSE":
            options2.ptermMouse = v;
            break;
          case "JSBTERMMOUSE":
            options2.jsbtermMouse = v;
            break;
          case "VT200HILITE":
            options2.vt200Hilite = v;
            break;
          case "GPMMOUSE":
            options2.gpmMouse = v;
            break;
          case "CELLMOTION":
            options2.cellMotion = v;
            break;
          case "ALLMOTION":
            options2.allMotion = v;
            break;
          case "SENDFOCUS":
            options2.sendFocus = v;
            break;
        }
      }
      return this.setMouse(options2, true);
    }
    if (this.term("rxvt-unicode")) {
      return this.setMouse({
        urxvtMouse: true,
        cellMotion: true,
        allMotion: true
      }, true);
    }
    if (this.term("rxvt")) {
      return this.setMouse({
        vt200Mouse: true,
        x10Mouse: true,
        cellMotion: true,
        allMotion: true
      }, true);
    }
    if (this.isVTE) {
      return this.setMouse({
        sgrMouse: true,
        cellMotion: true,
        allMotion: true
      }, true);
    }
    if (this.term("linux")) {
      return this.setMouse({
        vt200Mouse: true,
        gpmMouse: true
      }, true);
    }
    if (this.term("xterm") || this.term("screen") || this.tput && this.tput.strings.key_mouse) {
      return this.setMouse({
        vt200Mouse: true,
        utfMouse: true,
        cellMotion: true,
        allMotion: true
      }, true);
    }
  };
  Program.prototype.disableMouse = function() {
    if (!this._currentMouse)
      return;
    var obj = {};
    Object.keys(this._currentMouse).forEach(function(key) {
      obj[key] = false;
    });
    return this.setMouse(obj, false);
  };
  Program.prototype.setMouse = function(opt, enable) {
    if (opt.normalMouse != null) {
      opt.vt200Mouse = opt.normalMouse;
      opt.allMotion = opt.normalMouse;
    }
    if (opt.hiliteTracking != null) {
      opt.vt200Hilite = opt.hiliteTracking;
    }
    if (enable === true) {
      if (this._currentMouse) {
        this.setMouse(opt);
        Object.keys(opt).forEach(function(key) {
          this._currentMouse[key] = opt[key];
        }, this);
        return;
      }
      this._currentMouse = opt;
      this.mouseEnabled = true;
    } else if (enable === false) {
      delete this._currentMouse;
      this.mouseEnabled = false;
    }
    if (opt.x10Mouse != null) {
      if (opt.x10Mouse)
        this.setMode("?9");
      else
        this.resetMode("?9");
    }
    if (opt.vt200Mouse != null) {
      if (opt.vt200Mouse)
        this.setMode("?1000");
      else
        this.resetMode("?1000");
    }
    if (opt.vt200Hilite != null) {
      if (opt.vt200Hilite)
        this.setMode("?1001");
      else
        this.resetMode("?1001");
    }
    if (opt.cellMotion != null) {
      if (opt.cellMotion)
        this.setMode("?1002");
      else
        this.resetMode("?1002");
    }
    if (opt.allMotion != null) {
      if (this.tmux && this.tmuxVersion >= 2) {
        if (opt.allMotion)
          this._twrite("\x1B[?1003h");
        else
          this._twrite("\x1B[?1003l");
      } else {
        if (opt.allMotion)
          this.setMode("?1003");
        else
          this.resetMode("?1003");
      }
    }
    if (opt.sendFocus != null) {
      if (opt.sendFocus)
        this.setMode("?1004");
      else
        this.resetMode("?1004");
    }
    if (opt.utfMouse != null) {
      if (opt.utfMouse)
        this.setMode("?1005");
      else
        this.resetMode("?1005");
    }
    if (opt.sgrMouse != null) {
      if (opt.sgrMouse)
        this.setMode("?1006");
      else
        this.resetMode("?1006");
    }
    if (opt.urxvtMouse != null) {
      if (opt.urxvtMouse)
        this.setMode("?1015");
      else
        this.resetMode("?1015");
    }
    if (opt.decMouse != null) {
      if (opt.decMouse)
        this._write("\x1B[1;2'z\x1B[1;3'{");
      else
        this._write("\x1B['z");
    }
    if (opt.ptermMouse != null) {
      if (opt.ptermMouse)
        this._write("\x1B[>1h\x1B[>6h\x1B[>7h\x1B[>1h\x1B[>9l");
      else
        this._write("\x1B[>1l\x1B[>6l\x1B[>7l\x1B[>1l\x1B[>9h");
    }
    if (opt.jsbtermMouse != null) {
      if (opt.jsbtermMouse)
        this._write("\x1B[0~ZwLMRK+1Q\x1B\\");
      else
        this._write("\x1B[0~ZwQ\x1B\\");
    }
    if (opt.gpmMouse != null) {
      if (opt.gpmMouse)
        this.enableGpm();
      else
        this.disableGpm();
    }
  };
  Program.prototype.decstbm = Program.prototype.csr = Program.prototype.setScrollRegion = function(top, bottom) {
    if (!this.zero) {
      top = (top || 1) - 1;
      bottom = (bottom || this.rows) - 1;
    } else {
      top = top || 0;
      bottom = bottom || this.rows - 1;
    }
    this.scrollTop = top;
    this.scrollBottom = bottom;
    this.x = 0;
    this.y = 0;
    this._ncoords();
    if (this.tput)
      return this.put.csr(top, bottom);
    return this._write("\x1B[" + (top + 1) + ";" + (bottom + 1) + "r");
  };
  Program.prototype.scA = Program.prototype.saveCursorA = function() {
    this.savedX = this.x;
    this.savedY = this.y;
    if (this.tput)
      return this.put.sc();
    return this._write("\x1B[s");
  };
  Program.prototype.rcA = Program.prototype.restoreCursorA = function() {
    this.x = this.savedX || 0;
    this.y = this.savedY || 0;
    if (this.tput)
      return this.put.rc();
    return this._write("\x1B[u");
  };
  Program.prototype.cht = Program.prototype.cursorForwardTab = function(param) {
    this.x += 8;
    this._ncoords();
    if (this.tput)
      return this.put.tab(param);
    return this._write("\x1B[" + (param || 1) + "I");
  };
  Program.prototype.su = Program.prototype.scrollUp = function(param) {
    this.y -= param || 1;
    this._ncoords();
    if (this.tput)
      return this.put.parm_index(param);
    return this._write("\x1B[" + (param || 1) + "S");
  };
  Program.prototype.sd = Program.prototype.scrollDown = function(param) {
    this.y += param || 1;
    this._ncoords();
    if (this.tput)
      return this.put.parm_rindex(param);
    return this._write("\x1B[" + (param || 1) + "T");
  };
  Program.prototype.initMouseTracking = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "T");
  };
  Program.prototype.resetTitleModes = function() {
    return this._write("\x1B[>" + slice.call(arguments).join(";") + "T");
  };
  Program.prototype.cbt = Program.prototype.cursorBackwardTab = function(param) {
    this.x -= 8;
    this._ncoords();
    if (this.tput)
      return this.put.cbt(param);
    return this._write("\x1B[" + (param || 1) + "Z");
  };
  Program.prototype.rep = Program.prototype.repeatPrecedingCharacter = function(param) {
    this.x += param || 1;
    this._ncoords();
    if (this.tput)
      return this.put.rep(param);
    return this._write("\x1B[" + (param || 1) + "b");
  };
  Program.prototype.tbc = Program.prototype.tabClear = function(param) {
    if (this.tput)
      return this.put.tbc(param);
    return this._write("\x1B[" + (param || 0) + "g");
  };
  Program.prototype.mc = Program.prototype.mediaCopy = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "i");
  };
  Program.prototype.print_screen = Program.prototype.ps = Program.prototype.mc0 = function() {
    if (this.tput)
      return this.put.mc0();
    return this.mc("0");
  };
  Program.prototype.prtr_on = Program.prototype.po = Program.prototype.mc5 = function() {
    if (this.tput)
      return this.put.mc5();
    return this.mc("5");
  };
  Program.prototype.prtr_off = Program.prototype.pf = Program.prototype.mc4 = function() {
    if (this.tput)
      return this.put.mc4();
    return this.mc("4");
  };
  Program.prototype.prtr_non = Program.prototype.pO = Program.prototype.mc5p = function() {
    if (this.tput)
      return this.put.mc5p();
    return this.mc("?5");
  };
  Program.prototype.setResources = function() {
    return this._write("\x1B[>" + slice.call(arguments).join(";") + "m");
  };
  Program.prototype.disableModifiers = function(param) {
    return this._write("\x1B[>" + (param || "") + "n");
  };
  Program.prototype.setPointerMode = function(param) {
    return this._write("\x1B[>" + (param || "") + "p");
  };
  Program.prototype.decstr = Program.prototype.rs2 = Program.prototype.softReset = function() {
    if (this.tput)
      return this.put.rs2();
    return this._write("\x1B[!p\x1B[?3;4l\x1B[4l\x1B>");
  };
  Program.prototype.decrqm = Program.prototype.requestAnsiMode = function(param) {
    return this._write("\x1B[" + (param || "") + "$p");
  };
  Program.prototype.decrqmp = Program.prototype.requestPrivateMode = function(param) {
    return this._write("\x1B[?" + (param || "") + "$p");
  };
  Program.prototype.decscl = Program.prototype.setConformanceLevel = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + '"p');
  };
  Program.prototype.decll = Program.prototype.loadLEDs = function(param) {
    return this._write("\x1B[" + (param || "") + "q");
  };
  Program.prototype.decscusr = Program.prototype.setCursorStyle = function(param) {
    switch (param) {
      case "blinking block":
        param = 1;
        break;
      case "block":
      case "steady block":
        param = 2;
        break;
      case "blinking underline":
        param = 3;
        break;
      case "underline":
      case "steady underline":
        param = 4;
        break;
      case "blinking bar":
        param = 5;
        break;
      case "bar":
      case "steady bar":
        param = 6;
        break;
    }
    if (param === 2 && this.has("Se")) {
      return this.put.Se();
    }
    if (this.has("Ss")) {
      return this.put.Ss(param);
    }
    return this._write("\x1B[" + (param || 1) + " q");
  };
  Program.prototype.decsca = Program.prototype.setCharProtectionAttr = function(param) {
    return this._write("\x1B[" + (param || 0) + '"q');
  };
  Program.prototype.restorePrivateValues = function() {
    return this._write("\x1B[?" + slice.call(arguments).join(";") + "r");
  };
  Program.prototype.deccara = Program.prototype.setAttrInRectangle = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "$r");
  };
  Program.prototype.savePrivateValues = function() {
    return this._write("\x1B[?" + slice.call(arguments).join(";") + "s");
  };
  Program.prototype.manipulateWindow = function() {
    var args2 = slice.call(arguments);
    var callback = typeof args2[args2.length - 1] === "function" ? args2.pop() : function() {
    };
    return this.response("window-manipulation", "\x1B[" + args2.join(";") + "t", callback);
  };
  Program.prototype.getWindowSize = function(callback) {
    return this.manipulateWindow(18, callback);
  };
  Program.prototype.decrara = Program.prototype.reverseAttrInRectangle = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "$t");
  };
  Program.prototype.setTitleModeFeature = function() {
    return this._twrite("\x1B[>" + slice.call(arguments).join(";") + "t");
  };
  Program.prototype.decswbv = Program.prototype.setWarningBellVolume = function(param) {
    return this._write("\x1B[" + (param || "") + " t");
  };
  Program.prototype.decsmbv = Program.prototype.setMarginBellVolume = function(param) {
    return this._write("\x1B[" + (param || "") + " u");
  };
  Program.prototype.deccra = Program.prototype.copyRectangle = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "$v");
  };
  Program.prototype.decefr = Program.prototype.enableFilterRectangle = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "\'w");
  };
  Program.prototype.decreqtparm = Program.prototype.requestParameters = function(param) {
    return this._write("\x1B[" + (param || 0) + "x");
  };
  Program.prototype.decsace = Program.prototype.selectChangeExtent = function(param) {
    return this._write("\x1B[" + (param || 0) + "x");
  };
  Program.prototype.decfra = Program.prototype.fillRectangle = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "$x");
  };
  Program.prototype.decelr = Program.prototype.enableLocatorReporting = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "\'z");
  };
  Program.prototype.decera = Program.prototype.eraseRectangle = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "$z");
  };
  Program.prototype.decsle = Program.prototype.setLocatorEvents = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "\'{");
  };
  Program.prototype.decsera = Program.prototype.selectiveEraseRectangle = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + "${");
  };
  Program.prototype.decrqlp = Program.prototype.req_mouse_pos = Program.prototype.reqmp = Program.prototype.requestLocatorPosition = function(param, callback) {
    if (this.has("req_mouse_pos")) {
      var code = this.tput.req_mouse_pos(param);
      return this.response("locator-position", code, callback);
    }
    return this.response("locator-position", "\x1B[" + (param || "") + "\'|", callback);
  };
  Program.prototype.decic = Program.prototype.insertColumns = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + " }");
  };
  Program.prototype.decdc = Program.prototype.deleteColumns = function() {
    return this._write("\x1B[" + slice.call(arguments).join(";") + " ~");
  };
  Program.prototype.out = function(name2) {
    var args2 = Array.prototype.slice.call(arguments, 1);
    this.ret = true;
    var out = this[name2].apply(this, args2);
    this.ret = false;
    return out;
  };
  Program.prototype.sigtstp = function(callback) {
    var resume = this.pause();
    process.once("SIGCONT", function() {
      resume();
      if (callback)
        callback();
    });
    process.kill(process.pid, "SIGTSTP");
  };
  Program.prototype.pause = function(callback) {
    var self2 = this, isAlt = this.isAlt, mouseEnabled = this.mouseEnabled;
    this.lsaveCursor("pause");
    if (isAlt)
      this.normalBuffer();
    this.showCursor();
    if (mouseEnabled)
      this.disableMouse();
    var write4 = this.output.write;
    this.output.write = function() {
    };
    if (this.input.setRawMode) {
      this.input.setRawMode(false);
    }
    this.input.pause();
    return this._resume = function() {
      delete self2._resume;
      if (self2.input.setRawMode) {
        self2.input.setRawMode(true);
      }
      self2.input.resume();
      self2.output.write = write4;
      if (isAlt)
        self2.alternateBuffer();
      if (mouseEnabled)
        self2.enableMouse();
      self2.lrestoreCursor("pause", true);
      if (callback)
        callback();
    };
  };
  Program.prototype.resume = function() {
    if (this._resume)
      return this._resume();
  };
  module2.exports = Program;
});

// ../../node_modules/blessed/lib/widget.js
var require_widget = __commonJS((exports2) => {
  var widget = exports2;
  widget.classes = [
    "Node",
    "Screen",
    "Element",
    "Box",
    "Text",
    "Line",
    "ScrollableBox",
    "ScrollableText",
    "BigText",
    "List",
    "Form",
    "Input",
    "Textarea",
    "Textbox",
    "Button",
    "ProgressBar",
    "FileManager",
    "Checkbox",
    "RadioSet",
    "RadioButton",
    "Prompt",
    "Question",
    "Message",
    "Loading",
    "Listbar",
    "Log",
    "Table",
    "ListTable",
    "Terminal",
    "Image",
    "ANSIImage",
    "OverlayImage",
    "Video",
    "Layout"
  ];
  widget.classes.forEach(function(name2) {
    var file = name2.toLowerCase();
    widget[name2] = widget[file] = __require("./widgets/" + file);
  });
  widget.aliases = {
    ListBar: "Listbar",
    PNG: "ANSIImage"
  };
  Object.keys(widget.aliases).forEach(function(key) {
    var name2 = widget.aliases[key];
    widget[key] = widget[name2];
    widget[key.toLowerCase()] = widget[name2];
  });
});

// ../../node_modules/blessed/lib/unicode.js
var require_unicode = __commonJS((exports2) => {
  var hexify = function(n) {
    n = n.toString(16);
    while (n.length < 4)
      n = "0" + n;
    return n;
  };
  var stringFromCharCode = String.fromCharCode;
  var floor4 = Math.floor;
  exports2.charWidth = function(str, i) {
    var point = typeof str !== "number" ? exports2.codePointAt(str, i || 0) : str;
    if (point === 0)
      return 0;
    if (point === 9) {
      if (!exports2.blessed) {
        exports2.blessed = require_blessed();
      }
      return exports2.blessed.screen.global ? exports2.blessed.screen.global.tabc.length : 8;
    }
    if (point < 32 || point >= 127 && point < 160) {
      return 0;
    }
    if (exports2.combining[point]) {
      return 0;
    }
    if (point === 12288 || 65281 <= point && point <= 65376 || 65504 <= point && point <= 65510) {
      return 2;
    }
    if (4352 <= point && point <= 4447 || 4515 <= point && point <= 4519 || 4602 <= point && point <= 4607 || 9001 <= point && point <= 9002 || 11904 <= point && point <= 11929 || 11931 <= point && point <= 12019 || 12032 <= point && point <= 12245 || 12272 <= point && point <= 12283 || 12289 <= point && point <= 12350 || 12353 <= point && point <= 12438 || 12441 <= point && point <= 12543 || 12549 <= point && point <= 12589 || 12593 <= point && point <= 12686 || 12688 <= point && point <= 12730 || 12736 <= point && point <= 12771 || 12784 <= point && point <= 12830 || 12832 <= point && point <= 12871 || 12880 <= point && point <= 13054 || 13056 <= point && point <= 19903 || 19968 <= point && point <= 42124 || 42128 <= point && point <= 42182 || 43360 <= point && point <= 43388 || 44032 <= point && point <= 55203 || 55216 <= point && point <= 55238 || 55243 <= point && point <= 55291 || 63744 <= point && point <= 64255 || 65040 <= point && point <= 65049 || 65072 <= point && point <= 65106 || 65108 <= point && point <= 65126 || 65128 <= point && point <= 65131 || 110592 <= point && point <= 110593 || 127488 <= point && point <= 127490 || 127504 <= point && point <= 127546 || 127552 <= point && point <= 127560 || 127568 <= point && point <= 127569 || 131072 <= point && point <= 194367 || 177984 <= point && point <= 196605 || 196608 <= point && point <= 262141) {
      return 2;
    }
    if (process.env.NCURSES_CJK_WIDTH) {
      if (point === 161 || point === 164 || 167 <= point && point <= 168 || point === 170 || 173 <= point && point <= 174 || 176 <= point && point <= 180 || 182 <= point && point <= 186 || 188 <= point && point <= 191 || point === 198 || point === 208 || 215 <= point && point <= 216 || 222 <= point && point <= 225 || point === 230 || 232 <= point && point <= 234 || 236 <= point && point <= 237 || point === 240 || 242 <= point && point <= 243 || 247 <= point && point <= 250 || point === 252 || point === 254 || point === 257 || point === 273 || point === 275 || point === 283 || 294 <= point && point <= 295 || point === 299 || 305 <= point && point <= 307 || point === 312 || 319 <= point && point <= 322 || point === 324 || 328 <= point && point <= 331 || point === 333 || 338 <= point && point <= 339 || 358 <= point && point <= 359 || point === 363 || point === 462 || point === 464 || point === 466 || point === 468 || point === 470 || point === 472 || point === 474 || point === 476 || point === 593 || point === 609 || point === 708 || point === 711 || 713 <= point && point <= 715 || point === 717 || point === 720 || 728 <= point && point <= 731 || point === 733 || point === 735 || 768 <= point && point <= 879 || 913 <= point && point <= 929 || 931 <= point && point <= 937 || 945 <= point && point <= 961 || 963 <= point && point <= 969 || point === 1025 || 1040 <= point && point <= 1103 || point === 1105 || point === 8208 || 8211 <= point && point <= 8214 || 8216 <= point && point <= 8217 || 8220 <= point && point <= 8221 || 8224 <= point && point <= 8226 || 8228 <= point && point <= 8231 || point === 8240 || 8242 <= point && point <= 8243 || point === 8245 || point === 8251 || point === 8254 || point === 8308 || point === 8319 || 8321 <= point && point <= 8324 || point === 8364 || point === 8451 || point === 8453 || point === 8457 || point === 8467 || point === 8470 || 8481 <= point && point <= 8482 || point === 8486 || point === 8491 || 8531 <= point && point <= 8532 || 8539 <= point && point <= 8542 || 8544 <= point && point <= 8555 || 8560 <= point && point <= 8569 || point === 8585 || 8592 <= point && point <= 8601 || 8632 <= point && point <= 8633 || point === 8658 || point === 8660 || point === 8679 || point === 8704 || 8706 <= point && point <= 8707 || 8711 <= point && point <= 8712 || point === 8715 || point === 8719 || point === 8721 || point === 8725 || point === 8730 || 8733 <= point && point <= 8736 || point === 8739 || point === 8741 || 8743 <= point && point <= 8748 || point === 8750 || 8756 <= point && point <= 8759 || 8764 <= point && point <= 8765 || point === 8776 || point === 8780 || point === 8786 || 8800 <= point && point <= 8801 || 8804 <= point && point <= 8807 || 8810 <= point && point <= 8811 || 8814 <= point && point <= 8815 || 8834 <= point && point <= 8835 || 8838 <= point && point <= 8839 || point === 8853 || point === 8857 || point === 8869 || point === 8895 || point === 8978 || 9312 <= point && point <= 9449 || 9451 <= point && point <= 9547 || 9552 <= point && point <= 9587 || 9600 <= point && point <= 9615 || 9618 <= point && point <= 9621 || 9632 <= point && point <= 9633 || 9635 <= point && point <= 9641 || 9650 <= point && point <= 9651 || 9654 <= point && point <= 9655 || 9660 <= point && point <= 9661 || 9664 <= point && point <= 9665 || 9670 <= point && point <= 9672 || point === 9675 || 9678 <= point && point <= 9681 || 9698 <= point && point <= 9701 || point === 9711 || 9733 <= point && point <= 9734 || point === 9737 || 9742 <= point && point <= 9743 || 9748 <= point && point <= 9749 || point === 9756 || point === 9758 || point === 9792 || point === 9794 || 9824 <= point && point <= 9825 || 9827 <= point && point <= 9829 || 9831 <= point && point <= 9834 || 9836 <= point && point <= 9837 || point === 9839 || 9886 <= point && point <= 9887 || 9918 <= point && point <= 9919 || 9924 <= point && point <= 9933 || 9935 <= point && point <= 9953 || point === 9955 || 9960 <= point && point <= 9983 || point === 10045 || point === 10071 || 10102 <= point && point <= 10111 || 11093 <= point && point <= 11097 || 12872 <= point && point <= 12879 || 57344 <= point && point <= 63743 || 65024 <= point && point <= 65039 || point === 65533 || 127232 <= point && point <= 127242 || 127248 <= point && point <= 127277 || 127280 <= point && point <= 127337 || 127344 <= point && point <= 127386 || 917760 <= point && point <= 917999 || 983040 <= point && point <= 1048573 || 1048576 <= point && point <= 1114109) {
        return +process.env.NCURSES_CJK_WIDTH || 1;
      }
    }
    return 1;
  };
  exports2.strWidth = function(str) {
    var width = 0;
    for (var i = 0;i < str.length; i++) {
      width += exports2.charWidth(str, i);
      if (exports2.isSurrogate(str, i))
        i++;
    }
    return width;
  };
  exports2.isSurrogate = function(str, i) {
    var point = typeof str !== "number" ? exports2.codePointAt(str, i || 0) : str;
    return point > 65535;
  };
  exports2.combiningTable = [
    [768, 879],
    [1155, 1158],
    [1160, 1161],
    [1425, 1469],
    [1471, 1471],
    [1473, 1474],
    [1476, 1477],
    [1479, 1479],
    [1536, 1539],
    [1552, 1557],
    [1611, 1630],
    [1648, 1648],
    [1750, 1764],
    [1767, 1768],
    [1770, 1773],
    [1807, 1807],
    [1809, 1809],
    [1840, 1866],
    [1958, 1968],
    [2027, 2035],
    [2305, 2306],
    [2364, 2364],
    [2369, 2376],
    [2381, 2381],
    [2385, 2388],
    [2402, 2403],
    [2433, 2433],
    [2492, 2492],
    [2497, 2500],
    [2509, 2509],
    [2530, 2531],
    [2561, 2562],
    [2620, 2620],
    [2625, 2626],
    [2631, 2632],
    [2635, 2637],
    [2672, 2673],
    [2689, 2690],
    [2748, 2748],
    [2753, 2757],
    [2759, 2760],
    [2765, 2765],
    [2786, 2787],
    [2817, 2817],
    [2876, 2876],
    [2879, 2879],
    [2881, 2883],
    [2893, 2893],
    [2902, 2902],
    [2946, 2946],
    [3008, 3008],
    [3021, 3021],
    [3134, 3136],
    [3142, 3144],
    [3146, 3149],
    [3157, 3158],
    [3260, 3260],
    [3263, 3263],
    [3270, 3270],
    [3276, 3277],
    [3298, 3299],
    [3393, 3395],
    [3405, 3405],
    [3530, 3530],
    [3538, 3540],
    [3542, 3542],
    [3633, 3633],
    [3636, 3642],
    [3655, 3662],
    [3761, 3761],
    [3764, 3769],
    [3771, 3772],
    [3784, 3789],
    [3864, 3865],
    [3893, 3893],
    [3895, 3895],
    [3897, 3897],
    [3953, 3966],
    [3968, 3972],
    [3974, 3975],
    [3984, 3991],
    [3993, 4028],
    [4038, 4038],
    [4141, 4144],
    [4146, 4146],
    [4150, 4151],
    [4153, 4153],
    [4184, 4185],
    [4448, 4607],
    [4959, 4959],
    [5906, 5908],
    [5938, 5940],
    [5970, 5971],
    [6002, 6003],
    [6068, 6069],
    [6071, 6077],
    [6086, 6086],
    [6089, 6099],
    [6109, 6109],
    [6155, 6157],
    [6313, 6313],
    [6432, 6434],
    [6439, 6440],
    [6450, 6450],
    [6457, 6459],
    [6679, 6680],
    [6912, 6915],
    [6964, 6964],
    [6966, 6970],
    [6972, 6972],
    [6978, 6978],
    [7019, 7027],
    [7616, 7626],
    [7678, 7679],
    [8203, 8207],
    [8234, 8238],
    [8288, 8291],
    [8298, 8303],
    [8400, 8431],
    [12330, 12335],
    [12441, 12442],
    [43014, 43014],
    [43019, 43019],
    [43045, 43046],
    [64286, 64286],
    [65024, 65039],
    [65056, 65059],
    [65279, 65279],
    [65529, 65531],
    [68097, 68099],
    [68101, 68102],
    [68108, 68111],
    [68152, 68154],
    [68159, 68159],
    [119143, 119145],
    [119155, 119170],
    [119173, 119179],
    [119210, 119213],
    [119362, 119364],
    [917505, 917505],
    [917536, 917631],
    [917760, 917999]
  ];
  exports2.combining = exports2.combiningTable.reduce(function(out, row) {
    for (var i = row[0];i <= row[1]; i++) {
      out[i] = true;
    }
    return out;
  }, {});
  exports2.isCombining = function(str, i) {
    var point = typeof str !== "number" ? exports2.codePointAt(str, i || 0) : str;
    return exports2.combining[point] === true;
  };
  exports2.codePointAt = function(str, position) {
    if (str == null) {
      throw TypeError();
    }
    var string = String(str);
    if (string.codePointAt) {
      return string.codePointAt(position);
    }
    var size2 = string.length;
    var index = position ? Number(position) : 0;
    if (index !== index) {
      index = 0;
    }
    if (index < 0 || index >= size2) {
      return;
    }
    var first = string.charCodeAt(index);
    var second;
    if (first >= 55296 && first <= 56319 && size2 > index + 1) {
      second = string.charCodeAt(index + 1);
      if (second >= 56320 && second <= 57343) {
        return (first - 55296) * 1024 + second - 56320 + 65536;
      }
    }
    return first;
  };
  exports2.fromCodePoint = function() {
    if (String.fromCodePoint) {
      return String.fromCodePoint.apply(String, arguments);
    }
    var MAX_SIZE = 16384;
    var codeUnits = [];
    var highSurrogate;
    var lowSurrogate;
    var index = -1;
    var length3 = arguments.length;
    if (!length3) {
      return "";
    }
    var result = "";
    while (++index < length3) {
      var codePoint = Number(arguments[index]);
      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor4(codePoint) !== codePoint) {
        throw RangeError("Invalid code point: " + codePoint);
      }
      if (codePoint <= 65535) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 65536;
        highSurrogate = (codePoint >> 10) + 55296;
        lowSurrogate = codePoint % 1024 + 56320;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
      if (index + 1 === length3 || codeUnits.length > MAX_SIZE) {
        result += stringFromCharCode.apply(null, codeUnits);
        codeUnits.length = 0;
      }
    }
    return result;
  };
  exports2.chars = {};
  exports2.chars.wide = new RegExp("([" + "\\u1100-\\u115f" + "\\u2329\\u232a" + "\\u2e80-\\u303e\\u3040-\\ua4cf" + "\\uac00-\\ud7a3" + "\\uf900-\\ufaff" + "\\ufe10-\\ufe19" + "\\ufe30-\\ufe6f" + "\\uff00-\\uff60" + "\\uffe0-\\uffe6" + "])", "g");
  exports2.chars.swide = new RegExp("(" + "[\\ud840-\\ud87f][\\udc00-\\udffd]" + "|" + "[\\ud880-\\ud8bf][\\udc00-\\udffd]" + ")", "g");
  exports2.chars.all = new RegExp("(" + exports2.chars.swide.source.slice(1, -1) + "|" + exports2.chars.wide.source.slice(1, -1) + ")", "g");
  exports2.chars.surrogate = /[\ud800-\udbff][\udc00-\udfff]/g;
  exports2.chars.combining = exports2.combiningTable.reduce(function(out, row) {
    var low, high, range;
    if (row[0] > 65535) {
      low = exports2.fromCodePoint(row[0]);
      low = [
        hexify(low.charCodeAt(0)),
        hexify(low.charCodeAt(1))
      ];
      high = exports2.fromCodePoint(row[1]);
      high = [
        hexify(high.charCodeAt(0)),
        hexify(high.charCodeAt(1))
      ];
      range = "[\\u" + low[0] + "-" + "\\u" + high[0] + "]" + "[\\u" + low[1] + "-" + "\\u" + high[1] + "]";
      if (!~out.indexOf("|"))
        out += "]";
      out += "|" + range;
    } else {
      low = hexify(row[0]);
      high = hexify(row[1]);
      low = "\\u" + low;
      high = "\\u" + high;
      out += low + "-" + high;
    }
    return out;
  }, "[");
  exports2.chars.combining = new RegExp(exports2.chars.combining, "g");
});

// ../../node_modules/blessed/lib/events.js
var require_events2 = __commonJS((exports2, module2) => {
  var EventEmitter = function() {
    if (!this._events)
      this._events = {};
  };
  var slice = Array.prototype.slice;
  EventEmitter.prototype.setMaxListeners = function(n) {
    this._maxListeners = n;
  };
  EventEmitter.prototype.addListener = function(type2, listener) {
    if (!this._events[type2]) {
      this._events[type2] = listener;
    } else if (typeof this._events[type2] === "function") {
      this._events[type2] = [this._events[type2], listener];
    } else {
      this._events[type2].push(listener);
    }
    this._emit("newListener", [type2, listener]);
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.removeListener = function(type2, listener) {
    var handler = this._events[type2];
    if (!handler)
      return;
    if (typeof handler === "function" || handler.length === 1) {
      delete this._events[type2];
      this._emit("removeListener", [type2, listener]);
      return;
    }
    for (var i = 0;i < handler.length; i++) {
      if (handler[i] === listener || handler[i].listener === listener) {
        handler.splice(i, 1);
        this._emit("removeListener", [type2, listener]);
        return;
      }
    }
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.removeAllListeners = function(type2) {
    if (type2) {
      delete this._events[type2];
    } else {
      this._events = {};
    }
  };
  EventEmitter.prototype.once = function(type2, listener) {
    function on() {
      this.removeListener(type2, on);
      return listener.apply(this, arguments);
    }
    on.listener = listener;
    return this.on(type2, on);
  };
  EventEmitter.prototype.listeners = function(type2) {
    return typeof this._events[type2] === "function" ? [this._events[type2]] : this._events[type2] || [];
  };
  EventEmitter.prototype._emit = function(type2, args2) {
    var handler = this._events[type2], ret;
    if (!handler) {
      if (type2 === "error") {
        throw new args2[0];
      }
      return;
    }
    if (typeof handler === "function") {
      return handler.apply(this, args2);
    }
    for (var i = 0;i < handler.length; i++) {
      if (handler[i].apply(this, args2) === false) {
        ret = false;
      }
    }
    return ret !== false;
  };
  EventEmitter.prototype.emit = function(type2) {
    var args2 = slice.call(arguments, 1), params2 = slice.call(arguments), el = this;
    this._emit("event", params2);
    if (this.type === "screen") {
      return this._emit(type2, args2);
    }
    if (this._emit(type2, args2) === false) {
      return false;
    }
    type2 = "element " + type2;
    args2.unshift(this);
    do {
      if (!el._events[type2])
        continue;
      if (el._emit(type2, args2) === false) {
        return false;
      }
    } while (el = el.parent);
    return true;
  };
  exports2 = EventEmitter;
  exports2.EventEmitter = EventEmitter;
  module2.exports = exports2;
});

// ../../node_modules/blessed/lib/widgets/node.js
var require_node3 = __commonJS((exports2, module2) => {
  var Node = function(options2) {
    var self2 = this;
    var Screen = require_screen();
    if (!(this instanceof Node)) {
      return new Node(options2);
    }
    EventEmitter.call(this);
    options2 = options2 || {};
    this.options = options2;
    this.screen = this.screen || options2.screen;
    if (!this.screen) {
      if (this.type === "screen") {
        this.screen = this;
      } else if (Screen.total === 1) {
        this.screen = Screen.global;
      } else if (options2.parent) {
        this.screen = options2.parent;
        while (this.screen && this.screen.type !== "screen") {
          this.screen = this.screen.parent;
        }
      } else if (Screen.total) {
        this.screen = Screen.instances[Screen.instances.length - 1];
        process.nextTick(function() {
          if (!self2.parent) {
            throw new Error("Element (" + self2.type + ")" + " was not appended synchronously after the" + " screen\'s creation. Please set a `parent`" + " or `screen` option in the element\'s constructor" + " if you are going to use multiple screens and" + " append the element later.");
          }
        });
      } else {
        throw new Error("No active screen.");
      }
    }
    this.parent = options2.parent || null;
    this.children = [];
    this.$ = this._ = this.data = {};
    this.uid = Node.uid++;
    this.index = this.index != null ? this.index : -1;
    if (this.type !== "screen") {
      this.detached = true;
    }
    if (this.parent) {
      this.parent.append(this);
    }
    (options2.children || []).forEach(this.append.bind(this));
  };
  var EventEmitter = require_events2().EventEmitter;
  Node.uid = 0;
  Node.prototype.__proto__ = EventEmitter.prototype;
  Node.prototype.type = "node";
  Node.prototype.insert = function(element, i) {
    var self2 = this;
    if (element.screen && element.screen !== this.screen) {
      throw new Error("Cannot switch a node\'s screen.");
    }
    element.detach();
    element.parent = this;
    element.screen = this.screen;
    if (i === 0) {
      this.children.unshift(element);
    } else if (i === this.children.length) {
      this.children.push(element);
    } else {
      this.children.splice(i, 0, element);
    }
    element.emit("reparent", this);
    this.emit("adopt", element);
    (function emit(el) {
      var n = el.detached !== self2.detached;
      el.detached = self2.detached;
      if (n)
        el.emit("attach");
      el.children.forEach(emit);
    })(element);
    if (!this.screen.focused) {
      this.screen.focused = element;
    }
  };
  Node.prototype.prepend = function(element) {
    this.insert(element, 0);
  };
  Node.prototype.append = function(element) {
    this.insert(element, this.children.length);
  };
  Node.prototype.insertBefore = function(element, other) {
    var i = this.children.indexOf(other);
    if (~i)
      this.insert(element, i);
  };
  Node.prototype.insertAfter = function(element, other) {
    var i = this.children.indexOf(other);
    if (~i)
      this.insert(element, i + 1);
  };
  Node.prototype.remove = function(element) {
    if (element.parent !== this)
      return;
    var i = this.children.indexOf(element);
    if (!~i)
      return;
    element.clearPos();
    element.parent = null;
    this.children.splice(i, 1);
    i = this.screen.clickable.indexOf(element);
    if (~i)
      this.screen.clickable.splice(i, 1);
    i = this.screen.keyable.indexOf(element);
    if (~i)
      this.screen.keyable.splice(i, 1);
    element.emit("reparent", null);
    this.emit("remove", element);
    (function emit(el) {
      var n = el.detached !== true;
      el.detached = true;
      if (n)
        el.emit("detach");
      el.children.forEach(emit);
    })(element);
    if (this.screen.focused === element) {
      this.screen.rewindFocus();
    }
  };
  Node.prototype.detach = function() {
    if (this.parent)
      this.parent.remove(this);
  };
  Node.prototype.free = function() {
    return;
  };
  Node.prototype.destroy = function() {
    this.detach();
    this.forDescendants(function(el) {
      el.free();
      el.destroyed = true;
      el.emit("destroy");
    }, this);
  };
  Node.prototype.forDescendants = function(iter, s) {
    if (s)
      iter(this);
    this.children.forEach(function emit(el) {
      iter(el);
      el.children.forEach(emit);
    });
  };
  Node.prototype.forAncestors = function(iter, s) {
    var el = this;
    if (s)
      iter(this);
    while (el = el.parent) {
      iter(el);
    }
  };
  Node.prototype.collectDescendants = function(s) {
    var out = [];
    this.forDescendants(function(el) {
      out.push(el);
    }, s);
    return out;
  };
  Node.prototype.collectAncestors = function(s) {
    var out = [];
    this.forAncestors(function(el) {
      out.push(el);
    }, s);
    return out;
  };
  Node.prototype.emitDescendants = function() {
    var args2 = Array.prototype.slice(arguments), iter;
    if (typeof args2[args2.length - 1] === "function") {
      iter = args2.pop();
    }
    return this.forDescendants(function(el) {
      if (iter)
        iter(el);
      el.emit.apply(el, args2);
    }, true);
  };
  Node.prototype.emitAncestors = function() {
    var args2 = Array.prototype.slice(arguments), iter;
    if (typeof args2[args2.length - 1] === "function") {
      iter = args2.pop();
    }
    return this.forAncestors(function(el) {
      if (iter)
        iter(el);
      el.emit.apply(el, args2);
    }, true);
  };
  Node.prototype.hasDescendant = function(target) {
    return function find(el) {
      for (var i = 0;i < el.children.length; i++) {
        if (el.children[i] === target) {
          return true;
        }
        if (find(el.children[i]) === true) {
          return true;
        }
      }
      return false;
    }(this);
  };
  Node.prototype.hasAncestor = function(target) {
    var el = this;
    while (el = el.parent) {
      if (el === target)
        return true;
    }
    return false;
  };
  Node.prototype.get = function(name2, value) {
    if (this.data.hasOwnProperty(name2)) {
      return this.data[name2];
    }
    return value;
  };
  Node.prototype.set = function(name2, value) {
    return this.data[name2] = value;
  };
  module2.exports = Node;
});

// ../../node_modules/blessed/lib/widgets/element.js
var require_element = __commonJS((exports2, module2) => {
  var Element = function(options2) {
    var self2 = this;
    if (!(this instanceof Node)) {
      return new Element(options2);
    }
    options2 = options2 || {};
    if (options2.scrollable && !this._ignore && this.type !== "scrollable-box") {
      var ScrollableBox = require_scrollablebox();
      Object.getOwnPropertyNames(ScrollableBox.prototype).forEach(function(key) {
        if (key === "type")
          return;
        Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(ScrollableBox.prototype, key));
      }, this);
      this._ignore = true;
      ScrollableBox.call(this, options2);
      delete this._ignore;
      return this;
    }
    Node.call(this, options2);
    this.name = options2.name;
    options2.position = options2.position || {
      left: options2.left,
      right: options2.right,
      top: options2.top,
      bottom: options2.bottom,
      width: options2.width,
      height: options2.height
    };
    if (options2.position.width === "shrink" || options2.position.height === "shrink") {
      if (options2.position.width === "shrink") {
        delete options2.position.width;
      }
      if (options2.position.height === "shrink") {
        delete options2.position.height;
      }
      options2.shrink = true;
    }
    this.position = options2.position;
    this.noOverflow = options2.noOverflow;
    this.dockBorders = options2.dockBorders;
    this.shadow = options2.shadow;
    this.style = options2.style;
    if (!this.style) {
      this.style = {};
      this.style.fg = options2.fg;
      this.style.bg = options2.bg;
      this.style.bold = options2.bold;
      this.style.underline = options2.underline;
      this.style.blink = options2.blink;
      this.style.inverse = options2.inverse;
      this.style.invisible = options2.invisible;
      this.style.transparent = options2.transparent;
    }
    this.hidden = options2.hidden || false;
    this.fixed = options2.fixed || false;
    this.align = options2.align || "left";
    this.valign = options2.valign || "top";
    this.wrap = options2.wrap !== false;
    this.shrink = options2.shrink;
    this.fixed = options2.fixed;
    this.ch = options2.ch || " ";
    if (typeof options2.padding === "number" || !options2.padding) {
      options2.padding = {
        left: options2.padding,
        top: options2.padding,
        right: options2.padding,
        bottom: options2.padding
      };
    }
    this.padding = {
      left: options2.padding.left || 0,
      top: options2.padding.top || 0,
      right: options2.padding.right || 0,
      bottom: options2.padding.bottom || 0
    };
    this.border = options2.border;
    if (this.border) {
      if (typeof this.border === "string") {
        this.border = { type: this.border };
      }
      this.border.type = this.border.type || "bg";
      if (this.border.type === "ascii")
        this.border.type = "line";
      this.border.ch = this.border.ch || " ";
      this.style.border = this.style.border || this.border.style;
      if (!this.style.border) {
        this.style.border = {};
        this.style.border.fg = this.border.fg;
        this.style.border.bg = this.border.bg;
      }
      if (this.border.left == null)
        this.border.left = true;
      if (this.border.top == null)
        this.border.top = true;
      if (this.border.right == null)
        this.border.right = true;
      if (this.border.bottom == null)
        this.border.bottom = true;
    }
    if (options2.clickable) {
      this.screen._listenMouse(this);
    }
    if (options2.input || options2.keyable) {
      this.screen._listenKeys(this);
    }
    this.parseTags = options2.parseTags || options2.tags;
    this.setContent(options2.content || "", true);
    if (options2.label) {
      this.setLabel(options2.label);
    }
    if (options2.hoverText) {
      this.setHover(options2.hoverText);
    }
    this.on("newListener", function fn(type2) {
      if (type2 === "mouse" || type2 === "click" || type2 === "mouseover" || type2 === "mouseout" || type2 === "mousedown" || type2 === "mouseup" || type2 === "mousewheel" || type2 === "wheeldown" || type2 === "wheelup" || type2 === "mousemove") {
        self2.screen._listenMouse(self2);
      } else if (type2 === "keypress" || type2.indexOf("key ") === 0) {
        self2.screen._listenKeys(self2);
      }
    });
    this.on("resize", function() {
      self2.parseContent();
    });
    this.on("attach", function() {
      self2.parseContent();
    });
    this.on("detach", function() {
      delete self2.lpos;
    });
    if (options2.hoverBg != null) {
      options2.hoverEffects = options2.hoverEffects || {};
      options2.hoverEffects.bg = options2.hoverBg;
    }
    if (this.style.hover) {
      options2.hoverEffects = this.style.hover;
    }
    if (this.style.focus) {
      options2.focusEffects = this.style.focus;
    }
    if (options2.effects) {
      if (options2.effects.hover)
        options2.hoverEffects = options2.effects.hover;
      if (options2.effects.focus)
        options2.focusEffects = options2.effects.focus;
    }
    [
      ["hoverEffects", "mouseover", "mouseout", "_htemp"],
      ["focusEffects", "focus", "blur", "_ftemp"]
    ].forEach(function(props) {
      var pname = props[0], over = props[1], out = props[2], temp = props[3];
      self2.screen.setEffects(self2, self2, over, out, self2.options[pname], temp);
    });
    if (this.options.draggable) {
      this.draggable = true;
    }
    if (options2.focused) {
      this.focus();
    }
  };
  var assert = __require("assert");
  var colors = require_colors();
  var unicode = require_unicode();
  var nextTick = global.setImmediate || process.nextTick.bind(process);
  var helpers = require_helpers2();
  var Node = require_node3();
  Element.prototype.__proto__ = Node.prototype;
  Element.prototype.type = "element";
  Element.prototype.__defineGetter__("focused", function() {
    return this.screen.focused === this;
  });
  Element.prototype.sattr = function(style, fg, bg) {
    var { bold, underline, blink, inverse, invisible } = style;
    if (fg == null && bg == null) {
      fg = style.fg;
      bg = style.bg;
    }
    if (typeof bold === "function")
      bold = bold(this);
    if (typeof underline === "function")
      underline = underline(this);
    if (typeof blink === "function")
      blink = blink(this);
    if (typeof inverse === "function")
      inverse = inverse(this);
    if (typeof invisible === "function")
      invisible = invisible(this);
    if (typeof fg === "function")
      fg = fg(this);
    if (typeof bg === "function")
      bg = bg(this);
    return (invisible ? 16 : 0) << 18 | (inverse ? 8 : 0) << 18 | (blink ? 4 : 0) << 18 | (underline ? 2 : 0) << 18 | (bold ? 1 : 0) << 18 | colors.convert(fg) << 9 | colors.convert(bg);
  };
  Element.prototype.onScreenEvent = function(type2, handler) {
    var listeners = this._slisteners = this._slisteners || [];
    listeners.push({ type: type2, handler });
    this.screen.on(type2, handler);
  };
  Element.prototype.onceScreenEvent = function(type2, handler) {
    var listeners = this._slisteners = this._slisteners || [];
    var entry = { type: type2, handler };
    listeners.push(entry);
    this.screen.once(type2, function() {
      var i = listeners.indexOf(entry);
      if (~i)
        listeners.splice(i, 1);
      return handler.apply(this, arguments);
    });
  };
  Element.prototype.removeScreenEvent = function(type2, handler) {
    var listeners = this._slisteners = this._slisteners || [];
    for (var i = 0;i < listeners.length; i++) {
      var listener = listeners[i];
      if (listener.type === type2 && listener.handler === handler) {
        listeners.splice(i, 1);
        if (this._slisteners.length === 0) {
          delete this._slisteners;
        }
        break;
      }
    }
    this.screen.removeListener(type2, handler);
  };
  Element.prototype.free = function() {
    var listeners = this._slisteners = this._slisteners || [];
    for (var i = 0;i < listeners.length; i++) {
      var listener = listeners[i];
      this.screen.removeListener(listener.type, listener.handler);
    }
    delete this._slisteners;
  };
  Element.prototype.hide = function() {
    if (this.hidden)
      return;
    this.clearPos();
    this.hidden = true;
    this.emit("hide");
    if (this.screen.focused === this) {
      this.screen.rewindFocus();
    }
  };
  Element.prototype.show = function() {
    if (!this.hidden)
      return;
    this.hidden = false;
    this.emit("show");
  };
  Element.prototype.toggle = function() {
    return this.hidden ? this.show() : this.hide();
  };
  Element.prototype.focus = function() {
    return this.screen.focused = this;
  };
  Element.prototype.setContent = function(content, noClear, noTags) {
    if (!noClear)
      this.clearPos();
    this.content = content || "";
    this.parseContent(noTags);
    this.emit("set content");
  };
  Element.prototype.getContent = function() {
    if (!this._clines)
      return "";
    return this._clines.fake.join("\n");
  };
  Element.prototype.setText = function(content, noClear) {
    content = content || "";
    content = content.replace(/\x1b\[[\d;]*m/g, "");
    return this.setContent(content, noClear, true);
  };
  Element.prototype.getText = function() {
    return this.getContent().replace(/\x1b\[[\d;]*m/g, "");
  };
  Element.prototype.parseContent = function(noTags) {
    if (this.detached)
      return false;
    var width = this.width - this.iwidth;
    if (this._clines == null || this._clines.width !== width || this._clines.content !== this.content) {
      var content = this.content;
      content = content.replace(/[\x00-\x08\x0b-\x0c\x0e-\x1a\x1c-\x1f\x7f]/g, "").replace(/\x1b(?!\[[\d;]*m)/g, "").replace(/\r\n|\r/g, "\n").replace(/\t/g, this.screen.tabc);
      if (this.screen.fullUnicode) {
        content = content.replace(unicode.chars.all, "$1\x03");
        if (this.screen.program.isiTerm2) {
          content = content.replace(unicode.chars.combining, "");
        }
      } else {
        content = content.replace(unicode.chars.all, "??");
        content = content.replace(unicode.chars.combining, "");
        content = content.replace(unicode.chars.surrogate, "?");
      }
      if (!noTags) {
        content = this._parseTags(content);
      }
      this._clines = this._wrapContent(content, width);
      this._clines.width = width;
      this._clines.content = this.content;
      this._clines.attr = this._parseAttr(this._clines);
      this._clines.ci = [];
      this._clines.reduce(function(total, line) {
        this._clines.ci.push(total);
        return total + line.length + 1;
      }.bind(this), 0);
      this._pcontent = this._clines.join("\n");
      this.emit("parsed content");
      return true;
    }
    this._clines.attr = this._parseAttr(this._clines) || this._clines.attr;
    return false;
  };
  Element.prototype._parseTags = function(text) {
    if (!this.parseTags)
      return text;
    if (!/{\/?[\w\-,;!#]*}/.test(text))
      return text;
    var program = this.screen.program, out = "", state, bg = [], fg = [], flag = [], cap, slash, param, attr, esc;
    for (;; ) {
      if (!esc && (cap = /^{escape}/.exec(text))) {
        text = text.substring(cap[0].length);
        esc = true;
        continue;
      }
      if (esc && (cap = /^([\s\S]+?){\/escape}/.exec(text))) {
        text = text.substring(cap[0].length);
        out += cap[1];
        esc = false;
        continue;
      }
      if (esc) {
        out += text;
        break;
      }
      if (cap = /^{(\/?)([\w\-,;!#]*)}/.exec(text)) {
        text = text.substring(cap[0].length);
        slash = cap[1] === "/";
        param = cap[2].replace(/-/g, " ");
        if (param === "open") {
          out += "{";
          continue;
        } else if (param === "close") {
          out += "}";
          continue;
        }
        if (param.slice(-3) === " bg")
          state = bg;
        else if (param.slice(-3) === " fg")
          state = fg;
        else
          state = flag;
        if (slash) {
          if (!param) {
            out += program._attr("normal");
            bg.length = 0;
            fg.length = 0;
            flag.length = 0;
          } else {
            attr = program._attr(param, false);
            if (attr == null) {
              out += cap[0];
            } else {
              state.pop();
              if (state.length) {
                out += program._attr(state[state.length - 1]);
              } else {
                out += attr;
              }
            }
          }
        } else {
          if (!param) {
            out += cap[0];
          } else {
            attr = program._attr(param);
            if (attr == null) {
              out += cap[0];
            } else {
              state.push(param);
              out += attr;
            }
          }
        }
        continue;
      }
      if (cap = /^[\s\S]+?(?={\/?[\w\-,;!#]*})/.exec(text)) {
        text = text.substring(cap[0].length);
        out += cap[0];
        continue;
      }
      out += text;
      break;
    }
    return out;
  };
  Element.prototype._parseAttr = function(lines) {
    var dattr = this.sattr(this.style), attr = dattr, attrs = [], line, i, j, c;
    if (lines[0].attr === attr) {
      return;
    }
    for (j = 0;j < lines.length; j++) {
      line = lines[j];
      attrs[j] = attr;
      for (i = 0;i < line.length; i++) {
        if (line[i] === "\x1B") {
          if (c = /^\x1b\[[\d;]*m/.exec(line.substring(i))) {
            attr = this.screen.attrCode(c[0], attr, dattr);
            i += c[0].length - 1;
          }
        }
      }
    }
    return attrs;
  };
  Element.prototype._align = function(line, width, align) {
    if (!align)
      return line;
    var cline = line.replace(/\x1b\[[\d;]*m/g, ""), len = cline.length, s = width - len;
    if (this.shrink) {
      s = 0;
    }
    if (len === 0)
      return line;
    if (s < 0)
      return line;
    if (align === "center") {
      s = Array((s / 2 | 0) + 1).join(" ");
      return s + line + s;
    } else if (align === "right") {
      s = Array(s + 1).join(" ");
      return s + line;
    } else if (this.parseTags && ~line.indexOf("{|}")) {
      var parts = line.split("{|}");
      var cparts = cline.split("{|}");
      s = Math.max(width - cparts[0].length - cparts[1].length, 0);
      s = Array(s + 1).join(" ");
      return parts[0] + s + parts[1];
    }
    return line;
  };
  Element.prototype._wrapContent = function(content, width) {
    var tags = this.parseTags, state = this.align, wrap = this.wrap, margin = 0, rtof = [], ftor = [], out = [], no = 0, line, align, cap, total, i, part, j, lines, rest;
    lines = content.split("\n");
    if (!content) {
      out.push(content);
      out.rtof = [0];
      out.ftor = [[0]];
      out.fake = lines;
      out.real = out;
      out.mwidth = 0;
      return out;
    }
    if (this.scrollbar)
      margin++;
    if (this.type === "textarea")
      margin++;
    if (width > margin)
      width -= margin;
    main:
      for (;no < lines.length; no++) {
        line = lines[no];
        align = state;
        ftor.push([]);
        if (tags) {
          if (cap = /^{(left|center|right)}/.exec(line)) {
            line = line.substring(cap[0].length);
            align = state = cap[1] !== "left" ? cap[1] : null;
          }
          if (cap = /{\/(left|center|right)}$/.exec(line)) {
            line = line.slice(0, -cap[0].length);
            state = this.align;
          }
        }
        while (line.length > width) {
          for (i = 0, total = 0;i < line.length; i++) {
            while (line[i] === "\x1B") {
              while (line[i] && line[i++] !== "m")
                ;
            }
            if (!line[i])
              break;
            if (++total === width) {
              i++;
              if (!wrap) {
                rest = line.substring(i).match(/\x1b\[[^m]*m/g);
                rest = rest ? rest.join("") : "";
                out.push(this._align(line.substring(0, i) + rest, width, align));
                ftor[no].push(out.length - 1);
                rtof.push(no);
                continue main;
              }
              if (!this.screen.fullUnicode) {
                if (i !== line.length) {
                  j = i;
                  while (j > i - 10 && j > 0 && line[--j] !== " ")
                    ;
                  if (line[j] === " ")
                    i = j + 1;
                }
              } else {
                if (i !== line.length) {
                  if (unicode.isSurrogate(line, i))
                    i--;
                  for (var s = 0, n = 0;n < i; n++) {
                    if (unicode.isSurrogate(line, n))
                      s++, n++;
                  }
                  i += s;
                  j = i;
                  while (j > i - 10 && j > 0) {
                    j--;
                    if (line[j] === " " || line[j] === "\x03" || unicode.isSurrogate(line, j - 1) && line[j + 1] !== "\x03" || unicode.isCombining(line, j)) {
                      break;
                    }
                  }
                  if (line[j] === " " || line[j] === "\x03" || unicode.isSurrogate(line, j - 1) && line[j + 1] !== "\x03" || unicode.isCombining(line, j)) {
                    i = j + 1;
                  }
                }
              }
              break;
            }
          }
          part = line.substring(0, i);
          line = line.substring(i);
          out.push(this._align(part, width, align));
          ftor[no].push(out.length - 1);
          rtof.push(no);
          if (line === "")
            continue main;
          if (/^(?:\x1b[\[\d;]*m)+$/.test(line)) {
            out[out.length - 1] += line;
            continue main;
          }
        }
        out.push(this._align(line, width, align));
        ftor[no].push(out.length - 1);
        rtof.push(no);
      }
    out.rtof = rtof;
    out.ftor = ftor;
    out.fake = lines;
    out.real = out;
    out.mwidth = out.reduce(function(current, line2) {
      line2 = line2.replace(/\x1b\[[\d;]*m/g, "");
      return line2.length > current ? line2.length : current;
    }, 0);
    return out;
  };
  Element.prototype.__defineGetter__("visible", function() {
    var el = this;
    do {
      if (el.detached)
        return false;
      if (el.hidden)
        return false;
    } while (el = el.parent);
    return true;
  });
  Element.prototype.__defineGetter__("_detached", function() {
    var el = this;
    do {
      if (el.type === "screen")
        return false;
      if (!el.parent)
        return true;
    } while (el = el.parent);
    return false;
  });
  Element.prototype.enableMouse = function() {
    this.screen._listenMouse(this);
  };
  Element.prototype.enableKeys = function() {
    this.screen._listenKeys(this);
  };
  Element.prototype.enableInput = function() {
    this.screen._listenMouse(this);
    this.screen._listenKeys(this);
  };
  Element.prototype.__defineGetter__("draggable", function() {
    return this._draggable === true;
  });
  Element.prototype.__defineSetter__("draggable", function(draggable) {
    return draggable ? this.enableDrag(draggable) : this.disableDrag();
  });
  Element.prototype.enableDrag = function(verify) {
    var self2 = this;
    if (this._draggable)
      return true;
    if (typeof verify !== "function") {
      verify = function() {
        return true;
      };
    }
    this.enableMouse();
    this.on("mousedown", this._dragMD = function(data) {
      if (self2.screen._dragging)
        return;
      if (!verify(data))
        return;
      self2.screen._dragging = self2;
      self2._drag = {
        x: data.x - self2.aleft,
        y: data.y - self2.atop
      };
      self2.setFront();
    });
    this.onScreenEvent("mouse", this._dragM = function(data) {
      if (self2.screen._dragging !== self2)
        return;
      if (data.action !== "mousedown" && data.action !== "mousemove") {
        delete self2.screen._dragging;
        delete self2._drag;
        return;
      }
      if (!self2.parent)
        return;
      var ox = self2._drag.x, oy = self2._drag.y, px = self2.parent.aleft, py = self2.parent.atop, x = data.x - px - ox, y = data.y - py - oy;
      if (self2.position.right != null) {
        if (self2.position.left != null) {
          self2.width = "100%-" + (self2.parent.width - self2.width);
        }
        self2.position.right = null;
      }
      if (self2.position.bottom != null) {
        if (self2.position.top != null) {
          self2.height = "100%-" + (self2.parent.height - self2.height);
        }
        self2.position.bottom = null;
      }
      self2.rleft = x;
      self2.rtop = y;
      self2.screen.render();
    });
    return this._draggable = true;
  };
  Element.prototype.disableDrag = function() {
    if (!this._draggable)
      return false;
    delete this.screen._dragging;
    delete this._drag;
    this.removeListener("mousedown", this._dragMD);
    this.removeScreenEvent("mouse", this._dragM);
    return this._draggable = false;
  };
  Element.prototype.key = function() {
    return this.screen.program.key.apply(this, arguments);
  };
  Element.prototype.onceKey = function() {
    return this.screen.program.onceKey.apply(this, arguments);
  };
  Element.prototype.unkey = Element.prototype.removeKey = function() {
    return this.screen.program.unkey.apply(this, arguments);
  };
  Element.prototype.setIndex = function(index) {
    if (!this.parent)
      return;
    if (index < 0) {
      index = this.parent.children.length + index;
    }
    index = Math.max(index, 0);
    index = Math.min(index, this.parent.children.length - 1);
    var i = this.parent.children.indexOf(this);
    if (!~i)
      return;
    var item = this.parent.children.splice(i, 1)[0];
    this.parent.children.splice(index, 0, item);
  };
  Element.prototype.setFront = function() {
    return this.setIndex(-1);
  };
  Element.prototype.setBack = function() {
    return this.setIndex(0);
  };
  Element.prototype.clearPos = function(get, override) {
    if (this.detached)
      return;
    var lpos = this._getCoords(get);
    if (!lpos)
      return;
    this.screen.clearRegion(lpos.xi, lpos.xl, lpos.yi, lpos.yl, override);
  };
  Element.prototype.setLabel = function(options2) {
    var self2 = this;
    var Box = require_box();
    if (typeof options2 === "string") {
      options2 = { text: options2 };
    }
    if (this._label) {
      this._label.setContent(options2.text);
      if (options2.side !== "right") {
        this._label.rleft = 2 + (this.border ? -1 : 0);
        this._label.position.right = undefined;
        if (!this.screen.autoPadding) {
          this._label.rleft = 2;
        }
      } else {
        this._label.rright = 2 + (this.border ? -1 : 0);
        this._label.position.left = undefined;
        if (!this.screen.autoPadding) {
          this._label.rright = 2;
        }
      }
      return;
    }
    this._label = new Box({
      screen: this.screen,
      parent: this,
      content: options2.text,
      top: -this.itop,
      tags: this.parseTags,
      shrink: true,
      style: this.style.label
    });
    if (options2.side !== "right") {
      this._label.rleft = 2 - this.ileft;
    } else {
      this._label.rright = 2 - this.iright;
    }
    this._label._isLabel = true;
    if (!this.screen.autoPadding) {
      if (options2.side !== "right") {
        this._label.rleft = 2;
      } else {
        this._label.rright = 2;
      }
      this._label.rtop = 0;
    }
    var reposition = function() {
      self2._label.rtop = (self2.childBase || 0) - self2.itop;
      if (!self2.screen.autoPadding) {
        self2._label.rtop = self2.childBase || 0;
      }
      self2.screen.render();
    };
    this.on("scroll", this._labelScroll = function() {
      reposition();
    });
    this.on("resize", this._labelResize = function() {
      nextTick(function() {
        reposition();
      });
    });
  };
  Element.prototype.removeLabel = function() {
    if (!this._label)
      return;
    this.removeListener("scroll", this._labelScroll);
    this.removeListener("resize", this._labelResize);
    this._label.detach();
    delete this._labelScroll;
    delete this._labelResize;
    delete this._label;
  };
  Element.prototype.setHover = function(options2) {
    if (typeof options2 === "string") {
      options2 = { text: options2 };
    }
    this._hoverOptions = options2;
    this.enableMouse();
    this.screen._initHover();
  };
  Element.prototype.removeHover = function() {
    delete this._hoverOptions;
    if (!this.screen._hoverText || this.screen._hoverText.detached)
      return;
    this.screen._hoverText.detach();
    this.screen.render();
  };
  Element.prototype._getPos = function() {
    var pos = this.lpos;
    assert.ok(pos);
    if (pos.aleft != null)
      return pos;
    pos.aleft = pos.xi;
    pos.atop = pos.yi;
    pos.aright = this.screen.cols - pos.xl;
    pos.abottom = this.screen.rows - pos.yl;
    pos.width = pos.xl - pos.xi;
    pos.height = pos.yl - pos.yi;
    return pos;
  };
  Element.prototype._getWidth = function(get) {
    var parent = get ? this.parent._getPos() : this.parent, width = this.position.width, left, expr;
    if (typeof width === "string") {
      if (width === "half")
        width = "50%";
      expr = width.split(/(?=\+|-)/);
      width = expr[0];
      width = +width.slice(0, -1) / 100;
      width = parent.width * width | 0;
      width += +(expr[1] || 0);
      return width;
    }
    if (width == null) {
      left = this.position.left || 0;
      if (typeof left === "string") {
        if (left === "center")
          left = "50%";
        expr = left.split(/(?=\+|-)/);
        left = expr[0];
        left = +left.slice(0, -1) / 100;
        left = parent.width * left | 0;
        left += +(expr[1] || 0);
      }
      width = parent.width - (this.position.right || 0) - left;
      if (this.screen.autoPadding) {
        if ((this.position.left != null || this.position.right == null) && this.position.left !== "center") {
          width -= this.parent.ileft;
        }
        width -= this.parent.iright;
      }
    }
    return width;
  };
  Element.prototype.__defineGetter__("width", function() {
    return this._getWidth(false);
  });
  Element.prototype._getHeight = function(get) {
    var parent = get ? this.parent._getPos() : this.parent, height = this.position.height, top, expr;
    if (typeof height === "string") {
      if (height === "half")
        height = "50%";
      expr = height.split(/(?=\+|-)/);
      height = expr[0];
      height = +height.slice(0, -1) / 100;
      height = parent.height * height | 0;
      height += +(expr[1] || 0);
      return height;
    }
    if (height == null) {
      top = this.position.top || 0;
      if (typeof top === "string") {
        if (top === "center")
          top = "50%";
        expr = top.split(/(?=\+|-)/);
        top = expr[0];
        top = +top.slice(0, -1) / 100;
        top = parent.height * top | 0;
        top += +(expr[1] || 0);
      }
      height = parent.height - (this.position.bottom || 0) - top;
      if (this.screen.autoPadding) {
        if ((this.position.top != null || this.position.bottom == null) && this.position.top !== "center") {
          height -= this.parent.itop;
        }
        height -= this.parent.ibottom;
      }
    }
    return height;
  };
  Element.prototype.__defineGetter__("height", function() {
    return this._getHeight(false);
  });
  Element.prototype._getLeft = function(get) {
    var parent = get ? this.parent._getPos() : this.parent, left = this.position.left || 0, expr;
    if (typeof left === "string") {
      if (left === "center")
        left = "50%";
      expr = left.split(/(?=\+|-)/);
      left = expr[0];
      left = +left.slice(0, -1) / 100;
      left = parent.width * left | 0;
      left += +(expr[1] || 0);
      if (this.position.left === "center") {
        left -= this._getWidth(get) / 2 | 0;
      }
    }
    if (this.position.left == null && this.position.right != null) {
      return this.screen.cols - this._getWidth(get) - this._getRight(get);
    }
    if (this.screen.autoPadding) {
      if ((this.position.left != null || this.position.right == null) && this.position.left !== "center") {
        left += this.parent.ileft;
      }
    }
    return (parent.aleft || 0) + left;
  };
  Element.prototype.__defineGetter__("aleft", function() {
    return this._getLeft(false);
  });
  Element.prototype._getRight = function(get) {
    var parent = get ? this.parent._getPos() : this.parent, right;
    if (this.position.right == null && this.position.left != null) {
      right = this.screen.cols - (this._getLeft(get) + this._getWidth(get));
      if (this.screen.autoPadding) {
        right += this.parent.iright;
      }
      return right;
    }
    right = (parent.aright || 0) + (this.position.right || 0);
    if (this.screen.autoPadding) {
      right += this.parent.iright;
    }
    return right;
  };
  Element.prototype.__defineGetter__("aright", function() {
    return this._getRight(false);
  });
  Element.prototype._getTop = function(get) {
    var parent = get ? this.parent._getPos() : this.parent, top = this.position.top || 0, expr;
    if (typeof top === "string") {
      if (top === "center")
        top = "50%";
      expr = top.split(/(?=\+|-)/);
      top = expr[0];
      top = +top.slice(0, -1) / 100;
      top = parent.height * top | 0;
      top += +(expr[1] || 0);
      if (this.position.top === "center") {
        top -= this._getHeight(get) / 2 | 0;
      }
    }
    if (this.position.top == null && this.position.bottom != null) {
      return this.screen.rows - this._getHeight(get) - this._getBottom(get);
    }
    if (this.screen.autoPadding) {
      if ((this.position.top != null || this.position.bottom == null) && this.position.top !== "center") {
        top += this.parent.itop;
      }
    }
    return (parent.atop || 0) + top;
  };
  Element.prototype.__defineGetter__("atop", function() {
    return this._getTop(false);
  });
  Element.prototype._getBottom = function(get) {
    var parent = get ? this.parent._getPos() : this.parent, bottom;
    if (this.position.bottom == null && this.position.top != null) {
      bottom = this.screen.rows - (this._getTop(get) + this._getHeight(get));
      if (this.screen.autoPadding) {
        bottom += this.parent.ibottom;
      }
      return bottom;
    }
    bottom = (parent.abottom || 0) + (this.position.bottom || 0);
    if (this.screen.autoPadding) {
      bottom += this.parent.ibottom;
    }
    return bottom;
  };
  Element.prototype.__defineGetter__("abottom", function() {
    return this._getBottom(false);
  });
  Element.prototype.__defineGetter__("rleft", function() {
    return this.aleft - this.parent.aleft;
  });
  Element.prototype.__defineGetter__("rright", function() {
    return this.aright - this.parent.aright;
  });
  Element.prototype.__defineGetter__("rtop", function() {
    return this.atop - this.parent.atop;
  });
  Element.prototype.__defineGetter__("rbottom", function() {
    return this.abottom - this.parent.abottom;
  });
  Element.prototype.__defineSetter__("width", function(val) {
    if (this.position.width === val)
      return;
    if (/^\d+$/.test(val))
      val = +val;
    this.emit("resize");
    this.clearPos();
    return this.position.width = val;
  });
  Element.prototype.__defineSetter__("height", function(val) {
    if (this.position.height === val)
      return;
    if (/^\d+$/.test(val))
      val = +val;
    this.emit("resize");
    this.clearPos();
    return this.position.height = val;
  });
  Element.prototype.__defineSetter__("aleft", function(val) {
    var expr;
    if (typeof val === "string") {
      if (val === "center") {
        val = this.screen.width / 2 | 0;
        val -= this.width / 2 | 0;
      } else {
        expr = val.split(/(?=\+|-)/);
        val = expr[0];
        val = +val.slice(0, -1) / 100;
        val = this.screen.width * val | 0;
        val += +(expr[1] || 0);
      }
    }
    val -= this.parent.aleft;
    if (this.position.left === val)
      return;
    this.emit("move");
    this.clearPos();
    return this.position.left = val;
  });
  Element.prototype.__defineSetter__("aright", function(val) {
    val -= this.parent.aright;
    if (this.position.right === val)
      return;
    this.emit("move");
    this.clearPos();
    return this.position.right = val;
  });
  Element.prototype.__defineSetter__("atop", function(val) {
    var expr;
    if (typeof val === "string") {
      if (val === "center") {
        val = this.screen.height / 2 | 0;
        val -= this.height / 2 | 0;
      } else {
        expr = val.split(/(?=\+|-)/);
        val = expr[0];
        val = +val.slice(0, -1) / 100;
        val = this.screen.height * val | 0;
        val += +(expr[1] || 0);
      }
    }
    val -= this.parent.atop;
    if (this.position.top === val)
      return;
    this.emit("move");
    this.clearPos();
    return this.position.top = val;
  });
  Element.prototype.__defineSetter__("abottom", function(val) {
    val -= this.parent.abottom;
    if (this.position.bottom === val)
      return;
    this.emit("move");
    this.clearPos();
    return this.position.bottom = val;
  });
  Element.prototype.__defineSetter__("rleft", function(val) {
    if (this.position.left === val)
      return;
    if (/^\d+$/.test(val))
      val = +val;
    this.emit("move");
    this.clearPos();
    return this.position.left = val;
  });
  Element.prototype.__defineSetter__("rright", function(val) {
    if (this.position.right === val)
      return;
    this.emit("move");
    this.clearPos();
    return this.position.right = val;
  });
  Element.prototype.__defineSetter__("rtop", function(val) {
    if (this.position.top === val)
      return;
    if (/^\d+$/.test(val))
      val = +val;
    this.emit("move");
    this.clearPos();
    return this.position.top = val;
  });
  Element.prototype.__defineSetter__("rbottom", function(val) {
    if (this.position.bottom === val)
      return;
    this.emit("move");
    this.clearPos();
    return this.position.bottom = val;
  });
  Element.prototype.__defineGetter__("ileft", function() {
    return (this.border ? 1 : 0) + this.padding.left;
  });
  Element.prototype.__defineGetter__("itop", function() {
    return (this.border ? 1 : 0) + this.padding.top;
  });
  Element.prototype.__defineGetter__("iright", function() {
    return (this.border ? 1 : 0) + this.padding.right;
  });
  Element.prototype.__defineGetter__("ibottom", function() {
    return (this.border ? 1 : 0) + this.padding.bottom;
  });
  Element.prototype.__defineGetter__("iwidth", function() {
    return (this.border ? 2 : 0) + this.padding.left + this.padding.right;
  });
  Element.prototype.__defineGetter__("iheight", function() {
    return (this.border ? 2 : 0) + this.padding.top + this.padding.bottom;
  });
  Element.prototype.__defineGetter__("tpadding", function() {
    return this.padding.left + this.padding.top + this.padding.right + this.padding.bottom;
  });
  Element.prototype.__defineGetter__("left", function() {
    return this.rleft;
  });
  Element.prototype.__defineGetter__("right", function() {
    return this.rright;
  });
  Element.prototype.__defineGetter__("top", function() {
    return this.rtop;
  });
  Element.prototype.__defineGetter__("bottom", function() {
    return this.rbottom;
  });
  Element.prototype.__defineSetter__("left", function(val) {
    return this.rleft = val;
  });
  Element.prototype.__defineSetter__("right", function(val) {
    return this.rright = val;
  });
  Element.prototype.__defineSetter__("top", function(val) {
    return this.rtop = val;
  });
  Element.prototype.__defineSetter__("bottom", function(val) {
    return this.rbottom = val;
  });
  Element.prototype._getShrinkBox = function(xi, xl, yi, yl, get) {
    if (!this.children.length) {
      return { xi, xl: xi + 1, yi, yl: yi + 1 };
    }
    var i, el, ret, mxi = xi, mxl = xi + 1, myi = yi, myl = yi + 1;
    var _lpos;
    if (get) {
      _lpos = this.lpos;
      this.lpos = { xi, xl, yi, yl };
    }
    for (i = 0;i < this.children.length; i++) {
      el = this.children[i];
      ret = el._getCoords(get);
      if (!ret)
        continue;
      if (el.position.left == null && el.position.right != null) {
        ret.xl = xi + (ret.xl - ret.xi);
        ret.xi = xi;
        if (this.screen.autoPadding) {
          ret.xl += this.ileft;
          ret.xi += this.ileft;
        }
      }
      if (el.position.top == null && el.position.bottom != null) {
        ret.yl = yi + (ret.yl - ret.yi);
        ret.yi = yi;
        if (this.screen.autoPadding) {
          ret.yl += this.itop;
          ret.yi += this.itop;
        }
      }
      if (ret.xi < mxi)
        mxi = ret.xi;
      if (ret.xl > mxl)
        mxl = ret.xl;
      if (ret.yi < myi)
        myi = ret.yi;
      if (ret.yl > myl)
        myl = ret.yl;
    }
    if (get) {
      this.lpos = _lpos;
    }
    if (this.position.width == null && (this.position.left == null || this.position.right == null)) {
      if (this.position.left == null && this.position.right != null) {
        xi = xl - (mxl - mxi);
        if (!this.screen.autoPadding) {
          xi -= this.padding.left + this.padding.right;
        } else {
          xi -= this.ileft;
        }
      } else {
        xl = mxl;
        if (!this.screen.autoPadding) {
          xl += this.padding.left + this.padding.right;
          if (this.type === "list-table") {
            xl -= this.padding.left + this.padding.right;
            xl += this.iright;
          }
        } else {
          xl += this.iright;
        }
      }
    }
    if (this.position.height == null && (this.position.top == null || this.position.bottom == null) && (!this.scrollable || this._isList)) {
      if (this._isList) {
        myi = 0 - this.itop;
        myl = this.items.length + this.ibottom;
      }
      if (this.position.top == null && this.position.bottom != null) {
        yi = yl - (myl - myi);
        if (!this.screen.autoPadding) {
          yi -= this.padding.top + this.padding.bottom;
        } else {
          yi -= this.itop;
        }
      } else {
        yl = myl;
        if (!this.screen.autoPadding) {
          yl += this.padding.top + this.padding.bottom;
        } else {
          yl += this.ibottom;
        }
      }
    }
    return { xi, xl, yi, yl };
  };
  Element.prototype._getShrinkContent = function(xi, xl, yi, yl) {
    var h = this._clines.length, w = this._clines.mwidth || 1;
    if (this.position.width == null && (this.position.left == null || this.position.right == null)) {
      if (this.position.left == null && this.position.right != null) {
        xi = xl - w - this.iwidth;
      } else {
        xl = xi + w + this.iwidth;
      }
    }
    if (this.position.height == null && (this.position.top == null || this.position.bottom == null) && (!this.scrollable || this._isList)) {
      if (this.position.top == null && this.position.bottom != null) {
        yi = yl - h - this.iheight;
      } else {
        yl = yi + h + this.iheight;
      }
    }
    return { xi, xl, yi, yl };
  };
  Element.prototype._getShrink = function(xi, xl, yi, yl, get) {
    var shrinkBox = this._getShrinkBox(xi, xl, yi, yl, get), shrinkContent = this._getShrinkContent(xi, xl, yi, yl, get), xll = xl, yll = yl;
    if (shrinkBox.xl - shrinkBox.xi > shrinkContent.xl - shrinkContent.xi) {
      xi = shrinkBox.xi;
      xl = shrinkBox.xl;
    } else {
      xi = shrinkContent.xi;
      xl = shrinkContent.xl;
    }
    if (shrinkBox.yl - shrinkBox.yi > shrinkContent.yl - shrinkContent.yi) {
      yi = shrinkBox.yi;
      yl = shrinkBox.yl;
    } else {
      yi = shrinkContent.yi;
      yl = shrinkContent.yl;
    }
    if (xl < xll && this.position.left === "center") {
      xll = (xll - xl) / 2 | 0;
      xi += xll;
      xl += xll;
    }
    if (yl < yll && this.position.top === "center") {
      yll = (yll - yl) / 2 | 0;
      yi += yll;
      yl += yll;
    }
    return { xi, xl, yi, yl };
  };
  Element.prototype._getCoords = function(get, noscroll) {
    if (this.hidden)
      return;
    var xi = this._getLeft(get), xl = xi + this._getWidth(get), yi = this._getTop(get), yl = yi + this._getHeight(get), base = this.childBase || 0, el = this, fixed = this.fixed, coords, v, noleft, noright, notop, nobot, ppos, b;
    if (this.shrink) {
      coords = this._getShrink(xi, xl, yi, yl, get);
      xi = coords.xi, xl = coords.xl;
      yi = coords.yi, yl = coords.yl;
    }
    while (el = el.parent) {
      if (el.scrollable) {
        if (fixed) {
          fixed = false;
          continue;
        }
        break;
      }
    }
    var thisparent = el;
    if (el && !noscroll) {
      ppos = thisparent.lpos;
      if (!ppos)
        return;
      yi -= ppos.base;
      yl -= ppos.base;
      b = thisparent.border ? 1 : 0;
      if (this._isLabel) {
        b = 0;
      }
      if (yi < ppos.yi + b) {
        if (yl - 1 < ppos.yi + b) {
          return;
        } else {
          notop = true;
          v = ppos.yi - yi;
          if (this.border)
            v--;
          if (thisparent.border)
            v++;
          base += v;
          yi += v;
        }
      } else if (yl > ppos.yl - b) {
        if (yi > ppos.yl - 1 - b) {
          return;
        } else {
          nobot = true;
          v = yl - ppos.yl;
          if (this.border)
            v--;
          if (thisparent.border)
            v++;
          yl -= v;
        }
      }
      if (yi >= yl)
        return;
      if (xi < el.lpos.xi) {
        xi = el.lpos.xi;
        noleft = true;
        if (this.border)
          xi--;
        if (thisparent.border)
          xi++;
      }
      if (xl > el.lpos.xl) {
        xl = el.lpos.xl;
        noright = true;
        if (this.border)
          xl++;
        if (thisparent.border)
          xl--;
      }
      if (xi >= xl)
        return;
    }
    if (this.noOverflow && this.parent.lpos) {
      if (xi < this.parent.lpos.xi + this.parent.ileft) {
        xi = this.parent.lpos.xi + this.parent.ileft;
      }
      if (xl > this.parent.lpos.xl - this.parent.iright) {
        xl = this.parent.lpos.xl - this.parent.iright;
      }
      if (yi < this.parent.lpos.yi + this.parent.itop) {
        yi = this.parent.lpos.yi + this.parent.itop;
      }
      if (yl > this.parent.lpos.yl - this.parent.ibottom) {
        yl = this.parent.lpos.yl - this.parent.ibottom;
      }
    }
    return {
      xi,
      xl,
      yi,
      yl,
      base,
      noleft,
      noright,
      notop,
      nobot,
      renders: this.screen.renders
    };
  };
  Element.prototype.render = function() {
    this._emit("prerender");
    this.parseContent();
    var coords = this._getCoords(true);
    if (!coords) {
      delete this.lpos;
      return;
    }
    if (coords.xl - coords.xi <= 0) {
      coords.xl = Math.max(coords.xl, coords.xi);
      return;
    }
    if (coords.yl - coords.yi <= 0) {
      coords.yl = Math.max(coords.yl, coords.yi);
      return;
    }
    var lines = this.screen.lines, xi = coords.xi, xl = coords.xl, yi = coords.yi, yl = coords.yl, x, y, cell, attr, ch, content = this._pcontent, ci = this._clines.ci[coords.base], battr, dattr, c, visible, i, bch = this.ch;
    if (coords.base >= this._clines.ci.length) {
      ci = this._pcontent.length;
    }
    this.lpos = coords;
    if (this.border && this.border.type === "line") {
      this.screen._borderStops[coords.yi] = true;
      this.screen._borderStops[coords.yl - 1] = true;
    }
    dattr = this.sattr(this.style);
    attr = dattr;
    if (ci > 0) {
      attr = this._clines.attr[Math.min(coords.base, this._clines.length - 1)];
    }
    if (this.border)
      xi++, xl--, yi++, yl--;
    if (this.tpadding || this.valign && this.valign !== "top") {
      if (this.style.transparent) {
        for (y = Math.max(yi, 0);y < yl; y++) {
          if (!lines[y])
            break;
          for (x = Math.max(xi, 0);x < xl; x++) {
            if (!lines[y][x])
              break;
            lines[y][x][0] = colors.blend(attr, lines[y][x][0]);
            lines[y].dirty = true;
          }
        }
      } else {
        this.screen.fillRegion(dattr, bch, xi, xl, yi, yl);
      }
    }
    if (this.tpadding) {
      xi += this.padding.left, xl -= this.padding.right;
      yi += this.padding.top, yl -= this.padding.bottom;
    }
    if (this.valign === "middle" || this.valign === "bottom") {
      visible = yl - yi;
      if (this._clines.length < visible) {
        if (this.valign === "middle") {
          visible = visible / 2 | 0;
          visible -= this._clines.length / 2 | 0;
        } else if (this.valign === "bottom") {
          visible -= this._clines.length;
        }
        ci -= visible * (xl - xi);
      }
    }
    for (y = yi;y < yl; y++) {
      if (!lines[y]) {
        if (y >= this.screen.height || yl < this.ibottom) {
          break;
        } else {
          continue;
        }
      }
      for (x = xi;x < xl; x++) {
        cell = lines[y][x];
        if (!cell) {
          if (x >= this.screen.width || xl < this.iright) {
            break;
          } else {
            continue;
          }
        }
        ch = content[ci++] || bch;
        while (ch === "\x1B") {
          if (c = /^\x1b\[[\d;]*m/.exec(content.substring(ci - 1))) {
            ci += c[0].length - 1;
            attr = this.screen.attrCode(c[0], attr, dattr);
            if (this.parent._isList && this.parent.interactive && this.parent.items[this.parent.selected] === this && this.parent.options.invertSelected !== false) {
              attr = attr & ~(511 << 9) | dattr & 511 << 9;
            }
            ch = content[ci] || bch;
            ci++;
          } else {
            break;
          }
        }
        if (ch === "\t")
          ch = bch;
        if (ch === "\n") {
          if (x === xi && y !== yi && content[ci - 2] !== "\n") {
            x--;
            continue;
          }
          ch = bch;
          for (;x < xl; x++) {
            cell = lines[y][x];
            if (!cell)
              break;
            if (this.style.transparent) {
              lines[y][x][0] = colors.blend(attr, lines[y][x][0]);
              if (content[ci])
                lines[y][x][1] = ch;
              lines[y].dirty = true;
            } else {
              if (attr !== cell[0] || ch !== cell[1]) {
                lines[y][x][0] = attr;
                lines[y][x][1] = ch;
                lines[y].dirty = true;
              }
            }
          }
          continue;
        }
        if (this.screen.fullUnicode && content[ci - 1]) {
          var point = unicode.codePointAt(content, ci - 1);
          if (unicode.combining[point]) {
            if (point > 65535) {
              ch = content[ci - 1] + content[ci];
              ci++;
            }
            if (x - 1 >= xi) {
              lines[y][x - 1][1] += ch;
            } else if (y - 1 >= yi) {
              lines[y - 1][xl - 1][1] += ch;
            }
            x--;
            continue;
          }
          if (point > 65535) {
            ch = content[ci - 1] + content[ci];
            ci++;
          }
        }
        if (this._noFill)
          continue;
        if (this.style.transparent) {
          lines[y][x][0] = colors.blend(attr, lines[y][x][0]);
          if (content[ci])
            lines[y][x][1] = ch;
          lines[y].dirty = true;
        } else {
          if (attr !== cell[0] || ch !== cell[1]) {
            lines[y][x][0] = attr;
            lines[y][x][1] = ch;
            lines[y].dirty = true;
          }
        }
      }
    }
    if (this.scrollbar) {
      i = Math.max(this._clines.length, this._scrollBottom());
    }
    if (coords.notop || coords.nobot)
      i = -Infinity;
    if (this.scrollbar && yl - yi < i) {
      x = xl - 1;
      if (this.scrollbar.ignoreBorder && this.border)
        x++;
      if (this.alwaysScroll) {
        y = this.childBase / (i - (yl - yi));
      } else {
        y = (this.childBase + this.childOffset) / (i - 1);
      }
      y = yi + ((yl - yi) * y | 0);
      if (y >= yl)
        y = yl - 1;
      cell = lines[y] && lines[y][x];
      if (cell) {
        if (this.track) {
          ch = this.track.ch || " ";
          attr = this.sattr(this.style.track, this.style.track.fg || this.style.fg, this.style.track.bg || this.style.bg);
          this.screen.fillRegion(attr, ch, x, x + 1, yi, yl);
        }
        ch = this.scrollbar.ch || " ";
        attr = this.sattr(this.style.scrollbar, this.style.scrollbar.fg || this.style.fg, this.style.scrollbar.bg || this.style.bg);
        if (attr !== cell[0] || ch !== cell[1]) {
          lines[y][x][0] = attr;
          lines[y][x][1] = ch;
          lines[y].dirty = true;
        }
      }
    }
    if (this.border)
      xi--, xl++, yi--, yl++;
    if (this.tpadding) {
      xi -= this.padding.left, xl += this.padding.right;
      yi -= this.padding.top, yl += this.padding.bottom;
    }
    if (this.border) {
      battr = this.sattr(this.style.border);
      y = yi;
      if (coords.notop)
        y = -1;
      for (x = xi;x < xl; x++) {
        if (!lines[y])
          break;
        if (coords.noleft && x === xi)
          continue;
        if (coords.noright && x === xl - 1)
          continue;
        cell = lines[y][x];
        if (!cell)
          continue;
        if (this.border.type === "line") {
          if (x === xi) {
            ch = "\u250C";
            if (!this.border.left) {
              if (this.border.top) {
                ch = "\u2500";
              } else {
                continue;
              }
            } else {
              if (!this.border.top) {
                ch = "\u2502";
              }
            }
          } else if (x === xl - 1) {
            ch = "\u2510";
            if (!this.border.right) {
              if (this.border.top) {
                ch = "\u2500";
              } else {
                continue;
              }
            } else {
              if (!this.border.top) {
                ch = "\u2502";
              }
            }
          } else {
            ch = "\u2500";
          }
        } else if (this.border.type === "bg") {
          ch = this.border.ch;
        }
        if (!this.border.top && x !== xi && x !== xl - 1) {
          ch = " ";
          if (dattr !== cell[0] || ch !== cell[1]) {
            lines[y][x][0] = dattr;
            lines[y][x][1] = ch;
            lines[y].dirty = true;
            continue;
          }
        }
        if (battr !== cell[0] || ch !== cell[1]) {
          lines[y][x][0] = battr;
          lines[y][x][1] = ch;
          lines[y].dirty = true;
        }
      }
      y = yi + 1;
      for (;y < yl - 1; y++) {
        if (!lines[y])
          continue;
        cell = lines[y][xi];
        if (cell) {
          if (this.border.left) {
            if (this.border.type === "line") {
              ch = "\u2502";
            } else if (this.border.type === "bg") {
              ch = this.border.ch;
            }
            if (!coords.noleft) {
              if (battr !== cell[0] || ch !== cell[1]) {
                lines[y][xi][0] = battr;
                lines[y][xi][1] = ch;
                lines[y].dirty = true;
              }
            }
          } else {
            ch = " ";
            if (dattr !== cell[0] || ch !== cell[1]) {
              lines[y][xi][0] = dattr;
              lines[y][xi][1] = ch;
              lines[y].dirty = true;
            }
          }
        }
        cell = lines[y][xl - 1];
        if (cell) {
          if (this.border.right) {
            if (this.border.type === "line") {
              ch = "\u2502";
            } else if (this.border.type === "bg") {
              ch = this.border.ch;
            }
            if (!coords.noright) {
              if (battr !== cell[0] || ch !== cell[1]) {
                lines[y][xl - 1][0] = battr;
                lines[y][xl - 1][1] = ch;
                lines[y].dirty = true;
              }
            }
          } else {
            ch = " ";
            if (dattr !== cell[0] || ch !== cell[1]) {
              lines[y][xl - 1][0] = dattr;
              lines[y][xl - 1][1] = ch;
              lines[y].dirty = true;
            }
          }
        }
      }
      y = yl - 1;
      if (coords.nobot)
        y = -1;
      for (x = xi;x < xl; x++) {
        if (!lines[y])
          break;
        if (coords.noleft && x === xi)
          continue;
        if (coords.noright && x === xl - 1)
          continue;
        cell = lines[y][x];
        if (!cell)
          continue;
        if (this.border.type === "line") {
          if (x === xi) {
            ch = "\u2514";
            if (!this.border.left) {
              if (this.border.bottom) {
                ch = "\u2500";
              } else {
                continue;
              }
            } else {
              if (!this.border.bottom) {
                ch = "\u2502";
              }
            }
          } else if (x === xl - 1) {
            ch = "\u2518";
            if (!this.border.right) {
              if (this.border.bottom) {
                ch = "\u2500";
              } else {
                continue;
              }
            } else {
              if (!this.border.bottom) {
                ch = "\u2502";
              }
            }
          } else {
            ch = "\u2500";
          }
        } else if (this.border.type === "bg") {
          ch = this.border.ch;
        }
        if (!this.border.bottom && x !== xi && x !== xl - 1) {
          ch = " ";
          if (dattr !== cell[0] || ch !== cell[1]) {
            lines[y][x][0] = dattr;
            lines[y][x][1] = ch;
            lines[y].dirty = true;
          }
          continue;
        }
        if (battr !== cell[0] || ch !== cell[1]) {
          lines[y][x][0] = battr;
          lines[y][x][1] = ch;
          lines[y].dirty = true;
        }
      }
    }
    if (this.shadow) {
      y = Math.max(yi + 1, 0);
      for (;y < yl + 1; y++) {
        if (!lines[y])
          break;
        x = xl;
        for (;x < xl + 2; x++) {
          if (!lines[y][x])
            break;
          lines[y][x][0] = colors.blend(lines[y][x][0]);
          lines[y].dirty = true;
        }
      }
      y = yl;
      for (;y < yl + 1; y++) {
        if (!lines[y])
          break;
        for (x = Math.max(xi + 1, 0);x < xl; x++) {
          if (!lines[y][x])
            break;
          lines[y][x][0] = colors.blend(lines[y][x][0]);
          lines[y].dirty = true;
        }
      }
    }
    this.children.forEach(function(el) {
      if (el.screen._ci !== -1) {
        el.index = el.screen._ci++;
      }
      el.render();
    });
    this._emit("render", [coords]);
    return coords;
  };
  Element.prototype._render = Element.prototype.render;
  Element.prototype.insertLine = function(i, line) {
    if (typeof line === "string")
      line = line.split("\n");
    if (i !== i || i == null) {
      i = this._clines.ftor.length;
    }
    i = Math.max(i, 0);
    while (this._clines.fake.length < i) {
      this._clines.fake.push("");
      this._clines.ftor.push([this._clines.push("") - 1]);
      this._clines.rtof(this._clines.fake.length - 1);
    }
    var start = this._clines.length, diff, real;
    if (i >= this._clines.ftor.length) {
      real = this._clines.ftor[this._clines.ftor.length - 1];
      real = real[real.length - 1] + 1;
    } else {
      real = this._clines.ftor[i][0];
    }
    for (var j = 0;j < line.length; j++) {
      this._clines.fake.splice(i + j, 0, line[j]);
    }
    this.setContent(this._clines.fake.join("\n"), true);
    diff = this._clines.length - start;
    if (diff > 0) {
      var pos = this._getCoords();
      if (!pos)
        return;
      var height = pos.yl - pos.yi - this.iheight, base = this.childBase || 0, visible = real >= base && real - base < height;
      if (pos && visible && this.screen.cleanSides(this)) {
        this.screen.insertLine(diff, pos.yi + this.itop + real - base, pos.yi, pos.yl - this.ibottom - 1);
      }
    }
  };
  Element.prototype.deleteLine = function(i, n) {
    n = n || 1;
    if (i !== i || i == null) {
      i = this._clines.ftor.length - 1;
    }
    i = Math.max(i, 0);
    i = Math.min(i, this._clines.ftor.length - 1);
    var start = this._clines.length, diff, real = this._clines.ftor[i][0];
    while (n--) {
      this._clines.fake.splice(i, 1);
    }
    this.setContent(this._clines.fake.join("\n"), true);
    diff = start - this._clines.length;
    var height = 0;
    if (diff > 0) {
      var pos = this._getCoords();
      if (!pos)
        return;
      height = pos.yl - pos.yi - this.iheight;
      var base = this.childBase || 0, visible = real >= base && real - base < height;
      if (pos && visible && this.screen.cleanSides(this)) {
        this.screen.deleteLine(diff, pos.yi + this.itop + real - base, pos.yi, pos.yl - this.ibottom - 1);
      }
    }
    if (this._clines.length < height) {
      this.clearPos();
    }
  };
  Element.prototype.insertTop = function(line) {
    var fake = this._clines.rtof[this.childBase || 0];
    return this.insertLine(fake, line);
  };
  Element.prototype.insertBottom = function(line) {
    var h = (this.childBase || 0) + this.height - this.iheight, i = Math.min(h, this._clines.length), fake = this._clines.rtof[i - 1] + 1;
    return this.insertLine(fake, line);
  };
  Element.prototype.deleteTop = function(n) {
    var fake = this._clines.rtof[this.childBase || 0];
    return this.deleteLine(fake, n);
  };
  Element.prototype.deleteBottom = function(n) {
    var h = (this.childBase || 0) + this.height - 1 - this.iheight, i = Math.min(h, this._clines.length - 1), fake = this._clines.rtof[i];
    n = n || 1;
    return this.deleteLine(fake - (n - 1), n);
  };
  Element.prototype.setLine = function(i, line) {
    i = Math.max(i, 0);
    while (this._clines.fake.length < i) {
      this._clines.fake.push("");
    }
    this._clines.fake[i] = line;
    return this.setContent(this._clines.fake.join("\n"), true);
  };
  Element.prototype.setBaseLine = function(i, line) {
    var fake = this._clines.rtof[this.childBase || 0];
    return this.setLine(fake + i, line);
  };
  Element.prototype.getLine = function(i) {
    i = Math.max(i, 0);
    i = Math.min(i, this._clines.fake.length - 1);
    return this._clines.fake[i];
  };
  Element.prototype.getBaseLine = function(i) {
    var fake = this._clines.rtof[this.childBase || 0];
    return this.getLine(fake + i);
  };
  Element.prototype.clearLine = function(i) {
    i = Math.min(i, this._clines.fake.length - 1);
    return this.setLine(i, "");
  };
  Element.prototype.clearBaseLine = function(i) {
    var fake = this._clines.rtof[this.childBase || 0];
    return this.clearLine(fake + i);
  };
  Element.prototype.unshiftLine = function(line) {
    return this.insertLine(0, line);
  };
  Element.prototype.shiftLine = function(n) {
    return this.deleteLine(0, n);
  };
  Element.prototype.pushLine = function(line) {
    if (!this.content)
      return this.setLine(0, line);
    return this.insertLine(this._clines.fake.length, line);
  };
  Element.prototype.popLine = function(n) {
    return this.deleteLine(this._clines.fake.length - 1, n);
  };
  Element.prototype.getLines = function() {
    return this._clines.fake.slice();
  };
  Element.prototype.getScreenLines = function() {
    return this._clines.slice();
  };
  Element.prototype.strWidth = function(text) {
    text = this.parseTags ? helpers.stripTags(text) : text;
    return this.screen.fullUnicode ? unicode.strWidth(text) : helpers.dropUnicode(text).length;
  };
  Element.prototype.screenshot = function(xi, xl, yi, yl) {
    xi = this.lpos.xi + this.ileft + (xi || 0);
    if (xl != null) {
      xl = this.lpos.xi + this.ileft + (xl || 0);
    } else {
      xl = this.lpos.xl - this.iright;
    }
    yi = this.lpos.yi + this.itop + (yi || 0);
    if (yl != null) {
      yl = this.lpos.yi + this.itop + (yl || 0);
    } else {
      yl = this.lpos.yl - this.ibottom;
    }
    return this.screen.screenshot(xi, xl, yi, yl);
  };
  module2.exports = Element;
});

// ../../node_modules/blessed/lib/widgets/box.js
var require_box = __commonJS((exports2, module2) => {
  var Box = function(options2) {
    if (!(this instanceof Node)) {
      return new Box(options2);
    }
    options2 = options2 || {};
    Element.call(this, options2);
  };
  var Node = require_node3();
  var Element = require_element();
  Box.prototype.__proto__ = Element.prototype;
  Box.prototype.type = "box";
  module2.exports = Box;
});

// ../../node_modules/blessed/lib/widgets/scrollablebox.js
var require_scrollablebox = __commonJS((exports2, module2) => {
  var ScrollableBox = function(options2) {
    var self2 = this;
    if (!(this instanceof Node)) {
      return new ScrollableBox(options2);
    }
    options2 = options2 || {};
    Box.call(this, options2);
    if (options2.scrollable === false) {
      return this;
    }
    this.scrollable = true;
    this.childOffset = 0;
    this.childBase = 0;
    this.baseLimit = options2.baseLimit || Infinity;
    this.alwaysScroll = options2.alwaysScroll;
    this.scrollbar = options2.scrollbar;
    if (this.scrollbar) {
      this.scrollbar.ch = this.scrollbar.ch || " ";
      this.style.scrollbar = this.style.scrollbar || this.scrollbar.style;
      if (!this.style.scrollbar) {
        this.style.scrollbar = {};
        this.style.scrollbar.fg = this.scrollbar.fg;
        this.style.scrollbar.bg = this.scrollbar.bg;
        this.style.scrollbar.bold = this.scrollbar.bold;
        this.style.scrollbar.underline = this.scrollbar.underline;
        this.style.scrollbar.inverse = this.scrollbar.inverse;
        this.style.scrollbar.invisible = this.scrollbar.invisible;
      }
      if (this.track || this.scrollbar.track) {
        this.track = this.scrollbar.track || this.track;
        this.style.track = this.style.scrollbar.track || this.style.track;
        this.track.ch = this.track.ch || " ";
        this.style.track = this.style.track || this.track.style;
        if (!this.style.track) {
          this.style.track = {};
          this.style.track.fg = this.track.fg;
          this.style.track.bg = this.track.bg;
          this.style.track.bold = this.track.bold;
          this.style.track.underline = this.track.underline;
          this.style.track.inverse = this.track.inverse;
          this.style.track.invisible = this.track.invisible;
        }
        this.track.style = this.style.track;
      }
      if (options2.mouse) {
        this.on("mousedown", function(data) {
          if (self2._scrollingBar) {
            delete self2.screen._dragging;
            delete self2._drag;
            return;
          }
          var x = data.x - self2.aleft;
          var y = data.y - self2.atop;
          if (x === self2.width - self2.iright - 1) {
            delete self2.screen._dragging;
            delete self2._drag;
            var perc = (y - self2.itop) / (self2.height - self2.iheight);
            self2.setScrollPerc(perc * 100 | 0);
            self2.screen.render();
            var smd, smu;
            self2._scrollingBar = true;
            self2.onScreenEvent("mousedown", smd = function(data2) {
              var y2 = data2.y - self2.atop;
              var perc2 = y2 / self2.height;
              self2.setScrollPerc(perc2 * 100 | 0);
              self2.screen.render();
            });
            self2.onScreenEvent("mouseup", smu = function() {
              self2._scrollingBar = false;
              self2.removeScreenEvent("mousedown", smd);
              self2.removeScreenEvent("mouseup", smu);
            });
          }
        });
      }
    }
    if (options2.mouse) {
      this.on("wheeldown", function() {
        self2.scroll(self2.height / 2 | 0 || 1);
        self2.screen.render();
      });
      this.on("wheelup", function() {
        self2.scroll(-(self2.height / 2 | 0) || -1);
        self2.screen.render();
      });
    }
    if (options2.keys && !options2.ignoreKeys) {
      this.on("keypress", function(ch, key) {
        if (key.name === "up" || options2.vi && key.name === "k") {
          self2.scroll(-1);
          self2.screen.render();
          return;
        }
        if (key.name === "down" || options2.vi && key.name === "j") {
          self2.scroll(1);
          self2.screen.render();
          return;
        }
        if (options2.vi && key.name === "u" && key.ctrl) {
          self2.scroll(-(self2.height / 2 | 0) || -1);
          self2.screen.render();
          return;
        }
        if (options2.vi && key.name === "d" && key.ctrl) {
          self2.scroll(self2.height / 2 | 0 || 1);
          self2.screen.render();
          return;
        }
        if (options2.vi && key.name === "b" && key.ctrl) {
          self2.scroll(-self2.height || -1);
          self2.screen.render();
          return;
        }
        if (options2.vi && key.name === "f" && key.ctrl) {
          self2.scroll(self2.height || 1);
          self2.screen.render();
          return;
        }
        if (options2.vi && key.name === "g" && !key.shift) {
          self2.scrollTo(0);
          self2.screen.render();
          return;
        }
        if (options2.vi && key.name === "g" && key.shift) {
          self2.scrollTo(self2.getScrollHeight());
          self2.screen.render();
          return;
        }
      });
    }
    this.on("parsed content", function() {
      self2._recalculateIndex();
    });
    self2._recalculateIndex();
  };
  var Node = require_node3();
  var Box = require_box();
  ScrollableBox.prototype.__proto__ = Box.prototype;
  ScrollableBox.prototype.type = "scrollable-box";
  ScrollableBox.prototype.__defineGetter__("reallyScrollable", function() {
    if (this.shrink)
      return this.scrollable;
    return this.getScrollHeight() > this.height;
  });
  ScrollableBox.prototype._scrollBottom = function() {
    if (!this.scrollable)
      return 0;
    if (this._isList) {
      return this.items ? this.items.length : 0;
    }
    if (this.lpos && this.lpos._scrollBottom) {
      return this.lpos._scrollBottom;
    }
    var bottom = this.children.reduce(function(current, el) {
      if (!el.detached) {
        var lpos = el._getCoords(false, true);
        if (lpos) {
          return Math.max(current, el.rtop + (lpos.yl - lpos.yi));
        }
      }
      return Math.max(current, el.rtop + el.height);
    }, 0);
    if (this.lpos)
      this.lpos._scrollBottom = bottom;
    return bottom;
  };
  ScrollableBox.prototype.setScroll = ScrollableBox.prototype.scrollTo = function(offset, always) {
    this.scroll(0);
    return this.scroll(offset - (this.childBase + this.childOffset), always);
  };
  ScrollableBox.prototype.getScroll = function() {
    return this.childBase + this.childOffset;
  };
  ScrollableBox.prototype.scroll = function(offset, always) {
    if (!this.scrollable)
      return;
    if (this.detached)
      return;
    var visible = this.height - this.iheight, base = this.childBase, d, p, t, b, max4, emax;
    if (this.alwaysScroll || always) {
      this.childOffset = offset > 0 ? visible - 1 + offset : offset;
    } else {
      this.childOffset += offset;
    }
    if (this.childOffset > visible - 1) {
      d = this.childOffset - (visible - 1);
      this.childOffset -= d;
      this.childBase += d;
    } else if (this.childOffset < 0) {
      d = this.childOffset;
      this.childOffset += -d;
      this.childBase += d;
    }
    if (this.childBase < 0) {
      this.childBase = 0;
    } else if (this.childBase > this.baseLimit) {
      this.childBase = this.baseLimit;
    }
    if (this.childBase === base) {
      return this.emit("scroll");
    }
    this.parseContent();
    max4 = this._clines.length - (this.height - this.iheight);
    if (max4 < 0)
      max4 = 0;
    emax = this._scrollBottom() - (this.height - this.iheight);
    if (emax < 0)
      emax = 0;
    this.childBase = Math.min(this.childBase, Math.max(emax, max4));
    if (this.childBase < 0) {
      this.childBase = 0;
    } else if (this.childBase > this.baseLimit) {
      this.childBase = this.baseLimit;
    }
    p = this.lpos;
    if (p && this.childBase !== base && this.screen.cleanSides(this)) {
      t = p.yi + this.itop;
      b = p.yl - this.ibottom - 1;
      d = this.childBase - base;
      if (d > 0 && d < visible) {
        this.screen.deleteLine(d, t, t, b);
      } else if (d < 0 && -d < visible) {
        d = -d;
        this.screen.insertLine(d, t, t, b);
      }
    }
    return this.emit("scroll");
  };
  ScrollableBox.prototype._recalculateIndex = function() {
    var max4, emax;
    if (this.detached || !this.scrollable) {
      return 0;
    }
    max4 = this._clines.length - (this.height - this.iheight);
    if (max4 < 0)
      max4 = 0;
    emax = this._scrollBottom() - (this.height - this.iheight);
    if (emax < 0)
      emax = 0;
    this.childBase = Math.min(this.childBase, Math.max(emax, max4));
    if (this.childBase < 0) {
      this.childBase = 0;
    } else if (this.childBase > this.baseLimit) {
      this.childBase = this.baseLimit;
    }
  };
  ScrollableBox.prototype.resetScroll = function() {
    if (!this.scrollable)
      return;
    this.childOffset = 0;
    this.childBase = 0;
    return this.emit("scroll");
  };
  ScrollableBox.prototype.getScrollHeight = function() {
    return Math.max(this._clines.length, this._scrollBottom());
  };
  ScrollableBox.prototype.getScrollPerc = function(s) {
    var pos = this.lpos || this._getCoords();
    if (!pos)
      return s ? -1 : 0;
    var height = pos.yl - pos.yi - this.iheight, i = this.getScrollHeight(), p;
    if (height < i) {
      if (this.alwaysScroll) {
        p = this.childBase / (i - height);
      } else {
        p = (this.childBase + this.childOffset) / (i - 1);
      }
      return p * 100;
    }
    return s ? -1 : 0;
  };
  ScrollableBox.prototype.setScrollPerc = function(i) {
    var m = Math.max(this._clines.length, this._scrollBottom());
    return this.scrollTo(i / 100 * m | 0);
  };
  module2.exports = ScrollableBox;
});

// ../../node_modules/blessed/lib/widgets/scrollabletext.js
var require_scrollabletext = __commonJS((exports2, module2) => {
  var ScrollableText = function(options2) {
    if (!(this instanceof Node)) {
      return new ScrollableText(options2);
    }
    options2 = options2 || {};
    options2.alwaysScroll = true;
    ScrollableBox.call(this, options2);
  };
  var Node = require_node3();
  var ScrollableBox = require_scrollablebox();
  ScrollableText.prototype.__proto__ = ScrollableBox.prototype;
  ScrollableText.prototype.type = "scrollable-text";
  module2.exports = ScrollableText;
});

// ../../node_modules/blessed/lib/widgets/log.js
var require_log = __commonJS((exports2, module2) => {
  var Log = function(options2) {
    var self2 = this;
    if (!(this instanceof Node)) {
      return new Log(options2);
    }
    options2 = options2 || {};
    ScrollableText.call(this, options2);
    this.scrollback = options2.scrollback != null ? options2.scrollback : Infinity;
    this.scrollOnInput = options2.scrollOnInput;
    this.on("set content", function() {
      if (!self2._userScrolled || self2.scrollOnInput) {
        nextTick(function() {
          self2.setScrollPerc(100);
          self2._userScrolled = false;
          self2.screen.render();
        });
      }
    });
  };
  var util = __require("util");
  var nextTick = global.setImmediate || process.nextTick.bind(process);
  var Node = require_node3();
  var ScrollableText = require_scrollabletext();
  Log.prototype.__proto__ = ScrollableText.prototype;
  Log.prototype.type = "log";
  Log.prototype.log = Log.prototype.add = function() {
    var args2 = Array.prototype.slice.call(arguments);
    if (typeof args2[0] === "object") {
      args2[0] = util.inspect(args2[0], true, 20, true);
    }
    var text = util.format.apply(util, args2);
    this.emit("log", text);
    var ret = this.pushLine(text);
    if (this._clines.fake.length > this.scrollback) {
      this.shiftLine(0, this.scrollback / 3 | 0);
    }
    return ret;
  };
  Log.prototype._scroll = Log.prototype.scroll;
  Log.prototype.scroll = function(offset, always) {
    if (offset === 0)
      return this._scroll(offset, always);
    this._userScrolled = true;
    var ret = this._scroll(offset, always);
    if (this.getScrollPerc() === 100) {
      this._userScrolled = false;
    }
    return ret;
  };
  module2.exports = Log;
});

// ../../node_modules/blessed/lib/widgets/screen.js
var require_screen = __commonJS((exports2, module2) => {
  var Screen = function(options2) {
    var self2 = this;
    if (!(this instanceof Node)) {
      return new Screen(options2);
    }
    Screen.bind(this);
    options2 = options2 || {};
    if (options2.rsety && options2.listen) {
      options2 = { program: options2 };
    }
    this.program = options2.program;
    if (!this.program) {
      this.program = program({
        input: options2.input,
        output: options2.output,
        log: options2.log,
        debug: options2.debug,
        dump: options2.dump,
        terminal: options2.terminal || options2.term,
        resizeTimeout: options2.resizeTimeout,
        forceUnicode: options2.forceUnicode,
        tput: true,
        buffer: true,
        zero: true
      });
    } else {
      this.program.setupTput();
      this.program.useBuffer = true;
      this.program.zero = true;
      this.program.options.resizeTimeout = options2.resizeTimeout;
      if (options2.forceUnicode != null) {
        this.program.tput.features.unicode = options2.forceUnicode;
        this.program.tput.unicode = options2.forceUnicode;
      }
    }
    this.tput = this.program.tput;
    Node.call(this, options2);
    this.autoPadding = options2.autoPadding !== false;
    this.tabc = Array((options2.tabSize || 4) + 1).join(" ");
    this.dockBorders = options2.dockBorders;
    this.ignoreLocked = options2.ignoreLocked || [];
    this._unicode = this.tput.unicode || this.tput.numbers.U8 === 1;
    this.fullUnicode = this.options.fullUnicode && this._unicode;
    this.dattr = 0 << 18 | 511 << 9 | 511;
    this.renders = 0;
    this.position = {
      left: this.left = this.aleft = this.rleft = 0,
      right: this.right = this.aright = this.rright = 0,
      top: this.top = this.atop = this.rtop = 0,
      bottom: this.bottom = this.abottom = this.rbottom = 0,
      get height() {
        return self2.height;
      },
      get width() {
        return self2.width;
      }
    };
    this.ileft = 0;
    this.itop = 0;
    this.iright = 0;
    this.ibottom = 0;
    this.iheight = 0;
    this.iwidth = 0;
    this.padding = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    this.hover = null;
    this.history = [];
    this.clickable = [];
    this.keyable = [];
    this.grabKeys = false;
    this.lockKeys = false;
    this.focused;
    this._buf = "";
    this._ci = -1;
    if (options2.title) {
      this.title = options2.title;
    }
    options2.cursor = options2.cursor || {
      artificial: options2.artificialCursor,
      shape: options2.cursorShape,
      blink: options2.cursorBlink,
      color: options2.cursorColor
    };
    this.cursor = {
      artificial: options2.cursor.artificial || false,
      shape: options2.cursor.shape || "block",
      blink: options2.cursor.blink || false,
      color: options2.cursor.color || null,
      _set: false,
      _state: 1,
      _hidden: true
    };
    this.program.on("resize", function() {
      self2.alloc();
      self2.render();
      (function emit(el) {
        el.emit("resize");
        el.children.forEach(emit);
      })(self2);
    });
    this.program.on("focus", function() {
      self2.emit("focus");
    });
    this.program.on("blur", function() {
      self2.emit("blur");
    });
    this.program.on("warning", function(text) {
      self2.emit("warning", text);
    });
    this.on("newListener", function fn(type2) {
      if (type2 === "keypress" || type2.indexOf("key ") === 0 || type2 === "mouse") {
        if (type2 === "keypress" || type2.indexOf("key ") === 0)
          self2._listenKeys();
        if (type2 === "mouse")
          self2._listenMouse();
      }
      if (type2 === "mouse" || type2 === "click" || type2 === "mouseover" || type2 === "mouseout" || type2 === "mousedown" || type2 === "mouseup" || type2 === "mousewheel" || type2 === "wheeldown" || type2 === "wheelup" || type2 === "mousemove") {
        self2._listenMouse();
      }
    });
    this.setMaxListeners(Infinity);
    this.enter();
    this.postEnter();
  };
  var path2 = __require("path");
  var fs = __require("fs");
  var cp = __require("child_process");
  var colors = require_colors();
  var program = require_program();
  var unicode = require_unicode();
  var nextTick = global.setImmediate || process.nextTick.bind(process);
  var helpers = require_helpers2();
  var Node = require_node3();
  var Log = require_log();
  var Element = require_element();
  var Box = require_box();
  Screen.global = null;
  Screen.total = 0;
  Screen.instances = [];
  Screen.bind = function(screen) {
    if (!Screen.global) {
      Screen.global = screen;
    }
    if (!~Screen.instances.indexOf(screen)) {
      Screen.instances.push(screen);
      screen.index = Screen.total;
      Screen.total++;
    }
    if (Screen._bound)
      return;
    Screen._bound = true;
    process.on("uncaughtException", Screen._exceptionHandler = function(err) {
      if (process.listeners("uncaughtException").length > 1) {
        return;
      }
      Screen.instances.slice().forEach(function(screen2) {
        screen2.destroy();
      });
      err = err || new Error("Uncaught Exception.");
      console.error(err.stack ? err.stack + "" : err + "");
      nextTick(function() {
        process.exit(1);
      });
    });
    ["SIGTERM", "SIGINT", "SIGQUIT"].forEach(function(signal) {
      var name2 = "_" + signal.toLowerCase() + "Handler";
      process.on(signal, Screen[name2] = function() {
        if (process.listeners(signal).length > 1) {
          return;
        }
        nextTick(function() {
          process.exit(0);
        });
      });
    });
    process.on("exit", Screen._exitHandler = function() {
      Screen.instances.slice().forEach(function(screen2) {
        screen2.destroy();
      });
    });
  };
  Screen.prototype.__proto__ = Node.prototype;
  Screen.prototype.type = "screen";
  Screen.prototype.__defineGetter__("title", function() {
    return this.program.title;
  });
  Screen.prototype.__defineSetter__("title", function(title) {
    return this.program.title = title;
  });
  Screen.prototype.__defineGetter__("terminal", function() {
    return this.program.terminal;
  });
  Screen.prototype.__defineSetter__("terminal", function(terminal) {
    this.setTerminal(terminal);
    return this.program.terminal;
  });
  Screen.prototype.setTerminal = function(terminal) {
    var entered = !!this.program.isAlt;
    if (entered) {
      this._buf = "";
      this.program._buf = "";
      this.leave();
    }
    this.program.setTerminal(terminal);
    this.tput = this.program.tput;
    if (entered) {
      this.enter();
    }
  };
  Screen.prototype.enter = function() {
    if (this.program.isAlt)
      return;
    if (!this.cursor._set) {
      if (this.options.cursor.shape) {
        this.cursorShape(this.cursor.shape, this.cursor.blink);
      }
      if (this.options.cursor.color) {
        this.cursorColor(this.cursor.color);
      }
    }
    if (process.platform === "win32") {
      try {
        cp.execSync("cls", { stdio: "ignore", timeout: 1000 });
      } catch (e) {
      }
    }
    this.program.alternateBuffer();
    this.program.put.keypad_xmit();
    this.program.csr(0, this.height - 1);
    this.program.hideCursor();
    this.program.cup(0, 0);
    if (this.tput.strings.ena_acs) {
      this.program._write(this.tput.enacs());
    }
    this.alloc();
  };
  Screen.prototype.leave = function() {
    if (!this.program.isAlt)
      return;
    this.program.put.keypad_local();
    if (this.program.scrollTop !== 0 || this.program.scrollBottom !== this.rows - 1) {
      this.program.csr(0, this.height - 1);
    }
    this.program.showCursor();
    this.alloc();
    if (this._listenedMouse) {
      this.program.disableMouse();
    }
    this.program.normalBuffer();
    if (this.cursor._set)
      this.cursorReset();
    this.program.flush();
    if (process.platform === "win32") {
      try {
        cp.execSync("cls", { stdio: "ignore", timeout: 1000 });
      } catch (e) {
      }
    }
  };
  Screen.prototype.postEnter = function() {
    var self2 = this;
    if (this.options.debug) {
      this.debugLog = new Log({
        screen: this,
        parent: this,
        hidden: true,
        draggable: true,
        left: "center",
        top: "center",
        width: "30%",
        height: "30%",
        border: "line",
        label: " {bold}Debug Log{/bold} ",
        tags: true,
        keys: true,
        vi: true,
        mouse: true,
        scrollbar: {
          ch: " ",
          track: {
            bg: "yellow"
          },
          style: {
            inverse: true
          }
        }
      });
      this.debugLog.toggle = function() {
        if (self2.debugLog.hidden) {
          self2.saveFocus();
          self2.debugLog.show();
          self2.debugLog.setFront();
          self2.debugLog.focus();
        } else {
          self2.debugLog.hide();
          self2.restoreFocus();
        }
        self2.render();
      };
      this.debugLog.key(["q", "escape"], self2.debugLog.toggle);
      this.key("f12", self2.debugLog.toggle);
    }
    if (this.options.warnings) {
      this.on("warning", function(text) {
        var warning = new Box({
          screen: self2,
          parent: self2,
          left: "center",
          top: "center",
          width: "shrink",
          padding: 1,
          height: "shrink",
          align: "center",
          valign: "middle",
          border: "line",
          label: " {red-fg}{bold}WARNING{/} ",
          content: "{bold}" + text + "{/bold}",
          tags: true
        });
        self2.render();
        var timeout = setTimeout(function() {
          warning.destroy();
          self2.render();
        }, 1500);
        if (timeout.unref) {
          timeout.unref();
        }
      });
    }
  };
  Screen.prototype._destroy = Screen.prototype.destroy;
  Screen.prototype.destroy = function() {
    this.leave();
    var index = Screen.instances.indexOf(this);
    if (~index) {
      Screen.instances.splice(index, 1);
      Screen.total--;
      Screen.global = Screen.instances[0];
      if (Screen.total === 0) {
        Screen.global = null;
        process.removeListener("uncaughtException", Screen._exceptionHandler);
        process.removeListener("SIGTERM", Screen._sigtermHandler);
        process.removeListener("SIGINT", Screen._sigintHandler);
        process.removeListener("SIGQUIT", Screen._sigquitHandler);
        process.removeListener("exit", Screen._exitHandler);
        delete Screen._exceptionHandler;
        delete Screen._sigtermHandler;
        delete Screen._sigintHandler;
        delete Screen._sigquitHandler;
        delete Screen._exitHandler;
        delete Screen._bound;
      }
      this.destroyed = true;
      this.emit("destroy");
      this._destroy();
    }
    this.program.destroy();
  };
  Screen.prototype.log = function() {
    return this.program.log.apply(this.program, arguments);
  };
  Screen.prototype.debug = function() {
    if (this.debugLog) {
      this.debugLog.log.apply(this.debugLog, arguments);
    }
    return this.program.debug.apply(this.program, arguments);
  };
  Screen.prototype._listenMouse = function(el) {
    var self2 = this;
    if (el && !~this.clickable.indexOf(el)) {
      el.clickable = true;
      this.clickable.push(el);
    }
    if (this._listenedMouse)
      return;
    this._listenedMouse = true;
    this.program.enableMouse();
    if (this.options.sendFocus) {
      this.program.setMouse({ sendFocus: true }, true);
    }
    this.on("render", function() {
      self2._needsClickableSort = true;
    });
    this.program.on("mouse", function(data) {
      if (self2.lockKeys)
        return;
      if (self2._needsClickableSort) {
        self2.clickable = helpers.hsort(self2.clickable);
        self2._needsClickableSort = false;
      }
      var i = 0, el2, set, pos;
      for (;i < self2.clickable.length; i++) {
        el2 = self2.clickable[i];
        if (el2.detached || !el2.visible) {
          continue;
        }
        pos = el2.lpos;
        if (!pos)
          continue;
        if (data.x >= pos.xi && data.x < pos.xl && data.y >= pos.yi && data.y < pos.yl) {
          el2.emit("mouse", data);
          if (data.action === "mousedown") {
            self2.mouseDown = el2;
          } else if (data.action === "mouseup") {
            (self2.mouseDown || el2).emit("click", data);
            self2.mouseDown = null;
          } else if (data.action === "mousemove") {
            if (self2.hover && el2.index > self2.hover.index) {
              set = false;
            }
            if (self2.hover !== el2 && !set) {
              if (self2.hover) {
                self2.hover.emit("mouseout", data);
              }
              el2.emit("mouseover", data);
              self2.hover = el2;
            }
            set = true;
          }
          el2.emit(data.action, data);
          break;
        }
      }
      if ((data.action === "mousemove" || data.action === "mousedown" || data.action === "mouseup") && self2.hover && !set) {
        self2.hover.emit("mouseout", data);
        self2.hover = null;
      }
      self2.emit("mouse", data);
      self2.emit(data.action, data);
    });
    this.on("element click", function(el2) {
      if (el2.clickable === true && el2.options.autoFocus !== false) {
        el2.focus();
      }
    });
  };
  Screen.prototype.enableMouse = function(el) {
    this._listenMouse(el);
  };
  Screen.prototype._listenKeys = function(el) {
    var self2 = this;
    if (el && !~this.keyable.indexOf(el)) {
      el.keyable = true;
      this.keyable.push(el);
    }
    if (this._listenedKeys)
      return;
    this._listenedKeys = true;
    this.program.on("keypress", function(ch, key) {
      if (self2.lockKeys && !~self2.ignoreLocked.indexOf(key.full)) {
        return;
      }
      var { focused, grabKeys } = self2;
      if (!grabKeys || ~self2.ignoreLocked.indexOf(key.full)) {
        self2.emit("keypress", ch, key);
        self2.emit("key " + key.full, ch, key);
      }
      if (self2.grabKeys !== grabKeys || self2.lockKeys) {
        return;
      }
      if (focused && focused.keyable) {
        focused.emit("keypress", ch, key);
        focused.emit("key " + key.full, ch, key);
      }
    });
  };
  Screen.prototype.enableKeys = function(el) {
    this._listenKeys(el);
  };
  Screen.prototype.enableInput = function(el) {
    this._listenMouse(el);
    this._listenKeys(el);
  };
  Screen.prototype._initHover = function() {
    var self2 = this;
    if (this._hoverText) {
      return;
    }
    this._hoverText = new Box({
      screen: this,
      left: 0,
      top: 0,
      tags: false,
      height: "shrink",
      width: "shrink",
      border: "line",
      style: {
        border: {
          fg: "default"
        },
        bg: "default",
        fg: "default"
      }
    });
    this.on("mousemove", function(data) {
      if (self2._hoverText.detached)
        return;
      self2._hoverText.rleft = data.x + 1;
      self2._hoverText.rtop = data.y;
      self2.render();
    });
    this.on("element mouseover", function(el, data) {
      if (!el._hoverOptions)
        return;
      self2._hoverText.parseTags = el.parseTags;
      self2._hoverText.setContent(el._hoverOptions.text);
      self2.append(self2._hoverText);
      self2._hoverText.rleft = data.x + 1;
      self2._hoverText.rtop = data.y;
      self2.render();
    });
    this.on("element mouseout", function() {
      if (self2._hoverText.detached)
        return;
      self2._hoverText.detach();
      self2.render();
    });
    this.on("element mouseup", function(el) {
      if (!self2._hoverText.getContent())
        return;
      if (!el._hoverOptions)
        return;
      self2.append(self2._hoverText);
      self2.render();
    });
  };
  Screen.prototype.__defineGetter__("cols", function() {
    return this.program.cols;
  });
  Screen.prototype.__defineGetter__("rows", function() {
    return this.program.rows;
  });
  Screen.prototype.__defineGetter__("width", function() {
    return this.program.cols;
  });
  Screen.prototype.__defineGetter__("height", function() {
    return this.program.rows;
  });
  Screen.prototype.alloc = function(dirty) {
    var x, y;
    this.lines = [];
    for (y = 0;y < this.rows; y++) {
      this.lines[y] = [];
      for (x = 0;x < this.cols; x++) {
        this.lines[y][x] = [this.dattr, " "];
      }
      this.lines[y].dirty = !!dirty;
    }
    this.olines = [];
    for (y = 0;y < this.rows; y++) {
      this.olines[y] = [];
      for (x = 0;x < this.cols; x++) {
        this.olines[y][x] = [this.dattr, " "];
      }
    }
    this.program.clear();
  };
  Screen.prototype.realloc = function() {
    return this.alloc(true);
  };
  Screen.prototype.render = function() {
    var self2 = this;
    if (this.destroyed)
      return;
    this.emit("prerender");
    this._borderStops = {};
    this._ci = 0;
    this.children.forEach(function(el) {
      el.index = self2._ci++;
      el.render();
    });
    this._ci = -1;
    if (this.screen.dockBorders) {
      this._dockBorders();
    }
    this.draw(0, this.lines.length - 1);
    if (this.focused && this.focused._updateCursor) {
      this.focused._updateCursor(true);
    }
    this.renders++;
    this.emit("render");
  };
  Screen.prototype.blankLine = function(ch, dirty) {
    var out = [];
    for (var x = 0;x < this.cols; x++) {
      out[x] = [this.dattr, ch || " "];
    }
    out.dirty = dirty;
    return out;
  };
  Screen.prototype.insertLine = function(n, y, top, bottom) {
    if (!this.tput.strings.change_scroll_region || !this.tput.strings.delete_line || !this.tput.strings.insert_line)
      return;
    this._buf += this.tput.csr(top, bottom);
    this._buf += this.tput.cup(y, 0);
    this._buf += this.tput.il(n);
    this._buf += this.tput.csr(0, this.height - 1);
    var j = bottom + 1;
    while (n--) {
      this.lines.splice(y, 0, this.blankLine());
      this.lines.splice(j, 1);
      this.olines.splice(y, 0, this.blankLine());
      this.olines.splice(j, 1);
    }
  };
  Screen.prototype.deleteLine = function(n, y, top, bottom) {
    if (!this.tput.strings.change_scroll_region || !this.tput.strings.delete_line || !this.tput.strings.insert_line)
      return;
    this._buf += this.tput.csr(top, bottom);
    this._buf += this.tput.cup(y, 0);
    this._buf += this.tput.dl(n);
    this._buf += this.tput.csr(0, this.height - 1);
    var j = bottom + 1;
    while (n--) {
      this.lines.splice(j, 0, this.blankLine());
      this.lines.splice(y, 1);
      this.olines.splice(j, 0, this.blankLine());
      this.olines.splice(y, 1);
    }
  };
  Screen.prototype.insertLineNC = function(n, y, top, bottom) {
    if (!this.tput.strings.change_scroll_region || !this.tput.strings.delete_line)
      return;
    this._buf += this.tput.csr(top, bottom);
    this._buf += this.tput.cup(top, 0);
    this._buf += this.tput.dl(n);
    this._buf += this.tput.csr(0, this.height - 1);
    var j = bottom + 1;
    while (n--) {
      this.lines.splice(j, 0, this.blankLine());
      this.lines.splice(y, 1);
      this.olines.splice(j, 0, this.blankLine());
      this.olines.splice(y, 1);
    }
  };
  Screen.prototype.deleteLineNC = function(n, y, top, bottom) {
    if (!this.tput.strings.change_scroll_region || !this.tput.strings.delete_line)
      return;
    this._buf += this.tput.csr(top, bottom);
    this._buf += this.tput.cup(bottom, 0);
    this._buf += Array(n + 1).join("\n");
    this._buf += this.tput.csr(0, this.height - 1);
    var j = bottom + 1;
    while (n--) {
      this.lines.splice(j, 0, this.blankLine());
      this.lines.splice(y, 1);
      this.olines.splice(j, 0, this.blankLine());
      this.olines.splice(y, 1);
    }
  };
  Screen.prototype.insertBottom = function(top, bottom) {
    return this.deleteLine(1, top, top, bottom);
  };
  Screen.prototype.insertTop = function(top, bottom) {
    return this.insertLine(1, top, top, bottom);
  };
  Screen.prototype.deleteBottom = function(top, bottom) {
    return this.clearRegion(0, this.width, bottom, bottom);
  };
  Screen.prototype.deleteTop = function(top, bottom) {
    return this.deleteLine(1, top, top, bottom);
  };
  Screen.prototype.cleanSides = function(el) {
    var pos = el.lpos;
    if (!pos) {
      return false;
    }
    if (pos._cleanSides != null) {
      return pos._cleanSides;
    }
    if (pos.xi <= 0 && pos.xl >= this.width) {
      return pos._cleanSides = true;
    }
    if (this.options.fastCSR) {
      if (pos.yi < 0)
        return pos._cleanSides = false;
      if (pos.yl > this.height)
        return pos._cleanSides = false;
      if (this.width - (pos.xl - pos.xi) < 40) {
        return pos._cleanSides = true;
      }
      return pos._cleanSides = false;
    }
    if (!this.options.smartCSR) {
      return false;
    }
    var yi = pos.yi + el.itop, yl = pos.yl - el.ibottom, first, ch, x, y;
    if (pos.yi < 0)
      return pos._cleanSides = false;
    if (pos.yl > this.height)
      return pos._cleanSides = false;
    if (pos.xi - 1 < 0)
      return pos._cleanSides = true;
    if (pos.xl > this.width)
      return pos._cleanSides = true;
    for (x = pos.xi - 1;x >= 0; x--) {
      if (!this.olines[yi])
        break;
      first = this.olines[yi][x];
      for (y = yi;y < yl; y++) {
        if (!this.olines[y] || !this.olines[y][x])
          break;
        ch = this.olines[y][x];
        if (ch[0] !== first[0] || ch[1] !== first[1]) {
          return pos._cleanSides = false;
        }
      }
    }
    for (x = pos.xl;x < this.width; x++) {
      if (!this.olines[yi])
        break;
      first = this.olines[yi][x];
      for (y = yi;y < yl; y++) {
        if (!this.olines[y] || !this.olines[y][x])
          break;
        ch = this.olines[y][x];
        if (ch[0] !== first[0] || ch[1] !== first[1]) {
          return pos._cleanSides = false;
        }
      }
    }
    return pos._cleanSides = true;
  };
  Screen.prototype._dockBorders = function() {
    var lines = this.lines, stops = this._borderStops, i, y, x, ch;
    stops = Object.keys(stops).map(function(k) {
      return +k;
    }).sort(function(a, b) {
      return a - b;
    });
    for (i = 0;i < stops.length; i++) {
      y = stops[i];
      if (!lines[y])
        continue;
      for (x = 0;x < this.width; x++) {
        ch = lines[y][x][1];
        if (angles[ch]) {
          lines[y][x][1] = this._getAngle(lines, x, y);
          lines[y].dirty = true;
        }
      }
    }
  };
  Screen.prototype._getAngle = function(lines, x, y) {
    var angle = 0, attr = lines[y][x][0], ch = lines[y][x][1];
    if (lines[y][x - 1] && langles[lines[y][x - 1][1]]) {
      if (!this.options.ignoreDockContrast) {
        if (lines[y][x - 1][0] !== attr)
          return ch;
      }
      angle |= 1 << 3;
    }
    if (lines[y - 1] && uangles[lines[y - 1][x][1]]) {
      if (!this.options.ignoreDockContrast) {
        if (lines[y - 1][x][0] !== attr)
          return ch;
      }
      angle |= 1 << 2;
    }
    if (lines[y][x + 1] && rangles[lines[y][x + 1][1]]) {
      if (!this.options.ignoreDockContrast) {
        if (lines[y][x + 1][0] !== attr)
          return ch;
      }
      angle |= 1 << 1;
    }
    if (lines[y + 1] && dangles[lines[y + 1][x][1]]) {
      if (!this.options.ignoreDockContrast) {
        if (lines[y + 1][x][0] !== attr)
          return ch;
      }
      angle |= 1 << 0;
    }
    return angleTable[angle] || ch;
  };
  Screen.prototype.draw = function(start, end) {
    var x, y, line, out, ch, data, attr, fg, bg, flags;
    var main2 = "", pre, post;
    var clr, neq, xx;
    var lx = -1, ly = -1, o;
    var acs;
    if (this._buf) {
      main2 += this._buf;
      this._buf = "";
    }
    for (y = start;y <= end; y++) {
      line = this.lines[y];
      o = this.olines[y];
      if (!line.dirty && !(this.cursor.artificial && y === this.program.y)) {
        continue;
      }
      line.dirty = false;
      out = "";
      attr = this.dattr;
      for (x = 0;x < line.length; x++) {
        data = line[x][0];
        ch = line[x][1];
        if (this.cursor.artificial && !this.cursor._hidden && this.cursor._state && x === this.program.x && y === this.program.y) {
          var cattr = this._cursorAttr(this.cursor, data);
          if (cattr.ch)
            ch = cattr.ch;
          data = cattr.attr;
        }
        if (this.options.useBCE && ch === " " && (this.tput.bools.back_color_erase || (data & 511) === (this.dattr & 511)) && (data >> 18 & 8) === (this.dattr >> 18 & 8)) {
          clr = true;
          neq = false;
          for (xx = x;xx < line.length; xx++) {
            if (line[xx][0] !== data || line[xx][1] !== " ") {
              clr = false;
              break;
            }
            if (line[xx][0] !== o[xx][0] || line[xx][1] !== o[xx][1]) {
              neq = true;
            }
          }
          if (clr && neq) {
            lx = -1, ly = -1;
            if (data !== attr) {
              out += this.codeAttr(data);
              attr = data;
            }
            out += this.tput.cup(y, x);
            out += this.tput.el();
            for (xx = x;xx < line.length; xx++) {
              o[xx][0] = data;
              o[xx][1] = " ";
            }
            break;
          }
        }
        if (data === o[x][0] && ch === o[x][1]) {
          if (lx === -1) {
            lx = x;
            ly = y;
          }
          continue;
        } else if (lx !== -1) {
          if (this.tput.strings.parm_right_cursor) {
            out += y === ly ? this.tput.cuf(x - lx) : this.tput.cup(y, x);
          } else {
            out += this.tput.cup(y, x);
          }
          lx = -1, ly = -1;
        }
        o[x][0] = data;
        o[x][1] = ch;
        if (data !== attr) {
          if (attr !== this.dattr) {
            out += "\x1B[m";
          }
          if (data !== this.dattr) {
            out += "\x1B[";
            bg = data & 511;
            fg = data >> 9 & 511;
            flags = data >> 18;
            if (flags & 1) {
              out += "1;";
            }
            if (flags & 2) {
              out += "4;";
            }
            if (flags & 4) {
              out += "5;";
            }
            if (flags & 8) {
              out += "7;";
            }
            if (flags & 16) {
              out += "8;";
            }
            if (bg !== 511) {
              bg = this._reduceColor(bg);
              if (bg < 16) {
                if (bg < 8) {
                  bg += 40;
                } else if (bg < 16) {
                  bg -= 8;
                  bg += 100;
                }
                out += bg + ";";
              } else {
                out += "48;5;" + bg + ";";
              }
            }
            if (fg !== 511) {
              fg = this._reduceColor(fg);
              if (fg < 16) {
                if (fg < 8) {
                  fg += 30;
                } else if (fg < 16) {
                  fg -= 8;
                  fg += 90;
                }
                out += fg + ";";
              } else {
                out += "38;5;" + fg + ";";
              }
            }
            if (out[out.length - 1] === ";")
              out = out.slice(0, -1);
            out += "m";
          }
        }
        if (this.fullUnicode) {
          if (unicode.charWidth(line[x][1]) === 2) {
            if (x === line.length - 1 || angles[line[x + 1][1]]) {
              ch = " ";
              o[x][1] = "\0";
            } else {
              o[x][1] = "\0";
              o[++x][1] = "\0";
            }
          }
        }
        if (this.tput.strings.enter_alt_charset_mode && !this.tput.brokenACS && (this.tput.acscr[ch] || acs)) {
          if (this.tput.acscr[ch]) {
            if (acs) {
              ch = this.tput.acscr[ch];
            } else {
              ch = this.tput.smacs() + this.tput.acscr[ch];
              acs = true;
            }
          } else if (acs) {
            ch = this.tput.rmacs() + ch;
            acs = false;
          }
        } else {
          if (!this.tput.unicode && this.tput.numbers.U8 !== 1 && ch > "~") {
            ch = this.tput.utoa[ch] || "?";
          }
        }
        out += ch;
        attr = data;
      }
      if (attr !== this.dattr) {
        out += "\x1B[m";
      }
      if (out) {
        main2 += this.tput.cup(y, 0) + out;
      }
    }
    if (acs) {
      main2 += this.tput.rmacs();
      acs = false;
    }
    if (main2) {
      pre = "";
      post = "";
      pre += this.tput.sc();
      post += this.tput.rc();
      if (!this.program.cursorHidden) {
        pre += this.tput.civis();
        post += this.tput.cnorm();
      }
      this.program._write(pre + main2 + post);
    }
  };
  Screen.prototype._reduceColor = function(color) {
    return colors.reduce(color, this.tput.colors);
  };
  Screen.prototype.attrCode = function(code, cur, def) {
    var flags = cur >> 18 & 511, fg = cur >> 9 & 511, bg = cur & 511, c, i;
    code = code.slice(2, -1).split(";");
    if (!code[0])
      code[0] = "0";
    for (i = 0;i < code.length; i++) {
      c = +code[i] || 0;
      switch (c) {
        case 0:
          bg = def & 511;
          fg = def >> 9 & 511;
          flags = def >> 18 & 511;
          break;
        case 1:
          flags |= 1;
          break;
        case 22:
          flags = def >> 18 & 511;
          break;
        case 4:
          flags |= 2;
          break;
        case 24:
          flags = def >> 18 & 511;
          break;
        case 5:
          flags |= 4;
          break;
        case 25:
          flags = def >> 18 & 511;
          break;
        case 7:
          flags |= 8;
          break;
        case 27:
          flags = def >> 18 & 511;
          break;
        case 8:
          flags |= 16;
          break;
        case 28:
          flags = def >> 18 & 511;
          break;
        case 39:
          fg = def >> 9 & 511;
          break;
        case 49:
          bg = def & 511;
          break;
        case 100:
          fg = def >> 9 & 511;
          bg = def & 511;
          break;
        default:
          if (c === 48 && +code[i + 1] === 5) {
            i += 2;
            bg = +code[i];
            break;
          } else if (c === 48 && +code[i + 1] === 2) {
            i += 2;
            bg = colors.match(+code[i], +code[i + 1], +code[i + 2]);
            if (bg === -1)
              bg = def & 511;
            i += 2;
            break;
          } else if (c === 38 && +code[i + 1] === 5) {
            i += 2;
            fg = +code[i];
            break;
          } else if (c === 38 && +code[i + 1] === 2) {
            i += 2;
            fg = colors.match(+code[i], +code[i + 1], +code[i + 2]);
            if (fg === -1)
              fg = def >> 9 & 511;
            i += 2;
            break;
          }
          if (c >= 40 && c <= 47) {
            bg = c - 40;
          } else if (c >= 100 && c <= 107) {
            bg = c - 100;
            bg += 8;
          } else if (c === 49) {
            bg = def & 511;
          } else if (c >= 30 && c <= 37) {
            fg = c - 30;
          } else if (c >= 90 && c <= 97) {
            fg = c - 90;
            fg += 8;
          } else if (c === 39) {
            fg = def >> 9 & 511;
          } else if (c === 100) {
            fg = def >> 9 & 511;
            bg = def & 511;
          }
          break;
      }
    }
    return flags << 18 | fg << 9 | bg;
  };
  Screen.prototype.codeAttr = function(code) {
    var flags = code >> 18 & 511, fg = code >> 9 & 511, bg = code & 511, out = "";
    if (flags & 1) {
      out += "1;";
    }
    if (flags & 2) {
      out += "4;";
    }
    if (flags & 4) {
      out += "5;";
    }
    if (flags & 8) {
      out += "7;";
    }
    if (flags & 16) {
      out += "8;";
    }
    if (bg !== 511) {
      bg = this._reduceColor(bg);
      if (bg < 16) {
        if (bg < 8) {
          bg += 40;
        } else if (bg < 16) {
          bg -= 8;
          bg += 100;
        }
        out += bg + ";";
      } else {
        out += "48;5;" + bg + ";";
      }
    }
    if (fg !== 511) {
      fg = this._reduceColor(fg);
      if (fg < 16) {
        if (fg < 8) {
          fg += 30;
        } else if (fg < 16) {
          fg -= 8;
          fg += 90;
        }
        out += fg + ";";
      } else {
        out += "38;5;" + fg + ";";
      }
    }
    if (out[out.length - 1] === ";")
      out = out.slice(0, -1);
    return "\x1B[" + out + "m";
  };
  Screen.prototype.focusOffset = function(offset) {
    var shown = this.keyable.filter(function(el) {
      return !el.detached && el.visible;
    }).length;
    if (!shown || !offset) {
      return;
    }
    var i = this.keyable.indexOf(this.focused);
    if (!~i)
      return;
    if (offset > 0) {
      while (offset--) {
        if (++i > this.keyable.length - 1)
          i = 0;
        if (this.keyable[i].detached || !this.keyable[i].visible)
          offset++;
      }
    } else {
      offset = -offset;
      while (offset--) {
        if (--i < 0)
          i = this.keyable.length - 1;
        if (this.keyable[i].detached || !this.keyable[i].visible)
          offset++;
      }
    }
    return this.keyable[i].focus();
  };
  Screen.prototype.focusPrev = Screen.prototype.focusPrevious = function() {
    return this.focusOffset(-1);
  };
  Screen.prototype.focusNext = function() {
    return this.focusOffset(1);
  };
  Screen.prototype.focusPush = function(el) {
    if (!el)
      return;
    var old = this.history[this.history.length - 1];
    if (this.history.length === 10) {
      this.history.shift();
    }
    this.history.push(el);
    this._focus(el, old);
  };
  Screen.prototype.focusPop = function() {
    var old = this.history.pop();
    if (this.history.length) {
      this._focus(this.history[this.history.length - 1], old);
    }
    return old;
  };
  Screen.prototype.saveFocus = function() {
    return this._savedFocus = this.focused;
  };
  Screen.prototype.restoreFocus = function() {
    if (!this._savedFocus)
      return;
    this._savedFocus.focus();
    delete this._savedFocus;
    return this.focused;
  };
  Screen.prototype.rewindFocus = function() {
    var old = this.history.pop(), el;
    while (this.history.length) {
      el = this.history.pop();
      if (!el.detached && el.visible) {
        this.history.push(el);
        this._focus(el, old);
        return el;
      }
    }
    if (old) {
      old.emit("blur");
    }
  };
  Screen.prototype._focus = function(self2, old) {
    var el = self2;
    while (el = el.parent) {
      if (el.scrollable)
        break;
    }
    if (el && !el.detached) {
      var visible = self2.screen.height - el.atop - el.itop - el.abottom - el.ibottom;
      if (self2.rtop < el.childBase) {
        el.scrollTo(self2.rtop);
        self2.screen.render();
      } else if (self2.rtop + self2.height - self2.ibottom > el.childBase + visible) {
        el.scrollTo(self2.rtop - (el.height - self2.height) + el.itop, true);
        self2.screen.render();
      }
    }
    if (old) {
      old.emit("blur", self2);
    }
    self2.emit("focus", old);
  };
  Screen.prototype.__defineGetter__("focused", function() {
    return this.history[this.history.length - 1];
  });
  Screen.prototype.__defineSetter__("focused", function(el) {
    return this.focusPush(el);
  });
  Screen.prototype.clearRegion = function(xi, xl, yi, yl, override) {
    return this.fillRegion(this.dattr, " ", xi, xl, yi, yl, override);
  };
  Screen.prototype.fillRegion = function(attr, ch, xi, xl, yi, yl, override) {
    var lines = this.lines, cell, xx;
    if (xi < 0)
      xi = 0;
    if (yi < 0)
      yi = 0;
    for (;yi < yl; yi++) {
      if (!lines[yi])
        break;
      for (xx = xi;xx < xl; xx++) {
        cell = lines[yi][xx];
        if (!cell)
          break;
        if (override || attr !== cell[0] || ch !== cell[1]) {
          lines[yi][xx][0] = attr;
          lines[yi][xx][1] = ch;
          lines[yi].dirty = true;
        }
      }
    }
  };
  Screen.prototype.key = function() {
    return this.program.key.apply(this, arguments);
  };
  Screen.prototype.onceKey = function() {
    return this.program.onceKey.apply(this, arguments);
  };
  Screen.prototype.unkey = Screen.prototype.removeKey = function() {
    return this.program.unkey.apply(this, arguments);
  };
  Screen.prototype.spawn = function(file, args2, options2) {
    if (!Array.isArray(args2)) {
      options2 = args2;
      args2 = [];
    }
    var screen = this, program2 = screen.program, spawn = __require("child_process").spawn, mouse = program2.mouseEnabled, ps;
    options2 = options2 || {};
    options2.stdio = options2.stdio || "inherit";
    program2.lsaveCursor("spawn");
    program2.normalBuffer();
    program2.showCursor();
    if (mouse)
      program2.disableMouse();
    var write4 = program2.output.write;
    program2.output.write = function() {
    };
    program2.input.pause();
    if (program2.input.setRawMode) {
      program2.input.setRawMode(false);
    }
    var resume = function() {
      if (resume.done)
        return;
      resume.done = true;
      if (program2.input.setRawMode) {
        program2.input.setRawMode(true);
      }
      program2.input.resume();
      program2.output.write = write4;
      program2.alternateBuffer();
      if (mouse) {
        program2.enableMouse();
        if (screen.options.sendFocus) {
          screen.program.setMouse({ sendFocus: true }, true);
        }
      }
      screen.alloc();
      screen.render();
      screen.program.lrestoreCursor("spawn", true);
    };
    ps = spawn(file, args2, options2);
    ps.on("error", resume);
    ps.on("exit", resume);
    return ps;
  };
  Screen.prototype.exec = function(file, args2, options2, callback) {
    var ps = this.spawn(file, args2, options2);
    ps.on("error", function(err) {
      if (!callback)
        return;
      return callback(err, false);
    });
    ps.on("exit", function(code) {
      if (!callback)
        return;
      return callback(null, code === 0);
    });
    return ps;
  };
  Screen.prototype.readEditor = function(options2, callback) {
    if (typeof options2 === "string") {
      options2 = { editor: options2 };
    }
    if (!callback) {
      callback = options2;
      options2 = null;
    }
    if (!callback) {
      callback = function() {
      };
    }
    options2 = options2 || {};
    var self2 = this, editor = options2.editor || process.env.EDITOR || "vi", name2 = options2.name || process.title || "blessed", rnd = Math.random().toString(36).split(".").pop(), file = "/tmp/" + name2 + "." + rnd, args2 = [file], opt;
    opt = {
      stdio: "inherit",
      env: process.env,
      cwd: process.env.HOME
    };
    function writeFile(callback2) {
      if (!options2.value)
        return callback2();
      return fs.writeFile(file, options2.value, callback2);
    }
    return writeFile(function(err) {
      if (err)
        return callback(err);
      return self2.exec(editor, args2, opt, function(err2, success) {
        if (err2)
          return callback(err2);
        return fs.readFile(file, "utf8", function(err3, data) {
          return fs.unlink(file, function() {
            if (!success)
              return callback(new Error("Unsuccessful."));
            if (err3)
              return callback(err3);
            return callback(null, data);
          });
        });
      });
    });
  };
  Screen.prototype.displayImage = function(file, callback) {
    if (!file) {
      if (!callback)
        return;
      return callback(new Error("No image."));
    }
    file = path2.resolve(process.cwd(), file);
    if (!~file.indexOf("://")) {
      file = "file://" + file;
    }
    var args2 = ["w3m", "-T", "text/html"];
    var input = "<title>press q to exit</title>" + '<img align="center" src="' + file + '">';
    var opt = {
      stdio: ["pipe", 1, 2],
      env: process.env,
      cwd: process.env.HOME
    };
    var ps = this.spawn(args2[0], args2.slice(1), opt);
    ps.on("error", function(err) {
      if (!callback)
        return;
      return callback(err);
    });
    ps.on("exit", function(code) {
      if (!callback)
        return;
      if (code !== 0)
        return callback(new Error("Exit Code: " + code));
      return callback(null, code === 0);
    });
    ps.stdin.write(input + "\n");
    ps.stdin.end();
  };
  Screen.prototype.setEffects = function(el, fel, over, out, effects, temp) {
    if (!effects)
      return;
    var tmp = {};
    if (temp)
      el[temp] = tmp;
    if (typeof el !== "function") {
      var _el = el;
      el = function() {
        return _el;
      };
    }
    fel.on(over, function() {
      var element = el();
      Object.keys(effects).forEach(function(key) {
        var val = effects[key];
        if (val !== null && typeof val === "object") {
          tmp[key] = tmp[key] || {};
          Object.keys(val).forEach(function(k) {
            var v = val[k];
            tmp[key][k] = element.style[key][k];
            element.style[key][k] = v;
          });
          return;
        }
        tmp[key] = element.style[key];
        element.style[key] = val;
      });
      element.screen.render();
    });
    fel.on(out, function() {
      var element = el();
      Object.keys(effects).forEach(function(key) {
        var val = effects[key];
        if (val !== null && typeof val === "object") {
          tmp[key] = tmp[key] || {};
          Object.keys(val).forEach(function(k) {
            if (tmp[key].hasOwnProperty(k)) {
              element.style[key][k] = tmp[key][k];
            }
          });
          return;
        }
        if (tmp.hasOwnProperty(key)) {
          element.style[key] = tmp[key];
        }
      });
      element.screen.render();
    });
  };
  Screen.prototype.sigtstp = function(callback) {
    var self2 = this;
    this.program.sigtstp(function() {
      self2.alloc();
      self2.render();
      self2.program.lrestoreCursor("pause", true);
      if (callback)
        callback();
    });
  };
  Screen.prototype.copyToClipboard = function(text) {
    return this.program.copyToClipboard(text);
  };
  Screen.prototype.cursorShape = function(shape, blink) {
    var self2 = this;
    this.cursor.shape = shape || "block";
    this.cursor.blink = blink || false;
    this.cursor._set = true;
    if (this.cursor.artificial) {
      if (!this.program.hideCursor_old) {
        var hideCursor = this.program.hideCursor;
        this.program.hideCursor_old = this.program.hideCursor;
        this.program.hideCursor = function() {
          hideCursor.call(self2.program);
          self2.cursor._hidden = true;
          if (self2.renders)
            self2.render();
        };
      }
      if (!this.program.showCursor_old) {
        var showCursor = this.program.showCursor;
        this.program.showCursor_old = this.program.showCursor;
        this.program.showCursor = function() {
          self2.cursor._hidden = false;
          if (self2.program._exiting)
            showCursor.call(self2.program);
          if (self2.renders)
            self2.render();
        };
      }
      if (!this._cursorBlink) {
        this._cursorBlink = setInterval(function() {
          if (!self2.cursor.blink)
            return;
          self2.cursor._state ^= 1;
          if (self2.renders)
            self2.render();
        }, 500);
        if (this._cursorBlink.unref) {
          this._cursorBlink.unref();
        }
      }
      return true;
    }
    return this.program.cursorShape(this.cursor.shape, this.cursor.blink);
  };
  Screen.prototype.cursorColor = function(color) {
    this.cursor.color = color != null ? colors.convert(color) : null;
    this.cursor._set = true;
    if (this.cursor.artificial) {
      return true;
    }
    return this.program.cursorColor(colors.ncolors[this.cursor.color]);
  };
  Screen.prototype.cursorReset = Screen.prototype.resetCursor = function() {
    this.cursor.shape = "block";
    this.cursor.blink = false;
    this.cursor.color = null;
    this.cursor._set = false;
    if (this.cursor.artificial) {
      this.cursor.artificial = false;
      if (this.program.hideCursor_old) {
        this.program.hideCursor = this.program.hideCursor_old;
        delete this.program.hideCursor_old;
      }
      if (this.program.showCursor_old) {
        this.program.showCursor = this.program.showCursor_old;
        delete this.program.showCursor_old;
      }
      if (this._cursorBlink) {
        clearInterval(this._cursorBlink);
        delete this._cursorBlink;
      }
      return true;
    }
    return this.program.cursorReset();
  };
  Screen.prototype._cursorAttr = function(cursor, dattr) {
    var attr = dattr || this.dattr, cattr, ch;
    if (cursor.shape === "line") {
      attr &= ~(511 << 9);
      attr |= 7 << 9;
      ch = "\u2502";
    } else if (cursor.shape === "underline") {
      attr &= ~(511 << 9);
      attr |= 7 << 9;
      attr |= 2 << 18;
    } else if (cursor.shape === "block") {
      attr &= ~(511 << 9);
      attr |= 7 << 9;
      attr |= 8 << 18;
    } else if (typeof cursor.shape === "object" && cursor.shape) {
      cattr = Element.prototype.sattr.call(cursor, cursor.shape);
      if (cursor.shape.bold || cursor.shape.underline || cursor.shape.blink || cursor.shape.inverse || cursor.shape.invisible) {
        attr &= ~(511 << 18);
        attr |= (cattr >> 18 & 511) << 18;
      }
      if (cursor.shape.fg) {
        attr &= ~(511 << 9);
        attr |= (cattr >> 9 & 511) << 9;
      }
      if (cursor.shape.bg) {
        attr &= ~(511 << 0);
        attr |= cattr & 511;
      }
      if (cursor.shape.ch) {
        ch = cursor.shape.ch;
      }
    }
    if (cursor.color != null) {
      attr &= ~(511 << 9);
      attr |= cursor.color << 9;
    }
    return {
      ch,
      attr
    };
  };
  Screen.prototype.screenshot = function(xi, xl, yi, yl, term) {
    if (xi == null)
      xi = 0;
    if (xl == null)
      xl = this.cols;
    if (yi == null)
      yi = 0;
    if (yl == null)
      yl = this.rows;
    if (xi < 0)
      xi = 0;
    if (yi < 0)
      yi = 0;
    var x, y, line, out, ch, data, attr;
    var sdattr = this.dattr;
    if (term) {
      this.dattr = term.defAttr;
    }
    var main2 = "";
    for (y = yi;y < yl; y++) {
      line = term ? term.lines[y] : this.lines[y];
      if (!line)
        break;
      out = "";
      attr = this.dattr;
      for (x = xi;x < xl; x++) {
        if (!line[x])
          break;
        data = line[x][0];
        ch = line[x][1];
        if (data !== attr) {
          if (attr !== this.dattr) {
            out += "\x1B[m";
          }
          if (data !== this.dattr) {
            var _data = data;
            if (term) {
              if ((_data >> 9 & 511) === 257)
                _data |= 511 << 9;
              if ((_data & 511) === 256)
                _data |= 511;
            }
            out += this.codeAttr(_data);
          }
        }
        if (this.fullUnicode) {
          if (unicode.charWidth(line[x][1]) === 2) {
            if (x === xl - 1) {
              ch = " ";
            } else {
              x++;
            }
          }
        }
        out += ch;
        attr = data;
      }
      if (attr !== this.dattr) {
        out += "\x1B[m";
      }
      if (out) {
        main2 += (y > 0 ? "\n" : "") + out;
      }
    }
    main2 = main2.replace(/(?:\s*\x1b\[40m\s*\x1b\[m\s*)*$/, "") + "\n";
    if (term) {
      this.dattr = sdattr;
    }
    return main2;
  };
  Screen.prototype._getPos = function() {
    return this;
  };
  var angles = {
    "\u2518": true,
    "\u2510": true,
    "\u250C": true,
    "\u2514": true,
    "\u253C": true,
    "\u251C": true,
    "\u2524": true,
    "\u2534": true,
    "\u252C": true,
    "\u2502": true,
    "\u2500": true
  };
  var langles = {
    "\u250C": true,
    "\u2514": true,
    "\u253C": true,
    "\u251C": true,
    "\u2534": true,
    "\u252C": true,
    "\u2500": true
  };
  var uangles = {
    "\u2510": true,
    "\u250C": true,
    "\u253C": true,
    "\u251C": true,
    "\u2524": true,
    "\u252C": true,
    "\u2502": true
  };
  var rangles = {
    "\u2518": true,
    "\u2510": true,
    "\u253C": true,
    "\u2524": true,
    "\u2534": true,
    "\u252C": true,
    "\u2500": true
  };
  var dangles = {
    "\u2518": true,
    "\u2514": true,
    "\u253C": true,
    "\u251C": true,
    "\u2524": true,
    "\u2534": true,
    "\u2502": true
  };
  var angleTable = {
    "0000": "",
    "0001": "\u2502",
    "0010": "\u2500",
    "0011": "\u250C",
    "0100": "\u2502",
    "0101": "\u2502",
    "0110": "\u2514",
    "0111": "\u251C",
    "1000": "\u2500",
    "1001": "\u2510",
    "1010": "\u2500",
    "1011": "\u252C",
    "1100": "\u2518",
    "1101": "\u2524",
    "1110": "\u2534",
    "1111": "\u253C"
  };
  Object.keys(angleTable).forEach(function(key) {
    angleTable[parseInt(key, 2)] = angleTable[key];
    delete angleTable[key];
  });
  module2.exports = Screen;
});

// ../../node_modules/blessed/lib/helpers.js
var require_helpers2 = __commonJS((exports2) => {
  var fs = __require("fs");
  var unicode = require_unicode();
  var helpers = exports2;
  helpers.merge = function(a, b) {
    Object.keys(b).forEach(function(key) {
      a[key] = b[key];
    });
    return a;
  };
  helpers.asort = function(obj) {
    return obj.sort(function(a, b) {
      a = a.name.toLowerCase();
      b = b.name.toLowerCase();
      if (a[0] === "." && b[0] === ".") {
        a = a[1];
        b = b[1];
      } else {
        a = a[0];
        b = b[0];
      }
      return a > b ? 1 : a < b ? -1 : 0;
    });
  };
  helpers.hsort = function(obj) {
    return obj.sort(function(a, b) {
      return b.index - a.index;
    });
  };
  helpers.findFile = function(start, target) {
    return function read(dir) {
      var files2, file, stat, out;
      if (dir === "/dev" || dir === "/sys" || dir === "/proc" || dir === "/net") {
        return null;
      }
      try {
        files2 = fs.readdirSync(dir);
      } catch (e) {
        files2 = [];
      }
      for (var i = 0;i < files2.length; i++) {
        file = files2[i];
        if (file === target) {
          return (dir === "/" ? "" : dir) + "/" + file;
        }
        try {
          stat = fs.lstatSync((dir === "/" ? "" : dir) + "/" + file);
        } catch (e) {
          stat = null;
        }
        if (stat && stat.isDirectory() && !stat.isSymbolicLink()) {
          out = read((dir === "/" ? "" : dir) + "/" + file);
          if (out)
            return out;
        }
      }
      return null;
    }(start);
  };
  helpers.escape = function(text) {
    return text.replace(/[{}]/g, function(ch) {
      return ch === "{" ? "{open}" : "{close}";
    });
  };
  helpers.parseTags = function(text, screen) {
    return helpers.Element.prototype._parseTags.call({ parseTags: true, screen: screen || helpers.Screen.global }, text);
  };
  helpers.generateTags = function(style, text) {
    var open = "", close = "";
    Object.keys(style || {}).forEach(function(key) {
      var val = style[key];
      if (typeof val === "string") {
        val = val.replace(/^light(?!-)/, "light-");
        val = val.replace(/^bright(?!-)/, "bright-");
        open = "{" + val + "-" + key + "}" + open;
        close += "{/" + val + "-" + key + "}";
      } else {
        if (val === true) {
          open = "{" + key + "}" + open;
          close += "{/" + key + "}";
        }
      }
    });
    if (text != null) {
      return open + text + close;
    }
    return {
      open,
      close
    };
  };
  helpers.attrToBinary = function(style, element) {
    return helpers.Element.prototype.sattr.call(element || {}, style);
  };
  helpers.stripTags = function(text) {
    if (!text)
      return "";
    return text.replace(/{(\/?)([\w\-,;!#]*)}/g, "").replace(/\x1b\[[\d;]*m/g, "");
  };
  helpers.cleanTags = function(text) {
    return helpers.stripTags(text).trim();
  };
  helpers.dropUnicode = function(text) {
    if (!text)
      return "";
    return text.replace(unicode.chars.all, "??").replace(unicode.chars.combining, "").replace(unicode.chars.surrogate, "?");
  };
  helpers.__defineGetter__("Screen", function() {
    if (!helpers._screen) {
      helpers._screen = require_screen();
    }
    return helpers._screen;
  });
  helpers.__defineGetter__("Element", function() {
    if (!helpers._element) {
      helpers._element = require_element();
    }
    return helpers._element;
  });
});

// ../../node_modules/blessed/lib/blessed.js
var require_blessed = __commonJS((exports2, module2) => {
  var blessed = function() {
    return blessed.program.apply(null, arguments);
  };
  blessed.program = blessed.Program = require_program();
  blessed.tput = blessed.Tput = require_tput();
  blessed.widget = require_widget();
  blessed.colors = require_colors();
  blessed.unicode = require_unicode();
  blessed.helpers = require_helpers2();
  blessed.helpers.sprintf = blessed.tput.sprintf;
  blessed.helpers.tryRead = blessed.tput.tryRead;
  blessed.helpers.merge(blessed, blessed.helpers);
  blessed.helpers.merge(blessed, blessed.widget);
  module2.exports = blessed;
});

// ../../node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS((exports2) => {
  (function() {
    var re = {
      not_string: /[^s]/,
      not_bool: /[^t]/,
      not_type: /[^T]/,
      not_primitive: /[^v]/,
      number: /[diefg]/,
      numeric_arg: /[bcdiefguxX]/,
      json: /[j]/,
      not_json: /[^j]/,
      text: /^[^\x25]+/,
      modulo: /^\x25{2}/,
      placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
      key: /^([a-z_][a-z_\d]*)/i,
      key_access: /^\.([a-z_][a-z_\d]*)/i,
      index_access: /^\[(\d+)\]/,
      sign: /^[+-]/
    };
    function sprintf(key) {
      return sprintf_format(sprintf_parse(key), arguments);
    }
    function vsprintf(fmt, argv) {
      return sprintf.apply(null, [fmt].concat(argv || []));
    }
    function sprintf_format(parse_tree, argv) {
      var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign;
      for (i = 0;i < tree_length; i++) {
        if (typeof parse_tree[i] === "string") {
          output += parse_tree[i];
        } else if (typeof parse_tree[i] === "object") {
          ph = parse_tree[i];
          if (ph.keys) {
            arg = argv[cursor];
            for (k = 0;k < ph.keys.length; k++) {
              if (arg == undefined) {
                throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
              }
              arg = arg[ph.keys[k]];
            }
          } else if (ph.param_no) {
            arg = argv[ph.param_no];
          } else {
            arg = argv[cursor++];
          }
          if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
            arg = arg();
          }
          if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
            throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
          }
          if (re.number.test(ph.type)) {
            is_positive = arg >= 0;
          }
          switch (ph.type) {
            case "b":
              arg = parseInt(arg, 10).toString(2);
              break;
            case "c":
              arg = String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
            case "i":
              arg = parseInt(arg, 10);
              break;
            case "j":
              arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
              break;
            case "e":
              arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
              break;
            case "f":
              arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
              break;
            case "g":
              arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
              break;
            case "o":
              arg = (parseInt(arg, 10) >>> 0).toString(8);
              break;
            case "s":
              arg = String(arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "t":
              arg = String(!!arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "T":
              arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "u":
              arg = parseInt(arg, 10) >>> 0;
              break;
            case "v":
              arg = arg.valueOf();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "x":
              arg = (parseInt(arg, 10) >>> 0).toString(16);
              break;
            case "X":
              arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
              break;
          }
          if (re.json.test(ph.type)) {
            output += arg;
          } else {
            if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
              sign = is_positive ? "+" : "-";
              arg = arg.toString().replace(re.sign, "");
            } else {
              sign = "";
            }
            pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
            pad_length = ph.width - (sign + arg).length;
            pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
            output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
          }
        }
      }
      return output;
    }
    var sprintf_cache = Object.create(null);
    function sprintf_parse(fmt) {
      if (sprintf_cache[fmt]) {
        return sprintf_cache[fmt];
      }
      var _fmt = fmt, match, parse_tree = [], arg_names = 0;
      while (_fmt) {
        if ((match = re.text.exec(_fmt)) !== null) {
          parse_tree.push(match[0]);
        } else if ((match = re.modulo.exec(_fmt)) !== null) {
          parse_tree.push("%");
        } else if ((match = re.placeholder.exec(_fmt)) !== null) {
          if (match[2]) {
            arg_names |= 1;
            var field_list = [], replacement_field = match[2], field_match = [];
            if ((field_match = re.key.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else {
                  throw new SyntaxError("[sprintf] failed to parse named argument key");
                }
              }
            } else {
              throw new SyntaxError("[sprintf] failed to parse named argument key");
            }
            match[2] = field_list;
          } else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
          }
          parse_tree.push({
            placeholder: match[0],
            param_no: match[1],
            keys: match[2],
            sign: match[3],
            pad_char: match[4],
            align: match[5],
            width: match[6],
            precision: match[7],
            type: match[8]
          });
        } else {
          throw new SyntaxError("[sprintf] unexpected placeholder");
        }
        _fmt = _fmt.substring(match[0].length);
      }
      return sprintf_cache[fmt] = parse_tree;
    }
    if (typeof exports2 !== "undefined") {
      exports2.sprintf = sprintf;
      exports2.vsprintf = vsprintf;
    }
    if (typeof window !== "undefined") {
      window["sprintf"] = sprintf;
      window["vsprintf"] = vsprintf;
      if (typeof define === "function" && define["amd"]) {
        define(function() {
          return {
            sprintf,
            vsprintf
          };
        });
      }
    }
  })();
});

// ../../node_modules/pm2/lib/API/Dashboard.js
var require_Dashboard = __commonJS((exports2, module2) => {
  var timeSince = function(date) {
    var seconds = Math.floor((new Date - date) / 1000);
    var interval = Math.floor(seconds / 31536000);
    if (interval > 1) {
      return interval + "Y";
    }
    interval = Math.floor(seconds / 2592000);
    if (interval > 1) {
      return interval + "M";
    }
    interval = Math.floor(seconds / 86400);
    if (interval > 1) {
      return interval + "D";
    }
    interval = Math.floor(seconds / 3600);
    if (interval > 1) {
      return interval + "h";
    }
    interval = Math.floor(seconds / 60);
    if (interval > 1) {
      return interval + "m";
    }
    return Math.floor(seconds) + "s";
  };
  var gradient = function(p2, rgb_beginning, rgb_end) {
    var w = p2 / 100 * 2 - 1;
    var w1 = (w + 1) / 2;
    var w2 = 1 - w1;
    var rgb = [
      parseInt(rgb_beginning[0] * w1 + rgb_end[0] * w2),
      parseInt(rgb_beginning[1] * w1 + rgb_end[1] * w2),
      parseInt(rgb_beginning[2] * w1 + rgb_end[2] * w2)
    ];
    return "#" + ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1);
  };
  var os = __require("os");
  var p = __require("path");
  var blessed = require_blessed();
  var debug = require_src()("pm2:monit");
  var printf = require_sprintf().sprintf;
  var totalMem = os.totalmem();
  var Dashboard = {};
  var DEFAULT_PADDING = {
    top: 0,
    left: 1,
    right: 1
  };
  var WIDTH_LEFT_PANEL = 30;
  Dashboard.init = function() {
    this.screen = blessed.screen({
      smartCSR: true,
      fullUnicode: true
    });
    this.screen.title = "PM2 Dashboard";
    this.logLines = {};
    this.list = blessed.list({
      top: "0",
      left: "0",
      width: WIDTH_LEFT_PANEL + "%",
      height: "70%",
      padding: 0,
      scrollbar: {
        ch: " ",
        inverse: false
      },
      border: {
        type: "line"
      },
      keys: true,
      autoCommandKeys: true,
      tags: true,
      style: {
        selected: {
          bg: "blue",
          fg: "white"
        },
        scrollbar: {
          bg: "blue",
          fg: "black"
        },
        fg: "white",
        border: {
          fg: "blue"
        },
        header: {
          fg: "blue"
        }
      }
    });
    this.list.on("select item", (item, i2) => {
      this.logBox.clearItems();
    });
    this.logBox = blessed.list({
      label: " Logs ",
      top: "0",
      left: WIDTH_LEFT_PANEL + "%",
      width: 100 - WIDTH_LEFT_PANEL + "%",
      height: "70%",
      padding: DEFAULT_PADDING,
      scrollable: true,
      scrollbar: {
        ch: " ",
        inverse: false
      },
      keys: true,
      autoCommandKeys: true,
      tags: true,
      border: {
        type: "line"
      },
      style: {
        fg: "white",
        border: {
          fg: "white"
        },
        scrollbar: {
          bg: "blue",
          fg: "black"
        }
      }
    });
    this.metadataBox = blessed.box({
      label: " Metadata ",
      top: "70%",
      left: WIDTH_LEFT_PANEL + "%",
      width: 100 - WIDTH_LEFT_PANEL + "%",
      height: "26%",
      padding: DEFAULT_PADDING,
      scrollable: true,
      scrollbar: {
        ch: " ",
        inverse: false
      },
      keys: true,
      autoCommandKeys: true,
      tags: true,
      border: {
        type: "line"
      },
      style: {
        fg: "white",
        border: {
          fg: "white"
        },
        scrollbar: {
          bg: "blue",
          fg: "black"
        }
      }
    });
    this.metricsBox = blessed.list({
      label: " Custom Metrics ",
      top: "70%",
      left: "0%",
      width: WIDTH_LEFT_PANEL + "%",
      height: "26%",
      padding: DEFAULT_PADDING,
      scrollbar: {
        ch: " ",
        inverse: false
      },
      keys: true,
      autoCommandKeys: true,
      tags: true,
      border: {
        type: "line"
      },
      style: {
        fg: "white",
        border: {
          fg: "white"
        },
        scrollbar: {
          bg: "blue",
          fg: "black"
        }
      }
    });
    this.box4 = blessed.text({
      content: " left/right: switch boards | up/down/mouse: scroll | Ctrl-C: exit{|} {cyan-fg}{bold}To go further check out https://pm2.io/{/}  ",
      left: "0%",
      top: "95%",
      width: "100%",
      height: "6%",
      valign: "middle",
      tags: true,
      style: {
        fg: "white"
      }
    });
    this.list.focus();
    this.screen.append(this.list);
    this.screen.append(this.logBox);
    this.screen.append(this.metadataBox);
    this.screen.append(this.metricsBox);
    this.screen.append(this.box4);
    this.list.setLabel(" Process List ");
    this.screen.render();
    var that = this;
    var i = 0;
    var boards = ["list", "logBox", "metricsBox", "metadataBox"];
    this.screen.key(["left", "right"], function(ch, key) {
      key.name === "left" ? i-- : i++;
      if (i == 4)
        i = 0;
      if (i == -1)
        i = 3;
      that[boards[i]].focus();
      that[boards[i]].style.border.fg = "blue";
      if (key.name === "left") {
        if (i == 3)
          that[boards[0]].style.border.fg = "white";
        else
          that[boards[i + 1]].style.border.fg = "white";
      } else {
        if (i == 0)
          that[boards[3]].style.border.fg = "white";
        else
          that[boards[i - 1]].style.border.fg = "white";
      }
    });
    this.screen.key(["escape", "q", "C-c"], function(ch, key) {
      this.screen.destroy();
      process.exit(0);
    });
    setInterval(function() {
      that.screen.render();
    }, 300);
    return this;
  };
  Dashboard.refresh = function(processes) {
    debug("Monit refresh");
    if (!processes) {
      this.list.setItem(0, "No process available");
      return;
    }
    if (processes.length != this.list.items.length) {
      this.list.clearItems();
    }
    var mem = 0;
    processes.forEach(function(proc2) {
      mem += proc2.monit.memory;
    });
    processes.sort(function(a, b) {
      if (a.pm2_env.name < b.pm2_env.name)
        return -1;
      if (a.pm2_env.name > b.pm2_env.name)
        return 1;
      return 0;
    });
    for (var i = 0;i < processes.length; i++) {
      var memPercent = processes[i].monit.memory / mem * 100;
      var status = processes[i].pm2_env.status == "online" ? "{green-fg}" : "{red-fg}";
      status = status + "{bold}" + processes[i].pm2_env.status + "{/}";
      var name2 = processes[i].pm2_env.name || p.basename(processes[i].pm2_env.pm_exec_path);
      var item = printf("[%2s] %s {|} Mem: {bold}{%s-fg}%3d{/} MB    CPU: {bold}{%s-fg}%2d{/} %s  %s", processes[i].pm2_env.pm_id, name2, gradient(memPercent, [255, 0, 0], [0, 255, 0]), (processes[i].monit.memory / 1048576).toFixed(2), gradient(processes[i].monit.cpu, [255, 0, 0], [0, 255, 0]), processes[i].monit.cpu, "%", status);
      if (this.list.getItem(i)) {
        this.list.setItem(i, item);
      } else {
        this.list.pushItem(item);
      }
      var proc = processes[this.list.selected];
      let process_id = proc.pm_id;
      let logs = this.logLines[process_id];
      if (typeof logs !== "undefined") {
        this.logBox.setItems(logs);
        if (!this.logBox.focused) {
          this.logBox.setScrollPerc(100);
        }
      } else {
        this.logBox.clearItems();
      }
      this.logBox.setLabel(`  ${proc.pm2_env.name} Logs  `);
      this.metadataBox.setLine(0, "App Name              " + "{bold}" + proc.pm2_env.name + "{/}");
      this.metadataBox.setLine(1, "Namespace             " + "{bold}" + proc.pm2_env.namespace + "{/}");
      this.metadataBox.setLine(2, "Version               " + "{bold}" + proc.pm2_env.version + "{/}");
      this.metadataBox.setLine(3, "Restarts              " + proc.pm2_env.restart_time);
      this.metadataBox.setLine(4, "Uptime                " + (proc.pm2_env.pm_uptime && proc.pm2_env.status == "online" ? timeSince(proc.pm2_env.pm_uptime) : 0));
      this.metadataBox.setLine(5, "Script path           " + proc.pm2_env.pm_exec_path);
      this.metadataBox.setLine(6, "Script args           " + (proc.pm2_env.args ? (typeof proc.pm2_env.args == "string" ? JSON.parse(proc.pm2_env.args.replace(/'/g, '"')) : proc.pm2_env.args).join(" ") : "N/A"));
      this.metadataBox.setLine(7, "Interpreter           " + proc.pm2_env.exec_interpreter);
      this.metadataBox.setLine(8, "Interpreter args      " + (proc.pm2_env.node_args.length != 0 ? proc.pm2_env.node_args : "N/A"));
      this.metadataBox.setLine(9, "Exec mode             " + (proc.pm2_env.exec_mode == "fork_mode" ? "{bold}fork{/}" : "{blue-fg}{bold}cluster{/}"));
      this.metadataBox.setLine(10, "Node.js version       " + proc.pm2_env.node_version);
      this.metadataBox.setLine(11, "watch & reload        " + (proc.pm2_env.watch ? "{green-fg}{bold}\u2714{/}" : "{red-fg}{bold}\u2718{/}"));
      this.metadataBox.setLine(12, "Unstable restarts     " + proc.pm2_env.unstable_restarts);
      this.metadataBox.setLine(13, "Comment               " + (proc.pm2_env.versioning ? proc.pm2_env.versioning.comment : "N/A"));
      this.metadataBox.setLine(14, "Revision              " + (proc.pm2_env.versioning ? proc.pm2_env.versioning.revision : "N/A"));
      this.metadataBox.setLine(15, "Branch                " + (proc.pm2_env.versioning ? proc.pm2_env.versioning.branch : "N/A"));
      this.metadataBox.setLine(16, "Remote url            " + (proc.pm2_env.versioning ? proc.pm2_env.versioning.url : "N/A"));
      this.metadataBox.deleteLine(17);
      this.metadataBox.setLine(17, "Last update           " + (proc.pm2_env.versioning ? proc.pm2_env.versioning.update_time : "N/A"));
      if (Object.keys(proc.pm2_env.axm_monitor).length != this.metricsBox.items.length) {
        this.metricsBox.clearItems();
      }
      var j = 0;
      for (var key in proc.pm2_env.axm_monitor) {
        var metric_name = proc.pm2_env.axm_monitor[key].hasOwnProperty("value") ? proc.pm2_env.axm_monitor[key].value : proc.pm2_env.axm_monitor[key];
        var metric_unit = proc.pm2_env.axm_monitor[key].hasOwnProperty("unit") ? proc.pm2_env.axm_monitor[key].unit : null;
        var probe = `{bold}${key}{/} {|} ${metric_name}${metric_unit == null ? "" : " " + metric_unit}`;
        if (this.metricsBox.getItem(j)) {
          this.metricsBox.setItem(j, probe);
        } else {
          this.metricsBox.pushItem(probe);
        }
        j++;
      }
      this.screen.render();
    }
    return this;
  };
  Dashboard.log = function(type2, data) {
    var that = this;
    if (typeof this.logLines[data.process.pm_id] == "undefined") {
      this.logLines[data.process.pm_id] = [];
    }
    switch (type2) {
      case "PM2":
        var color = "{blue-fg}";
        break;
      case "out":
        var color = "{green-fg}";
        break;
      case "err":
        var color = "{red-fg}";
        break;
      default:
        var color = "{white-fg}";
    }
    var logs = data.data.split("\n");
    logs.forEach((log) => {
      if (log.length > 0) {
        this.logLines[data.process.pm_id].push(color + data.process.name + "{/} > " + log);
        let count = 0;
        let max_count = 0;
        let leading_process_id = -1;
        for (var process_id in this.logLines) {
          count += this.logLines[process_id].length;
          if (this.logLines[process_id].length > max_count) {
            leading_process_id = process_id;
            max_count = this.logLines[process_id].length;
          }
        }
        if (count > 200) {
          this.logLines[leading_process_id].shift();
        }
      }
    });
    return this;
  };
  module2.exports = Dashboard;
});

// ../../node_modules/charm/lib/encode.js
var require_encode2 = __commonJS((exports2, module2) => {
  var encode = module2.exports = function(xs) {
    function bytes(s) {
      if (typeof s === "string") {
        return s.split("").map(ord);
      } else if (Array.isArray(s)) {
        return s.reduce(function(acc, c) {
          return acc.concat(bytes(c));
        }, []);
      }
    }
    return new Buffer([27].concat(bytes(xs)));
  };
  var ord = encode.ord = function ord(c) {
    return c.charCodeAt(0);
  };
});

// ../../node_modules/charm/index.js
var require_charm = __commonJS((exports2, module2) => {
  var tty = __require("tty");
  var encode = require_encode2();
  var Stream = __require("stream").Stream;
  var exports2 = module2.exports = function() {
    var input = null;
    function setInput(s) {
      if (input)
        throw new Error("multiple inputs specified");
      else
        input = s;
    }
    var output = null;
    function setOutput(s) {
      if (output)
        throw new Error("multiple outputs specified");
      else
        output = s;
    }
    for (var i = 0;i < arguments.length; i++) {
      var arg = arguments[i];
      if (!arg)
        continue;
      if (arg.readable)
        setInput(arg);
      else if (arg.stdin || arg.input)
        setInput(arg.stdin || arg.input);
      if (arg.writable)
        setOutput(arg);
      else if (arg.stdout || arg.output)
        setOutput(arg.stdout || arg.output);
    }
    if (input && typeof input.fd === "number" && tty.isatty(input.fd)) {
      if (process.stdin.setRawMode) {
        process.stdin.setRawMode(true);
      } else
        tty.setRawMode(true);
    }
    var charm = new Charm;
    if (input) {
      input.pipe(charm);
    }
    if (output) {
      charm.pipe(output);
    }
    charm.once("^C", process.exit);
    charm.once("end", function() {
      if (input) {
        if (typeof input.fd === "number" && tty.isatty(input.fd)) {
          if (process.stdin.setRawMode) {
            process.stdin.setRawMode(false);
          } else
            tty.setRawMode(false);
        }
        input.destroy();
      }
    });
    return charm;
  };
  var Charm = exports2.Charm = function Charm() {
    this.writable = true;
    this.readable = true;
    this.pending = [];
  };
  Charm.prototype = new Stream;
  Charm.prototype.write = function(buf) {
    var self2 = this;
    if (self2.pending.length) {
      var codes = extractCodes(buf);
      var matched = false;
      for (var i = 0;i < codes.length; i++) {
        for (var j = 0;j < self2.pending.length; j++) {
          var cb = self2.pending[j];
          if (cb(codes[i])) {
            matched = true;
            self2.pending.splice(j, 1);
            break;
          }
        }
      }
      if (matched)
        return;
    }
    if (buf.length === 1) {
      if (buf[0] === 3)
        self2.emit("^C");
      if (buf[0] === 4)
        self2.emit("^D");
    }
    self2.emit("data", buf);
    return self2;
  };
  Charm.prototype.destroy = function() {
    this.end();
  };
  Charm.prototype.end = function(buf) {
    if (buf)
      this.write(buf);
    this.emit("end");
  };
  Charm.prototype.reset = function(cb) {
    this.write(encode("c"));
    return this;
  };
  Charm.prototype.position = function(x, y) {
    if (typeof x === "function") {
      var cb = x;
      this.pending.push(function(buf) {
        if (buf[0] === 27 && buf[1] === encode.ord("[") && buf[buf.length - 1] === encode.ord("R")) {
          var pos = buf.toString().slice(2, -1).split(";").map(Number);
          cb(pos[1], pos[0]);
          return true;
        }
      });
      this.write(encode("[6n"));
    } else {
      this.write(encode("[" + Math.floor(y) + ";" + Math.floor(x) + "f"));
    }
    return this;
  };
  Charm.prototype.move = function(x, y) {
    var bufs = [];
    if (y < 0)
      this.up(-y);
    else if (y > 0)
      this.down(y);
    if (x > 0)
      this.right(x);
    else if (x < 0)
      this.left(-x);
    return this;
  };
  Charm.prototype.up = function(y) {
    if (y === undefined)
      y = 1;
    this.write(encode("[" + Math.floor(y) + "A"));
    return this;
  };
  Charm.prototype.down = function(y) {
    if (y === undefined)
      y = 1;
    this.write(encode("[" + Math.floor(y) + "B"));
    return this;
  };
  Charm.prototype.right = function(x) {
    if (x === undefined)
      x = 1;
    this.write(encode("[" + Math.floor(x) + "C"));
    return this;
  };
  Charm.prototype.left = function(x) {
    if (x === undefined)
      x = 1;
    this.write(encode("[" + Math.floor(x) + "D"));
    return this;
  };
  Charm.prototype.column = function(x) {
    this.write(encode("[" + Math.floor(x) + "G"));
    return this;
  };
  Charm.prototype.push = function(withAttributes) {
    this.write(encode(withAttributes ? "7" : "[s"));
    return this;
  };
  Charm.prototype.pop = function(withAttributes) {
    this.write(encode(withAttributes ? "8" : "[u"));
    return this;
  };
  Charm.prototype.erase = function(s) {
    if (s === "end" || s === "$") {
      this.write(encode("[K"));
    } else if (s === "start" || s === "^") {
      this.write(encode("[1K"));
    } else if (s === "line") {
      this.write(encode("[2K"));
    } else if (s === "down") {
      this.write(encode("[J"));
    } else if (s === "up") {
      this.write(encode("[1J"));
    } else if (s === "screen") {
      this.write(encode("[1J"));
    } else {
      this.emit("error", new Error("Unknown erase type: " + s));
    }
    return this;
  };
  Charm.prototype.display = function(attr) {
    var c = {
      reset: 0,
      bright: 1,
      dim: 2,
      underscore: 4,
      blink: 5,
      reverse: 7,
      hidden: 8
    }[attr];
    if (c === undefined) {
      this.emit("error", new Error("Unknown attribute: " + attr));
    }
    this.write(encode("[" + c + "m"));
    return this;
  };
  Charm.prototype.foreground = function(color) {
    if (typeof color === "number") {
      if (color < 0 || color >= 256) {
        this.emit("error", new Error("Color out of range: " + color));
      }
      this.write(encode("[38;5;" + color + "m"));
    } else {
      var c = {
        black: 30,
        red: 31,
        green: 32,
        yellow: 33,
        blue: 34,
        magenta: 35,
        cyan: 36,
        white: 37
      }[color.toLowerCase()];
      if (!c)
        this.emit("error", new Error("Unknown color: " + color));
      this.write(encode("[" + c + "m"));
    }
    return this;
  };
  Charm.prototype.background = function(color) {
    if (typeof color === "number") {
      if (color < 0 || color >= 256) {
        this.emit("error", new Error("Color out of range: " + color));
      }
      this.write(encode("[48;5;" + color + "m"));
    } else {
      var c = {
        black: 40,
        red: 41,
        green: 42,
        yellow: 43,
        blue: 44,
        magenta: 45,
        cyan: 46,
        white: 47
      }[color.toLowerCase()];
      if (!c)
        this.emit("error", new Error("Unknown color: " + color));
      this.write(encode("[" + c + "m"));
    }
    return this;
  };
  Charm.prototype.cursor = function(visible) {
    this.write(encode(visible ? "[?25h" : "[?25l"));
    return this;
  };
  var extractCodes = exports2.extractCodes = function(buf) {
    var codes = [];
    var start = -1;
    for (var i = 0;i < buf.length; i++) {
      if (buf[i] === 27) {
        if (start >= 0)
          codes.push(buf.slice(start, i));
        start = i;
      } else if (start >= 0 && i === buf.length - 1) {
        codes.push(buf.slice(start));
      }
    }
    return codes;
  };
});

// ../../node_modules/pm2-multimeter/lib/bar.js
var require_bar = __commonJS((exports2, module2) => {
  var Bar = module2.exports = function(charm, x, y, params2) {
    this.charm = charm;
    this.x = x;
    this.y = y;
    this.width = params2.width || 10;
    this.offset = params2.offset || 0;
    this.before = params2.before || "[";
    this.after = params2.after || "] ";
    this.solid = params2.solid || {
      background: "blue",
      foreground: "white",
      text: "|"
    };
    this.empty = params2.empty || {
      background: null,
      foreground: null,
      text: " "
    };
    this.progress = {
      percent: 0,
      ratio: 0
    };
  };
  Bar.prototype.draw = function(bars, msg) {
    bars = Math.floor(bars);
    this.charm.push(true);
    if (this.y.toString().match(/^[+-]/)) {
      if (this.y.toString().match(/^-/)) {
        this.charm.up(-this.y + this.offset);
      } else if (this.y.toString().match(/^\+/)) {
        this.charm.down(+this.y - this.offset);
      }
      this.charm.column(+this.x);
    } else {
      this.charm.position(this.x, this.y);
    }
    this.charm.write(this.before);
    if (this.solid.background) {
      this.charm.background(this.solid.background);
    }
    if (this.solid.foreground) {
      this.charm.foreground(this.solid.foreground);
    }
    this.charm.write(Array(bars + 1).join(this.solid.text)).display("reset");
    if (this.empty.background) {
      this.charm.background(this.empty.background);
    }
    if (this.empty.foreground) {
      this.charm.foreground(this.empty.foreground);
    }
    this.charm.write(Array(this.width - bars + 1).join(this.empty.text)).write(this.after + msg);
    this.charm.pop(true);
    return this;
  };
  Bar.prototype.percent = function(p, msg) {
    if (p === undefined) {
      return this.progress.percent;
    } else {
      p = Math.min(100, p);
      this.progress.percent = p;
      this.progress.ratio = [p, 100];
      this.draw(this.width * p / 100, msg || Math.floor(p) + " %");
      return this;
    }
  };
  Bar.prototype.ratio = function(n, d, msg) {
    if (n === undefined && d === undefined) {
      return this.progress.ratio;
    } else {
      var f = n / d;
      this.progress.ratio = [n, d];
      this.progress.percent = f * 100;
      this.draw(this.width * f, msg || n + " / " + d);
      return this;
    }
  };
});

// ../../node_modules/pm2-multimeter/index.js
var require_pm2_multimeter = __commonJS((exports2, module2) => {
  var charmer = require_charm();
  var Bar = require_bar();
  var exports2 = module2.exports = function(c) {
    if (c instanceof charmer.Charm) {
      var charm = c;
    } else {
      var charm = charmer.apply(null, arguments);
      charm.on("^C", function() {
        charm.destroy();
      });
    }
    var multi = function(x, y, params2) {
      if (typeof x === "object") {
        params2 = x;
        x = params2.x;
        y = params2.y;
      }
      if (!params2)
        params2 = {};
      if (x === undefined)
        x = "+0";
      if (y === undefined)
        y = "+0";
      var bar = new Bar(charm, x, y, params2);
      multi.bars.push(bar);
      bar.offset = multi.offset;
      multi.on("offset", function(o) {
        bar.offset = o;
      });
      return bar;
    };
    multi.bars = [];
    multi.rel = function(x, y, params2) {
      return multi(x, "-" + y, params2);
    };
    multi.drop = function(params2, cb) {
      if (!cb) {
        cb = params2;
        params2 = {};
      }
      charm.position(function(x, y) {
        var bar = new Bar(charm, x, y, params2);
        multi.bars.push(bar);
        multi.on("offset", function(o) {
          bar.offset = o;
        });
        cb(bar);
      });
    };
    multi.charm = charm;
    charm.setMaxListeners(0);
    multi.destroy = charm.destroy.bind(charm);
    multi.on = charm.on.bind(charm);
    multi.emit = charm.emit.bind(charm);
    multi.removeListener = charm.removeListener.bind(charm);
    multi.write = charm.write.bind(charm);
    (function() {
      var offset = 0;
      Object.defineProperty(multi, "offset", {
        set: function(o) {
          offset = o;
          multi.emit("offset", o);
        },
        get: function() {
          return offset;
        }
      });
    })();
    return multi;
  };
});

// ../../node_modules/pm2/lib/API/Monit.js
var require_Monit = __commonJS((exports2, module2) => {
  var multimeter = require_pm2_multimeter();
  var os = __require("os");
  var p = __require("path");
  var chalk = require_source();
  var UX = require_UX();
  var debug = require_src()("pm2:monit");
  var RATIO_T1 = Math.floor(os.totalmem() / 500);
  var RATIO_T2 = Math.floor(os.totalmem() / 50);
  var RATIO_T3 = Math.floor(os.totalmem() / 5);
  var RATIO_T4 = Math.floor(os.totalmem());
  var Monit = {};
  Object.size = function(obj) {
    var size2 = 0, key;
    for (key in obj) {
      if (obj.hasOwnProperty(key))
        size2++;
    }
    return size2;
  };
  Monit.reset = function(msg) {
    this.multi.charm.reset();
    this.multi.write(`\x1B[32m\u232C PM2 \x1B[39mmonitoring\x1B[96m (To go further check out https://app.pm2.io) \x1B[39m

`);
    if (msg) {
      this.multi.write(msg);
    }
    this.bars = {};
    return this;
  };
  Monit.init = function() {
    this.multi = multimeter(process);
    this.multi.on("^C", this.stop);
    this.reset();
    return this;
  };
  Monit.stop = function() {
    this.multi.charm.destroy();
    process.exit(0);
  };
  Monit.refresh = function(processes) {
    debug("Monit refresh");
    if (!processes) {
      processes = [];
    }
    var num = processes.length;
    this.num_bars = Object.size(this.bars);
    if (num !== this.num_bars) {
      debug("Monit addProcesses - actual: %s, new: %s", this.num_bars, num);
      return this.addProcesses(processes);
    } else {
      if (num === 0) {
        return;
      }
      debug("Monit refresh");
      var proc;
      for (var i = 0;i < num; i++) {
        proc = processes[i];
        if (this.bars[proc.pm_id] && proc.pm2_env.status !== this.bars[proc.pm_id].status) {
          debug("bars for %s does not exist", proc.pm_id);
          this.addProcesses(processes);
          break;
        }
        this.updateBars(proc);
      }
    }
    return this;
  };
  Monit.addProcess = function(proc, i) {
    if (proc.pm_id in this.bars) {
      return;
    }
    if (proc.monit.error)
      throw new Error(JSON.stringify(proc.monit.error));
    var process_name = proc.pm2_env.name || p.basename(proc.pm2_env.pm_exec_path);
    var status = proc.pm2_env.status == "online" ? chalk.green.bold("\u25CF") : chalk.red.bold("\u25CF");
    this.multi.write(" " + status + " " + chalk.green.bold(process_name));
    this.multi.write("\n");
    this.multi.write("[" + proc.pm2_env.pm_id + "] [" + proc.pm2_env.exec_mode + "]\n");
    var bar_cpu = this.multi(40, i * 2 + 3 + i, {
      width: 30,
      solid: {
        text: "|",
        foreground: "white",
        background: "blue"
      },
      empty: {
        text: " "
      }
    });
    var bar_memory = this.multi(40, i * 2 + 4 + i, {
      width: 30,
      solid: {
        text: "|",
        foreground: "white",
        background: "red"
      },
      empty: {
        text: " "
      }
    });
    this.bars[proc.pm_id] = {
      memory: bar_memory,
      cpu: bar_cpu,
      status: proc.pm2_env.status
    };
    this.updateBars(proc);
    this.multi.write("\n");
    return this;
  };
  Monit.addProcesses = function(processes) {
    if (!processes) {
      processes = [];
    }
    this.reset();
    var num = processes.length;
    if (num > 0) {
      for (var i = 0;i < num; i++) {
        this.addProcess(processes[i], i);
      }
    } else {
      this.reset("No processes to monit");
    }
  };
  Monit.drawRatio = function(bar_memory, memory) {
    var scale = 0;
    if (memory < RATIO_T1)
      scale = RATIO_T1;
    else if (memory < RATIO_T2)
      scale = RATIO_T2;
    else if (memory < RATIO_T3)
      scale = RATIO_T3;
    else
      scale = RATIO_T4;
    bar_memory.ratio(memory, scale, UX.helpers.bytesToSize(memory, 3));
  };
  Monit.updateBars = function(proc) {
    if (this.bars[proc.pm_id]) {
      if (proc.pm2_env.status !== "online" || proc.pm2_env.status !== this.bars[proc.pm_id].status) {
        this.bars[proc.pm_id].cpu.percent(0, chalk.red(proc.pm2_env.status));
        this.drawRatio(this.bars[proc.pm_id].memory, 0, chalk.red(proc.pm2_env.status));
      } else if (!proc.monit) {
        this.bars[proc.pm_id].cpu.percent(0, chalk.red("No data"));
        this.drawRatio(this.bars[proc.pm_id].memory, 0, chalk.red("No data"));
      } else {
        this.bars[proc.pm_id].cpu.percent(proc.monit.cpu);
        this.drawRatio(this.bars[proc.pm_id].memory, proc.monit.memory);
      }
    }
    return this;
  };
  module2.exports = Monit;
});

// ../../node_modules/pm2/lib/API/Extra.js
var require_Extra = __commonJS((exports2, module2) => {
  var __dirname = "C:\\Users\\balle\\Documents\\GitHub\\echoesmd\\node_modules\\pm2\\lib\\API";
  var cst = require_constants2();
  var Common = require_Common();
  var UX = require_UX();
  var chalk = require_source();
  var path2 = __require("path");
  var fs = __require("fs");
  var fmt = require_fmt();
  var dayjs = require_dayjs_min();
  var pkg = require_package();
  var copyDirSync = require_copydirSync();
  module2.exports = function(CLI) {
    CLI.prototype.getVersion = function(cb) {
      var that = this;
      that.Client.executeRemote("getVersion", {}, function(err) {
        return cb ? cb.apply(null, arguments) : that.exitCli(cst.SUCCESS_EXIT);
      });
    };
    CLI.prototype.launchSysMonitoring = function(cb) {
      if (this.pm2_configuration && this.pm2_configuration.sysmonit != "true" || process.env.TRAVIS || global.it === "function" || cst.IS_WINDOWS === true)
        return cb ? cb(null) : null;
      var filepath;
      try {
        filepath = path2.dirname(__require.resolve("C:\Users\balle\Documents\GitHub\echoesmd\node_modules\pm2-sysmonit\index.js"));
      } catch (e) {
        return cb ? cb(null) : null;
      }
      this.start({
        script: filepath
      }, {
        started_as_module: true
      }, (err, res) => {
        if (err) {
          Common.printError(cst.PREFIX_MSG_ERR + "Error while trying to serve : " + err.message || err);
          return cb ? cb(err) : this.speedList(cst.ERROR_EXIT);
        }
        return cb ? cb(null) : this.speedList();
      });
    };
    CLI.prototype.env = function(app_id, cb) {
      var procs = [];
      var printed = 0;
      this.Client.executeRemote("getMonitorData", {}, (err, list) => {
        list.forEach((l) => {
          if (app_id == l.pm_id) {
            printed++;
            var env = Common.safeExtend({}, l.pm2_env);
            Object.keys(env).forEach((key) => {
              console.log(`${key}: ${chalk.green(env[key])}`);
            });
          }
        });
        if (printed == 0) {
          Common.err(`Modules with id ${app_id} not found`);
          return cb ? cb.apply(null, arguments) : this.exitCli(cst.ERROR_EXIT);
        }
        return cb ? cb.apply(null, arguments) : this.exitCli(cst.SUCCESS_EXIT);
      });
    };
    CLI.prototype.report = function() {
      var that = this;
      var Log = require_Log();
      that.Client.executeRemote("getReport", {}, function(err, report) {
        console.log();
        console.log();
        console.log();
        console.log("```");
        fmt.title("PM2 report");
        fmt.field("Date", new Date);
        fmt.sep();
        if (report && !err) {
          fmt.title(chalk.bold.blue("Daemon"));
          fmt.field("pm2d version", report.pm2_version);
          fmt.field("node version", report.node_version);
          fmt.field("node path", report.node_path);
          fmt.field("argv", report.argv);
          fmt.field("argv0", report.argv0);
          fmt.field("user", report.user);
          fmt.field("uid", report.uid);
          fmt.field("gid", report.gid);
          fmt.field("uptime", dayjs(new Date).diff(report.started_at, "minute") + "min");
        }
        fmt.sep();
        fmt.title(chalk.bold.blue("CLI"));
        fmt.field("local pm2", pkg.version);
        fmt.field("node version", process.versions.node);
        fmt.field("node path", process.env["_"] || "not found");
        fmt.field("argv", process.argv);
        fmt.field("argv0", process.argv0);
        fmt.field("user", process.env.USER || process.env.LNAME || process.env.USERNAME);
        if (cst.IS_WINDOWS === false && process.geteuid)
          fmt.field("uid", process.geteuid());
        if (cst.IS_WINDOWS === false && process.getegid)
          fmt.field("gid", process.getegid());
        var os = __require("os");
        fmt.sep();
        fmt.title(chalk.bold.blue("System info"));
        fmt.field("arch", os.arch());
        fmt.field("platform", os.platform());
        fmt.field("type", os.type());
        fmt.field("cpus", os.cpus()[0].model);
        fmt.field("cpus nb", Object.keys(os.cpus()).length);
        fmt.field("freemem", os.freemem());
        fmt.field("totalmem", os.totalmem());
        fmt.field("home", os.homedir());
        that.Client.executeRemote("getMonitorData", {}, function(err2, list) {
          fmt.sep();
          fmt.title(chalk.bold.blue("PM2 list"));
          UX.list(list, that.gl_interact_infos);
          fmt.sep();
          fmt.title(chalk.bold.blue("Daemon logs"));
          Log.tail([{
            path: cst.PM2_LOG_FILE_PATH,
            app_name: "PM2",
            type: "PM2"
          }], 20, false, function() {
            console.log("```");
            console.log();
            console.log();
            console.log(chalk.bold.green("Please copy/paste the above report in your issue on https://github.com/Unitech/pm2/issues"));
            console.log();
            console.log();
            that.exitCli(cst.SUCCESS_EXIT);
          });
        });
      });
    };
    CLI.prototype.getPID = function(app_name, cb) {
      var that = this;
      if (typeof app_name === "function") {
        cb = app_name;
        app_name = null;
      }
      this.Client.executeRemote("getMonitorData", {}, function(err, list) {
        if (err) {
          Common.printError(cst.PREFIX_MSG_ERR + err);
          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
        }
        var pids = [];
        list.forEach(function(app) {
          if (!app_name || app_name == app.name)
            pids.push(app.pid);
        });
        if (!cb) {
          Common.printOut(pids.join("\n"));
          return that.exitCli(cst.SUCCESS_EXIT);
        }
        return cb(null, pids);
      });
    };
    CLI.prototype.profile = function(type2, time, cb) {
      var that = this;
      var dayjs2 = require_dayjs_min();
      var cmd;
      if (type2 == "cpu") {
        cmd = {
          ext: ".cpuprofile",
          action: "profileCPU"
        };
      }
      if (type2 == "mem") {
        cmd = {
          ext: ".heapprofile",
          action: "profileMEM"
        };
      }
      var file = path2.join(process.cwd(), dayjs2().format("dd-HH:mm:ss") + cmd.ext);
      time = time || 1e4;
      console.log(`Starting ${cmd.action} profiling for ${time}ms...`);
      that.Client.executeRemote(cmd.action, {
        pwd: file,
        timeout: time
      }, function(err) {
        if (err) {
          console.error(err);
          return that.exitCli(1);
        }
        console.log(`Profile done in ${file}`);
        return cb ? cb.apply(null, arguments) : that.exitCli(cst.SUCCESS_EXIT);
      });
    };
    function basicMDHighlight(lines) {
      console.log("\n\n+-------------------------------------+");
      console.log(chalk.bold("README.md content:"));
      lines = lines.split("\n");
      var isInner = false;
      lines.forEach((l) => {
        if (l.startsWith("#"))
          console.log(chalk.bold.green(l));
        else if (isInner || l.startsWith("```")) {
          if (isInner && l.startsWith("```"))
            isInner = false;
          else if (isInner == false)
            isInner = true;
          console.log(chalk.grey(l));
        } else if (l.startsWith("`"))
          console.log(chalk.grey(l));
        else
          console.log(l);
      });
      console.log("+-------------------------------------+");
    }
    CLI.prototype.boilerplate = function(cb) {
      var i = 0;
      var projects = [];
      var enquirer = require_enquirer();
      const forEach2 = require_forEach();
      fs.readdir(path2.join(__dirname, "../templates/sample-apps"), (err, items) => {
        forEach2(items, (app, next) => {
          var fp = path2.join(__dirname, "../templates/sample-apps", app);
          fs.readFile(path2.join(fp, "package.json"), (err2, dt) => {
            var meta2 = JSON.parse(dt);
            meta2.fullpath = fp;
            meta2.folder_name = app;
            projects.push(meta2);
            next();
          });
        }, () => {
          const prompt = new enquirer.Select({
            name: "boilerplate",
            message: "Select a boilerplate",
            choices: projects.map((p, i2) => {
              return {
                message: `${chalk.bold.blue(p.name)} ${p.description}`,
                value: `${i2}`
              };
            })
          });
          prompt.run().then((answer) => {
            var p = projects[parseInt(answer)];
            basicMDHighlight(fs.readFileSync(path2.join(p.fullpath, "README.md")).toString());
            console.log(chalk.bold(`>> Project copied inside folder ./${p.folder_name}/\n`));
            copyDirSync(p.fullpath, path2.join(process.cwd(), p.folder_name));
            this.start(path2.join(p.fullpath, "ecosystem.config.js"), {
              cwd: p.fullpath
            }, () => {
              return cb ? cb.apply(null, arguments) : this.speedList(cst.SUCCESS_EXIT);
            });
          }).catch((e) => {
            return cb ? cb.apply(null, arguments) : this.speedList(cst.SUCCESS_EXIT);
          });
        });
      });
    };
    CLI.prototype.sendLineToStdin = function(pm_id, line, separator, cb) {
      var that = this;
      if (!cb && typeof separator == "function") {
        cb = separator;
        separator = null;
      }
      var packet = {
        pm_id,
        line: line + (separator || "\n")
      };
      that.Client.executeRemote("sendLineToStdin", packet, function(err, res) {
        if (err) {
          Common.printError(cst.PREFIX_MSG_ERR + err);
          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
        }
        return cb ? cb(null, res) : that.speedList();
      });
    };
    CLI.prototype.attach = function(pm_id, separator, cb) {
      var that = this;
      var readline = __require("readline");
      if (isNaN(pm_id)) {
        Common.printError("pm_id must be a process number (not a process name)");
        return cb ? cb(Common.retErr("pm_id must be number")) : that.exitCli(cst.ERROR_EXIT);
      }
      if (typeof separator == "function") {
        cb = separator;
        separator = null;
      }
      var rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });
      rl.on("close", function() {
        return cb ? cb() : that.exitCli(cst.SUCCESS_EXIT);
      });
      that.Client.launchBus(function(err, bus, socket) {
        if (err) {
          Common.printError(err);
          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
        }
        bus.on("log:*", function(type2, packet) {
          if (packet.process.pm_id !== parseInt(pm_id))
            return;
          process.stdout.write(packet.data);
        });
      });
      rl.on("line", function(line) {
        that.sendLineToStdin(pm_id, line, separator, function() {
        });
      });
    };
    CLI.prototype.sendDataToProcessId = function(proc_id, packet, cb) {
      var that = this;
      if (typeof proc_id === "object" && typeof packet === "function") {
        cb = packet;
        packet = proc_id;
      } else {
        packet.id = proc_id;
      }
      that.Client.executeRemote("sendDataToProcessId", packet, function(err, res) {
        if (err) {
          Common.printError(err);
          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
        }
        Common.printOut("successfully sent data to process");
        return cb ? cb(null, res) : that.speedList();
      });
    };
    CLI.prototype.msgProcess = function(opts, cb) {
      var that = this;
      that.Client.executeRemote("msgProcess", opts, cb);
    };
    CLI.prototype.trigger = function(pm_id, action_name, params2, cb) {
      if (typeof params2 === "function") {
        cb = params2;
        params2 = null;
      }
      var cmd = {
        msg: action_name
      };
      var counter = 0;
      var process_wait_count = 0;
      var that = this;
      var results = [];
      if (params2)
        cmd.opts = params2;
      if (isNaN(pm_id))
        cmd.name = pm_id;
      else
        cmd.id = pm_id;
      this.launchBus(function(err, bus) {
        bus.on("axm:reply", function(ret) {
          if (ret.process.name == pm_id || ret.process.pm_id == pm_id || ret.process.namespace == pm_id || pm_id == "all") {
            results.push(ret);
            Common.printOut("[%s:%s:%s]=%j", ret.process.name, ret.process.pm_id, ret.process.namespace, ret.data.return);
            if (++counter == process_wait_count)
              return cb ? cb(null, results) : that.exitCli(cst.SUCCESS_EXIT);
          }
        });
        that.msgProcess(cmd, function(err2, data) {
          if (err2) {
            Common.printError(err2);
            return cb ? cb(Common.retErr(err2)) : that.exitCli(cst.ERROR_EXIT);
          }
          if (data.process_count == 0) {
            Common.printError("Not any process has received a command (offline or unexistent)");
            return cb ? cb(Common.retErr("Unknown process")) : that.exitCli(cst.ERROR_EXIT);
          }
          process_wait_count = data.process_count;
          Common.printOut(chalk.bold("%s processes have received command %s"), data.process_count, action_name);
        });
      });
    };
    CLI.prototype.sendSignalToProcessName = function(signal, process_name, cb) {
      var that = this;
      that.Client.executeRemote("sendSignalToProcessName", {
        signal,
        process_name
      }, function(err, list) {
        if (err) {
          Common.printError(err);
          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
        }
        Common.printOut("successfully sent signal %s to process name %s", signal, process_name);
        return cb ? cb(null, list) : that.speedList();
      });
    };
    CLI.prototype.sendSignalToProcessId = function(signal, process_id, cb) {
      var that = this;
      that.Client.executeRemote("sendSignalToProcessId", {
        signal,
        process_id
      }, function(err, list) {
        if (err) {
          Common.printError(err);
          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
        }
        Common.printOut("successfully sent signal %s to process id %s", signal, process_id);
        return cb ? cb(null, list) : that.speedList();
      });
    };
    CLI.prototype.autoinstall = function(cb) {
      var filepath = path2.resolve(path2.dirname("Extra.js"), "../Sysinfo/ServiceDetection/ServiceDetection.js");
      this.start(filepath, (err, res) => {
        if (err) {
          Common.printError(cst.PREFIX_MSG_ERR + "Error while trying to serve : " + err.message || err);
          return cb ? cb(err) : this.speedList(cst.ERROR_EXIT);
        }
        return cb ? cb(null) : this.speedList();
      });
    };
    CLI.prototype.serve = function(target_path, port, opts, commander, cb) {
      var that = this;
      var servePort = process.env.PM2_SERVE_PORT || port || 8080;
      var servePath = path2.resolve(process.env.PM2_SERVE_PATH || target_path || ".");
      var filepath = path2.resolve(path2.dirname("Extra.js"), "./Serve.js");
      if (typeof commander.name === "string")
        opts.name = commander.name;
      else
        opts.name = "static-page-server-" + servePort;
      if (!opts.env)
        opts.env = {};
      opts.env.PM2_SERVE_PORT = servePort;
      opts.env.PM2_SERVE_PATH = servePath;
      opts.env.PM2_SERVE_SPA = opts.spa;
      if (opts.basicAuthUsername && opts.basicAuthPassword) {
        opts.env.PM2_SERVE_BASIC_AUTH = "true";
        opts.env.PM2_SERVE_BASIC_AUTH_USERNAME = opts.basicAuthUsername;
        opts.env.PM2_SERVE_BASIC_AUTH_PASSWORD = opts.basicAuthPassword;
      }
      if (opts.monitor) {
        opts.env.PM2_SERVE_MONITOR = opts.monitor;
      }
      opts.cwd = servePath;
      this.start(filepath, opts, function(err, res) {
        if (err) {
          Common.printError(cst.PREFIX_MSG_ERR + "Error while trying to serve : " + err.message || err);
          return cb ? cb(err) : that.speedList(cst.ERROR_EXIT);
        }
        Common.printOut(cst.PREFIX_MSG + "Serving " + servePath + " on port " + servePort);
        return cb ? cb(null, res) : that.speedList();
      });
    };
    CLI.prototype.ping = function(cb) {
      var that = this;
      that.Client.executeRemote("ping", {}, function(err, res) {
        if (err) {
          Common.printError(err);
          return cb ? cb(new Error(err)) : that.exitCli(cst.ERROR_EXIT);
        }
        Common.printOut(res);
        return cb ? cb(null, res) : that.exitCli(cst.SUCCESS_EXIT);
      });
    };
    CLI.prototype.remote = function(command, opts, cb) {
      var that = this;
      that[command](opts.name, function(err_cmd, ret) {
        if (err_cmd)
          console.error(err_cmd);
        console.log("Command %s finished", command);
        return cb(err_cmd, ret);
      });
    };
    CLI.prototype.remoteV2 = function(command, opts, cb) {
      var that = this;
      if (that[command].length == 1)
        return that[command](cb);
      opts.args.push(cb);
      return that[command].apply(this, opts.args);
    };
    CLI.prototype.generateSample = function(mode) {
      var that = this;
      var templatePath;
      if (mode == "simple")
        templatePath = path2.join(cst.TEMPLATE_FOLDER, cst.APP_CONF_TPL_SIMPLE);
      else
        templatePath = path2.join(cst.TEMPLATE_FOLDER, cst.APP_CONF_TPL);
      var sample = fs.readFileSync(templatePath);
      var dt = sample.toString();
      var f_name = "ecosystem.config.js";
      var pwd = process.env.PWD || process.cwd();
      try {
        fs.writeFileSync(path2.join(pwd, f_name), dt);
      } catch (e) {
        console.error(e.stack || e);
        return that.exitCli(cst.ERROR_EXIT);
      }
      Common.printOut("File %s generated", path2.join(pwd, f_name));
      that.exitCli(cst.SUCCESS_EXIT);
    };
    CLI.prototype.dashboard = function(cb) {
      var that = this;
      var Dashboard = require_Dashboard();
      if (cb)
        return cb(new Error("Dashboard cant be called programmatically"));
      Dashboard.init();
      this.Client.launchBus(function(err, bus) {
        if (err) {
          console.error("Error launchBus: " + err);
          that.exitCli(cst.ERROR_EXIT);
        }
        bus.on("log:*", function(type2, data) {
          Dashboard.log(type2, data);
        });
      });
      process.on("SIGINT", function() {
        this.Client.disconnectBus(function() {
          process.exit(cst.SUCCESS_EXIT);
        });
      });
      function refreshDashboard() {
        that.Client.executeRemote("getMonitorData", {}, function(err, list) {
          if (err) {
            console.error("Error retrieving process list: " + err);
            that.exitCli(cst.ERROR_EXIT);
          }
          Dashboard.refresh(list);
          setTimeout(function() {
            refreshDashboard();
          }, 800);
        });
      }
      refreshDashboard();
    };
    CLI.prototype.monit = function(cb) {
      var that = this;
      var Monit = require_Monit();
      if (cb)
        return cb(new Error("Monit cant be called programmatically"));
      Monit.init();
      function launchMonitor() {
        that.Client.executeRemote("getMonitorData", {}, function(err, list) {
          if (err) {
            console.error("Error retrieving process list: " + err);
            that.exitCli(conf.ERROR_EXIT);
          }
          Monit.refresh(list);
          setTimeout(function() {
            launchMonitor();
          }, 400);
        });
      }
      launchMonitor();
    };
    CLI.prototype.inspect = function(app_name, cb) {
      const that = this;
      this.trigger(app_name, "internal:inspect", function(err, res) {
        if (res && res[0]) {
          if (res[0].data.return === "") {
            Common.printOut(`Inspect disabled on ${app_name}`);
          } else {
            Common.printOut(`Inspect enabled on ${app_name} => go to chrome : chrome://inspect !!!`);
          }
        } else {
          Common.printOut(`Unable to activate inspect mode on ${app_name} !!!`);
        }
        that.exitCli(cst.SUCCESS_EXIT);
      });
    };
  };
});

// ../../node_modules/pm2-deploy/deploy
var exports_deploy = {};
__export(exports_deploy, {
  default: () => deploy_default
});
var deploy_default;
var init_deploy = __esm(() => {
  deploy_default = "./deploy-b4f7c8167a9f86b3.";
});

// ../../node_modules/run-series/index.js
var require_run_series = __commonJS((exports2, module2) => {
  var runSeries = function(tasks, cb) {
    var current = 0;
    var results = [];
    var isSync = true;
    function done(err) {
      function end() {
        if (cb)
          cb(err, results);
      }
      if (isSync)
        process.nextTick(end);
      else
        end();
    }
    function each(err, result) {
      results.push(result);
      if (++current >= tasks.length || err)
        done(err);
      else
        tasks[current](each);
    }
    if (tasks.length > 0)
      tasks[0](each);
    else
      done(null);
    isSync = false;
  };
  /*! run-series. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  module2.exports = runSeries;
});

// ../../node_modules/tv4/tv4.js
var require_tv4 = __commonJS((exports2, module2) => {
  (function(global2, factory) {
    if (typeof define === "function" && define.amd) {
      define([], factory);
    } else if (typeof module2 !== "undefined" && exports2) {
      module2.exports = factory();
    } else {
      global2.tv4 = factory();
    }
  })(exports2, function() {
    if (!Object.keys) {
      Object.keys = function() {
        var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !{ toString: null }.propertyIsEnumerable("toString"), dontEnums = [
          "toString",
          "toLocaleString",
          "valueOf",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "constructor"
        ], dontEnumsLength = dontEnums.length;
        return function(obj) {
          if (typeof obj !== "object" && typeof obj !== "function" || obj === null) {
            throw new TypeError("Object.keys called on non-object");
          }
          var result = [];
          for (var prop in obj) {
            if (hasOwnProperty.call(obj, prop)) {
              result.push(prop);
            }
          }
          if (hasDontEnumBug) {
            for (var i = 0;i < dontEnumsLength; i++) {
              if (hasOwnProperty.call(obj, dontEnums[i])) {
                result.push(dontEnums[i]);
              }
            }
          }
          return result;
        };
      }();
    }
    if (!Object.create) {
      Object.create = function() {
        function F() {
        }
        return function(o) {
          if (arguments.length !== 1) {
            throw new Error("Object.create implementation only accepts one parameter.");
          }
          F.prototype = o;
          return new F;
        };
      }();
    }
    if (!Array.isArray) {
      Array.isArray = function(vArg) {
        return Object.prototype.toString.call(vArg) === "[object Array]";
      };
    }
    if (!Array.prototype.indexOf) {
      Array.prototype.indexOf = function(searchElement) {
        if (this === null) {
          throw new TypeError;
        }
        var t = Object(this);
        var len = t.length >>> 0;
        if (len === 0) {
          return -1;
        }
        var n = 0;
        if (arguments.length > 1) {
          n = Number(arguments[1]);
          if (n !== n) {
            n = 0;
          } else if (n !== 0 && n !== Infinity && n !== -Infinity) {
            n = (n > 0 || -1) * Math.floor(Math.abs(n));
          }
        }
        if (n >= len) {
          return -1;
        }
        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
        for (;k < len; k++) {
          if (k in t && t[k] === searchElement) {
            return k;
          }
        }
        return -1;
      };
    }
    if (!Object.isFrozen) {
      Object.isFrozen = function(obj) {
        var key2 = "tv4_test_frozen_key";
        while (obj.hasOwnProperty(key2)) {
          key2 += Math.random();
        }
        try {
          obj[key2] = true;
          delete obj[key2];
          return false;
        } catch (e) {
          return true;
        }
      };
    }
    var uriTemplateGlobalModifiers = {
      "+": true,
      "#": true,
      ".": true,
      "/": true,
      ";": true,
      "?": true,
      "&": true
    };
    var uriTemplateSuffices = {
      "*": true
    };
    function notReallyPercentEncode(string) {
      return encodeURI(string).replace(/%25[0-9][0-9]/g, function(doubleEncoded) {
        return "%" + doubleEncoded.substring(3);
      });
    }
    function uriTemplateSubstitution(spec) {
      var modifier = "";
      if (uriTemplateGlobalModifiers[spec.charAt(0)]) {
        modifier = spec.charAt(0);
        spec = spec.substring(1);
      }
      var separator = "";
      var prefix = "";
      var shouldEscape = true;
      var showVariables = false;
      var trimEmptyString = false;
      if (modifier === "+") {
        shouldEscape = false;
      } else if (modifier === ".") {
        prefix = ".";
        separator = ".";
      } else if (modifier === "/") {
        prefix = "/";
        separator = "/";
      } else if (modifier === "#") {
        prefix = "#";
        shouldEscape = false;
      } else if (modifier === ";") {
        prefix = ";";
        separator = ";";
        showVariables = true;
        trimEmptyString = true;
      } else if (modifier === "?") {
        prefix = "?";
        separator = "&";
        showVariables = true;
      } else if (modifier === "&") {
        prefix = "&";
        separator = "&";
        showVariables = true;
      }
      var varNames = [];
      var varList = spec.split(",");
      var varSpecs = [];
      var varSpecMap = {};
      for (var i = 0;i < varList.length; i++) {
        var varName = varList[i];
        var truncate = null;
        if (varName.indexOf(":") !== -1) {
          var parts = varName.split(":");
          varName = parts[0];
          truncate = parseInt(parts[1], 10);
        }
        var suffices = {};
        while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {
          suffices[varName.charAt(varName.length - 1)] = true;
          varName = varName.substring(0, varName.length - 1);
        }
        var varSpec = {
          truncate,
          name: varName,
          suffices
        };
        varSpecs.push(varSpec);
        varSpecMap[varName] = varSpec;
        varNames.push(varName);
      }
      var subFunction = function(valueFunction) {
        var result = "";
        var startIndex = 0;
        for (var i2 = 0;i2 < varSpecs.length; i2++) {
          var varSpec2 = varSpecs[i2];
          var value = valueFunction(varSpec2.name);
          if (value === null || value === undefined || Array.isArray(value) && value.length === 0 || typeof value === "object" && Object.keys(value).length === 0) {
            startIndex++;
            continue;
          }
          if (i2 === startIndex) {
            result += prefix;
          } else {
            result += separator || ",";
          }
          if (Array.isArray(value)) {
            if (showVariables) {
              result += varSpec2.name + "=";
            }
            for (var j = 0;j < value.length; j++) {
              if (j > 0) {
                result += varSpec2.suffices["*"] ? separator || "," : ",";
                if (varSpec2.suffices["*"] && showVariables) {
                  result += varSpec2.name + "=";
                }
              }
              result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, "%21") : notReallyPercentEncode(value[j]);
            }
          } else if (typeof value === "object") {
            if (showVariables && !varSpec2.suffices["*"]) {
              result += varSpec2.name + "=";
            }
            var first = true;
            for (var key2 in value) {
              if (!first) {
                result += varSpec2.suffices["*"] ? separator || "," : ",";
              }
              first = false;
              result += shouldEscape ? encodeURIComponent(key2).replace(/!/g, "%21") : notReallyPercentEncode(key2);
              result += varSpec2.suffices["*"] ? "=" : ",";
              result += shouldEscape ? encodeURIComponent(value[key2]).replace(/!/g, "%21") : notReallyPercentEncode(value[key2]);
            }
          } else {
            if (showVariables) {
              result += varSpec2.name;
              if (!trimEmptyString || value !== "") {
                result += "=";
              }
            }
            if (varSpec2.truncate != null) {
              value = value.substring(0, varSpec2.truncate);
            }
            result += shouldEscape ? encodeURIComponent(value).replace(/!/g, "%21") : notReallyPercentEncode(value);
          }
        }
        return result;
      };
      subFunction.varNames = varNames;
      return {
        prefix,
        substitution: subFunction
      };
    }
    function UriTemplate(template) {
      if (!(this instanceof UriTemplate)) {
        return new UriTemplate(template);
      }
      var parts = template.split("{");
      var textParts = [parts.shift()];
      var prefixes = [];
      var substitutions = [];
      var varNames = [];
      while (parts.length > 0) {
        var part = parts.shift();
        var spec = part.split("}")[0];
        var remainder = part.substring(spec.length + 1);
        var funcs = uriTemplateSubstitution(spec);
        substitutions.push(funcs.substitution);
        prefixes.push(funcs.prefix);
        textParts.push(remainder);
        varNames = varNames.concat(funcs.substitution.varNames);
      }
      this.fill = function(valueFunction) {
        var result = textParts[0];
        for (var i = 0;i < substitutions.length; i++) {
          var substitution = substitutions[i];
          result += substitution(valueFunction);
          result += textParts[i + 1];
        }
        return result;
      };
      this.varNames = varNames;
      this.template = template;
    }
    UriTemplate.prototype = {
      toString: function() {
        return this.template;
      },
      fillFromObject: function(obj) {
        return this.fill(function(varName) {
          return obj[varName];
        });
      }
    };
    var ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {
      this.missing = [];
      this.missingMap = {};
      this.formatValidators = parent ? Object.create(parent.formatValidators) : {};
      this.schemas = parent ? Object.create(parent.schemas) : {};
      this.collectMultiple = collectMultiple;
      this.errors = [];
      this.handleError = collectMultiple ? this.collectError : this.returnError;
      if (checkRecursive) {
        this.checkRecursive = true;
        this.scanned = [];
        this.scannedFrozen = [];
        this.scannedFrozenSchemas = [];
        this.scannedFrozenValidationErrors = [];
        this.validatedSchemasKey = "tv4_validation_id";
        this.validationErrorsKey = "tv4_validation_errors_id";
      }
      if (trackUnknownProperties) {
        this.trackUnknownProperties = true;
        this.knownPropertyPaths = {};
        this.unknownPropertyPaths = {};
      }
      this.errorReporter = errorReporter || defaultErrorReporter("en");
      if (typeof this.errorReporter === "string") {
        throw new Error("debug");
      }
      this.definedKeywords = {};
      if (parent) {
        for (var key2 in parent.definedKeywords) {
          this.definedKeywords[key2] = parent.definedKeywords[key2].slice(0);
        }
      }
    };
    ValidatorContext.prototype.defineKeyword = function(keyword, keywordFunction) {
      this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];
      this.definedKeywords[keyword].push(keywordFunction);
    };
    ValidatorContext.prototype.createError = function(code, messageParams, dataPath, schemaPath, subErrors, data, schema) {
      var error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);
      error.message = this.errorReporter(error, data, schema);
      return error;
    };
    ValidatorContext.prototype.returnError = function(error) {
      return error;
    };
    ValidatorContext.prototype.collectError = function(error) {
      if (error) {
        this.errors.push(error);
      }
      return null;
    };
    ValidatorContext.prototype.prefixErrors = function(startIndex, dataPath, schemaPath) {
      for (var i = startIndex;i < this.errors.length; i++) {
        this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);
      }
      return this;
    };
    ValidatorContext.prototype.banUnknownProperties = function(data, schema) {
      for (var unknownPath in this.unknownPropertyPaths) {
        var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, { path: unknownPath }, unknownPath, "", null, data, schema);
        var result = this.handleError(error);
        if (result) {
          return result;
        }
      }
      return null;
    };
    ValidatorContext.prototype.addFormat = function(format, validator) {
      if (typeof format === "object") {
        for (var key2 in format) {
          this.addFormat(key2, format[key2]);
        }
        return this;
      }
      this.formatValidators[format] = validator;
    };
    ValidatorContext.prototype.resolveRefs = function(schema, urlHistory) {
      if (schema["$ref"] !== undefined) {
        urlHistory = urlHistory || {};
        if (urlHistory[schema["$ref"]]) {
          return this.createError(ErrorCodes.CIRCULAR_REFERENCE, { urls: Object.keys(urlHistory).join(", ") }, "", "", null, undefined, schema);
        }
        urlHistory[schema["$ref"]] = true;
        schema = this.getSchema(schema["$ref"], urlHistory);
      }
      return schema;
    };
    ValidatorContext.prototype.getSchema = function(url, urlHistory) {
      var schema;
      if (this.schemas[url] !== undefined) {
        schema = this.schemas[url];
        return this.resolveRefs(schema, urlHistory);
      }
      var baseUrl = url;
      var fragment = "";
      if (url.indexOf("#") !== -1) {
        fragment = url.substring(url.indexOf("#") + 1);
        baseUrl = url.substring(0, url.indexOf("#"));
      }
      if (typeof this.schemas[baseUrl] === "object") {
        schema = this.schemas[baseUrl];
        var pointerPath = decodeURIComponent(fragment);
        if (pointerPath === "") {
          return this.resolveRefs(schema, urlHistory);
        } else if (pointerPath.charAt(0) !== "/") {
          return;
        }
        var parts = pointerPath.split("/").slice(1);
        for (var i = 0;i < parts.length; i++) {
          var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
          if (schema[component] === undefined) {
            schema = undefined;
            break;
          }
          schema = schema[component];
        }
        if (schema !== undefined) {
          return this.resolveRefs(schema, urlHistory);
        }
      }
      if (this.missing[baseUrl] === undefined) {
        this.missing.push(baseUrl);
        this.missing[baseUrl] = baseUrl;
        this.missingMap[baseUrl] = baseUrl;
      }
    };
    ValidatorContext.prototype.searchSchemas = function(schema, url) {
      if (Array.isArray(schema)) {
        for (var i = 0;i < schema.length; i++) {
          this.searchSchemas(schema[i], url);
        }
      } else if (schema && typeof schema === "object") {
        if (typeof schema.id === "string") {
          if (isTrustedUrl(url, schema.id)) {
            if (this.schemas[schema.id] === undefined) {
              this.schemas[schema.id] = schema;
            }
          }
        }
        for (var key2 in schema) {
          if (key2 !== "enum") {
            if (typeof schema[key2] === "object") {
              this.searchSchemas(schema[key2], url);
            } else if (key2 === "$ref") {
              var uri = getDocumentUri(schema[key2]);
              if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {
                this.missingMap[uri] = uri;
              }
            }
          }
        }
      }
    };
    ValidatorContext.prototype.addSchema = function(url, schema) {
      if (typeof url !== "string" || typeof schema === "undefined") {
        if (typeof url === "object" && typeof url.id === "string") {
          schema = url;
          url = schema.id;
        } else {
          return;
        }
      }
      if (url === getDocumentUri(url) + "#") {
        url = getDocumentUri(url);
      }
      this.schemas[url] = schema;
      delete this.missingMap[url];
      normSchema(schema, url);
      this.searchSchemas(schema, url);
    };
    ValidatorContext.prototype.getSchemaMap = function() {
      var map = {};
      for (var key2 in this.schemas) {
        map[key2] = this.schemas[key2];
      }
      return map;
    };
    ValidatorContext.prototype.getSchemaUris = function(filterRegExp) {
      var list = [];
      for (var key2 in this.schemas) {
        if (!filterRegExp || filterRegExp.test(key2)) {
          list.push(key2);
        }
      }
      return list;
    };
    ValidatorContext.prototype.getMissingUris = function(filterRegExp) {
      var list = [];
      for (var key2 in this.missingMap) {
        if (!filterRegExp || filterRegExp.test(key2)) {
          list.push(key2);
        }
      }
      return list;
    };
    ValidatorContext.prototype.dropSchemas = function() {
      this.schemas = {};
      this.reset();
    };
    ValidatorContext.prototype.reset = function() {
      this.missing = [];
      this.missingMap = {};
      this.errors = [];
    };
    ValidatorContext.prototype.validateAll = function(data, schema, dataPathParts, schemaPathParts, dataPointerPath) {
      var topLevel;
      schema = this.resolveRefs(schema);
      if (!schema) {
        return null;
      } else if (schema instanceof ValidationError) {
        this.errors.push(schema);
        return schema;
      }
      var startErrorCount = this.errors.length;
      var frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;
      if (this.checkRecursive && data && typeof data === "object") {
        topLevel = !this.scanned.length;
        if (data[this.validatedSchemasKey]) {
          var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);
          if (schemaIndex !== -1) {
            this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);
            return null;
          }
        }
        if (Object.isFrozen(data)) {
          frozenIndex = this.scannedFrozen.indexOf(data);
          if (frozenIndex !== -1) {
            var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);
            if (frozenSchemaIndex !== -1) {
              this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);
              return null;
            }
          }
        }
        this.scanned.push(data);
        if (Object.isFrozen(data)) {
          if (frozenIndex === -1) {
            frozenIndex = this.scannedFrozen.length;
            this.scannedFrozen.push(data);
            this.scannedFrozenSchemas.push([]);
          }
          scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;
          this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;
          this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];
        } else {
          if (!data[this.validatedSchemasKey]) {
            try {
              Object.defineProperty(data, this.validatedSchemasKey, {
                value: [],
                configurable: true
              });
              Object.defineProperty(data, this.validationErrorsKey, {
                value: [],
                configurable: true
              });
            } catch (e) {
              data[this.validatedSchemasKey] = [];
              data[this.validationErrorsKey] = [];
            }
          }
          scannedSchemasIndex = data[this.validatedSchemasKey].length;
          data[this.validatedSchemasKey][scannedSchemasIndex] = schema;
          data[this.validationErrorsKey][scannedSchemasIndex] = [];
        }
      }
      var errorCount = this.errors.length;
      var error = this.validateBasic(data, schema, dataPointerPath) || this.validateNumeric(data, schema, dataPointerPath) || this.validateString(data, schema, dataPointerPath) || this.validateArray(data, schema, dataPointerPath) || this.validateObject(data, schema, dataPointerPath) || this.validateCombinations(data, schema, dataPointerPath) || this.validateHypermedia(data, schema, dataPointerPath) || this.validateFormat(data, schema, dataPointerPath) || this.validateDefinedKeywords(data, schema, dataPointerPath) || null;
      if (topLevel) {
        while (this.scanned.length) {
          var item = this.scanned.pop();
          delete item[this.validatedSchemasKey];
        }
        this.scannedFrozen = [];
        this.scannedFrozenSchemas = [];
      }
      if (error || errorCount !== this.errors.length) {
        while (dataPathParts && dataPathParts.length || schemaPathParts && schemaPathParts.length) {
          var dataPart = dataPathParts && dataPathParts.length ? "" + dataPathParts.pop() : null;
          var schemaPart = schemaPathParts && schemaPathParts.length ? "" + schemaPathParts.pop() : null;
          if (error) {
            error = error.prefixWith(dataPart, schemaPart);
          }
          this.prefixErrors(errorCount, dataPart, schemaPart);
        }
      }
      if (scannedFrozenSchemaIndex !== null) {
        this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);
      } else if (scannedSchemasIndex !== null) {
        data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);
      }
      return this.handleError(error);
    };
    ValidatorContext.prototype.validateFormat = function(data, schema) {
      if (typeof schema.format !== "string" || !this.formatValidators[schema.format]) {
        return null;
      }
      var errorMessage = this.formatValidators[schema.format].call(null, data, schema);
      if (typeof errorMessage === "string" || typeof errorMessage === "number") {
        return this.createError(ErrorCodes.FORMAT_CUSTOM, { message: errorMessage }, "", "/format", null, data, schema);
      } else if (errorMessage && typeof errorMessage === "object") {
        return this.createError(ErrorCodes.FORMAT_CUSTOM, { message: errorMessage.message || "?" }, errorMessage.dataPath || "", errorMessage.schemaPath || "/format", null, data, schema);
      }
      return null;
    };
    ValidatorContext.prototype.validateDefinedKeywords = function(data, schema, dataPointerPath) {
      for (var key2 in this.definedKeywords) {
        if (typeof schema[key2] === "undefined") {
          continue;
        }
        var validationFunctions = this.definedKeywords[key2];
        for (var i = 0;i < validationFunctions.length; i++) {
          var func = validationFunctions[i];
          var result = func(data, schema[key2], schema, dataPointerPath);
          if (typeof result === "string" || typeof result === "number") {
            return this.createError(ErrorCodes.KEYWORD_CUSTOM, { key: key2, message: result }, "", "", null, data, schema).prefixWith(null, key2);
          } else if (result && typeof result === "object") {
            var code = result.code;
            if (typeof code === "string") {
              if (!ErrorCodes[code]) {
                throw new Error("Undefined error code (use defineError): " + code);
              }
              code = ErrorCodes[code];
            } else if (typeof code !== "number") {
              code = ErrorCodes.KEYWORD_CUSTOM;
            }
            var messageParams = typeof result.message === "object" ? result.message : { key: key2, message: result.message || "?" };
            var schemaPath = result.schemaPath || "/" + key2.replace(/~/g, "~0").replace(/\//g, "~1");
            return this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);
          }
        }
      }
      return null;
    };
    function recursiveCompare(A, B) {
      if (A === B) {
        return true;
      }
      if (A && B && typeof A === "object" && typeof B === "object") {
        if (Array.isArray(A) !== Array.isArray(B)) {
          return false;
        } else if (Array.isArray(A)) {
          if (A.length !== B.length) {
            return false;
          }
          for (var i = 0;i < A.length; i++) {
            if (!recursiveCompare(A[i], B[i])) {
              return false;
            }
          }
        } else {
          var key2;
          for (key2 in A) {
            if (B[key2] === undefined && A[key2] !== undefined) {
              return false;
            }
          }
          for (key2 in B) {
            if (A[key2] === undefined && B[key2] !== undefined) {
              return false;
            }
          }
          for (key2 in A) {
            if (!recursiveCompare(A[key2], B[key2])) {
              return false;
            }
          }
        }
        return true;
      }
      return false;
    }
    ValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {
      var error;
      if (error = this.validateType(data, schema, dataPointerPath)) {
        return error.prefixWith(null, "type");
      }
      if (error = this.validateEnum(data, schema, dataPointerPath)) {
        return error.prefixWith(null, "type");
      }
      return null;
    };
    ValidatorContext.prototype.validateType = function validateType(data, schema) {
      if (schema.type === undefined) {
        return null;
      }
      var dataType = typeof data;
      if (data === null) {
        dataType = "null";
      } else if (Array.isArray(data)) {
        dataType = "array";
      }
      var allowedTypes = schema.type;
      if (!Array.isArray(allowedTypes)) {
        allowedTypes = [allowedTypes];
      }
      for (var i = 0;i < allowedTypes.length; i++) {
        var type2 = allowedTypes[i];
        if (type2 === dataType || type2 === "integer" && dataType === "number" && data % 1 === 0) {
          return null;
        }
      }
      return this.createError(ErrorCodes.INVALID_TYPE, { type: dataType, expected: allowedTypes.join("/") }, "", "", null, data, schema);
    };
    ValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {
      if (schema["enum"] === undefined) {
        return null;
      }
      for (var i = 0;i < schema["enum"].length; i++) {
        var enumVal = schema["enum"][i];
        if (recursiveCompare(data, enumVal)) {
          return null;
        }
      }
      return this.createError(ErrorCodes.ENUM_MISMATCH, { value: typeof JSON !== "undefined" ? JSON.stringify(data) : data }, "", "", null, data, schema);
    };
    ValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {
      return this.validateMultipleOf(data, schema, dataPointerPath) || this.validateMinMax(data, schema, dataPointerPath) || this.validateNaN(data, schema, dataPointerPath) || null;
    };
    var CLOSE_ENOUGH_LOW = Math.pow(2, -51);
    var CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;
    ValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {
      var multipleOf = schema.multipleOf || schema.divisibleBy;
      if (multipleOf === undefined) {
        return null;
      }
      if (typeof data === "number") {
        var remainder = data / multipleOf % 1;
        if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {
          return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, { value: data, multipleOf }, "", "", null, data, schema);
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {
      if (typeof data !== "number") {
        return null;
      }
      if (schema.minimum !== undefined) {
        if (data < schema.minimum) {
          return this.createError(ErrorCodes.NUMBER_MINIMUM, { value: data, minimum: schema.minimum }, "", "/minimum", null, data, schema);
        }
        if (schema.exclusiveMinimum && data === schema.minimum) {
          return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, { value: data, minimum: schema.minimum }, "", "/exclusiveMinimum", null, data, schema);
        }
      }
      if (schema.maximum !== undefined) {
        if (data > schema.maximum) {
          return this.createError(ErrorCodes.NUMBER_MAXIMUM, { value: data, maximum: schema.maximum }, "", "/maximum", null, data, schema);
        }
        if (schema.exclusiveMaximum && data === schema.maximum) {
          return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, { value: data, maximum: schema.maximum }, "", "/exclusiveMaximum", null, data, schema);
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {
      if (typeof data !== "number") {
        return null;
      }
      if (isNaN(data) === true || data === Infinity || data === -Infinity) {
        return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, { value: data }, "", "/type", null, data, schema);
      }
      return null;
    };
    ValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {
      return this.validateStringLength(data, schema, dataPointerPath) || this.validateStringPattern(data, schema, dataPointerPath) || null;
    };
    ValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {
      if (typeof data !== "string") {
        return null;
      }
      if (schema.minLength !== undefined) {
        if (data.length < schema.minLength) {
          return this.createError(ErrorCodes.STRING_LENGTH_SHORT, { length: data.length, minimum: schema.minLength }, "", "/minLength", null, data, schema);
        }
      }
      if (schema.maxLength !== undefined) {
        if (data.length > schema.maxLength) {
          return this.createError(ErrorCodes.STRING_LENGTH_LONG, { length: data.length, maximum: schema.maxLength }, "", "/maxLength", null, data, schema);
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {
      if (typeof data !== "string" || typeof schema.pattern !== "string" && !(schema.pattern instanceof RegExp)) {
        return null;
      }
      var regexp;
      if (schema.pattern instanceof RegExp) {
        regexp = schema.pattern;
      } else {
        var body, flags = "";
        var literal = schema.pattern.match(/^\/(.+)\/([img]*)$/);
        if (literal) {
          body = literal[1];
          flags = literal[2];
        } else {
          body = schema.pattern;
        }
        regexp = new RegExp(body, flags);
      }
      if (!regexp.test(data)) {
        return this.createError(ErrorCodes.STRING_PATTERN, { pattern: schema.pattern }, "", "/pattern", null, data, schema);
      }
      return null;
    };
    ValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {
      if (!Array.isArray(data)) {
        return null;
      }
      return this.validateArrayLength(data, schema, dataPointerPath) || this.validateArrayUniqueItems(data, schema, dataPointerPath) || this.validateArrayItems(data, schema, dataPointerPath) || null;
    };
    ValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {
      var error;
      if (schema.minItems !== undefined) {
        if (data.length < schema.minItems) {
          error = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, { length: data.length, minimum: schema.minItems }, "", "/minItems", null, data, schema);
          if (this.handleError(error)) {
            return error;
          }
        }
      }
      if (schema.maxItems !== undefined) {
        if (data.length > schema.maxItems) {
          error = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, { length: data.length, maximum: schema.maxItems }, "", "/maxItems", null, data, schema);
          if (this.handleError(error)) {
            return error;
          }
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {
      if (schema.uniqueItems) {
        for (var i = 0;i < data.length; i++) {
          for (var j = i + 1;j < data.length; j++) {
            if (recursiveCompare(data[i], data[j])) {
              var error = this.createError(ErrorCodes.ARRAY_UNIQUE, { match1: i, match2: j }, "", "/uniqueItems", null, data, schema);
              if (this.handleError(error)) {
                return error;
              }
            }
          }
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {
      if (schema.items === undefined) {
        return null;
      }
      var error, i;
      if (Array.isArray(schema.items)) {
        for (i = 0;i < data.length; i++) {
          if (i < schema.items.length) {
            if (error = this.validateAll(data[i], schema.items[i], [i], ["items", i], dataPointerPath + "/" + i)) {
              return error;
            }
          } else if (schema.additionalItems !== undefined) {
            if (typeof schema.additionalItems === "boolean") {
              if (!schema.additionalItems) {
                error = this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, "/" + i, "/additionalItems", null, data, schema);
                if (this.handleError(error)) {
                  return error;
                }
              }
            } else if (error = this.validateAll(data[i], schema.additionalItems, [i], ["additionalItems"], dataPointerPath + "/" + i)) {
              return error;
            }
          }
        }
      } else {
        for (i = 0;i < data.length; i++) {
          if (error = this.validateAll(data[i], schema.items, [i], ["items"], dataPointerPath + "/" + i)) {
            return error;
          }
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {
      if (typeof data !== "object" || data === null || Array.isArray(data)) {
        return null;
      }
      return this.validateObjectMinMaxProperties(data, schema, dataPointerPath) || this.validateObjectRequiredProperties(data, schema, dataPointerPath) || this.validateObjectProperties(data, schema, dataPointerPath) || this.validateObjectDependencies(data, schema, dataPointerPath) || null;
    };
    ValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {
      var keys3 = Object.keys(data);
      var error;
      if (schema.minProperties !== undefined) {
        if (keys3.length < schema.minProperties) {
          error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, { propertyCount: keys3.length, minimum: schema.minProperties }, "", "/minProperties", null, data, schema);
          if (this.handleError(error)) {
            return error;
          }
        }
      }
      if (schema.maxProperties !== undefined) {
        if (keys3.length > schema.maxProperties) {
          error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, { propertyCount: keys3.length, maximum: schema.maxProperties }, "", "/maxProperties", null, data, schema);
          if (this.handleError(error)) {
            return error;
          }
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {
      if (schema.required !== undefined) {
        for (var i = 0;i < schema.required.length; i++) {
          var key2 = schema.required[i];
          if (data[key2] === undefined) {
            var error = this.createError(ErrorCodes.OBJECT_REQUIRED, { key: key2 }, "", "/required/" + i, null, data, schema);
            if (this.handleError(error)) {
              return error;
            }
          }
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {
      var error;
      for (var key2 in data) {
        var keyPointerPath = dataPointerPath + "/" + key2.replace(/~/g, "~0").replace(/\//g, "~1");
        var foundMatch = false;
        if (schema.properties !== undefined && schema.properties[key2] !== undefined) {
          foundMatch = true;
          if (error = this.validateAll(data[key2], schema.properties[key2], [key2], ["properties", key2], keyPointerPath)) {
            return error;
          }
        }
        if (schema.patternProperties !== undefined) {
          for (var patternKey in schema.patternProperties) {
            var regexp = new RegExp(patternKey);
            if (regexp.test(key2)) {
              foundMatch = true;
              if (error = this.validateAll(data[key2], schema.patternProperties[patternKey], [key2], ["patternProperties", patternKey], keyPointerPath)) {
                return error;
              }
            }
          }
        }
        if (!foundMatch) {
          if (schema.additionalProperties !== undefined) {
            if (this.trackUnknownProperties) {
              this.knownPropertyPaths[keyPointerPath] = true;
              delete this.unknownPropertyPaths[keyPointerPath];
            }
            if (typeof schema.additionalProperties === "boolean") {
              if (!schema.additionalProperties) {
                error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, { key: key2 }, "", "/additionalProperties", null, data, schema).prefixWith(key2, null);
                if (this.handleError(error)) {
                  return error;
                }
              }
            } else {
              if (error = this.validateAll(data[key2], schema.additionalProperties, [key2], ["additionalProperties"], keyPointerPath)) {
                return error;
              }
            }
          } else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {
            this.unknownPropertyPaths[keyPointerPath] = true;
          }
        } else if (this.trackUnknownProperties) {
          this.knownPropertyPaths[keyPointerPath] = true;
          delete this.unknownPropertyPaths[keyPointerPath];
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {
      var error;
      if (schema.dependencies !== undefined) {
        for (var depKey in schema.dependencies) {
          if (data[depKey] !== undefined) {
            var dep = schema.dependencies[depKey];
            if (typeof dep === "string") {
              if (data[dep] === undefined) {
                error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, { key: depKey, missing: dep }, "", "", null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
                if (this.handleError(error)) {
                  return error;
                }
              }
            } else if (Array.isArray(dep)) {
              for (var i = 0;i < dep.length; i++) {
                var requiredKey = dep[i];
                if (data[requiredKey] === undefined) {
                  error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, { key: depKey, missing: requiredKey }, "", "/" + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
                  if (this.handleError(error)) {
                    return error;
                  }
                }
              }
            } else {
              if (error = this.validateAll(data, dep, [], ["dependencies", depKey], dataPointerPath)) {
                return error;
              }
            }
          }
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {
      return this.validateAllOf(data, schema, dataPointerPath) || this.validateAnyOf(data, schema, dataPointerPath) || this.validateOneOf(data, schema, dataPointerPath) || this.validateNot(data, schema, dataPointerPath) || null;
    };
    ValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {
      if (schema.allOf === undefined) {
        return null;
      }
      var error;
      for (var i = 0;i < schema.allOf.length; i++) {
        var subSchema = schema.allOf[i];
        if (error = this.validateAll(data, subSchema, [], ["allOf", i], dataPointerPath)) {
          return error;
        }
      }
      return null;
    };
    ValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {
      if (schema.anyOf === undefined) {
        return null;
      }
      var errors = [];
      var startErrorCount = this.errors.length;
      var oldUnknownPropertyPaths, oldKnownPropertyPaths;
      if (this.trackUnknownProperties) {
        oldUnknownPropertyPaths = this.unknownPropertyPaths;
        oldKnownPropertyPaths = this.knownPropertyPaths;
      }
      var errorAtEnd = true;
      for (var i = 0;i < schema.anyOf.length; i++) {
        if (this.trackUnknownProperties) {
          this.unknownPropertyPaths = {};
          this.knownPropertyPaths = {};
        }
        var subSchema = schema.anyOf[i];
        var errorCount = this.errors.length;
        var error = this.validateAll(data, subSchema, [], ["anyOf", i], dataPointerPath);
        if (error === null && errorCount === this.errors.length) {
          this.errors = this.errors.slice(0, startErrorCount);
          if (this.trackUnknownProperties) {
            for (var knownKey in this.knownPropertyPaths) {
              oldKnownPropertyPaths[knownKey] = true;
              delete oldUnknownPropertyPaths[knownKey];
            }
            for (var unknownKey in this.unknownPropertyPaths) {
              if (!oldKnownPropertyPaths[unknownKey]) {
                oldUnknownPropertyPaths[unknownKey] = true;
              }
            }
            errorAtEnd = false;
            continue;
          }
          return null;
        }
        if (error) {
          errors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));
        }
      }
      if (this.trackUnknownProperties) {
        this.unknownPropertyPaths = oldUnknownPropertyPaths;
        this.knownPropertyPaths = oldKnownPropertyPaths;
      }
      if (errorAtEnd) {
        errors = errors.concat(this.errors.slice(startErrorCount));
        this.errors = this.errors.slice(0, startErrorCount);
        return this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors, data, schema);
      }
    };
    ValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {
      if (schema.oneOf === undefined) {
        return null;
      }
      var validIndex = null;
      var errors = [];
      var startErrorCount = this.errors.length;
      var oldUnknownPropertyPaths, oldKnownPropertyPaths;
      if (this.trackUnknownProperties) {
        oldUnknownPropertyPaths = this.unknownPropertyPaths;
        oldKnownPropertyPaths = this.knownPropertyPaths;
      }
      for (var i = 0;i < schema.oneOf.length; i++) {
        if (this.trackUnknownProperties) {
          this.unknownPropertyPaths = {};
          this.knownPropertyPaths = {};
        }
        var subSchema = schema.oneOf[i];
        var errorCount = this.errors.length;
        var error = this.validateAll(data, subSchema, [], ["oneOf", i], dataPointerPath);
        if (error === null && errorCount === this.errors.length) {
          if (validIndex === null) {
            validIndex = i;
          } else {
            this.errors = this.errors.slice(0, startErrorCount);
            return this.createError(ErrorCodes.ONE_OF_MULTIPLE, { index1: validIndex, index2: i }, "", "/oneOf", null, data, schema);
          }
          if (this.trackUnknownProperties) {
            for (var knownKey in this.knownPropertyPaths) {
              oldKnownPropertyPaths[knownKey] = true;
              delete oldUnknownPropertyPaths[knownKey];
            }
            for (var unknownKey in this.unknownPropertyPaths) {
              if (!oldKnownPropertyPaths[unknownKey]) {
                oldUnknownPropertyPaths[unknownKey] = true;
              }
            }
          }
        } else if (error) {
          errors.push(error);
        }
      }
      if (this.trackUnknownProperties) {
        this.unknownPropertyPaths = oldUnknownPropertyPaths;
        this.knownPropertyPaths = oldKnownPropertyPaths;
      }
      if (validIndex === null) {
        errors = errors.concat(this.errors.slice(startErrorCount));
        this.errors = this.errors.slice(0, startErrorCount);
        return this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors, data, schema);
      } else {
        this.errors = this.errors.slice(0, startErrorCount);
      }
      return null;
    };
    ValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {
      if (schema.not === undefined) {
        return null;
      }
      var oldErrorCount = this.errors.length;
      var oldUnknownPropertyPaths, oldKnownPropertyPaths;
      if (this.trackUnknownProperties) {
        oldUnknownPropertyPaths = this.unknownPropertyPaths;
        oldKnownPropertyPaths = this.knownPropertyPaths;
        this.unknownPropertyPaths = {};
        this.knownPropertyPaths = {};
      }
      var error = this.validateAll(data, schema.not, null, null, dataPointerPath);
      var notErrors = this.errors.slice(oldErrorCount);
      this.errors = this.errors.slice(0, oldErrorCount);
      if (this.trackUnknownProperties) {
        this.unknownPropertyPaths = oldUnknownPropertyPaths;
        this.knownPropertyPaths = oldKnownPropertyPaths;
      }
      if (error === null && notErrors.length === 0) {
        return this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not", null, data, schema);
      }
      return null;
    };
    ValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {
      if (!schema.links) {
        return null;
      }
      var error;
      for (var i = 0;i < schema.links.length; i++) {
        var ldo = schema.links[i];
        if (ldo.rel === "describedby") {
          var template = new UriTemplate(ldo.href);
          var allPresent = true;
          for (var j = 0;j < template.varNames.length; j++) {
            if (!(template.varNames[j] in data)) {
              allPresent = false;
              break;
            }
          }
          if (allPresent) {
            var schemaUrl = template.fillFromObject(data);
            var subSchema = { $ref: schemaUrl };
            if (error = this.validateAll(data, subSchema, [], ["links", i], dataPointerPath)) {
              return error;
            }
          }
        }
      }
    };
    function parseURI(url) {
      var m = String(url).replace(/^\s+|\s+$/g, "").match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
      return m ? {
        href: m[0] || "",
        protocol: m[1] || "",
        authority: m[2] || "",
        host: m[3] || "",
        hostname: m[4] || "",
        port: m[5] || "",
        pathname: m[6] || "",
        search: m[7] || "",
        hash: m[8] || ""
      } : null;
    }
    function resolveUrl(base, href) {
      function removeDotSegments(input) {
        var output = [];
        input.replace(/^(\.\.?(\/|$))+/, "").replace(/\/(\.(\/|$))+/g, "/").replace(/\/\.\.$/, "/../").replace(/\/?[^\/]*/g, function(p) {
          if (p === "/..") {
            output.pop();
          } else {
            output.push(p);
          }
        });
        return output.join("").replace(/^\//, input.charAt(0) === "/" ? "/" : "");
      }
      href = parseURI(href || "");
      base = parseURI(base || "");
      return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === "/" ? href.pathname : href.pathname ? (base.authority && !base.pathname ? "/" : "") + base.pathname.slice(0, base.pathname.lastIndexOf("/") + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
    }
    function getDocumentUri(uri) {
      return uri.split("#")[0];
    }
    function normSchema(schema, baseUri) {
      if (schema && typeof schema === "object") {
        if (baseUri === undefined) {
          baseUri = schema.id;
        } else if (typeof schema.id === "string") {
          baseUri = resolveUrl(baseUri, schema.id);
          schema.id = baseUri;
        }
        if (Array.isArray(schema)) {
          for (var i = 0;i < schema.length; i++) {
            normSchema(schema[i], baseUri);
          }
        } else {
          if (typeof schema["$ref"] === "string") {
            schema["$ref"] = resolveUrl(baseUri, schema["$ref"]);
          }
          for (var key2 in schema) {
            if (key2 !== "enum") {
              normSchema(schema[key2], baseUri);
            }
          }
        }
      }
    }
    function defaultErrorReporter(language) {
      language = language || "en";
      var errorMessages = languages[language];
      return function(error) {
        var messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];
        if (typeof messageTemplate !== "string") {
          return "Unknown error code " + error.code + ": " + JSON.stringify(error.messageParams);
        }
        var messageParams = error.params;
        return messageTemplate.replace(/\{([^{}]*)\}/g, function(whole, varName) {
          var subValue = messageParams[varName];
          return typeof subValue === "string" || typeof subValue === "number" ? subValue : whole;
        });
      };
    }
    var ErrorCodes = {
      INVALID_TYPE: 0,
      ENUM_MISMATCH: 1,
      ANY_OF_MISSING: 10,
      ONE_OF_MISSING: 11,
      ONE_OF_MULTIPLE: 12,
      NOT_PASSED: 13,
      NUMBER_MULTIPLE_OF: 100,
      NUMBER_MINIMUM: 101,
      NUMBER_MINIMUM_EXCLUSIVE: 102,
      NUMBER_MAXIMUM: 103,
      NUMBER_MAXIMUM_EXCLUSIVE: 104,
      NUMBER_NOT_A_NUMBER: 105,
      STRING_LENGTH_SHORT: 200,
      STRING_LENGTH_LONG: 201,
      STRING_PATTERN: 202,
      OBJECT_PROPERTIES_MINIMUM: 300,
      OBJECT_PROPERTIES_MAXIMUM: 301,
      OBJECT_REQUIRED: 302,
      OBJECT_ADDITIONAL_PROPERTIES: 303,
      OBJECT_DEPENDENCY_KEY: 304,
      ARRAY_LENGTH_SHORT: 400,
      ARRAY_LENGTH_LONG: 401,
      ARRAY_UNIQUE: 402,
      ARRAY_ADDITIONAL_ITEMS: 403,
      FORMAT_CUSTOM: 500,
      KEYWORD_CUSTOM: 501,
      CIRCULAR_REFERENCE: 600,
      UNKNOWN_PROPERTY: 1000
    };
    var ErrorCodeLookup = {};
    for (var key in ErrorCodes) {
      ErrorCodeLookup[ErrorCodes[key]] = key;
    }
    var ErrorMessagesDefault = {
      INVALID_TYPE: "Invalid type: {type} (expected {expected})",
      ENUM_MISMATCH: "No enum match for: {value}",
      ANY_OF_MISSING: "Data does not match any schemas from \"anyOf\"",
      ONE_OF_MISSING: "Data does not match any schemas from \"oneOf\"",
      ONE_OF_MULTIPLE: "Data is valid against more than one schema from \"oneOf\": indices {index1} and {index2}",
      NOT_PASSED: "Data matches schema from \"not\"",
      NUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",
      NUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",
      NUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",
      NUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",
      NUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",
      NUMBER_NOT_A_NUMBER: "Value {value} is not a valid number",
      STRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",
      STRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",
      STRING_PATTERN: "String does not match pattern: {pattern}",
      OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",
      OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",
      OBJECT_REQUIRED: "Missing required property: {key}",
      OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",
      OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",
      ARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",
      ARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",
      ARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",
      ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",
      FORMAT_CUSTOM: "Format validation failed ({message})",
      KEYWORD_CUSTOM: "Keyword failed: {key} ({message})",
      CIRCULAR_REFERENCE: "Circular $refs: {urls}",
      UNKNOWN_PROPERTY: "Unknown property (not in schema)"
    };
    function ValidationError(code, params2, dataPath, schemaPath, subErrors) {
      Error.call(this);
      if (code === undefined) {
        throw new Error("No error code supplied: " + schemaPath);
      }
      this.message = "";
      this.params = params2;
      this.code = code;
      this.dataPath = dataPath || "";
      this.schemaPath = schemaPath || "";
      this.subErrors = subErrors || null;
      var err = new Error(this.message);
      this.stack = err.stack || err.stacktrace;
      if (!this.stack) {
        try {
          throw err;
        } catch (err2) {
          this.stack = err2.stack || err2.stacktrace;
        }
      }
    }
    ValidationError.prototype = Object.create(Error.prototype);
    ValidationError.prototype.constructor = ValidationError;
    ValidationError.prototype.name = "ValidationError";
    ValidationError.prototype.prefixWith = function(dataPrefix, schemaPrefix) {
      if (dataPrefix !== null) {
        dataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
        this.dataPath = "/" + dataPrefix + this.dataPath;
      }
      if (schemaPrefix !== null) {
        schemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
        this.schemaPath = "/" + schemaPrefix + this.schemaPath;
      }
      if (this.subErrors !== null) {
        for (var i = 0;i < this.subErrors.length; i++) {
          this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);
        }
      }
      return this;
    };
    function isTrustedUrl(baseUrl, testUrl) {
      if (testUrl.substring(0, baseUrl.length) === baseUrl) {
        var remainder = testUrl.substring(baseUrl.length);
        if (testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === "/" || remainder.charAt(0) === "#" || remainder.charAt(0) === "?") {
          return true;
        }
      }
      return false;
    }
    var languages = {};
    function createApi(language) {
      var globalContext = new ValidatorContext;
      var currentLanguage;
      var customErrorReporter;
      var api = {
        setErrorReporter: function(reporter) {
          if (typeof reporter === "string") {
            return this.language(reporter);
          }
          customErrorReporter = reporter;
          return true;
        },
        addFormat: function() {
          globalContext.addFormat.apply(globalContext, arguments);
        },
        language: function(code) {
          if (!code) {
            return currentLanguage;
          }
          if (!languages[code]) {
            code = code.split("-")[0];
          }
          if (languages[code]) {
            currentLanguage = code;
            return code;
          }
          return false;
        },
        addLanguage: function(code, messageMap) {
          var key2;
          for (key2 in ErrorCodes) {
            if (messageMap[key2] && !messageMap[ErrorCodes[key2]]) {
              messageMap[ErrorCodes[key2]] = messageMap[key2];
            }
          }
          var rootCode = code.split("-")[0];
          if (!languages[rootCode]) {
            languages[code] = messageMap;
            languages[rootCode] = messageMap;
          } else {
            languages[code] = Object.create(languages[rootCode]);
            for (key2 in messageMap) {
              if (typeof languages[rootCode][key2] === "undefined") {
                languages[rootCode][key2] = messageMap[key2];
              }
              languages[code][key2] = messageMap[key2];
            }
          }
          return this;
        },
        freshApi: function(language2) {
          var result = createApi();
          if (language2) {
            result.language(language2);
          }
          return result;
        },
        validate: function(data, schema, checkRecursive, banUnknownProperties) {
          var def = defaultErrorReporter(currentLanguage);
          var errorReporter = customErrorReporter ? function(error2, data2, schema2) {
            return customErrorReporter(error2, data2, schema2) || def(error2, data2, schema2);
          } : def;
          var context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);
          if (typeof schema === "string") {
            schema = { $ref: schema };
          }
          context.addSchema("", schema);
          var error = context.validateAll(data, schema, null, null, "");
          if (!error && banUnknownProperties) {
            error = context.banUnknownProperties(data, schema);
          }
          this.error = error;
          this.missing = context.missing;
          this.valid = error === null;
          return this.valid;
        },
        validateResult: function() {
          var result = { toString: function() {
            return this.valid ? "valid" : this.error.message;
          } };
          this.validate.apply(result, arguments);
          return result;
        },
        validateMultiple: function(data, schema, checkRecursive, banUnknownProperties) {
          var def = defaultErrorReporter(currentLanguage);
          var errorReporter = customErrorReporter ? function(error, data2, schema2) {
            return customErrorReporter(error, data2, schema2) || def(error, data2, schema2);
          } : def;
          var context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);
          if (typeof schema === "string") {
            schema = { $ref: schema };
          }
          context.addSchema("", schema);
          context.validateAll(data, schema, null, null, "");
          if (banUnknownProperties) {
            context.banUnknownProperties(data, schema);
          }
          var result = { toString: function() {
            return this.valid ? "valid" : this.error.message;
          } };
          result.errors = context.errors;
          result.missing = context.missing;
          result.valid = result.errors.length === 0;
          return result;
        },
        addSchema: function() {
          return globalContext.addSchema.apply(globalContext, arguments);
        },
        getSchema: function() {
          return globalContext.getSchema.apply(globalContext, arguments);
        },
        getSchemaMap: function() {
          return globalContext.getSchemaMap.apply(globalContext, arguments);
        },
        getSchemaUris: function() {
          return globalContext.getSchemaUris.apply(globalContext, arguments);
        },
        getMissingUris: function() {
          return globalContext.getMissingUris.apply(globalContext, arguments);
        },
        dropSchemas: function() {
          globalContext.dropSchemas.apply(globalContext, arguments);
        },
        defineKeyword: function() {
          globalContext.defineKeyword.apply(globalContext, arguments);
        },
        defineError: function(codeName, codeNumber, defaultMessage) {
          if (typeof codeName !== "string" || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {
            throw new Error("Code name must be a string in UPPER_CASE_WITH_UNDERSCORES");
          }
          if (typeof codeNumber !== "number" || codeNumber % 1 !== 0 || codeNumber < 1e4) {
            throw new Error("Code number must be an integer > 10000");
          }
          if (typeof ErrorCodes[codeName] !== "undefined") {
            throw new Error("Error already defined: " + codeName + " as " + ErrorCodes[codeName]);
          }
          if (typeof ErrorCodeLookup[codeNumber] !== "undefined") {
            throw new Error("Error code already used: " + ErrorCodeLookup[codeNumber] + " as " + codeNumber);
          }
          ErrorCodes[codeName] = codeNumber;
          ErrorCodeLookup[codeNumber] = codeName;
          ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;
          for (var langCode in languages) {
            var language2 = languages[langCode];
            if (language2[codeName]) {
              language2[codeNumber] = language2[codeNumber] || language2[codeName];
            }
          }
        },
        reset: function() {
          globalContext.reset();
          this.error = null;
          this.missing = [];
          this.valid = true;
        },
        missing: [],
        error: null,
        valid: true,
        normSchema,
        resolveUrl,
        getDocumentUri,
        errorCodes: ErrorCodes
      };
      api.language(language || "en");
      return api;
    }
    var tv4 = createApi();
    tv4.addLanguage("en-gb", ErrorMessagesDefault);
    tv4.tv4 = tv4;
    return tv4;
  });
});

// ../../node_modules/pm2-deploy/deploy.js
var require_deploy = __commonJS((exports2, module2) => {
  var spawn = function(config, args2, cb) {
    var cmd = format('echo \'%j\' | "%s"', config, __require.resolve("C:\Users\balle\Documents\GitHub\echoesmd\node_modules\pm2-deploy\deploy"));
    args2 = args2 || [];
    if (args2.length > 0) {
      var cmdArgs = args2.map(function(arg) {
        return format('"%s"', arg);
      }).join(" ");
      cmd = [cmd, cmdArgs].join(" ");
    }
    var proc = child_process.spawn("sh", ["-c", cmd], { stdio: "inherit" });
    var error;
    proc.on("error", function(err) {
      error = err;
    });
    proc.on("close", function(code) {
      if (code === 0)
        return cb(null, args2);
      error = error || new Error(format("Deploy failed with exit code: %s", code));
      error.code = code;
      return cb(error);
    });
  };
  var clone = function(obj) {
    return JSON.parse(JSON.stringify(obj));
  };
  var castArray = function(arg) {
    return Array.isArray(arg) ? arg : [arg];
  };
  var deployForEnv = function(deployConfig, env, args2, cb) {
    if (!deployConfig[env]) {
      return cb(new Error(format("%s not defined in deploy section", env)));
    }
    var envConfig = clone(deployConfig[env]);
    if (envConfig.ssh_options) {
      envConfig.ssh_options = castArray(envConfig.ssh_options).map(function(option) {
        return format("-o %s", option);
      }).join(" ");
    }
    var result = tv4.validateResult(envConfig, schema);
    if (!result.valid) {
      return cb(result.error);
    }
    if (true) {
      console.log("--> Deploying to %s environment", env);
    }
    if (process.platform !== "win32") {
      envConfig.path = path2.resolve(envConfig.path);
    }
    var hosts = castArray(envConfig.host);
    var jobs = hosts.map(function(host) {
      return function job(done) {
        if (true) {
          console.log("--> on host %s", host.host ? host.host : host);
        }
        var config = clone(envConfig);
        config.host = host;
        config["post-deploy"] = prependEnv(config["post-deploy"], config.env);
        spawn(config, args2, done);
      };
    });
    series(jobs, function(err, result2) {
      result2 = Array.isArray(envConfig.host) ? result2 : result2[0];
      cb(err, result2);
    });
    return false;
  };
  var envToString = function(env) {
    env = env || {};
    return Object.keys(env).map(function(name2) {
      return format("%s=%s", name2.toUpperCase(), env[name2]);
    }).join(" ");
  };
  var prependEnv = function(cmd, env) {
    const envVars = envToString(env);
    if (!envVars)
      return cmd;
    if (!cmd)
      return format("export %s", envVars);
    return format("export %s && %s", envVars, cmd);
  };
  var child_process = __require("child_process");
  var format = __require("util").format;
  var path2 = __require("path");
  var series = require_run_series();
  var tv4 = require_tv4();
  var schema = {
    type: "object",
    properties: {
      user: { type: "string", minLength: 1 },
      host: { type: ["string", "array"] },
      repo: { type: "string" },
      path: { type: "string" },
      ref: { type: "string" },
      fetch: { type: "string" }
    },
    required: ["host", "repo", "path", "ref"]
  };
  module2.exports = {
    deployForEnv
  };
});

// ../../node_modules/pm2/lib/API/Deploy.js
var require_Deploy = __commonJS((exports2, module2) => {
  var deployHelper = function() {
    console.log("");
    console.log("-----> Helper: Deployment with PM2");
    console.log("");
    console.log("  Generate a sample ecosystem.config.js with the command");
    console.log("  $ pm2 ecosystem");
    console.log("  Then edit the file depending on your needs");
    console.log("");
    console.log("  Commands:");
    console.log("    setup                run remote setup commands");
    console.log("    update               update deploy to the latest release");
    console.log("    revert [n]           revert to [n]th last deployment or 1");
    console.log("    curr[ent]            output current release commit");
    console.log("    prev[ious]           output previous release commit");
    console.log("    exec|run <cmd>       execute the given <cmd>");
    console.log("    list                 list previous deploy commits");
    console.log('    [ref]                deploy to [ref], the "ref" setting, or latest tag');
    console.log("");
    console.log("");
    console.log("  Basic Examples:");
    console.log("");
    console.log("    First initialize remote production host:");
    console.log("    $ pm2 deploy ecosystem.config.js production setup");
    console.log("");
    console.log("    Then deploy new code:");
    console.log("    $ pm2 deploy ecosystem.config.js production");
    console.log("");
    console.log("    If I want to revert to the previous commit:");
    console.log("    $ pm2 deploy ecosystem.config.js production revert 1");
    console.log("");
    console.log("    Execute a command on remote server:");
    console.log('    $ pm2 deploy ecosystem.config.js production exec "pm2 restart all"');
    console.log("");
    console.log("    PM2 will look by default to the ecosystem.config.js file so you dont need to give the file name:");
    console.log("    $ pm2 deploy production");
    console.log("    Else you have to tell PM2 the name of your ecosystem file");
    console.log("");
    console.log("    More examples in https://github.com/Unitech/pm2");
    console.log("");
  };
  var fs = __require("fs");
  var cst = require_constants2();
  var Utility = require_Utility();
  var Common = require_Common();
  module2.exports = function(CLI) {
    CLI.prototype.deploy = function(file, commands, cb) {
      var that = this;
      if (file == "help") {
        deployHelper();
        return cb ? cb() : that.exitCli(cst.SUCCESS_EXIT);
      }
      var args2 = commands.rawArgs;
      var env;
      args2.splice(0, args2.indexOf("deploy") + 1);
      if (!Common.isConfigFile(file)) {
        env = args2[0];
        var defaultConfigNames = [...Common.getConfigFileCandidates("ecosystem"), "ecosystem.json5", "package.json"];
        file = Utility.whichFileExists(defaultConfigNames);
        if (!file) {
          Common.printError("Not any default deployment file exists." + " Allowed default config file names are: " + defaultConfigNames.join(", "));
          return cb ? cb("Not any default ecosystem file present") : that.exitCli(cst.ERROR_EXIT);
        }
      } else
        env = args2[1];
      var json_conf = null;
      try {
        json_conf = Common.parseConfig(fs.readFileSync(file), file);
      } catch (e) {
        Common.printError(e);
        return cb ? cb(e) : that.exitCli(cst.ERROR_EXIT);
      }
      if (!env) {
        deployHelper();
        return cb ? cb() : that.exitCli(cst.SUCCESS_EXIT);
      }
      if (!json_conf.deploy || !json_conf.deploy[env]) {
        Common.printError("%s environment is not defined in %s file", env, file);
        return cb ? cb("%s environment is not defined in %s file") : that.exitCli(cst.ERROR_EXIT);
      }
      if (!json_conf.deploy[env]["post-deploy"]) {
        json_conf.deploy[env]["post-deploy"] = "pm2 startOrRestart " + file + " --env " + env;
      }
      require_deploy().deployForEnv(json_conf.deploy, env, args2, function(err, data) {
        if (err) {
          Common.printError("Deploy failed");
          Common.printError(err.message || err);
          return cb ? cb(err) : that.exitCli(cst.ERROR_EXIT);
        }
        Common.printOut("--> Success");
        return cb ? cb(null, data) : that.exitCli(cst.SUCCESS_EXIT);
      });
    };
  };
});

// ../../node_modules/pm2/lib/API/Modules/index.js
var require_Modules = __commonJS((exports2, module2) => {
  var cst = require_constants2();
  var Common = require_Common();
  var chalk = require_source();
  var forEachLimit = require_forEachLimit();
  var Modularizer = require_Modularizer();
  module2.exports = function(CLI) {
    CLI.prototype.install = function(module_name, opts, cb) {
      var that = this;
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      Modularizer.install(this, module_name, opts, function(err, data) {
        if (err) {
          Common.printError(cst.PREFIX_MSG_ERR + (err.message || err));
          return cb ? cb(Common.retErr(err)) : that.speedList(cst.ERROR_EXIT);
        }
        return cb ? cb(null, data) : that.speedList(cst.SUCCESS_EXIT);
      });
    };
    CLI.prototype.uninstall = function(module_name, cb) {
      var that = this;
      Modularizer.uninstall(this, module_name, function(err, data) {
        if (err)
          return cb ? cb(Common.retErr(err)) : that.speedList(cst.ERROR_EXIT);
        return cb ? cb(null, data) : that.speedList(cst.SUCCESS_EXIT);
      });
    };
    CLI.prototype.launchAll = function(CLI2, cb) {
      Modularizer.launchModules(CLI2, cb);
    };
    CLI.prototype.package = function(module_path, cb) {
      Modularizer.package(this, module_path, (err, res) => {
        if (err) {
          Common.errMod(err);
          return cb ? cb(err) : this.exitCli(1);
        }
        Common.logMod(`Module packaged in ${res.path}`);
        return cb ? cb(err) : this.exitCli(0);
      });
    };
    CLI.prototype.publish = function(folder, opts, cb) {
      var that = this;
      Modularizer.publish(this, folder, opts, function(err, data) {
        if (err)
          return cb ? cb(Common.retErr(err)) : that.speedList(cst.ERROR_EXIT);
        return cb ? cb(null, data) : that.speedList(cst.SUCCESS_EXIT);
      });
    };
    CLI.prototype.generateModuleSample = function(app_name, cb) {
      var that = this;
      Modularizer.generateSample(app_name, function(err, data) {
        if (err)
          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
        return cb ? cb(null, data) : that.exitCli(cst.SUCCESS_EXIT);
      });
    };
    CLI.prototype.deleteModule = function(module_name, cb) {
      var that = this;
      var found_proc = [];
      this.Client.getAllProcess(function(err, procs) {
        if (err) {
          Common.printError("Error retrieving process list: " + err);
          return cb(Common.retErr(err));
        }
        procs.forEach(function(proc) {
          if (proc.pm2_env.name == module_name && proc.pm2_env.pmx_module) {
            found_proc.push(proc.pm_id);
          }
        });
        if (found_proc.length == 0)
          return cb();
        that._operate("deleteProcessId", found_proc[0], function(err2) {
          if (err2)
            return cb(Common.retErr(err2));
          Common.printOut("In memory process deleted");
          return cb();
        });
      });
    };
  };
});

// ../../node_modules/pm2/lib/API/pm2-plus/link.js
var require_link = __commonJS((exports2, module2) => {
  var cst = require_constants2();
  var Common = require_Common();
  var chalk = require_source();
  var fs = __require("fs");
  var KMDaemon = require_InteractorClient();
  var pkg = require_package();
  module2.exports = function(CLI) {
    CLI.prototype.linkManagement = function(cmd, public_key, machine, opts, cb) {
      var that = this;
      if (cmd == "stop" || cmd == "kill") {
        that.gl_is_km_linked = false;
        console.log(cst.PM2_IO_MSG + " Stopping agent...");
        return that.killAgent(function(err) {
          if (err) {
            Common.printError(err);
            return process.exit(cst.ERROR_EXIT);
          }
          console.log(cst.PM2_IO_MSG + " Stopped");
          that.reload("all", () => {
            return process.exit(cst.SUCCESS_EXIT);
          });
        });
      }
      if (cmd == "info") {
        console.log(cst.PM2_IO_MSG + " Getting agent information...");
        that.agentInfos(function(err, infos2) {
          if (err) {
            console.error(cst.PM2_IO_MSG_ERR + " " + err.message);
            return that.exitCli(cst.ERROR_EXIT);
          }
          console.log(infos2);
          return that.exitCli(cst.SUCCESS_EXIT);
        });
        return false;
      }
      if (cmd == "delete") {
        that.gl_is_km_linked = false;
        console.log(cst.PM2_IO_MSG + " Permanently disable agent...");
        that.killAgent(function(err) {
          try {
            fs.unlinkSync(cst.INTERACTION_CONF);
          } catch (e) {
            console.log(cst.PM2_IO_MSG + " No interaction config file found");
            return process.exit(cst.SUCCESS_EXIT);
          }
          console.log(cst.PM2_IO_MSG + " Agent interaction ended");
          if (!cb)
            return process.exit(cst.SUCCESS_EXIT);
          return cb();
        });
        return false;
      }
      if (cmd && !public_key) {
        console.error(cst.PM2_IO_MSG + " Command [%s] unknown or missing public key", cmd);
        return process.exit(cst.ERROR_EXIT);
      }
      var infos;
      if (!cmd) {
        infos = null;
      } else
        infos = {
          public_key,
          secret_key: cmd,
          machine_name: machine,
          info_node: opts.infoNode || null,
          pm2_version: pkg.version
        };
      that.link(infos, cb);
    };
    CLI.prototype.link = function(infos, cb) {
      var that = this;
      process.env.WS_JSON_PATCH = true;
      KMDaemon.launchAndInteract(cst, infos, function(err, dt) {
        if (err) {
          Common.printError(cst.PM2_IO_MSG + " Run `$ pm2 plus` to connect");
          return that.exitCli(cst.ERROR_EXIT);
        }
        console.log(chalk.bold.green("[+] PM2+ activated!"));
        if (!cb) {
          return that.exitCli(cst.SUCCESS_EXIT);
        }
        return cb(null, dt);
      });
    };
    CLI.prototype.agentInfos = function(cb) {
      KMDaemon.getInteractInfo(this._conf, function(err, data) {
        if (err)
          return cb(Common.retErr(err));
        return cb(null, data);
      });
    };
    CLI.prototype.killAgent = function(cb) {
      var that = this;
      KMDaemon.killInteractorDaemon(that._conf, function(err) {
        if (err)
          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.SUCCESS_EXIT);
        return cb ? cb(null) : that.exitCli(cst.SUCCESS_EXIT);
      });
    };
    CLI.prototype.unlink = function(cb) {
      this.linkManagement("delete", cb);
    };
  };
});

// ../../node_modules/pm2/lib/API/pm2-plus/process-selector.js
var require_process_selector = __commonJS((exports2, module2) => {
  var fs = __require("fs");
  var forEachLimit = require_forEachLimit();
  var cst = require_constants2();
  var Common = require_Common();
  module2.exports = function(CLI) {
    CLI.prototype.monitorState = function(state, target, cb) {
      var that = this;
      if (!target) {
        Common.printError(cst.PREFIX_MSG_ERR + "Please specify an <app_name|pm_id>");
        return cb ? cb(new Error("argument missing")) : that.exitCli(cst.ERROR_EXIT);
      }
      function monitor(pm_id, cb2) {
        that.Client.executeRemote(state, pm_id, cb2);
      }
      if (target === "all") {
        that.Client.getAllProcessId(function(err, procs) {
          if (err) {
            Common.printError(err);
            return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
          }
          forEachLimit(procs, 1, monitor, function(err2, res) {
            return typeof cb === "function" ? cb(err2, res) : that.speedList();
          });
        });
      } else if (!Number.isInteger(parseInt(target))) {
        this.Client.getProcessIdByName(target, true, function(err, procs) {
          if (err) {
            Common.printError(err);
            return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
          }
          forEachLimit(procs, 1, monitor, function(err2, res) {
            return typeof cb === "function" ? cb(err2, res) : that.speedList();
          });
        });
      } else {
        monitor(parseInt(target), function(err, res) {
          return typeof cb === "function" ? cb(err, res) : that.speedList();
        });
      }
    };
  };
});

// ../../node_modules/pm2/lib/tools/open.js
var require_open = __commonJS((exports2, module2) => {
  var open = function(target, appName, callback) {
    var opener;
    if (typeof appName === "function") {
      callback = appName;
      appName = null;
    }
    switch (process.platform) {
      case "darwin":
        if (appName) {
          opener = 'open -a "' + escape2(appName) + '"';
        } else {
          opener = "open";
        }
        break;
      case "win32":
        if (appName) {
          opener = 'start "" "' + escape2(appName) + '"';
        } else {
          opener = 'start ""';
        }
        break;
      default:
        if (appName) {
          opener = escape2(appName);
        } else {
          opener = path2.join(__dirname, "./xdg-open");
        }
        break;
    }
    if (process.env.SUDO_USER) {
      opener = "sudo -u " + process.env.SUDO_USER + " " + opener;
    }
    return exec(opener + ' "' + escape2(target) + '"', callback);
  };
  var escape2 = function(s) {
    return s.replace(/"/g, "\\\"");
  };
  var __dirname = "C:\\Users\\balle\\Documents\\GitHub\\echoesmd\\node_modules\\pm2\\lib\\tools";
  var exec = __require("child_process").exec;
  var path2 = __require("path");
  module2.exports = open;
});

// ../../node_modules/pm2/lib/API/pm2-plus/helpers.js
var require_helpers3 = __commonJS((exports2, module2) => {
  var processesAreAlreadyMonitored = function(CLI, cb) {
    CLI.Client.executeRemote("getMonitorData", {}, function(err, list) {
      if (err)
        return cb(false);
      var l = list.filter((l3) => l3.pm2_env.km_link == true);
      var l2 = list.filter((l3) => l3.name == "pm2-server-monit");
      return cb(l.length > 0 && l2.length > 0 ? true : false);
    });
  };
  var cst = require_constants2();
  var Common = require_Common();
  var chalk = require_source();
  var forEach2 = require_forEach();
  var open = require_open();
  var Modules = require_Modules();
  module2.exports = function(CLI) {
    CLI.prototype.openDashboard = function() {
      if (!this.gl_interact_infos) {
        Common.printError(chalk.bold.white("Agent if offline, type `$ pm2 plus` to log in"));
        return this.exitCli(cst.ERROR_EXIT);
      }
      var uri = `https://app.pm2.io/#/r/${this.gl_interact_infos.public_key}`;
      console.log(cst.PM2_IO_MSG + ` Opening ${uri}`);
      open(uri);
      setTimeout((_) => {
        this.exitCli();
      }, 200);
    };
    CLI.prototype.clearSetup = function(opts, cb) {
      const modules = ["event-loop-inspector"];
      this.gl_is_km_linked = false;
      forEach2(modules, (_module, next) => {
        Modules.uninstall(this, _module, () => {
          next();
        });
      }, (err) => {
        this.reload("all", () => {
          return cb();
        });
      });
    };
    CLI.prototype.minimumSetup = function(opts, cb) {
      var self2 = this;
      this.gl_is_km_linked = true;
      function install(cb2) {
        var modules = [];
        if (opts.type === "enterprise" || opts.type === "plus") {
          modules = ["pm2-logrotate", "pm2-server-monit"];
          if (opts.type === "enterprise") {
            modules.push("deep-metrics");
          }
        }
        forEach2(modules, (_module, next) => {
          Modules.install(self2, _module, {}, () => {
            next();
          });
        }, (err) => {
          self2.reload("all", () => {
            return cb2();
          });
        });
      }
      processesAreAlreadyMonitored(self2, (already_monitored) => {
        if (already_monitored) {
          console.log(cst.PM2_IO_MSG + ` PM2 ${opts.type || ""} bundle already installed`);
          return cb();
        }
        if (opts.installAll)
          return install(cb);
        return install(cb);
      });
    };
  };
});

// ../../node_modules/pm2/lib/API/Configuration.js
var require_Configuration2 = __commonJS((exports2, module2) => {
  var interactiveConfigEdit = function(cb) {
    UX.helpers.openEditor(cst.PM2_MODULE_CONF_FILE, function(err, data) {
      Common.printOut(chalk.bold("Module configuration (%s) edited."), cst.PM2_MODULE_CONF_FILE);
      Common.printOut(chalk.bold("To take changes into account, please restart module related."), cst.PM2_MODULE_CONF_FILE);
      if (err)
        return cb(Common.retErr(err));
      return cb(null, { success: true });
    });
  };
  var displayConf = function(target_app, cb) {
    if (typeof target_app == "function") {
      cb = target_app;
      target_app = null;
    }
    Configuration.getAll(function(err, data) {
      UX.helpers.dispKeys(data, target_app);
      return cb();
    });
  };
  var Common = require_Common();
  var cst = require_constants2();
  var UX = require_UX();
  var chalk = require_source();
  var Configuration = require_Configuration();
  module2.exports = function(CLI) {
    CLI.prototype.get = function(key, cb) {
      var that = this;
      if (!key || key == "all") {
        displayConf(function(err, data) {
          if (err)
            return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
          return cb ? cb(null, { success: true }) : that.exitCli(cst.SUCCESS_EXIT);
        });
        return false;
      }
      Configuration.get(key, function(err, data) {
        if (err) {
          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
        }
        if (key.indexOf(":") === -1 && key.indexOf(".") === -1) {
          displayConf(key, function() {
            console.log("Modules configuration. Copy/Paste line to edit values.");
            return cb ? cb(null, { success: true }) : that.exitCli(cst.SUCCESS_EXIT);
          });
          return false;
        }
        var module_name, key_name;
        if (key.indexOf(":") > -1) {
          module_name = key.split(":")[0];
          key_name = key.split(":")[1];
        } else if (key.indexOf(".") > -1) {
          module_name = key.split(".")[0];
          key_name = key.split(".")[1];
        }
        Common.printOut("Value for module " + chalk.blue(module_name), "key " + chalk.blue(key_name) + ": " + chalk.bold.green(data));
        return cb ? cb(null, { success: true }) : that.exitCli(cst.SUCCESS_EXIT);
      });
    };
    CLI.prototype.set = function(key, value, cb) {
      var that = this;
      if (!key) {
        interactiveConfigEdit(function(err) {
          if (err)
            return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
          return cb ? cb(null, { success: true }) : that.exitCli(cst.SUCCESS_EXIT);
        });
        return false;
      }
      Configuration.set(key, value, function(err) {
        if (err)
          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
        var values = [];
        if (key.indexOf(".") > -1)
          values = key.split(".");
        if (key.indexOf(":") > -1)
          values = key.split(":");
        if (values && values.length > 1) {
          var app_name = values[0];
          process.env.PM2_PROGRAMMATIC = "true";
          that.restart(app_name, {
            updateEnv: true
          }, function(err2, data) {
            process.env.PM2_PROGRAMMATIC = "false";
            if (!err2)
              Common.printOut(cst.PREFIX_MSG + "Module %s restarted", app_name);
            Common.log("Setting changed");
            displayConf(app_name, function() {
              return cb ? cb(null, { success: true }) : that.exitCli(cst.SUCCESS_EXIT);
            });
          });
          return false;
        }
        displayConf(null, function() {
          return cb ? cb(null, { success: true }) : that.exitCli(cst.SUCCESS_EXIT);
        });
      });
    };
    CLI.prototype.multiset = function(serial, cb) {
      var that = this;
      Configuration.multiset(serial, function(err, data) {
        if (err)
          return cb ? cb({ success: false, err }) : that.exitCli(cst.ERROR_EXIT);
        var values = [];
        var key = serial.match(/(?:[^ "]+|"[^"]*")+/g)[0];
        if (key.indexOf(".") > -1)
          values = key.split(".");
        if (key.indexOf(":") > -1)
          values = key.split(":");
        if (values && values.length > 1) {
          var app_name = values[0];
          process.env.PM2_PROGRAMMATIC = "true";
          that.restart(app_name, {
            updateEnv: true
          }, function(err2, data2) {
            process.env.PM2_PROGRAMMATIC = "false";
            if (!err2)
              Common.printOut(cst.PREFIX_MSG + "Module %s restarted", app_name);
            displayConf(app_name, function() {
              return cb ? cb(null, { success: true }) : that.exitCli(cst.SUCCESS_EXIT);
            });
          });
          return false;
        }
        displayConf(app_name, function() {
          return cb ? cb(null, { success: true }) : that.exitCli(cst.SUCCESS_EXIT);
        });
      });
    };
    CLI.prototype.unset = function(key, cb) {
      var that = this;
      Configuration.unset(key, function(err) {
        if (err) {
          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
        }
        displayConf(function() {
          cb ? cb(null, { success: true }) : that.exitCli(cst.SUCCESS_EXIT);
        });
      });
    };
    CLI.prototype.conf = function(key, value, cb) {
      var that = this;
      if (typeof value === "function") {
        cb = value;
        value = null;
      }
      if (key && value) {
        that.set(key, value, function(err) {
          if (err)
            return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
          return cb ? cb(null, { success: true }) : that.exitCli(cst.SUCCESS_EXIT);
        });
      } else if (key) {
        that.get(key, function(err, data) {
          if (err)
            return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
          return cb ? cb(null, { success: true }) : that.exitCli(cst.SUCCESS_EXIT);
        });
      } else {
        interactiveConfigEdit(function(err) {
          if (err)
            return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
          return cb ? cb(null, { success: true }) : that.exitCli(cst.SUCCESS_EXIT);
        });
      }
    };
  };
});

// ../../node_modules/pm2/lib/API/Version.js
var require_Version = __commonJS((exports2, module2) => {
  var cst = require_constants2();
  var Common = require_Common();
  var fs = __require("fs");
  var eachSeries = require_eachSeries2();
  var child = __require("child_process");
  var printError = Common.printError;
  var printOut = Common.printOut;
  module2.exports = function(CLI) {
    var EXEC_TIMEOUT = 60000;
    CLI.prototype._pull = function(opts, cb) {
      var that = this;
      var process_name = opts.process_name;
      var reload_type = opts.action;
      printOut(cst.PREFIX_MSG + "Updating repository for process name %s", process_name);
      that.Client.getProcessByNameOrId(process_name, function(err, processes) {
        if (err || processes.length === 0) {
          printError("No processes with this name or id : %s", process_name);
          return cb ? cb({ msg: "Process not found: " + process_name }) : that.exitCli(cst.ERROR_EXIT);
        }
        var proc = processes[0];
        if (!proc.pm2_env.versioning) {
          printOut(cst.PREFIX_MSG + "No versioning system found for process %s", process_name);
          return cb ? cb({ success: false, msg: "No versioning system found for process" }) : that.exitCli(cst.SUCCESS_EXIT);
        }
        require_vizion().update({
          folder: proc.pm2_env.versioning.repo_path
        }, function(err2, meta2) {
          if (err2 !== null) {
            return cb ? cb({ msg: err2 }) : that.exitCli(cst.ERROR_EXIT);
          }
          if (meta2.success === true) {
            getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function(command_list) {
              execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err3, res) {
                if (err3 !== null) {
                  printError(err3);
                  return cb ? cb({ msg: meta2.output + err3 }) : that.exitCli(cst.ERROR_EXIT);
                } else {
                  printOut(cst.PREFIX_MSG + "Process successfully updated %s", process_name);
                  printOut(cst.PREFIX_MSG + "Current commit %s", meta2.current_revision);
                  return that[reload_type](process_name, function(err4, procs) {
                    if (err4 && cb)
                      return cb(err4);
                    if (err4)
                      console.error(err4);
                    return cb ? cb(null, meta2.output + res) : that.exitCli(cst.SUCCESS_EXIT);
                  });
                }
              });
            });
          } else {
            printOut(cst.PREFIX_MSG + "Already up-to-date or an error occured for app: %s", process_name);
            return cb ? cb({ success: false, msg: "Already up to date" }) : that.exitCli(cst.SUCCESS_EXIT);
          }
          return false;
        });
        return false;
      });
    };
    CLI.prototype.pullCommitId = function(process_name, commit_id, cb) {
      var reload_type = "reload";
      var that = this;
      printOut(cst.PREFIX_MSG + "Updating repository for process name %s", process_name);
      that.Client.getProcessByNameOrId(process_name, function(err, processes) {
        if (err || processes.length === 0) {
          printError("No processes with this name or id : %s", process_name);
          return cb ? cb({ msg: "Process not found: " + process_name }) : that.exitCli(cst.ERROR_EXIT);
        }
        var proc = processes[0];
        if (proc.pm2_env.versioning) {
          require_vizion().isUpToDate({ folder: proc.pm2_env.versioning.repo_path }, function(err2, meta2) {
            if (err2 !== null)
              return cb ? cb({ msg: err2 }) : that.exitCli(cst.ERROR_EXIT);
            require_vizion().revertTo({
              revision: commit_id,
              folder: proc.pm2_env.versioning.repo_path
            }, function(err22, meta22) {
              if (!err22 && meta22.success) {
                getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function(command_list) {
                  execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err3, res) {
                    if (err3 !== null) {
                      printError(err3);
                      return cb ? cb({ msg: err3 }) : that.exitCli(cst.ERROR_EXIT);
                    } else {
                      printOut(cst.PREFIX_MSG + "Process successfully updated %s", process_name);
                      printOut(cst.PREFIX_MSG + "Current commit %s", commit_id);
                      return that[reload_type](process_name, cb);
                    }
                  });
                });
              } else {
                printOut(cst.PREFIX_MSG + "Already up-to-date or an error occured: %s", process_name);
                return cb ? cb(null, { success: meta2.success }) : that.exitCli(cst.SUCCESS_EXIT);
              }
            });
          });
        } else {
          printOut(cst.PREFIX_MSG + "No versioning system found for process %s", process_name);
          return cb ? cb(null, { success: false }) : that.exitCli(cst.SUCCESS_EXIT);
        }
      });
    };
    CLI.prototype.backward = function(process_name, cb) {
      var that = this;
      printOut(cst.PREFIX_MSG + "Downgrading to previous commit repository for process name %s", process_name);
      that.Client.getProcessByNameOrId(process_name, function(err, processes) {
        if (err || processes.length === 0) {
          printError("No processes with this name or id : %s", process_name);
          return cb ? cb({ msg: "Process not found: " + process_name }) : that.exitCli(cst.ERROR_EXIT);
        }
        var proc = processes[0];
        process_name = proc.name;
        if (proc.pm2_env.versioning === undefined || proc.pm2_env.versioning === null)
          return cb({ msg: "Versioning unknown" });
        require_vizion().prev({
          folder: proc.pm2_env.versioning.repo_path
        }, function(err2, meta2) {
          if (err2)
            return cb ? cb({ msg: err2, data: meta2 }) : that.exitCli(cst.ERROR_EXIT);
          if (meta2.success !== true) {
            printOut(cst.PREFIX_MSG + "No versioning system found for process %s", process_name);
            return cb ? cb({ msg: err2, data: meta2 }) : that.exitCli(cst.ERROR_EXIT);
          }
          getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function(command_list) {
            execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err3, res) {
              if (err3 !== null) {
                require_vizion().next({ folder: proc.pm2_env.versioning.repo_path }, function(err22, meta22) {
                  printError(err3);
                  return cb ? cb({ msg: meta2.output + err3 }) : that.exitCli(cst.ERROR_EXIT);
                });
                return false;
              }
              printOut(cst.PREFIX_MSG + "Process successfully updated %s", process_name);
              printOut(cst.PREFIX_MSG + "Current commit %s", meta2.current_revision);
              that.reload(process_name, function(err4, procs) {
                if (err4)
                  return cb(err4);
                return cb ? cb(null, meta2.output + res) : that.exitCli(cst.SUCCESS_EXIT);
              });
            });
          });
        });
      });
    };
    CLI.prototype.forward = function(process_name, cb) {
      var that = this;
      printOut(cst.PREFIX_MSG + "Updating to next commit repository for process name %s", process_name);
      that.Client.getProcessByNameOrId(process_name, function(err, processes) {
        if (err || processes.length === 0) {
          printError("No processes with this name or id: %s", process_name);
          return cb ? cb({ msg: "Process not found: " + process_name }) : that.exitCli(cst.ERROR_EXIT);
        }
        var proc = processes[0];
        process_name = proc.name;
        if (proc.pm2_env.versioning) {
          require_vizion().next({ folder: proc.pm2_env.versioning.repo_path }, function(err2, meta2) {
            if (err2 !== null)
              return cb ? cb({ msg: err2 }) : that.exitCli(cst.ERROR_EXIT);
            if (meta2.success === true) {
              getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function(command_list) {
                execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err3, res) {
                  if (err3 !== null) {
                    require_vizion().prev({ folder: proc.pm2_env.versioning.repo_path }, function(err22, meta22) {
                      printError(err3);
                      return cb ? cb({ msg: meta2.output + err3 }) : that.exitCli(cst.ERROR_EXIT);
                    });
                  } else {
                    printOut(cst.PREFIX_MSG + "Process successfully updated %s", process_name);
                    printOut(cst.PREFIX_MSG + "Current commit %s", meta2.current_revision);
                    that.reload(process_name, function(err4, procs) {
                      if (err4)
                        return cb(err4);
                      return cb ? cb(null, meta2.output + res) : that.exitCli(cst.SUCCESS_EXIT);
                    });
                  }
                });
              });
            } else {
              printOut(cst.PREFIX_MSG + "Already up-to-date or an error occured: %s", process_name);
              return cb ? cb(null, { success: meta2.success }) : that.exitCli(cst.SUCCESS_EXIT);
            }
          });
        } else {
          printOut(cst.PREFIX_MSG + "No versioning system found for process %s", process_name);
          return cb ? cb({ success: false, msg: "No versioning system found" }) : that.exitCli(cst.SUCCESS_EXIT);
        }
      });
    };
    var exec = function(cmd, callback) {
      var output = "";
      var c = child.exec(cmd, {
        env: process.env,
        maxBuffer: 3 * 1024 * 1024,
        timeout: EXEC_TIMEOUT
      }, function(err) {
        if (callback)
          callback(err ? err.code : 0, output);
      });
      c.stdout.on("data", function(data) {
        output += data;
      });
      c.stderr.on("data", function(data) {
        output += data;
      });
    };
    var execCommands = function(repo_path, command_list, cb) {
      var stdout = "";
      eachSeries(command_list, function(command, callback) {
        stdout += "\n" + command;
        exec("cd " + repo_path + ";" + command, function(code, output) {
          stdout += "\n" + output;
          if (code === 0)
            callback();
          else
            callback("`" + command + "` failed");
        });
      }, function(err) {
        if (err)
          return cb(stdout + "\n" + err);
        return cb(null, stdout);
      });
    };
    var getPostUpdateCmds = function(repo_path, proc_name, cb) {
      if (typeof repo_path !== "string")
        return cb([]);
      if (repo_path[repo_path.length - 1] !== "/")
        repo_path += "/";
      var searchForCommands = function(file, callback) {
        fs.exists(repo_path + file, function(exists) {
          if (exists) {
            try {
              var conf_string = fs.readFileSync(repo_path + file);
              var data = Common.parseConfig(conf_string, repo_path + file);
            } catch (e) {
              console.error(e.message || e);
            }
            if (data && data.apps) {
              eachSeries(data.apps, function(item, callb) {
                if (item.name && item.name === proc_name) {
                  if (item.post_update && typeof item.post_update === "object") {
                    if (item.exec_timeout)
                      EXEC_TIMEOUT = parseInt(item.exec_timeout);
                    return callb(item.post_update);
                  } else {
                    return callb();
                  }
                } else
                  return callb();
              }, function(final) {
                return callback(final);
              });
            } else {
              return callback();
            }
          } else {
            return callback();
          }
        });
      };
      eachSeries(["ecosystem.json", "process.json", "package.json"], searchForCommands, function(final) {
        return cb(final ? final : []);
      });
    };
    CLI.prototype.pullAndRestart = function(process_name, cb) {
      this._pull({ process_name, action: "reload" }, cb);
    };
    CLI.prototype.pullAndReload = function(process_name, cb) {
      this._pull({ process_name, action: "reload" }, cb);
    };
    CLI.prototype._pullCommitId = function(opts, cb) {
      this.pullCommitId(opts.pm2_name, opts.commit_id, cb);
    };
  };
});

// ../../node_modules/pm2/lib/API/Startup.js
var require_Startup = __commonJS((exports2, module2) => {
  var __dirname = "C:\\Users\\balle\\Documents\\GitHub\\echoesmd\\node_modules\\pm2\\lib\\API";
  var chalk = require_source();
  var path2 = __require("path");
  var fs = __require("fs");
  var forEachLimit = require_forEachLimit();
  var eachLimit = require_eachLimit();
  var Common = require_Common();
  var cst = require_constants2();
  var util = __require("util");
  var tmpPath = __require("os").tmpdir;
  var which = require_which();
  var sexec = require_sexec();
  module2.exports = function(CLI) {
    function isNotRoot(startup_mode, platform, opts, cb) {
      Common.printOut(`${cst.PREFIX_MSG}To ${startup_mode} the Startup Script, copy/paste the following command:`);
      if (opts.user) {
        console.log("sudo env PATH=$PATH:" + path2.dirname(process.execPath) + " pm2 " + opts.args[1].name() + " " + platform + " -u " + opts.user + " --hp " + process.env.HOME);
        return cb(new Error("You have to run this with elevated rights"));
      }
      return sexec("whoami", { silent: true }, function(err, stdout, stderr) {
        console.log("sudo env PATH=$PATH:" + path2.dirname(process.execPath) + " " + __require.main.filename + " " + opts.args[1].name() + " " + platform + " -u " + stdout.trim() + " --hp " + process.env.HOME);
        return cb(new Error("You have to run this with elevated rights"));
      });
    }
    function detectInitSystem() {
      var hash_map = {
        systemctl: "systemd",
        "update-rc.d": "upstart",
        chkconfig: "systemv",
        "rc-update": "openrc",
        launchctl: "launchd",
        sysrc: "rcd",
        rcctl: "rcd-openbsd",
        svcadm: "smf"
      };
      var init_systems = Object.keys(hash_map);
      for (var i = 0;i < init_systems.length; i++) {
        if (which(init_systems[i]) != null) {
          break;
        }
      }
      if (i >= init_systems.length) {
        Common.printError(cst.PREFIX_MSG_ERR + "Init system not found");
        return null;
      }
      Common.printOut(cst.PREFIX_MSG + "Init System found: " + chalk.bold(hash_map[init_systems[i]]));
      return hash_map[init_systems[i]];
    }
    CLI.prototype.uninstallStartup = function(platform, opts, cb) {
      var commands;
      var that = this;
      var actual_platform = detectInitSystem();
      var user = opts.user || process.env.USER || process.env.LOGNAME;
      var service_name = opts.serviceName || "pm2-" + user;
      var openrc_service_name = "pm2";
      var launchd_service_name = opts.serviceName || "pm2." + user;
      if (!platform)
        platform = actual_platform;
      else if (actual_platform && actual_platform !== platform) {
        Common.printOut("-----------------------------------------------------------");
        Common.printOut(" PM2 detected " + actual_platform + " but you precised " + platform);
        Common.printOut(" Please verify that your choice is indeed your init system");
        Common.printOut(" If you arent sure, just run : pm2 startup");
        Common.printOut("-----------------------------------------------------------");
      }
      if (platform === null)
        throw new Error("Init system not found");
      if (!cb) {
        cb = function(err, data) {
          if (err)
            return that.exitCli(cst.ERROR_EXIT);
          return that.exitCli(cst.SUCCESS_EXIT);
        };
      }
      if (process.getuid() != 0) {
        return isNotRoot("unsetup", platform, opts, cb);
      }
      if (fs.existsSync("/etc/init.d/pm2-init.sh")) {
        platform = "oldsystem";
      }
      switch (platform) {
        case "systemd":
          commands = [
            "systemctl stop " + service_name,
            "systemctl disable " + service_name,
            "rm /etc/systemd/system/" + service_name + ".service"
          ];
          break;
        case "systemv":
          commands = [
            "chkconfig " + service_name + " off",
            "rm /etc/init.d/" + service_name
          ];
          break;
        case "oldsystem":
          Common.printOut(cst.PREFIX_MSG + "Disabling and deleting old startup system");
          commands = [
            "update-rc.d pm2-init.sh disable",
            "update-rc.d -f pm2-init.sh remove",
            "rm /etc/init.d/pm2-init.sh"
          ];
          break;
        case "openrc":
          service_name = openrc_service_name;
          commands = [
            "/etc/init.d/" + service_name + " stop",
            "rc-update delete " + service_name + " default",
            "rm /etc/init.d/" + service_name
          ];
          break;
        case "upstart":
          commands = [
            "update-rc.d " + service_name + " disable",
            "update-rc.d -f " + service_name + " remove",
            "rm /etc/init.d/" + service_name
          ];
          break;
        case "launchd":
          var destination = path2.join(process.env.HOME, "Library/LaunchAgents/" + launchd_service_name + ".plist");
          commands = [
            "launchctl remove " + launchd_service_name + " || true",
            "rm " + destination
          ];
          break;
        case "rcd":
          service_name = opts.serviceName || "pm2_" + user;
          commands = [
            "/usr/local/etc/rc.d/" + service_name + " stop",
            "sysrc -x " + service_name + "_enable",
            "rm /usr/local/etc/rc.d/" + service_name
          ];
          break;
        case "rcd-openbsd":
          service_name = opts.serviceName || "pm2_" + user;
          var destination = path2.join("/etc/rc.d", service_name);
          commands = [
            "rcctl stop " + service_name,
            "rcctl disable " + service_name,
            "rm " + destination
          ];
          break;
        case "smf":
          service_name = opts.serviceName || "pm2_" + user;
          commands = [
            "svcadm disable " + service_name,
            "svccfg delete -f " + service_name
          ];
      }
      sexec(commands.join("&& "), function(code, stdout, stderr) {
        Common.printOut(stdout);
        Common.printOut(stderr);
        if (code == 0) {
          Common.printOut(cst.PREFIX_MSG + chalk.bold("Init file disabled."));
        } else {
          Common.printOut(cst.ERROR_MSG + chalk.bold("Return code : " + code));
        }
        cb(null, {
          commands,
          platform
        });
      });
    };
    CLI.prototype.startup = function(platform, opts, cb) {
      var that = this;
      var actual_platform = detectInitSystem();
      var user = opts.user || process.env.USER || process.env.LOGNAME;
      var service_name = opts.serviceName || "pm2-" + user;
      var openrc_service_name = "pm2";
      var launchd_service_name = opts.serviceName || "pm2." + user;
      if (!platform)
        platform = actual_platform;
      else if (actual_platform && actual_platform !== platform) {
        Common.printOut("-----------------------------------------------------------");
        Common.printOut(" PM2 detected " + actual_platform + " but you precised " + platform);
        Common.printOut(" Please verify that your choice is indeed your init system");
        Common.printOut(" If you arent sure, just run : pm2 startup");
        Common.printOut("-----------------------------------------------------------");
      }
      if (platform == null)
        throw new Error("Init system not found");
      if (!cb) {
        cb = function(err, data) {
          if (err)
            return that.exitCli(cst.ERROR_EXIT);
          return that.exitCli(cst.SUCCESS_EXIT);
        };
      }
      if (process.getuid() != 0) {
        return isNotRoot("setup", platform, opts, cb);
      }
      var destination;
      var commands;
      var template;
      function getTemplate(type2) {
        return fs.readFileSync(path2.join(__dirname, "..", "templates/init-scripts", type2 + ".tpl"), { encoding: "utf8" });
      }
      switch (platform) {
        case "ubuntu":
        case "centos":
        case "arch":
        case "oracle":
        case "systemd":
          if (opts.waitIp)
            template = getTemplate("systemd-online");
          else
            template = getTemplate("systemd");
          destination = "/etc/systemd/system/" + service_name + ".service";
          commands = [
            "systemctl enable " + service_name
          ];
          break;
        case "ubuntu14":
        case "ubuntu12":
        case "upstart":
          template = getTemplate("upstart");
          destination = "/etc/init.d/" + service_name;
          commands = [
            "chmod +x " + destination,
            "mkdir -p /var/lock/subsys",
            "touch /var/lock/subsys/" + service_name,
            "update-rc.d " + service_name + " defaults"
          ];
          break;
        case "systemv":
        case "amazon":
        case "centos6":
          template = getTemplate("upstart");
          destination = "/etc/init.d/" + service_name;
          commands = [
            "chmod +x " + destination,
            "mkdir -p /var/lock/subsys",
            "touch /var/lock/subsys/" + service_name,
            "chkconfig --add " + service_name,
            "chkconfig " + service_name + " on",
            "initctl list"
          ];
          break;
        case "macos":
        case "darwin":
        case "launchd":
          template = getTemplate("launchd");
          destination = path2.join(process.env.HOME, "Library/LaunchAgents/" + launchd_service_name + ".plist");
          commands = [
            "mkdir -p " + path2.join(process.env.HOME, "Library/LaunchAgents"),
            "launchctl load -w " + destination
          ];
          break;
        case "freebsd":
        case "rcd":
          template = getTemplate("rcd");
          service_name = opts.serviceName || "pm2_" + user;
          destination = "/usr/local/etc/rc.d/" + service_name;
          commands = [
            "chmod 755 " + destination,
            "sysrc " + service_name + "_enable=YES"
          ];
          break;
        case "openbsd":
        case "rcd-openbsd":
          template = getTemplate("rcd-openbsd");
          service_name = opts.serviceName || "pm2_" + user;
          destination = path2.join("/etc/rc.d/", service_name);
          commands = [
            "chmod 755 " + destination,
            "rcctl enable " + service_name,
            "rcctl start " + service_name
          ];
          break;
        case "openrc":
          template = getTemplate("openrc");
          service_name = openrc_service_name;
          destination = "/etc/init.d/" + service_name;
          commands = [
            "chmod +x " + destination,
            "rc-update add " + service_name + " default"
          ];
          break;
        case "smf":
        case "sunos":
        case "solaris":
          template = getTemplate("smf");
          service_name = opts.serviceName || "pm2_" + user;
          destination = path2.join(tmpPath(), service_name + ".xml");
          commands = [
            "svccfg import " + destination,
            "svcadm enable " + service_name
          ];
          break;
        default:
          throw new Error("Unknown platform / init system name");
      }
      var envPath;
      if (cst.HAS_NODE_EMBEDDED == true)
        envPath = util.format("%s:%s", process.env.PATH || "", path2.dirname(process.execPath));
      else if (new RegExp(path2.dirname(process.execPath)).test(process.env.PATH))
        envPath = process.env.PATH;
      else
        envPath = util.format("%s:%s", process.env.PATH || "", path2.dirname(process.execPath));
      template = template.replace(/%PM2_PATH%/g, process.mainModule.filename).replace(/%NODE_PATH%/g, envPath).replace(/%USER%/g, user).replace(/%HOME_PATH%/g, opts.hp ? path2.resolve(opts.hp, ".pm2") : cst.PM2_ROOT_PATH).replace(/%SERVICE_NAME%/g, service_name);
      Common.printOut(chalk.bold("Platform"), platform);
      Common.printOut(chalk.bold("Template"));
      Common.printOut(template);
      Common.printOut(chalk.bold("Target path"));
      Common.printOut(destination);
      Common.printOut(chalk.bold("Command list"));
      Common.printOut(commands);
      Common.printOut(cst.PREFIX_MSG + "Writing init configuration in " + destination);
      try {
        fs.writeFileSync(destination, template);
      } catch (e) {
        console.error(cst.PREFIX_MSG_ERR + "Failure when trying to write startup script");
        console.error(e.message || e);
        return cb(e);
      }
      Common.printOut(cst.PREFIX_MSG + "Making script booting at startup...");
      forEachLimit(commands, 1, function(command, next) {
        Common.printOut(cst.PREFIX_MSG + "[-] Executing: %s...", chalk.bold(command));
        sexec(command, function(code, stdout, stderr) {
          if (code === 0) {
            Common.printOut(cst.PREFIX_MSG + chalk.bold("[v] Command successfully executed."));
            return next();
          } else {
            Common.printOut(chalk.red("[ERROR] Exit code : " + code));
            return next(new Error(command + " failed, see error above."));
          }
        });
      }, function(err) {
        if (err) {
          console.error(cst.PREFIX_MSG_ERR + (err.message || err));
          return cb(err);
        }
        Common.printOut(chalk.bold.blue("+---------------------------------------+"));
        Common.printOut(chalk.bold.blue(cst.PREFIX_MSG + "Freeze a process list on reboot via:"));
        Common.printOut(chalk.bold("$ pm2 save"));
        Common.printOut("");
        Common.printOut(chalk.bold.blue(cst.PREFIX_MSG + "Remove init script via:"));
        Common.printOut(chalk.bold("$ pm2 unstartup " + platform));
        return cb(null, {
          destination,
          template
        });
      });
    };
    CLI.prototype.autodump = function(cb) {
      return cb();
    };
    CLI.prototype.dump = function(force, cb) {
      var env_arr = [];
      var that = this;
      if (typeof force === "function") {
        cb = force;
        force = false;
      }
      if (!cb)
        Common.printOut(cst.PREFIX_MSG + "Saving current process list...");
      that.Client.executeRemote("getMonitorData", {}, function(err, list) {
        if (err) {
          Common.printError("Error retrieving process list: " + err);
          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
        }
        function fin(err2) {
          if (!force && env_arr.length === 0 && !process.env.FORCE) {
            if (!fs.existsSync(cst.DUMP_FILE_PATH)) {
              that.clearDump(function() {
              });
            }
            if (cb) {
              return cb(new Error("Process list empty, cannot save empty list"));
            } else {
              Common.printOut(cst.PREFIX_MSG_WARNING + "PM2 is not managing any process, skipping save...");
              Common.printOut(cst.PREFIX_MSG_WARNING + "To force saving use: pm2 save --force");
              that.exitCli(cst.SUCCESS_EXIT);
              return;
            }
          }
          try {
            if (fs.existsSync(cst.DUMP_FILE_PATH)) {
              fs.writeFileSync(cst.DUMP_BACKUP_FILE_PATH, fs.readFileSync(cst.DUMP_FILE_PATH));
            }
          } catch (e) {
            console.error(e.stack || e);
            Common.printOut(cst.PREFIX_MSG_ERR + "Failed to back up dump file in %s", cst.DUMP_BACKUP_FILE_PATH);
          }
          try {
            fs.writeFileSync(cst.DUMP_FILE_PATH, JSON.stringify(env_arr, "", 2));
          } catch (e) {
            console.error(e.stack || e);
            try {
              if (fs.existsSync(cst.DUMP_BACKUP_FILE_PATH)) {
                fs.writeFileSync(cst.DUMP_FILE_PATH, fs.readFileSync(cst.DUMP_BACKUP_FILE_PATH));
              }
            } catch (e2) {
              fs.unlinkSync(cst.DUMP_FILE_PATH);
              console.error(e2.stack || e2);
            }
            Common.printOut(cst.PREFIX_MSG_ERR + "Failed to save dump file in %s", cst.DUMP_FILE_PATH);
            return that.exitCli(cst.ERROR_EXIT);
          }
          if (cb)
            return cb(null, { success: true });
          Common.printOut(cst.PREFIX_MSG + "Successfully saved in %s", cst.DUMP_FILE_PATH);
          return that.exitCli(cst.SUCCESS_EXIT);
        }
        (function ex(apps) {
          if (!apps[0])
            return fin(null);
          delete apps[0].pm2_env.instances;
          delete apps[0].pm2_env.pm_id;
          delete apps[0].pm2_env.prev_restart_delay;
          if (!apps[0].pm2_env.pmx_module)
            env_arr.push(apps[0].pm2_env);
          apps.shift();
          return ex(apps);
        })(list);
      });
    };
    CLI.prototype.clearDump = function(cb) {
      fs.writeFileSync(cst.DUMP_FILE_PATH, JSON.stringify([]));
      if (cb && typeof cb === "function")
        return cb();
      Common.printOut(cst.PREFIX_MSG + "Successfully created %s", cst.DUMP_FILE_PATH);
      return this.exitCli(cst.SUCCESS_EXIT);
    };
    CLI.prototype.resurrect = function(cb) {
      var apps = {};
      var that = this;
      var processes;
      function readDumpFile(dumpFilePath) {
        Common.printOut(cst.PREFIX_MSG + "Restoring processes located in %s", dumpFilePath);
        try {
          var apps2 = fs.readFileSync(dumpFilePath);
        } catch (e) {
          Common.printError(cst.PREFIX_MSG_ERR + "Failed to read dump file in %s", dumpFilePath);
          throw e;
        }
        return apps2;
      }
      function parseDumpFile(dumpFilePath, apps2) {
        try {
          var processes2 = Common.parseConfig(apps2, "none");
        } catch (e) {
          Common.printError(cst.PREFIX_MSG_ERR + "Failed to parse dump file in %s", dumpFilePath);
          try {
            fs.unlinkSync(dumpFilePath);
          } catch (e2) {
            console.error(e2.stack || e2);
          }
          throw e;
        }
        return processes2;
      }
      try {
        apps = readDumpFile(cst.DUMP_FILE_PATH);
        processes = parseDumpFile(cst.DUMP_FILE_PATH, apps);
      } catch (e) {
        try {
          apps = readDumpFile(cst.DUMP_BACKUP_FILE_PATH);
          processes = parseDumpFile(cst.DUMP_BACKUP_FILE_PATH, apps);
        } catch (e2) {
          Common.printError(cst.PREFIX_MSG_ERR + "No processes saved; DUMP file doesn\'t exist");
          return that.speedList();
        }
      }
      that.Client.executeRemote("getMonitorData", {}, function(err, list) {
        if (err) {
          Common.printError(err);
          return that.exitCli(1);
        }
        var current = [];
        var target = [];
        list.forEach(function(app) {
          if (!current[app.name])
            current[app.name] = 0;
          current[app.name]++;
        });
        processes.forEach(function(app) {
          if (!target[app.name])
            target[app.name] = 0;
          target[app.name]++;
        });
        var tostart = Object.keys(target).filter(function(i) {
          return Object.keys(current).indexOf(i) < 0;
        });
        eachLimit(processes, cst.CONCURRENT_ACTIONS, function(app, next) {
          if (tostart.indexOf(app.name) == -1)
            return next();
          that.Client.executeRemote("prepare", app, function(err2, dt) {
            if (err2)
              Common.printError(err2);
            else
              Common.printOut(cst.PREFIX_MSG + "Process %s restored", app.pm_exec_path);
            next();
          });
        }, function(err2) {
          return cb ? cb(null, apps) : that.speedList();
        });
      });
    };
  };
});

// ../../node_modules/pm2/lib/API/LogManagement.js
var require_LogManagement = __commonJS((exports2, module2) => {
  var chalk = require_source();
  var util = __require("util");
  var fs = __require("fs");
  var exec = __require("child_process").exec;
  var path2 = __require("path");
  var Log = require_Log();
  var cst = require_constants2();
  var Common = require_Common();
  module2.exports = function(CLI) {
    CLI.prototype.flush = function(api, cb) {
      var that = this;
      if (!api) {
        Common.printOut(cst.PREFIX_MSG + "Flushing " + cst.PM2_LOG_FILE_PATH);
        fs.closeSync(fs.openSync(cst.PM2_LOG_FILE_PATH, "w"));
      }
      that.Client.executeRemote("getMonitorData", {}, function(err, list) {
        if (err) {
          Common.printError(err);
          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
        }
        list.forEach(function(l) {
          if (typeof api == "undefined") {
            Common.printOut(cst.PREFIX_MSG + "Flushing:");
            Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_out_log_path);
            Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_err_log_path);
            if (l.pm2_env.pm_log_path) {
              Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_log_path);
              fs.closeSync(fs.openSync(l.pm2_env.pm_log_path, "w"));
            }
            fs.closeSync(fs.openSync(l.pm2_env.pm_out_log_path, "w"));
            fs.closeSync(fs.openSync(l.pm2_env.pm_err_log_path, "w"));
          } else if (l.pm2_env.pm_id == api || l.pm2_env.name === api) {
            Common.printOut(cst.PREFIX_MSG + "Flushing:");
            if (l.pm2_env.pm_log_path && fs.existsSync(l.pm2_env.pm_log_path)) {
              Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_log_path);
              fs.closeSync(fs.openSync(l.pm2_env.pm_log_path, "w"));
            }
            if (l.pm2_env.pm_out_log_path && fs.existsSync(l.pm2_env.pm_out_log_path)) {
              Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_out_log_path);
              fs.closeSync(fs.openSync(l.pm2_env.pm_out_log_path, "w"));
            }
            if (l.pm2_env.pm_err_log_path && fs.existsSync(l.pm2_env.pm_err_log_path)) {
              Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_err_log_path);
              fs.closeSync(fs.openSync(l.pm2_env.pm_err_log_path, "w"));
            }
          }
        });
        Common.printOut(cst.PREFIX_MSG + "Logs flushed");
        return cb ? cb(null, list) : that.exitCli(cst.SUCCESS_EXIT);
      });
    };
    CLI.prototype.logrotate = function(opts, cb) {
      var that = this;
      if (process.getuid() != 0) {
        return exec("whoami", function(err, stdout, stderr) {
          Common.printError(cst.PREFIX_MSG + "You have to run this command as root. Execute the following command:");
          Common.printError(cst.PREFIX_MSG + chalk.grey("      sudo env PATH=$PATH:" + path2.dirname(process.execPath) + " pm2 logrotate -u " + stdout.trim()));
          cb ? cb(Common.retErr("You have to run this with elevated rights")) : that.exitCli(cst.ERROR_EXIT);
        });
      }
      if (!fs.existsSync("/etc/logrotate.d")) {
        Common.printError(cst.PREFIX_MSG + "/etc/logrotate.d does not exist we can not copy the default configuration.");
        return cb ? cb(Common.retErr("/etc/logrotate.d does not exist")) : that.exitCli(cst.ERROR_EXIT);
      }
      var templatePath = path2.join(cst.TEMPLATE_FOLDER, cst.LOGROTATE_SCRIPT);
      Common.printOut(cst.PREFIX_MSG + "Getting logrorate template " + templatePath);
      var script = fs.readFileSync(templatePath, { encoding: "utf8" });
      var user = opts.user || "root";
      script = script.replace(/%HOME_PATH%/g, cst.PM2_ROOT_PATH).replace(/%USER%/g, user);
      try {
        fs.writeFileSync("/etc/logrotate.d/pm2-" + user, script);
      } catch (e) {
        console.error(e.stack || e);
      }
      Common.printOut(cst.PREFIX_MSG + "Logrotate configuration added to /etc/logrotate.d/pm2");
      return cb ? cb(null, { success: true }) : that.exitCli(cst.SUCCESS_EXIT);
    };
    CLI.prototype.reloadLogs = function(cb) {
      var that = this;
      Common.printOut("Reloading all logs...");
      that.Client.executeRemote("reloadLogs", {}, function(err, logs) {
        if (err) {
          Common.printError(err);
          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);
        }
        Common.printOut("All logs reloaded");
        return cb ? cb(null, logs) : that.exitCli(cst.SUCCESS_EXIT);
      });
    };
    CLI.prototype.streamLogs = function(id2, lines, raw, timestamp, exclusive, highlight) {
      var that = this;
      var files_list = [];
      id2 = id2 || "all";
      lines = lines !== undefined ? lines : 20;
      lines = lines < 0 ? -lines : lines;
      var pushIfUnique = function(entry) {
        var exists = false;
        if (entry.path.toLowerCase && entry.path.toLowerCase() !== "/dev/null") {
          files_list.some(function(file) {
            if (file.path === entry.path)
              exists = true;
            return exists;
          });
          if (exists)
            return;
          files_list.push(entry);
        }
      };
      that.Client.executeRemote("getMonitorData", {}, function(err, list) {
        var regexList = [];
        var namespaceList = [];
        if (err) {
          Common.printError(err);
          that.exitCli(cst.ERROR_EXIT);
        }
        if (lines === 0)
          return Log.stream(that.Client, id2, raw, timestamp, exclusive, highlight);
        Common.printOut(chalk.bold.grey(util.format.call(this, "[TAILING] Tailing last %d lines for [%s] process%s (change the value with --lines option)", lines, id2, id2 === "all" ? "es" : "")));
        list.forEach(function(proc) {
          if (proc.pm2_env && (id2 === "all" || proc.pm2_env.name == id2 || proc.pm2_env.pm_id == id2)) {
            if (proc.pm2_env.pm_out_log_path && exclusive !== "err")
              pushIfUnique({
                path: proc.pm2_env.pm_out_log_path,
                app_name: proc.pm2_env.pm_id + "|" + proc.pm2_env.name,
                type: "out"
              });
            if (proc.pm2_env.pm_err_log_path && exclusive !== "out")
              pushIfUnique({
                path: proc.pm2_env.pm_err_log_path,
                app_name: proc.pm2_env.pm_id + "|" + proc.pm2_env.name,
                type: "err"
              });
          } else if (proc.pm2_env && proc.pm2_env.namespace == id2) {
            if (namespaceList.indexOf(proc.pm2_env.name) === -1) {
              namespaceList.push(proc.pm2_env.name);
            }
            if (proc.pm2_env.pm_out_log_path && exclusive !== "err")
              pushIfUnique({
                path: proc.pm2_env.pm_out_log_path,
                app_name: proc.pm2_env.pm_id + "|" + proc.pm2_env.name,
                type: "out"
              });
            if (proc.pm2_env.pm_err_log_path && exclusive !== "out")
              pushIfUnique({
                path: proc.pm2_env.pm_err_log_path,
                app_name: proc.pm2_env.pm_id + "|" + proc.pm2_env.name,
                type: "err"
              });
          } else if (proc.pm2_env && (isNaN(id2) && id2[0] === "/" && id2[id2.length - 1] === "/")) {
            var regex = new RegExp(id2.replace(/\//g, ""));
            if (regex.test(proc.pm2_env.name)) {
              if (regexList.indexOf(proc.pm2_env.name) === -1) {
                regexList.push(proc.pm2_env.name);
              }
              if (proc.pm2_env.pm_out_log_path && exclusive !== "err")
                pushIfUnique({
                  path: proc.pm2_env.pm_out_log_path,
                  app_name: proc.pm2_env.pm_id + "|" + proc.pm2_env.name,
                  type: "out"
                });
              if (proc.pm2_env.pm_err_log_path && exclusive !== "out")
                pushIfUnique({
                  path: proc.pm2_env.pm_err_log_path,
                  app_name: proc.pm2_env.pm_id + "|" + proc.pm2_env.name,
                  type: "err"
                });
            }
          }
        });
        if (!raw && (id2 === "all" || id2 === "PM2") && exclusive === false) {
          Log.tail([{
            path: cst.PM2_LOG_FILE_PATH,
            app_name: "PM2",
            type: "PM2"
          }], lines, raw, function() {
            Log.tail(files_list, lines, raw, function() {
              Log.stream(that.Client, id2, raw, timestamp, exclusive, highlight);
            });
          });
        } else {
          Log.tail(files_list, lines, raw, function() {
            if (regexList.length > 0) {
              regexList.forEach(function(id3) {
                Log.stream(that.Client, id3, raw, timestamp, exclusive, highlight);
              });
            } else if (namespaceList.length > 0) {
              namespaceList.forEach(function(id3) {
                Log.stream(that.Client, id3, raw, timestamp, exclusive, highlight);
              });
            } else {
              Log.stream(that.Client, id2, raw, timestamp, exclusive, highlight);
            }
          });
        }
      });
    };
    CLI.prototype.printLogs = function(id2, lines, raw, timestamp, exclusive) {
      var that = this;
      var files_list = [];
      id2 = id2 || "all";
      lines = lines !== undefined ? lines : 20;
      lines = lines < 0 ? -lines : lines;
      var pushIfUnique = function(entry) {
        var exists = false;
        if (entry.path.toLowerCase && entry.path.toLowerCase() !== "/dev/null") {
          files_list.some(function(file) {
            if (file.path === entry.path)
              exists = true;
            return exists;
          });
          if (exists)
            return;
          files_list.push(entry);
        }
      };
      that.Client.executeRemote("getMonitorData", {}, function(err, list) {
        if (err) {
          Common.printError(err);
          that.exitCli(cst.ERROR_EXIT);
        }
        if (lines <= 0) {
          return that.exitCli(cst.SUCCESS_EXIT);
        }
        Common.printOut(chalk.bold.grey(util.format.call(this, "[TAILING] Tailing last %d lines for [%s] process%s (change the value with --lines option)", lines, id2, id2 === "all" ? "es" : "")));
        list.forEach(function(proc) {
          if (proc.pm2_env && (id2 === "all" || proc.pm2_env.name == id2 || proc.pm2_env.pm_id == id2)) {
            if (proc.pm2_env.pm_out_log_path && exclusive !== "err")
              pushIfUnique({
                path: proc.pm2_env.pm_out_log_path,
                app_name: proc.pm2_env.pm_id + "|" + proc.pm2_env.name,
                type: "out"
              });
            if (proc.pm2_env.pm_err_log_path && exclusive !== "out")
              pushIfUnique({
                path: proc.pm2_env.pm_err_log_path,
                app_name: proc.pm2_env.pm_id + "|" + proc.pm2_env.name,
                type: "err"
              });
          } else if (proc.pm2_env && (isNaN(id2) && id2[0] === "/" && id2[id2.length - 1] === "/")) {
            var regex = new RegExp(id2.replace(/\//g, ""));
            if (regex.test(proc.pm2_env.name)) {
              if (proc.pm2_env.pm_out_log_path && exclusive !== "err")
                pushIfUnique({
                  path: proc.pm2_env.pm_out_log_path,
                  app_name: proc.pm2_env.pm_id + "|" + proc.pm2_env.name,
                  type: "out"
                });
              if (proc.pm2_env.pm_err_log_path && exclusive !== "out")
                pushIfUnique({
                  path: proc.pm2_env.pm_err_log_path,
                  app_name: proc.pm2_env.pm_id + "|" + proc.pm2_env.name,
                  type: "err"
                });
            }
          }
        });
        if (!raw && (id2 === "all" || id2 === "PM2") && exclusive === false) {
          Log.tail([{
            path: cst.PM2_LOG_FILE_PATH,
            app_name: "PM2",
            type: "PM2"
          }], lines, raw, function() {
            Log.tail(files_list, lines, raw, function() {
              that.exitCli(cst.SUCCESS_EXIT);
            });
          });
        } else {
          Log.tail(files_list, lines, raw, function() {
            that.exitCli(cst.SUCCESS_EXIT);
          });
        }
      });
    };
  };
});

// ../../node_modules/pm2/lib/tools/promise.min.js
var require_promise_min = __commonJS((exports2, module2) => {
  (function(e) {
    function n() {
    }
    function t(e2, n2) {
      return function() {
        e2.apply(n2, arguments);
      };
    }
    function o(e2) {
      if (typeof this != "object")
        throw new TypeError("Promises must be constructed via new");
      if (typeof e2 != "function")
        throw new TypeError("not a function");
      this._state = 0, this._handled = false, this._value = undefined, this._deferreds = [], s(e2, this);
    }
    function i(e2, n2) {
      for (;e2._state === 3; )
        e2 = e2._value;
      return e2._state === 0 ? void e2._deferreds.push(n2) : (e2._handled = true, void o._immediateFn(function() {
        var t2 = e2._state === 1 ? n2.onFulfilled : n2.onRejected;
        if (t2 === null)
          return void (e2._state === 1 ? r : u)(n2.promise, e2._value);
        var o2;
        try {
          o2 = t2(e2._value);
        } catch (e3) {
          return void u(n2.promise, e3);
        }
        r(n2.promise, o2);
      }));
    }
    function r(e2, n2) {
      try {
        if (n2 === e2)
          throw new TypeError("A promise cannot be resolved with itself.");
        if (n2 && (typeof n2 == "object" || typeof n2 == "function")) {
          var i2 = n2.then;
          if (n2 instanceof o)
            return e2._state = 3, e2._value = n2, void f(e2);
          if (typeof i2 == "function")
            return void s(t(i2, n2), e2);
        }
        e2._state = 1, e2._value = n2, f(e2);
      } catch (n3) {
        u(e2, n3);
      }
    }
    function u(e2, n2) {
      e2._state = 2, e2._value = n2, f(e2);
    }
    function f(e2) {
      e2._state === 2 && e2._deferreds.length === 0 && o._immediateFn(function() {
        e2._handled || o._unhandledRejectionFn(e2._value);
      });
      for (var n2 = 0, t2 = e2._deferreds.length;n2 < t2; n2++)
        i(e2, e2._deferreds[n2]);
      e2._deferreds = null;
    }
    function c(e2, n2, t2) {
      this.onFulfilled = typeof e2 == "function" ? e2 : null, this.onRejected = typeof n2 == "function" ? n2 : null, this.promise = t2;
    }
    function s(e2, n2) {
      var t2 = false;
      try {
        e2(function(e3) {
          t2 || (t2 = true, r(n2, e3));
        }, function(e3) {
          t2 || (t2 = true, u(n2, e3));
        });
      } catch (e3) {
        if (t2)
          return;
        t2 = true, u(n2, e3);
      }
    }
    var a = setTimeout;
    o.prototype.catch = function(e2) {
      return this.then(null, e2);
    }, o.prototype.then = function(e2, t2) {
      var o2 = new this.constructor(n);
      return i(this, new c(e2, t2, o2)), o2;
    }, o.all = function(e2) {
      var n2 = Array.prototype.slice.call(e2);
      return new o(function(e3, t2) {
        function o2(r3, u2) {
          try {
            if (u2 && (typeof u2 == "object" || typeof u2 == "function")) {
              var f2 = u2.then;
              if (typeof f2 == "function")
                return void f2.call(u2, function(e4) {
                  o2(r3, e4);
                }, t2);
            }
            n2[r3] = u2, --i2 === 0 && e3(n2);
          } catch (e4) {
            t2(e4);
          }
        }
        if (n2.length === 0)
          return e3([]);
        for (var i2 = n2.length, r2 = 0;r2 < n2.length; r2++)
          o2(r2, n2[r2]);
      });
    }, o.resolve = function(e2) {
      return e2 && typeof e2 == "object" && e2.constructor === o ? e2 : new o(function(n2) {
        n2(e2);
      });
    }, o.reject = function(e2) {
      return new o(function(n2, t2) {
        t2(e2);
      });
    }, o.race = function(e2) {
      return new o(function(n2, t2) {
        for (var o2 = 0, i2 = e2.length;o2 < i2; o2++)
          e2[o2].then(n2, t2);
      });
    }, o._immediateFn = typeof setImmediate == "function" && function(e2) {
      setImmediate(e2);
    } || function(e2) {
      a(e2, 0);
    }, o._unhandledRejectionFn = function(e2) {
      typeof console != "undefined" && console && console.warn("Possible Unhandled Promise Rejection:", e2);
    }, o._setImmediateFn = function(e2) {
      o._immediateFn = e2;
    }, o._setUnhandledRejectionFn = function(e2) {
      o._unhandledRejectionFn = e2;
    }, typeof module2 != "undefined" && exports2 ? module2.exports = o : e.Promise || (e.Promise = o);
  })(exports2);
});

// ../../node_modules/mute-stream/mute.js
var require_mute = __commonJS((exports2, module2) => {
  var MuteStream = function(opts) {
    Stream.apply(this);
    opts = opts || {};
    this.writable = this.readable = true;
    this.muted = false;
    this.on("pipe", this._onpipe);
    this.replace = opts.replace;
    this._prompt = opts.prompt || null;
    this._hadControl = false;
  };
  var onPipe = function(src) {
    this._src = src;
  };
  var getIsTTY = function() {
    return this._dest ? this._dest.isTTY : this._src ? this._src.isTTY : false;
  };
  var setIsTTY = function(isTTY2) {
    Object.defineProperty(this, "isTTY", {
      value: isTTY2,
      enumerable: true,
      writable: true,
      configurable: true
    });
  };
  var proxy = function(fn) {
    return function() {
      var d = this._dest;
      var s = this._src;
      if (d && d[fn])
        d[fn].apply(d, arguments);
      if (s && s[fn])
        s[fn].apply(s, arguments);
    };
  };
  var Stream = __require("stream");
  module2.exports = MuteStream;
  MuteStream.prototype = Object.create(Stream.prototype);
  Object.defineProperty(MuteStream.prototype, "constructor", {
    value: MuteStream,
    enumerable: false
  });
  MuteStream.prototype.mute = function() {
    this.muted = true;
  };
  MuteStream.prototype.unmute = function() {
    this.muted = false;
  };
  Object.defineProperty(MuteStream.prototype, "_onpipe", {
    value: onPipe,
    enumerable: false,
    writable: true,
    configurable: true
  });
  Object.defineProperty(MuteStream.prototype, "isTTY", {
    get: getIsTTY,
    set: setIsTTY,
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MuteStream.prototype, "rows", {
    get: function() {
      return this._dest ? this._dest.rows : this._src ? this._src.rows : undefined;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MuteStream.prototype, "columns", {
    get: function() {
      return this._dest ? this._dest.columns : this._src ? this._src.columns : undefined;
    },
    enumerable: true,
    configurable: true
  });
  MuteStream.prototype.pipe = function(dest, options2) {
    this._dest = dest;
    return Stream.prototype.pipe.call(this, dest, options2);
  };
  MuteStream.prototype.pause = function() {
    if (this._src)
      return this._src.pause();
  };
  MuteStream.prototype.resume = function() {
    if (this._src)
      return this._src.resume();
  };
  MuteStream.prototype.write = function(c) {
    if (this.muted) {
      if (!this.replace)
        return true;
      if (c.match(/^\u001b/)) {
        if (c.indexOf(this._prompt) === 0) {
          c = c.substr(this._prompt.length);
          c = c.replace(/./g, this.replace);
          c = this._prompt + c;
        }
        this._hadControl = true;
        return this.emit("data", c);
      } else {
        if (this._prompt && this._hadControl && c.indexOf(this._prompt) === 0) {
          this._hadControl = false;
          this.emit("data", this._prompt);
          c = c.substr(this._prompt.length);
        }
        c = c.toString().replace(/./g, this.replace);
      }
    }
    this.emit("data", c);
  };
  MuteStream.prototype.end = function(c) {
    if (this.muted) {
      if (c && this.replace) {
        c = c.toString().replace(/./g, this.replace);
      } else {
        c = null;
      }
    }
    if (c)
      this.emit("data", c);
    this.emit("end");
  };
  MuteStream.prototype.destroy = proxy("destroy");
  MuteStream.prototype.destroySoon = proxy("destroySoon");
  MuteStream.prototype.close = proxy("close");
});

// ../../node_modules/read/lib/read.js
var require_read = __commonJS((exports2, module2) => {
  var read = function(opts, cb) {
    if (opts.num) {
      throw new Error("read() no longer accepts a char number limit");
    }
    if (typeof opts.default !== "undefined" && typeof opts.default !== "string" && typeof opts.default !== "number") {
      throw new Error("default value must be string or number");
    }
    var input = opts.input || process.stdin;
    var output = opts.output || process.stdout;
    var prompt = (opts.prompt || "").trim() + " ";
    var silent = opts.silent;
    var editDef = false;
    var timeout = opts.timeout;
    var def = opts.default || "";
    if (def) {
      if (silent) {
        prompt += "(<default hidden>) ";
      } else if (opts.edit) {
        editDef = true;
      } else {
        prompt += "(" + def + ") ";
      }
    }
    var terminal = !!(opts.terminal || output.isTTY);
    var m = new Mute({ replace: opts.replace, prompt });
    m.pipe(output, { end: false });
    output = m;
    var rlOpts = { input, output, terminal };
    if (process.version.match(/^v0\.6/)) {
      var rl = readline.createInterface(rlOpts.input, rlOpts.output);
    } else {
      var rl = readline.createInterface(rlOpts);
    }
    output.unmute();
    rl.setPrompt(prompt);
    rl.prompt();
    if (silent) {
      output.mute();
    } else if (editDef) {
      rl.line = def;
      rl.cursor = def.length;
      rl._refreshLine();
    }
    var called = false;
    rl.on("line", onLine);
    rl.on("error", onError);
    rl.on("SIGINT", function() {
      rl.close();
      onError(new Error("canceled"));
    });
    var timer;
    if (timeout) {
      timer = setTimeout(function() {
        onError(new Error("timed out"));
      }, timeout);
    }
    function done() {
      called = true;
      rl.close();
      if (process.version.match(/^v0\.6/)) {
        rl.input.removeAllListeners("data");
        rl.input.removeAllListeners("keypress");
        rl.input.pause();
      }
      clearTimeout(timer);
      output.mute();
      output.end();
    }
    function onError(er) {
      if (called)
        return;
      done();
      return cb(er);
    }
    function onLine(line) {
      if (called)
        return;
      if (silent && terminal) {
        output.unmute();
        output.write("\r\n");
      }
      done();
      line = line.replace(/\r?\n$/, "");
      var isDefault = !!(editDef && line === def);
      if (def && !line) {
        isDefault = true;
        line = def;
      }
      cb(null, line, isDefault);
    }
  };
  module2.exports = read;
  var readline = __require("readline");
  var Mute = require_mute();
});

// ../../node_modules/promptly/index.js
var require_promptly = __commonJS((exports2, module2) => {
  var prompt = function(message, opts, fn) {
    var readOpts = {
      prompt: message,
      input: opts.input || process.stdin,
      output: opts.output || process.stdout,
      silent: opts.silent,
      replace: opts.replace || ""
    };
    read(readOpts, function(err, data) {
      if (err) {
        return;
      }
      if (opts.trim) {
        data = data.trim();
      }
      if (opts["default"] == null && !data) {
        return promptly.prompt(message, opts, fn);
      } else {
        data = data || opts["default"];
      }
      if (opts.validator) {
        if (!Array.isArray(opts.validator)) {
          opts.validator = [opts.validator];
        }
        var x;
        var length3 = opts.validator.length;
        for (x = 0;x < length3; x += 1) {
          try {
            data = opts.validator[x](data);
          } catch (e) {
            if (opts.retry) {
              if (e.message) {
                readOpts.output.write(e.message + "\n");
              }
              return promptly.prompt(message, opts, fn);
            }
            e.retry = promptly.prompt.bind(promptly, message, opts, fn);
            return fn(e);
          }
        }
      }
      fn(null, data);
    });
  };
  var read = require_read();
  var promptly = exports2;
  promptly.prompt = function(message, opts, fn) {
    if (typeof opts === "function") {
      fn = opts;
      opts = {};
    } else if (!opts) {
      opts = {};
    }
    if (opts.trim === undefined) {
      opts.trim = true;
    }
    if (opts.retry === undefined) {
      opts.retry = true;
    }
    if (fn) {
      return prompt(message, opts, fn);
    }
    return new Promise(function(resolve, reject) {
      prompt(message, opts, function(err, result) {
        if (err) {
          return reject(err);
        }
        resolve(result);
      });
    });
  };
  promptly.password = function(message, opts, fn) {
    if (typeof opts === "function") {
      fn = opts;
      opts = {};
    } else {
      opts = opts || {};
    }
    if (opts.silent === undefined) {
      opts.silent = true;
    }
    if (opts.trim === undefined) {
      opts.trim = false;
    }
    if (opts["default"] === undefined) {
      opts["default"] = "";
    }
    return promptly.prompt(message, opts, fn);
  };
  promptly.confirm = function(message, opts, fn) {
    if (typeof opts === "function") {
      fn = opts;
      opts = {};
    } else if (!opts) {
      opts = {};
    }
    opts.validator = opts.validator || [];
    if (!Array.isArray(opts.validator)) {
      opts.validator = [opts.validator];
    }
    var validator = function(value) {
      if (typeof value === "string") {
        value = value.toLowerCase();
      }
      switch (value) {
        case "y":
        case "yes":
        case "1":
        case true:
          return true;
        case "n":
        case "no":
        case "0":
        case false:
          return false;
      }
      throw new Error;
    };
    opts.validator.push(validator);
    return promptly.choose(message, [true, false], opts, fn);
  };
  promptly.choose = function(message, choices, opts, fn) {
    if (typeof opts === "function") {
      fn = opts;
      opts = {};
    } else if (!opts) {
      opts = {};
    }
    opts.validator = opts.validator || [];
    if (!Array.isArray(opts.validator)) {
      opts.validator = [opts.validator];
    }
    var nrChoices = choices.length;
    var validator = function(value) {
      var x;
      for (x = 0;x < nrChoices; x++) {
        if (choices[x] == value) {
          return choices[x];
        }
      }
      throw new Error("Invalid choice: " + value);
    };
    opts.validator.push(validator);
    return promptly.prompt(message, opts, fn);
  };
});

// ../../node_modules/pm2/lib/API/Containerizer.js
var require_Containerizer = __commonJS((exports2, module2) => {
  var pspawn = function(cmd) {
    return new Promise2(function(resolve, reject) {
      var p_cmd = cmd.split(" ");
      var install_instance = spawn(p_cmd[0], p_cmd.splice(1, cmd.length), {
        stdio: "inherit",
        env: process.env,
        shell: true
      });
      install_instance.on("close", function(code) {
        if (code != 0) {
          console.log(chalk.bold.red("Command failed"));
          return reject(new Error("Bad cmd return"));
        }
        return resolve();
      });
      install_instance.on("error", function(err) {
        return reject(err);
      });
    });
  };
  var checkDockerSetup = function() {
    return new Promise2(function(resolve, reject) {
      exec("docker version -f '{{.Client.Version}}'", function(err, stdout, stderr) {
        if (err) {
          console.error(chalk.red.bold("[Docker access] Error while trying to use docker command"));
          if (err.message && err.message.indexOf("Cannot connect to the Docker") > -1) {
            console.log();
            console.log(chalk.blue.bold("[Solution] Setup Docker to be able to be used without sudo rights:"));
            console.log(chalk.bold("$ sudo groupadd docker"));
            console.log(chalk.bold("$ sudo usermod -aG docker $USER"));
            console.log(chalk.bold("Then LOGOUT and LOGIN your Linux session"));
            console.log("Read more: http://bit.ly/29JGdCE");
          }
          return reject(err);
        }
        return resolve();
      });
    });
  };
  var parseAndSwitch = function(file_content, main_file, opts) {
    var lines = file_content.split("\n");
    var mode = opts.mode;
    lines[0] = "FROM keymetrics/pm2:" + opts.node_version;
    for (var i = 0;i < lines.length; i++) {
      var line = lines[i];
      if (["## DISTRIBUTION MODE", "## DEVELOPMENT MODE"].indexOf(line) > -1 || i == lines.length - 1) {
        lines.splice(i, lines.length);
        lines[i] = "## " + mode.toUpperCase() + " MODE";
        lines[i + 1] = "ENV NODE_ENV=" + (mode == "distribution" ? "production" : mode);
        if (mode == "distribution") {
          lines[i + 2] = "COPY . /var/app";
          lines[i + 3] = 'CMD ["pm2-docker", "' + main_file + '", "--env", "production"]';
        }
        if (mode == "development") {
          lines[i + 2] = 'CMD ["pm2-dev", "' + main_file + '", "--env", "development"]';
        }
        break;
      }
    }
    lines = lines.join("\n");
    return lines;
  };
  var switchDockerFile = function(docker_filepath, main_file, opts) {
    return new Promise2(function(resolve, reject) {
      var data = fs.readFileSync(docker_filepath, "utf8").toString();
      if (["distribution", "development"].indexOf(opts.mode) == -1)
        return reject(new Error("Unknown mode"));
      var lines = parseAndSwitch(data, main_file, opts);
      fs.writeFile(docker_filepath, lines, function(err) {
        if (err)
          return reject(err);
        resolve({
          Dockerfile_path: docker_filepath,
          Dockerfile: lines,
          CMD: ""
        });
      });
    });
  };
  var generateDockerfile = function(docker_filepath, main_file, opts) {
    return new Promise2(function(resolve, reject) {
      var tpl_file = path2.join(cst.TEMPLATE_FOLDER, cst.DOCKERFILE_NODEJS);
      var template = fs.readFileSync(tpl_file, { encoding: "utf8" });
      var CMD;
      template = parseAndSwitch(template, main_file, opts);
      fs.writeFile(docker_filepath, template, function(err) {
        if (err)
          return reject(err);
        resolve({
          Dockerfile_path: docker_filepath,
          Dockerfile: template,
          CMD
        });
      });
    });
  };
  var handleExit = function(CLI, opts, mode) {
    process.on("SIGINT", function() {
      CLI.disconnect();
      if (mode != "distribution")
        return false;
      exec("docker ps -lq", function(err, stdout, stderr) {
        if (err) {
          console.error(err);
        }
        require_vizion().analyze({ folder: process.cwd() }, function recur_path(err2, meta2) {
          if (!err2 && meta2.revision) {
            var commit_id = util.format("#%s(%s) %s", meta2.branch, meta2.revision.slice(0, 5), meta2.comment);
            console.log(chalk.bold.magenta('$ docker commit -m "%s" %s %s'), commit_id, stdout.replace("\n", ""), opts.imageName);
          } else
            console.log(chalk.bold.magenta("$ docker commit %s %s"), stdout.replace("\n", ""), opts.imageName);
          console.log(chalk.bold.magenta("$ docker push %s"), opts.imageName);
        });
      });
    });
  };
  var spawn = __require("child_process").spawn;
  var exec = __require("child_process").exec;
  var chalk = require_source();
  var util = __require("util");
  var fmt = require_fmt();
  var fs = __require("fs");
  var path2 = __require("path");
  var cst = require_constants2();
  var Promise2 = require_promise_min();
  module2.exports = function(CLI) {
    CLI.prototype.generateDockerfile = function(script, opts) {
      var docker_filepath = path2.join(process.cwd(), "Dockerfile");
      var that = this;
      fs.stat(docker_filepath, function(err, stat) {
        if (err || opts.force == true) {
          generateDockerfile(docker_filepath, script, {
            mode: "development"
          }).then(function() {
            console.log(chalk.bold("New Dockerfile generated in current folder"));
            console.log(chalk.bold("You can now run\n$ pm2 docker:dev <file|config>"));
            return that.exitCli(cst.SUCCESS_EXIT);
          });
          return false;
        }
        console.log(chalk.red.bold("Dockerfile already exists in this folder, use --force if you want to replace it"));
        that.exitCli(cst.ERROR_EXIT);
      });
    };
    CLI.prototype.dockerMode = function(script, opts, mode) {
      var promptly = require_promptly();
      var self2 = this;
      handleExit(self2, opts, mode);
      if (mode == "distribution" && !opts.imageName) {
        console.error(chalk.bold.red("--image-name [name] option is missing"));
        return self2.exitCli(cst.ERROR_EXIT);
      }
      var template;
      var app_path, main_script;
      var image_name;
      var node_version = opts.nodeVersion ? opts.nodeVersion.split(".")[0] : "latest";
      image_name = opts.imageName || __require("crypto").randomBytes(6).toString("hex");
      if (script.indexOf("/") > -1) {
        app_path = path2.join(process.cwd(), path2.dirname(script));
        main_script = path2.basename(script);
      } else {
        app_path = process.cwd();
        main_script = script;
      }
      checkDockerSetup().then(function() {
        return new Promise2(function(resolve, reject) {
          var docker_filepath = path2.join(process.cwd(), "Dockerfile");
          fs.stat(docker_filepath, function(err, stat) {
            if (err) {
              if (opts.force == true) {
                return resolve(generateDockerfile(docker_filepath, main_script, {
                  node_version,
                  mode
                }));
              }
              if (opts.dockerdaemon)
                return resolve(generateDockerfile(docker_filepath, main_script, {
                  node_version,
                  mode
                }));
              promptly.prompt("No Dockerfile in current directory, ok to generate a new one? (y/n)", function(err2, value) {
                if (value == "y")
                  return resolve(generateDockerfile(docker_filepath, main_script, {
                    node_version,
                    mode
                  }));
                else
                  return self2.exitCli(cst.SUCCESS_EXIT);
              });
              return false;
            }
            return resolve(switchDockerFile(docker_filepath, main_script, {
              node_version,
              mode
            }));
          });
        });
      }).then(function(_template) {
        template = _template;
        return Promise2.resolve();
      }).then(function() {
        var docker_build = util.format("docker build -t %s -f %s", image_name, template.Dockerfile_path);
        if (opts.fresh == true)
          docker_build += " --no-cache";
        docker_build += " .";
        console.log();
        fmt.sep();
        fmt.title("Building Boot System");
        fmt.field("Type", chalk.cyan.bold("Docker"));
        fmt.field("Mode", mode);
        fmt.field("Image name", image_name);
        fmt.field("Docker build command", docker_build);
        fmt.field("Dockerfile path", template.Dockerfile_path);
        fmt.sep();
        return pspawn(docker_build);
      }).then(function() {
        var docker_run = "docker run --net host";
        if (opts.dockerdaemon == true)
          docker_run += " -d";
        if (mode != "distribution")
          docker_run += util.format(" -v %s:/var/app -v /var/app/node_modules", app_path);
        docker_run += " " + image_name;
        var dockerfile_parsed = template.Dockerfile.split("\n");
        var base_image = dockerfile_parsed[0];
        var run_cmd = dockerfile_parsed[dockerfile_parsed.length - 1];
        console.log();
        fmt.sep();
        fmt.title("Booting");
        fmt.field("Type", chalk.cyan.bold("Docker"));
        fmt.field("Mode", mode);
        fmt.field("Base Image", base_image);
        fmt.field("Image Name", image_name);
        fmt.field("Docker Command", docker_run);
        fmt.field("RUN Command", run_cmd);
        fmt.field("CWD", app_path);
        fmt.sep();
        return pspawn(docker_run);
      }).then(function() {
        console.log(chalk.blue.bold(">>> Leaving Docker instance uuid=%s"), image_name);
        self2.disconnect();
        return Promise2.resolve();
      }).catch(function(err) {
        console.log();
        console.log(chalk.grey("Raw error=", err.message));
        self2.disconnect();
      });
    };
  };
  module2.exports.generateDockerfile = generateDockerfile;
  module2.exports.parseAndSwitch = parseAndSwitch;
  module2.exports.switchDockerFile = switchDockerFile;
});

// ../../node_modules/pm2/lib/API.js
var require_API = __commonJS((exports2, module2) => {
  var __dirname = "C:\\Users\\balle\\Documents\\GitHub\\echoesmd\\node_modules\\pm2\\lib";
  var commander = require_commander();
  var fs = __require("fs");
  var path2 = __require("path");
  var eachLimit = require_eachLimit();
  var series = require_series();
  var debug = require_src()("pm2:cli");
  var util = __require("util");
  var chalk = require_source();
  var fclone = require_fclone();
  var DockerMgmt = require_Docker();
  var conf2 = require_constants2();
  var Client = require_Client();
  var Common = require_Common();
  var KMDaemon = require_InteractorClient();
  var Config = require_Config();
  var Modularizer = require_Modularizer();
  var path_structure = require_paths();
  var UX = require_UX();
  var pkg = require_package();
  var hf = require_flagExt();
  var Configuration = require_Configuration();
  var sexec = require_sexec();
  var IMMUTABLE_MSG = chalk.bold.blue("Use --update-env to update environment variables");

  class API {
    constructor(opts) {
      if (!opts)
        opts = {};
      var that = this;
      this.daemon_mode = typeof opts.daemon_mode == "undefined" ? true : opts.daemon_mode;
      this.pm2_home = conf2.PM2_ROOT_PATH;
      this.public_key = conf2.PUBLIC_KEY || opts.public_key || null;
      this.secret_key = conf2.SECRET_KEY || opts.secret_key || null;
      this.machine_name = conf2.MACHINE_NAME || opts.machine_name || null;
      this.cwd = process.cwd();
      if (opts.cwd) {
        this.cwd = path2.resolve(opts.cwd);
      }
      if (opts.pm2_home && opts.independent == true)
        throw new Error("You cannot set a pm2_home and independent instance in same time");
      if (opts.pm2_home) {
        this.pm2_home = opts.pm2_home;
        conf2 = Object.assign(conf2, path_structure(this.pm2_home));
      } else if (opts.independent == true && conf2.IS_WINDOWS === false) {
        const crypto = __require("crypto");
        var random_file = crypto.randomBytes(8).toString("hex");
        this.pm2_home = path2.join("/tmp", random_file);
        if (typeof opts.daemon_mode == "undefined")
          this.daemon_mode = false;
        conf2 = Object.assign(conf2, path_structure(this.pm2_home));
      }
      this._conf = conf2;
      if (conf2.IS_WINDOWS) {
        if (process.stdout._handle && process.stdout._handle.setBlocking)
          process.stdout._handle.setBlocking(true);
      }
      this.Client = new Client({
        pm2_home: that.pm2_home,
        conf: this._conf,
        secret_key: this.secret_key,
        public_key: this.public_key,
        daemon_mode: this.daemon_mode,
        machine_name: this.machine_name
      });
      this.pm2_configuration = Configuration.getSync("pm2") || {};
      this.gl_interact_infos = null;
      this.gl_is_km_linked = false;
      try {
        var pid = fs.readFileSync(conf2.INTERACTOR_PID_PATH);
        pid = parseInt(pid.toString().trim());
        process.kill(pid, 0);
        that.gl_is_km_linked = true;
      } catch (e) {
        that.gl_is_km_linked = false;
      }
      if (this.secret_key && false)
        ;
      KMDaemon.ping(this._conf, function(err, result) {
        if (!err && result === true) {
          fs.readFile(conf2.INTERACTION_CONF, (err2, _conf) => {
            if (!err2) {
              try {
                that.gl_interact_infos = JSON.parse(_conf.toString());
              } catch (e) {
                var json5 = require_json5();
                try {
                  that.gl_interact_infos = json5.parse(_conf.toString());
                } catch (e2) {
                  console.error(e2);
                  that.gl_interact_infos = null;
                }
              }
            }
          });
        }
      });
      this.gl_retry = 0;
    }
    connect(noDaemon, cb) {
      var that = this;
      this.start_timer = new Date;
      if (typeof cb == "undefined") {
        cb = noDaemon;
        noDaemon = false;
      } else if (noDaemon === true) {
        this.Client.daemon_mode = false;
        this.daemon_mode = false;
      }
      this.Client.start(function(err, meta2) {
        if (err)
          return cb(err);
        if (meta2.new_pm2_instance == false && that.daemon_mode === true)
          return cb(err, meta2);
        that.launchSysMonitoring(() => {
        });
        that.launchAll(that, function(err_mod) {
          return cb(err, meta2);
        });
      });
    }
    destroy(cb) {
      var that = this;
      debug("Killing and deleting current deamon");
      this.killDaemon(function() {
        var cmd = "rm -rf " + that.pm2_home;
        var test_path = path2.join(that.pm2_home, "module_conf.json");
        var test_path_2 = path2.join(that.pm2_home, "pm2.pid");
        if (that.pm2_home.indexOf(".pm2") > -1)
          return cb(new Error("Destroy is not a allowed method on .pm2"));
        fs.access(test_path, fs.R_OK, function(err) {
          if (err)
            return cb(err);
          debug("Deleting temporary folder %s", that.pm2_home);
          sexec(cmd, cb);
        });
      });
    }
    disconnect(cb) {
      var that = this;
      if (!cb)
        cb = function() {
        };
      this.Client.close(function(err, data) {
        debug("The session lasted %ds", (new Date - that.start_timer) / 1000);
        return cb(err, data);
      });
    }
    close(cb) {
      this.disconnect(cb);
    }
    launchModules(cb) {
      this.launchAll(this, cb);
    }
    launchBus(cb) {
      this.Client.launchBus(cb);
    }
    exitCli(code) {
      var that = this;
      if (conf2.PM2_PROGRAMMATIC && process.env.PM2_USAGE != "CLI")
        return false;
      KMDaemon.disconnectRPC(function() {
        that.Client.close(function() {
          code = code || 0;
          var fds = 0;
          function tryToExit() {
            if (fds & 1 && fds & 2) {
              debug("This command took %ds to execute", (new Date - that.start_timer) / 1000);
              process.exit(code);
            }
          }
          [process.stdout, process.stderr].forEach(function(std) {
            var fd = std.fd;
            if (!std.bufferSize) {
              fds = fds | fd;
            } else {
              std.write && std.write("", function() {
                fds = fds | fd;
                tryToExit();
              });
            }
            delete std.write;
          });
          tryToExit();
        });
      });
    }
    start(cmd, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      if (!opts)
        opts = {};
      var that = this;
      if (Array.isArray(opts.watch) && opts.watch.length === 0)
        opts.watch = (opts.rawArgs ? !!~opts.rawArgs.indexOf("--watch") : !!~process.argv.indexOf("--watch")) || false;
      if (Common.isConfigFile(cmd) || typeof cmd === "object") {
        that._startJson(cmd, opts, "restartProcessId", (err, procs) => {
          return cb ? cb(err, procs) : this.speedList();
        });
      } else {
        that._startScript(cmd, opts, (err, procs) => {
          return cb ? cb(err, procs) : this.speedList(0);
        });
      }
    }
    reset(process_name, cb) {
      var that = this;
      function processIds(ids, cb2) {
        eachLimit(ids, conf2.CONCURRENT_ACTIONS, function(id2, next) {
          that.Client.executeRemote("resetMetaProcessId", id2, function(err, res) {
            if (err)
              console.error(err);
            Common.printOut(conf2.PREFIX_MSG + "Resetting meta for process id %d", id2);
            return next();
          });
        }, function(err) {
          if (err)
            return cb2(Common.retErr(err));
          return cb2 ? cb2(null, { success: true }) : that.speedList();
        });
      }
      if (process_name == "all") {
        that.Client.getAllProcessId(function(err, ids) {
          if (err) {
            Common.printError(err);
            return cb ? cb(Common.retErr(err)) : that.exitCli(conf2.ERROR_EXIT);
          }
          return processIds(ids, cb);
        });
      } else if (isNaN(process_name)) {
        that.Client.getProcessIdByName(process_name, function(err, ids) {
          if (err) {
            Common.printError(err);
            return cb ? cb(Common.retErr(err)) : that.exitCli(conf2.ERROR_EXIT);
          }
          if (ids.length === 0) {
            Common.printError("Unknown process name");
            return cb ? cb(new Error("Unknown process name")) : that.exitCli(conf2.ERROR_EXIT);
          }
          return processIds(ids, cb);
        });
      } else {
        processIds([process_name], cb);
      }
    }
    update(cb) {
      var that = this;
      Common.printOut("Be sure to have the latest version by doing `npm install pm2@latest -g` before doing this procedure.");
      that.Client.executeRemote("notifyKillPM2", {}, function() {
      });
      that.getVersion(function(err, new_version) {
        if (!that.gl_is_km_linked && !err && pkg.version != new_version) {
          var dt = fs.readFileSync(path2.join(__dirname, that._conf.PM2_UPDATE));
          console.log(dt.toString());
        }
        that.dump(function(err2) {
          that.killDaemon(function() {
            that.Client.launchDaemon({ interactor: false }, function(err3, child) {
              that.Client.launchRPC(function() {
                that.resurrect(function() {
                  Common.printOut(chalk.blue.bold(">>>>>>>>>> PM2 updated"));
                  that.launchSysMonitoring(() => {
                  });
                  that.launchAll(that, function() {
                    KMDaemon.launchAndInteract(that._conf, {
                      pm2_version: pkg.version
                    }, function(err4, data, interactor_proc) {
                    });
                    setTimeout(() => {
                      return cb ? cb(null, { success: true }) : that.speedList();
                    }, 250);
                  });
                });
              });
            });
          });
        });
      });
      return false;
    }
    reload(process_name, opts, cb) {
      var that = this;
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      var delay = Common.lockReload();
      if (delay > 0 && opts.force != true) {
        Common.printError(conf2.PREFIX_MSG_ERR + "Reload already in progress, please try again in " + Math.floor((conf2.RELOAD_LOCK_TIMEOUT - delay) / 1000) + " seconds or use --force");
        return cb ? cb(new Error("Reload in progress")) : that.exitCli(conf2.ERROR_EXIT);
      }
      if (Common.isConfigFile(process_name))
        that._startJson(process_name, opts, "reloadProcessId", function(err2, apps) {
          Common.unlockReload();
          if (err2)
            return cb ? cb(err2) : that.exitCli(conf2.ERROR_EXIT);
          return cb ? cb(null, apps) : that.exitCli(conf2.SUCCESS_EXIT);
        });
      else {
        if (opts && opts.env) {
          var err = "Using --env [env] without passing the ecosystem.config.js does not work";
          Common.err(err);
          Common.unlockReload();
          return cb ? cb(Common.retErr(err)) : that.exitCli(conf2.ERROR_EXIT);
        }
        if (opts && !opts.updateEnv)
          Common.printOut(IMMUTABLE_MSG);
        that._operate("reloadProcessId", process_name, opts, function(err2, apps) {
          Common.unlockReload();
          if (err2)
            return cb ? cb(err2) : that.exitCli(conf2.ERROR_EXIT);
          return cb ? cb(null, apps) : that.exitCli(conf2.SUCCESS_EXIT);
        });
      }
    }
    restart(cmd, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      var that = this;
      if (typeof cmd === "number")
        cmd = cmd.toString();
      if (cmd == "-") {
        process.stdin.resume();
        process.stdin.setEncoding("utf8");
        process.stdin.on("data", function(param) {
          process.stdin.pause();
          that.actionFromJson("restartProcessId", param, opts, "pipe", cb);
        });
      } else if (Common.isConfigFile(cmd) || typeof cmd === "object")
        that._startJson(cmd, opts, "restartProcessId", cb);
      else {
        if (opts && opts.env) {
          var err = "Using --env [env] without passing the ecosystem.config.js does not work";
          Common.err(err);
          return cb ? cb(Common.retErr(err)) : that.exitCli(conf2.ERROR_EXIT);
        }
        if (opts && !opts.updateEnv)
          Common.printOut(IMMUTABLE_MSG);
        that._operate("restartProcessId", cmd, opts, cb);
      }
    }
    delete(process_name, jsonVia, cb) {
      var that = this;
      if (typeof jsonVia === "function") {
        cb = jsonVia;
        jsonVia = null;
      }
      if (typeof process_name === "number") {
        process_name = process_name.toString();
      }
      if (jsonVia == "pipe")
        return that.actionFromJson("deleteProcessId", process_name, commander, "pipe", (err, procs) => {
          return cb ? cb(err, procs) : this.speedList();
        });
      if (Common.isConfigFile(process_name))
        return that.actionFromJson("deleteProcessId", process_name, commander, "file", (err, procs) => {
          return cb ? cb(err, procs) : this.speedList();
        });
      else {
        that._operate("deleteProcessId", process_name, (err, procs) => {
          return cb ? cb(err, procs) : this.speedList();
        });
      }
    }
    stop(process_name, cb) {
      var that = this;
      if (typeof process_name === "number")
        process_name = process_name.toString();
      if (process_name == "-") {
        process.stdin.resume();
        process.stdin.setEncoding("utf8");
        process.stdin.on("data", function(param) {
          process.stdin.pause();
          that.actionFromJson("stopProcessId", param, commander, "pipe", (err, procs) => {
            return cb ? cb(err, procs) : this.speedList();
          });
        });
      } else if (Common.isConfigFile(process_name))
        that.actionFromJson("stopProcessId", process_name, commander, "file", (err, procs) => {
          return cb ? cb(err, procs) : this.speedList();
        });
      else
        that._operate("stopProcessId", process_name, (err, procs) => {
          return cb ? cb(err, procs) : this.speedList();
        });
    }
    list(opts, cb) {
      var that = this;
      if (typeof opts == "function") {
        cb = opts;
        opts = null;
      }
      that.Client.executeRemote("getMonitorData", {}, function(err, list) {
        if (err) {
          Common.printError(err);
          return cb ? cb(Common.retErr(err)) : that.exitCli(conf2.ERROR_EXIT);
        }
        if (opts && opts.rawArgs && opts.rawArgs.indexOf("--watch") > -1) {
          let show = function() {
            process.stdout.write("\x1B[2J");
            process.stdout.write("\x1B[0f");
            console.log("Last refresh: ", dayjs().format());
            that.Client.executeRemote("getMonitorData", {}, function(err2, list2) {
              UX.list(list2, null);
            });
          };
          var dayjs = require_dayjs_min();
          show();
          setInterval(show, 900);
          return false;
        }
        return cb ? cb(null, list) : that.speedList(null);
      });
    }
    killDaemon(cb) {
      process.env.PM2_STATUS = "stopping";
      var that = this;
      that.Client.executeRemote("notifyKillPM2", {}, function() {
      });
      that._operate("deleteProcessId", "all", function(err, list) {
        Common.printOut(conf2.PREFIX_MSG + "[v] All Applications Stopped");
        process.env.PM2_SILENT = "false";
        that.killAgent(function(err2, data) {
          if (!err2) {
            Common.printOut(conf2.PREFIX_MSG + "[v] Agent Stopped");
          }
          that.Client.killDaemon(function(err3, res) {
            if (err3)
              Common.printError(err3);
            Common.printOut(conf2.PREFIX_MSG + "[v] PM2 Daemon Stopped");
            return cb ? cb(err3, res) : that.exitCli(conf2.SUCCESS_EXIT);
          });
        });
      });
    }
    kill(cb) {
      this.killDaemon(cb);
    }
    _startScript(script, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      var that = this;
      var app_conf = Config.filterOptions(opts);
      var appConf = {};
      if (typeof app_conf.name == "function")
        delete app_conf.name;
      delete app_conf.args;
      var argsIndex;
      if (opts.rawArgs && (argsIndex = opts.rawArgs.indexOf("--")) >= 0)
        app_conf.args = opts.rawArgs.slice(argsIndex + 1);
      else if (opts.scriptArgs)
        app_conf.args = opts.scriptArgs;
      app_conf.script = script;
      if (!app_conf.namespace)
        app_conf.namespace = "default";
      if ((appConf = Common.verifyConfs(app_conf)) instanceof Error) {
        Common.err(appConf);
        return cb ? cb(Common.retErr(appConf)) : that.exitCli(conf2.ERROR_EXIT);
      }
      app_conf = appConf[0];
      if (opts.watchDelay) {
        if (typeof opts.watchDelay === "string" && opts.watchDelay.indexOf("ms") !== -1)
          app_conf.watch_delay = parseInt(opts.watchDelay);
        else {
          app_conf.watch_delay = parseFloat(opts.watchDelay) * 1000;
        }
      }
      var mas = [];
      if (typeof opts.ext != "undefined")
        hf.make_available_extension(opts, mas);
      mas.length > 0 && (app_conf.ignore_watch = mas);
      if (app_conf.write) {
        var dst_path = path2.join(process.env.PWD || process.cwd(), app_conf.name + "-pm2.json");
        Common.printOut(conf2.PREFIX_MSG + "Writing configuration to", chalk.blue(dst_path));
        try {
          fs.writeFileSync(dst_path, JSON.stringify(app_conf, null, 2));
        } catch (e) {
          console.error(e.stack || e);
        }
      }
      series([
        restartExistingProcessName,
        restartExistingNameSpace,
        restartExistingProcessId,
        restartExistingProcessPathOrStartNew
      ], function(err, data) {
        if (err instanceof Error)
          return cb ? cb(err) : that.exitCli(conf2.ERROR_EXIT);
        var ret = {};
        data.forEach(function(_dt) {
          if (_dt !== undefined)
            ret = _dt;
        });
        return cb ? cb(null, ret) : that.speedList();
      });
      function restartExistingProcessName(cb2) {
        if (!isNaN(script) || typeof script === "string" && script.indexOf("/") != -1 || typeof script === "string" && path2.extname(script) !== "")
          return cb2(null);
        that.Client.getProcessIdByName(script, function(err, ids) {
          if (err && cb2)
            return cb2(err);
          if (ids.length > 0) {
            that._operate("restartProcessId", script, opts, function(err2, list) {
              if (err2)
                return cb2(err2);
              Common.printOut(conf2.PREFIX_MSG + "Process successfully started");
              return cb2(true, list);
            });
          } else
            return cb2(null);
        });
      }
      function restartExistingNameSpace(cb2) {
        if (!isNaN(script) || typeof script === "string" && script.indexOf("/") != -1 || typeof script === "string" && path2.extname(script) !== "")
          return cb2(null);
        if (script !== "all") {
          that.Client.getProcessIdsByNamespace(script, function(err, ids) {
            if (err && cb2)
              return cb2(err);
            if (ids.length > 0) {
              that._operate("restartProcessId", script, opts, function(err2, list) {
                if (err2)
                  return cb2(err2);
                Common.printOut(conf2.PREFIX_MSG + "Process successfully started");
                return cb2(true, list);
              });
            } else
              return cb2(null);
          });
        } else {
          that._operate("restartProcessId", "all", function(err, list) {
            if (err)
              return cb2(err);
            Common.printOut(conf2.PREFIX_MSG + "Process successfully started");
            return cb2(true, list);
          });
        }
      }
      function restartExistingProcessId(cb2) {
        if (isNaN(script))
          return cb2(null);
        that._operate("restartProcessId", script, opts, function(err, list) {
          if (err)
            return cb2(err);
          Common.printOut(conf2.PREFIX_MSG + "Process successfully started");
          return cb2(true, list);
        });
      }
      function restartExistingProcessPathOrStartNew(cb2) {
        that.Client.executeRemote("getMonitorData", {}, function(err, procs) {
          if (err)
            return cb2 ? cb2(new Error(err)) : that.exitCli(conf2.ERROR_EXIT);
          var full_path = path2.resolve(that.cwd, script);
          var managed_script = null;
          procs.forEach(function(proc) {
            if (proc.pm2_env.pm_exec_path == full_path && proc.pm2_env.name == app_conf.name)
              managed_script = proc;
          });
          if (managed_script && (managed_script.pm2_env.status == conf2.STOPPED_STATUS || managed_script.pm2_env.status == conf2.STOPPING_STATUS || managed_script.pm2_env.status == conf2.ERRORED_STATUS)) {
            var app_name = managed_script.pm2_env.name;
            that._operate("restartProcessId", app_name, opts, function(err2, list) {
              if (err2)
                return cb2 ? cb2(new Error(err2)) : that.exitCli(conf2.ERROR_EXIT);
              Common.printOut(conf2.PREFIX_MSG + "Process successfully started");
              return cb2(true, list);
            });
            return false;
          } else if (managed_script && !opts.force) {
            Common.err("Script already launched, add -f option to force re-execution");
            return cb2(new Error("Script already launched"));
          }
          var resolved_paths = null;
          try {
            resolved_paths = Common.resolveAppAttributes({
              cwd: that.cwd,
              pm2_home: that.pm2_home
            }, app_conf);
          } catch (e) {
            Common.err(e.message);
            return cb2(Common.retErr(e));
          }
          Common.printOut(conf2.PREFIX_MSG + "Starting %s in %s (%d instance" + (resolved_paths.instances > 1 ? "s" : "") + ")", resolved_paths.pm_exec_path, resolved_paths.exec_mode, resolved_paths.instances);
          if (!resolved_paths.env)
            resolved_paths.env = {};
          resolved_paths.env["PM2_HOME"] = that.pm2_home;
          var additional_env = Modularizer.getAdditionalConf(resolved_paths.name);
          Object.assign(resolved_paths.env, additional_env);
          resolved_paths.km_link = that.gl_is_km_linked;
          that.Client.executeRemote("prepare", resolved_paths, function(err2, data) {
            if (err2) {
              Common.printError(conf2.PREFIX_MSG_ERR + "Error while launching application", err2.stack || err2);
              return cb2(Common.retErr(err2));
            }
            Common.printOut(conf2.PREFIX_MSG + "Done.");
            return cb2(true, data);
          });
          return false;
        });
      }
    }
    _startJson(file, opts, action, pipe, cb) {
      var config = {};
      var appConf = {};
      var staticConf = [];
      var deployConf = {};
      var apps_info = [];
      var that = this;
      if (typeof cb === "undefined" && typeof pipe === "function") {
        cb = pipe;
      }
      if (typeof file === "object") {
        config = file;
      } else if (pipe === "pipe") {
        config = Common.parseConfig(file, "pipe");
      } else {
        var data = null;
        var isAbsolute = path2.isAbsolute(file);
        var file_path = isAbsolute ? file : path2.join(that.cwd, file);
        debug("Resolved filepath %s", file_path);
        try {
          data = fs.readFileSync(file_path);
        } catch (e) {
          Common.printError(conf2.PREFIX_MSG_ERR + "File " + file + " not found");
          return cb ? cb(Common.retErr(e)) : that.exitCli(conf2.ERROR_EXIT);
        }
        try {
          config = Common.parseConfig(data, file);
        } catch (e) {
          Common.printError(conf2.PREFIX_MSG_ERR + "File " + file + " malformated");
          console.error(e);
          return cb ? cb(Common.retErr(e)) : that.exitCli(conf2.ERROR_EXIT);
        }
      }
      if (config.deploy)
        deployConf = config.deploy;
      if (config.static)
        staticConf = config.static;
      if (config.apps)
        appConf = config.apps;
      else if (config.pm2)
        appConf = config.pm2;
      else
        appConf = config;
      if (!Array.isArray(appConf))
        appConf = [appConf];
      if ((appConf = Common.verifyConfs(appConf)) instanceof Error)
        return cb ? cb(appConf) : that.exitCli(conf2.ERROR_EXIT);
      process.env.PM2_JSON_PROCESSING = true;
      var apps_name = [];
      var proc_list = {};
      staticConf.forEach(function(serve) {
        appConf.push({
          name: serve.name ? serve.name : `static-page-server-${serve.port}`,
          script: path2.resolve(__dirname, "API", "Serve.js"),
          env: {
            PM2_SERVE_PORT: serve.port,
            PM2_SERVE_HOST: serve.host,
            PM2_SERVE_PATH: serve.path,
            PM2_SERVE_SPA: serve.spa,
            PM2_SERVE_DIRECTORY: serve.directory,
            PM2_SERVE_BASIC_AUTH: serve.basic_auth !== undefined,
            PM2_SERVE_BASIC_AUTH_USERNAME: serve.basic_auth ? serve.basic_auth.username : null,
            PM2_SERVE_BASIC_AUTH_PASSWORD: serve.basic_auth ? serve.basic_auth.password : null,
            PM2_SERVE_MONITOR: serve.monitor
          }
        });
      });
      appConf.forEach(function(app) {
        if (!app.env) {
          app.env = {};
        }
        app.env.io = app.io;
        if (opts.only) {
          var apps = opts.only.split(/,| /);
          if (apps.indexOf(app.name) == -1)
            return false;
        }
        if (!app.namespace) {
          if (opts.namespace)
            app.namespace = opts.namespace;
          else
            app.namespace = "default";
        }
        if (!app.watch && opts.watch && opts.watch === true)
          app.watch = true;
        if (!app.ignore_watch && opts.ignore_watch)
          app.ignore_watch = opts.ignore_watch;
        if (opts.install_url)
          app.install_url = opts.install_url;
        if (opts.instances && typeof opts.instances === "number")
          app.instances = opts.instances;
        if (opts.uid)
          app.uid = opts.uid;
        if (opts.gid)
          app.gid = opts.gid;
        if (app.append_env_to_name && opts.env)
          app.name += "-" + opts.env;
        if (opts.name_prefix && app.name.indexOf(opts.name_prefix) == -1)
          app.name = `${opts.name_prefix}:${app.name}`;
        app.username = Common.getCurrentUsername();
        apps_name.push(app.name);
      });
      that.Client.executeRemote("getMonitorData", {}, function(err, raw_proc_list) {
        if (err) {
          Common.printError(err);
          return cb ? cb(Common.retErr(err)) : that.exitCli(conf2.ERROR_EXIT);
        }
        raw_proc_list.forEach(function(proc) {
          proc_list[proc.name] = proc;
        });
        eachLimit(Object.keys(proc_list), conf2.CONCURRENT_ACTIONS, function(proc_name, next) {
          if (apps_name.indexOf(proc_name) == -1)
            return next();
          if (!(action == "reloadProcessId" || action == "softReloadProcessId" || action == "restartProcessId"))
            throw new Error("Wrong action called");
          var apps = appConf.filter(function(app) {
            return app.name == proc_name;
          });
          var envs = apps.map(function(app) {
            return Common.mergeEnvironmentVariables(app, opts.env, deployConf);
          });
          var env = envs.reduce(function(e1, e2) {
            return Object.assign(e1, e2);
          });
          env.updateEnv = true;
          that._operate(action, proc_name, env, function(err2, ret) {
            if (err2)
              Common.printError(err2);
            apps_info = apps_info.concat(ret);
            that.Client.notifyGod(action, proc_name);
            apps_name.splice(apps_name.indexOf(proc_name), 1);
            return next();
          });
        }, function(err2) {
          if (err2)
            return cb ? cb(Common.retErr(err2)) : that.exitCli(conf2.ERROR_EXIT);
          if (apps_name.length > 0 && action != "start")
            Common.printOut(conf2.PREFIX_MSG_WARNING + "Applications %s not running, starting...", apps_name.join(", "));
          return startApps(apps_name, function(err3, apps) {
            apps_info = apps_info.concat(apps);
            return cb ? cb(err3, apps_info) : that.speedList(err3 ? 1 : 0);
          });
        });
        return false;
      });
      function startApps(app_name_to_start, cb2) {
        var apps_to_start = [];
        var apps_started = [];
        var apps_errored = [];
        appConf.forEach(function(app, i) {
          if (app_name_to_start.indexOf(app.name) != -1) {
            apps_to_start.push(appConf[i]);
          }
        });
        eachLimit(apps_to_start, conf2.CONCURRENT_ACTIONS, function(app, next) {
          if (opts.cwd)
            app.cwd = opts.cwd;
          if (opts.force_name)
            app.name = opts.force_name;
          if (opts.started_as_module)
            app.pmx_module = true;
          var resolved_paths = null;
          if (app.script === "serve") {
            app.script = path2.resolve(__dirname, "API", "Serve.js");
          }
          try {
            resolved_paths = Common.resolveAppAttributes({
              cwd: that.cwd,
              pm2_home: that.pm2_home
            }, app);
          } catch (e) {
            apps_errored.push(e);
            Common.err(`Error: ${e.message}`);
            return next();
          }
          if (!resolved_paths.env)
            resolved_paths.env = {};
          resolved_paths.env["PM2_HOME"] = that.pm2_home;
          var additional_env = Modularizer.getAdditionalConf(resolved_paths.name);
          Object.assign(resolved_paths.env, additional_env);
          resolved_paths.env = Common.mergeEnvironmentVariables(resolved_paths, opts.env, deployConf);
          delete resolved_paths.env.current_conf;
          resolved_paths.km_link = that.gl_is_km_linked;
          if (resolved_paths.wait_ready) {
            Common.warn(`App ${resolved_paths.name} has option 'wait_ready' set, waiting for app to be ready...`);
          }
          that.Client.executeRemote("prepare", resolved_paths, function(err, data2) {
            if (err) {
              Common.printError(conf2.PREFIX_MSG_ERR + "Process failed to launch %s", err.message ? err.message : err);
              return next();
            }
            if (data2.length === 0) {
              Common.printError(conf2.PREFIX_MSG_ERR + "Process config loading failed", data2);
              return next();
            }
            Common.printOut(conf2.PREFIX_MSG + "App [%s] launched (%d instances)", data2[0].pm2_env.name, data2.length);
            apps_started = apps_started.concat(data2);
            next();
          });
        }, function(err) {
          var final_error = err || apps_errored.length > 0 ? apps_errored : null;
          return cb2 ? cb2(final_error, apps_started) : that.speedList();
        });
        return false;
      }
    }
    actionFromJson(action, file, opts, jsonVia, cb) {
      var appConf = {};
      var ret_processes = [];
      var that = this;
      if (typeof file == "object") {
        cb = typeof jsonVia == "function" ? jsonVia : cb;
        appConf = file;
      } else if (jsonVia == "file") {
        var data = null;
        try {
          data = fs.readFileSync(file);
        } catch (e) {
          Common.printError(conf2.PREFIX_MSG_ERR + "File " + file + " not found");
          return cb ? cb(Common.retErr(e)) : that.exitCli(conf2.ERROR_EXIT);
        }
        try {
          appConf = Common.parseConfig(data, file);
        } catch (e) {
          Common.printError(conf2.PREFIX_MSG_ERR + "File " + file + " malformated");
          console.error(e);
          return cb ? cb(Common.retErr(e)) : that.exitCli(conf2.ERROR_EXIT);
        }
      } else if (jsonVia == "pipe") {
        appConf = Common.parseConfig(file, "pipe");
      } else {
        Common.printError("Bad call to actionFromJson, jsonVia should be one of file, pipe");
        return that.exitCli(conf2.ERROR_EXIT);
      }
      if (appConf.apps)
        appConf = appConf.apps;
      if (!Array.isArray(appConf))
        appConf = [appConf];
      if ((appConf = Common.verifyConfs(appConf)) instanceof Error)
        return cb ? cb(appConf) : that.exitCli(conf2.ERROR_EXIT);
      eachLimit(appConf, conf2.CONCURRENT_ACTIONS, function(proc, next1) {
        var name2 = "";
        var new_env;
        if (!proc.name)
          name2 = path2.basename(proc.script);
        else
          name2 = proc.name;
        if (opts.only && opts.only != name2)
          return process.nextTick(next1);
        if (opts && opts.env)
          new_env = Common.mergeEnvironmentVariables(proc, opts.env);
        else
          new_env = Common.mergeEnvironmentVariables(proc);
        that.Client.getProcessIdByName(name2, function(err, ids) {
          if (err) {
            Common.printError(err);
            return next1();
          }
          if (!ids)
            return next1();
          eachLimit(ids, conf2.CONCURRENT_ACTIONS, function(id2, next2) {
            var opts2 = {};
            if (action == "restartProcessId") {
              opts2 = { id: id2, env: new_env };
            } else {
              opts2 = id2;
            }
            that.Client.executeRemote(action, opts2, function(err2, res) {
              ret_processes.push(res);
              if (err2) {
                Common.printError(err2);
                return next2();
              }
              if (action == "restartProcessId") {
                that.Client.notifyGod("restart", id2);
              } else if (action == "deleteProcessId") {
                that.Client.notifyGod("delete", id2);
              } else if (action == "stopProcessId") {
                that.Client.notifyGod("stop", id2);
              }
              Common.printOut(conf2.PREFIX_MSG + "[%s](%d) \u2713", name2, id2);
              return next2();
            });
          }, function(err2) {
            return next1(null, ret_processes);
          });
        });
      }, function(err) {
        if (cb)
          return cb(null, ret_processes);
        else
          return that.speedList();
      });
    }
    _operate(action_name, process_name, envs, cb) {
      var that = this;
      var update_env = false;
      var ret = [];
      if (!envs)
        envs = {};
      if (typeof envs == "function") {
        cb = envs;
        envs = {};
      }
      if (envs.updateEnv === true)
        update_env = true;
      var concurrent_actions = envs.parallel || conf2.CONCURRENT_ACTIONS;
      if (!process.env.PM2_JSON_PROCESSING || envs.commands) {
        envs = that._handleAttributeUpdate(envs);
      }
      if (!envs.current_conf) {
        var _conf = fclone(envs);
        envs = {
          current_conf: _conf
        };
        envs.current_conf.km_link = that.gl_is_km_linked;
      }
      function processIds(ids, cb2) {
        Common.printOut(conf2.PREFIX_MSG + "Applying action %s on app [%s](ids: %s)", action_name, process_name, ids);
        if (ids.length <= 2)
          concurrent_actions = 1;
        if (action_name == "deleteProcessId")
          concurrent_actions = 10;
        eachLimit(ids, concurrent_actions, function(id2, next) {
          var opts;
          if (action_name == "restartProcessId" || action_name == "reloadProcessId" || action_name == "softReloadProcessId") {
            var new_env = {};
            if (update_env === true) {
              if (conf2.PM2_PROGRAMMATIC == true)
                new_env = Common.safeExtend({}, process.env);
              else
                new_env = Object.assign({}, process.env);
              Object.keys(envs).forEach(function(k) {
                new_env[k] = envs[k];
              });
            } else {
              new_env = envs;
            }
            opts = {
              id: id2,
              env: new_env
            };
          } else {
            opts = id2;
          }
          that.Client.executeRemote(action_name, opts, function(err, res) {
            if (err) {
              Common.printError(conf2.PREFIX_MSG_ERR + "Process %s not found", id2);
              return next(`Process ${id2} not found`);
            }
            if (action_name == "restartProcessId") {
              that.Client.notifyGod("restart", id2);
            } else if (action_name == "deleteProcessId") {
              that.Client.notifyGod("delete", id2);
            } else if (action_name == "stopProcessId") {
              that.Client.notifyGod("stop", id2);
            } else if (action_name == "reloadProcessId") {
              that.Client.notifyGod("reload", id2);
            } else if (action_name == "softReloadProcessId") {
              that.Client.notifyGod("graceful reload", id2);
            }
            if (!Array.isArray(res))
              res = [res];
            res.forEach(function(proc) {
              Common.printOut(conf2.PREFIX_MSG + "[%s](%d) \u2713", proc.pm2_env ? proc.pm2_env.name : process_name, id2);
              if (action_name == "stopProcessId" && proc.pm2_env && proc.pm2_env.cron_restart) {
                Common.warn(`App ${chalk.bold(proc.pm2_env.name)} stopped but CRON RESTART is still UP ${proc.pm2_env.cron_restart}`);
              }
              if (!proc.pm2_env)
                return false;
              ret.push({
                name: proc.pm2_env.name,
                namespace: proc.pm2_env.namespace,
                pm_id: proc.pm2_env.pm_id,
                status: proc.pm2_env.status,
                restart_time: proc.pm2_env.restart_time,
                pm2_env: {
                  name: proc.pm2_env.name,
                  namespace: proc.pm2_env.namespace,
                  pm_id: proc.pm2_env.pm_id,
                  status: proc.pm2_env.status,
                  restart_time: proc.pm2_env.restart_time,
                  env: proc.pm2_env.env
                }
              });
            });
            return next();
          });
        }, function(err) {
          if (err)
            return cb2 ? cb2(Common.retErr(err)) : that.exitCli(conf2.ERROR_EXIT);
          return cb2 ? cb2(null, ret) : that.speedList();
        });
      }
      if (process_name == "all") {
        let reoperate = function(err, ids) {
          if (err) {
            Common.printError(err);
            return cb ? cb(Common.retErr(err)) : that.exitCli(conf2.ERROR_EXIT);
          }
          if (!ids || ids.length === 0) {
            Common.printError(conf2.PREFIX_MSG_WARNING + "No process found");
            return cb ? cb(new Error("process name not found")) : that.exitCli(conf2.ERROR_EXIT);
          }
          return processIds(ids, cb);
        };
        var fn;
        if (process.env.PM2_STATUS == "stopping")
          that.Client.getAllProcessId(function(err, ids) {
            reoperate(err, ids);
          });
        else
          that.Client.getAllProcessIdWithoutModules(function(err, ids) {
            reoperate(err, ids);
          });
      } else if (isNaN(process_name) && process_name[0] === "/" && process_name[process_name.length - 1] === "/") {
        var regex = new RegExp(process_name.replace(/\//g, ""));
        that.Client.executeRemote("getMonitorData", {}, function(err, list) {
          if (err) {
            Common.printError("Error retrieving process list: " + err);
            return cb(err);
          }
          var found_proc = [];
          list.forEach(function(proc) {
            if (regex.test(proc.pm2_env.name)) {
              found_proc.push(proc.pm_id);
            }
          });
          if (found_proc.length === 0) {
            Common.printError(conf2.PREFIX_MSG_WARNING + "No process found");
            return cb ? cb(new Error("process name not found")) : that.exitCli(conf2.ERROR_EXIT);
          }
          return processIds(found_proc, cb);
        });
      } else if (isNaN(process_name)) {
        var allow_module_restart = action_name == "restartProcessId" ? true : false;
        that.Client.getProcessIdByName(process_name, allow_module_restart, function(err, ids) {
          if (err) {
            Common.printError(err);
            return cb ? cb(Common.retErr(err)) : that.exitCli(conf2.ERROR_EXIT);
          }
          if (ids && ids.length > 0) {
            var additional_env = Modularizer.getAdditionalConf(process_name);
            Object.assign(envs, additional_env);
            return processIds(ids, cb);
          }
          that.Client.getProcessIdsByNamespace(process_name, allow_module_restart, function(err2, ns_process_ids) {
            if (err2) {
              Common.printError(err2);
              return cb ? cb(Common.retErr(err2)) : that.exitCli(conf2.ERROR_EXIT);
            }
            if (!ns_process_ids || ns_process_ids.length === 0) {
              Common.printError(conf2.PREFIX_MSG_ERR + "Process or Namespace %s not found", process_name);
              return cb ? cb(new Error("process or namespace not found")) : that.exitCli(conf2.ERROR_EXIT);
            }
            var ns_additional_env = Modularizer.getAdditionalConf(process_name);
            Object.assign(envs, ns_additional_env);
            return processIds(ns_process_ids, cb);
          });
        });
      } else {
        if (that.pm2_configuration.docker == "true" || that.pm2_configuration.docker == true) {
          that.Client.executeRemote("getMonitorData", {}, (err, proc_list) => {
            var higher_id = 0;
            proc_list.forEach((p) => {
              p.pm_id > higher_id && (higher_id = p.pm_id);
            });
            if (process_name > higher_id)
              return DockerMgmt.processCommand(that, higher_id, process_name, action_name, (err2) => {
                if (err2) {
                  Common.printError(conf2.PREFIX_MSG_ERR + (err2.message ? err2.message : err2));
                  return cb ? cb(Common.retErr(err2)) : that.exitCli(conf2.ERROR_EXIT);
                }
                return cb ? cb(null, ret) : that.speedList();
              });
            that.Client.getProcessIdByName(process_name, function(err2, ids) {
              if (ids.length > 0)
                return processIds(ids, cb);
              that.Client.getProcessIdsByNamespace(process_name, function(err3, ns_process_ids) {
                if (ns_process_ids.length > 0)
                  return processIds(ns_process_ids, cb);
                return processIds([process_name], cb);
              });
            });
          });
        } else {
          that.Client.getProcessIdByName(process_name, function(err, ids) {
            if (ids.length > 0)
              return processIds(ids, cb);
            that.Client.getProcessIdsByNamespace(process_name, function(err2, ns_process_ids) {
              if (ns_process_ids.length > 0)
                return processIds(ns_process_ids, cb);
              return processIds([process_name], cb);
            });
          });
        }
      }
    }
    _handleAttributeUpdate(opts) {
      var conf3 = Config.filterOptions(opts);
      var that = this;
      if (typeof conf3.name != "string")
        delete conf3.name;
      var argsIndex = 0;
      if (opts.rawArgs && (argsIndex = opts.rawArgs.indexOf("--")) >= 0) {
        conf3.args = opts.rawArgs.slice(argsIndex + 1);
      }
      var appConf = Common.verifyConfs(conf3)[0];
      if (appConf instanceof Error) {
        Common.printError("Error while transforming CamelCase args to underscore");
        return appConf;
      }
      if (argsIndex == -1)
        delete appConf.args;
      if (appConf.name == "undefined")
        delete appConf.name;
      delete appConf.exec_mode;
      if (Array.isArray(appConf.watch) && appConf.watch.length === 0) {
        if (!~opts.rawArgs.indexOf("--watch"))
          delete appConf.watch;
      }
      if (process.env.PM2_DEEP_MONITORING)
        appConf.deep_monitoring = true;
      if (appConf.treekill === true)
        delete appConf.treekill;
      if (appConf.pmx === true)
        delete appConf.pmx;
      if (appConf.vizion === true)
        delete appConf.vizion;
      if (appConf.automation === true)
        delete appConf.automation;
      if (appConf.autostart === true)
        delete appConf.autostart;
      if (appConf.autorestart === true)
        delete appConf.autorestart;
      return appConf;
    }
    getProcessIdByName(name2, cb) {
      var that = this;
      this.Client.getProcessIdByName(name2, function(err, id2) {
        if (err) {
          Common.printError(err);
          return cb ? cb(Common.retErr(err)) : that.exitCli(conf2.ERROR_EXIT);
        }
        console.log(id2);
        return cb ? cb(null, id2) : that.exitCli(conf2.SUCCESS_EXIT);
      });
    }
    jlist(debug2) {
      var that = this;
      that.Client.executeRemote("getMonitorData", {}, function(err, list) {
        if (err) {
          Common.printError(err);
          return that.exitCli(conf2.ERROR_EXIT);
        }
        if (debug2) {
          process.stdout.write(util.inspect(list, false, null, false));
        } else {
          process.stdout.write(JSON.stringify(list));
        }
        that.exitCli(conf2.SUCCESS_EXIT);
      });
    }
    slist(tree) {
      this.Client.executeRemote("getSystemData", {}, (err, sys_infos) => {
        if (err) {
          Common.err(err);
          return this.exitCli(conf2.ERROR_EXIT);
        }
        if (tree === true) {
          var treeify = require_treeify();
          console.log(treeify.asTree(sys_infos, true));
        } else
          process.stdout.write(util.inspect(sys_infos, false, null, false));
        this.exitCli(conf2.SUCCESS_EXIT);
      });
    }
    speedList(code, apps_acted) {
      var that = this;
      var systemdata = null;
      var acted = [];
      if (code != 0 && code != null) {
        return that.exitCli(code ? code : conf2.SUCCESS_EXIT);
      }
      if (apps_acted && apps_acted.length > 0) {
        apps_acted.forEach((proc) => {
          acted.push(proc.pm2_env ? proc.pm2_env.pm_id : proc.pm_id);
        });
      }
      if (conf2.PM2_PROGRAMMATIC && process.env.PM2_USAGE != "CLI")
        return false;
      return that.Client.executeRemote("getMonitorData", {}, (err, proc_list) => {
        doList(err, proc_list);
      });
      function doList(err, list) {
        if (err) {
          if (that.gl_retry == 0) {
            that.gl_retry += 1;
            return setTimeout(that.speedList.bind(that), 1400);
          }
          console.error("Error retrieving process list: %s.\nA process seems to be on infinite loop, retry in 5 seconds", err);
          return that.exitCli(conf2.ERROR_EXIT);
        }
        if (process.stdout.isTTY === false) {
          UX.list_min(list);
        } else if (commander.miniList && !commander.silent)
          UX.list_min(list);
        else if (!commander.silent) {
          if (that.gl_interact_infos) {
            var dashboard_url = `https://app.pm2.io/#/r/${that.gl_interact_infos.public_key}`;
            if (that.gl_interact_infos.info_node != "https://root.keymetrics.io") {
              dashboard_url = `${that.gl_interact_infos.info_node}/#/r/${that.gl_interact_infos.public_key}`;
            }
            Common.printOut("%s PM2+ activated | Instance Name: %s | Dash: %s", chalk.green.bold("\u21C6"), chalk.bold(that.gl_interact_infos.machine_name), chalk.bold(dashboard_url));
          }
          UX.list(list, commander);
        }
        if (that.Client.daemon_mode == false) {
          Common.printOut("[--no-daemon] Continue to stream logs");
          Common.printOut("[--no-daemon] Exit on target PM2 exit pid=" + fs.readFileSync(conf2.PM2_PID_FILE_PATH).toString());
          global._auto_exit = true;
          return that.streamLogs("all", 0, false, "HH:mm:ss", false);
        } else if (!process.env.TRAVIS && true && acted.length > 0 && commander.attach === true) {
          Common.info(`Log streaming apps id: ${chalk.cyan(acted.join(" "))}, exit with Ctrl-C or will exit in 10secs`);
          return acted.forEach((proc_name) => {
            that.streamLogs(proc_name, 0, false, null, false);
          });
        } else {
          return that.exitCli(code ? code : conf2.SUCCESS_EXIT);
        }
      }
    }
    scale(app_name, number, cb) {
      var that = this;
      function addProcs(proc, value, cb2) {
        (function ex(proc2, number2) {
          if (number2-- === 0)
            return cb2();
          Common.printOut(conf2.PREFIX_MSG + "Scaling up application");
          that.Client.executeRemote("duplicateProcessId", proc2.pm2_env.pm_id, ex.bind(this, proc2, number2));
        })(proc, number);
      }
      function rmProcs(procs, value, cb2) {
        var i = 0;
        (function ex(procs2, number2) {
          if (number2++ === 0)
            return cb2();
          that._operate("deleteProcessId", procs2[i++].pm2_env.pm_id, ex.bind(this, procs2, number2));
        })(procs, number);
      }
      function end() {
        return cb ? cb(null, { success: true }) : that.speedList();
      }
      this.Client.getProcessByName(app_name, function(err, procs) {
        if (err) {
          Common.printError(err);
          return cb ? cb(Common.retErr(err)) : that.exitCli(conf2.ERROR_EXIT);
        }
        if (!procs || procs.length === 0) {
          Common.printError(conf2.PREFIX_MSG_ERR + "Application %s not found", app_name);
          return cb ? cb(new Error("App not found")) : that.exitCli(conf2.ERROR_EXIT);
        }
        var proc_number = procs.length;
        if (typeof number === "string" && number.indexOf("+") >= 0) {
          number = parseInt(number, 10);
          return addProcs(procs[0], number, end);
        } else if (typeof number === "string" && number.indexOf("-") >= 0) {
          number = parseInt(number, 10);
          return rmProcs(procs[0], number, end);
        } else {
          number = parseInt(number, 10);
          number = number - proc_number;
          if (number < 0)
            return rmProcs(procs, number, end);
          else if (number > 0)
            return addProcs(procs[0], number, end);
          else {
            Common.printError(conf2.PREFIX_MSG_ERR + "Nothing to do");
            return cb ? cb(new Error("Same process number")) : that.exitCli(conf2.ERROR_EXIT);
          }
        }
      });
    }
    describe(pm2_id, cb) {
      var that = this;
      var found_proc = [];
      that.Client.executeRemote("getMonitorData", {}, function(err, list) {
        if (err) {
          Common.printError("Error retrieving process list: " + err);
          that.exitCli(conf2.ERROR_EXIT);
        }
        list.forEach(function(proc) {
          if (!isNaN(pm2_id) && proc.pm_id == pm2_id || typeof pm2_id === "string" && proc.name == pm2_id) {
            found_proc.push(proc);
          }
        });
        if (found_proc.length === 0) {
          Common.printError(conf2.PREFIX_MSG_WARNING + "%s doesn\'t exist", pm2_id);
          return cb ? cb(null, []) : that.exitCli(conf2.ERROR_EXIT);
        }
        if (!cb) {
          found_proc.forEach(function(proc) {
            UX.describe(proc);
          });
        }
        return cb ? cb(null, found_proc) : that.exitCli(conf2.SUCCESS_EXIT);
      });
    }
    deepUpdate(cb) {
      var that = this;
      Common.printOut(conf2.PREFIX_MSG + "Updating PM2...");
      var child = sexec("npm i -g pm2@latest; pm2 update");
      child.stdout.on("end", function() {
        Common.printOut(conf2.PREFIX_MSG + "PM2 successfully updated");
        cb ? cb(null, { success: true }) : that.exitCli(conf2.SUCCESS_EXIT);
      });
    }
  }
  require_Extra()(API);
  require_Deploy()(API);
  require_Modules()(API);
  require_link()(API);
  require_process_selector()(API);
  require_helpers3()(API);
  require_Configuration2()(API);
  require_Version()(API);
  require_Startup()(API);
  require_LogManagement()(API);
  require_Containerizer()(API);
  module2.exports = API;
});

// ../../node_modules/pm2/index.js
var require_pm22 = __commonJS((exports2, module2) => {
  process.env.PM2_PROGRAMMATIC = "true";
  var API = require_API();
  module2.exports = new API;
  module2.exports.custom = API;
});

// ../../node_modules/@hocuspocus/server/dist/hocuspocus-server.esm.js
var import_async_lock = __toESM(require_lib(), 1);

// ../../node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js
var floor = Math.floor;
var min = (a, b) => a < b ? a : b;
var max = (a, b) => a > b ? a : b;
var BIT8 = 128;
var BITS7 = 127;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i = 0;i < len; i++) {
    buf[i] = encodedString.codePointAt(i);
  }
  return buf;
};
var utf8TextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder : null;
var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array).length === 1) {
  utf8TextDecoder = null;
}
var write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder, BITS7 & num);
};
var _strBuffer = new Uint8Array(30000);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i = 0;i < written; i++) {
      write(encoder, _strBuffer[i]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
var _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i = 0;i < len; i++) {
    write(encoder, encodedString.codePointAt(i));
  }
};
var writeVarString = utf8TextEncoder && utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
var create = (s) => new Error(s);
var errorUnexpectedEndOfArray = create("Unexpected end of array");
var errorIntegerOutOfRange = create("Integer out of Range");
var AuthMessageType;
(function(AuthMessageType2) {
  AuthMessageType2[AuthMessageType2["Token"] = 0] = "Token";
  AuthMessageType2[AuthMessageType2["PermissionDenied"] = 1] = "PermissionDenied";
  AuthMessageType2[AuthMessageType2["Authenticated"] = 2] = "Authenticated";
})(AuthMessageType || (AuthMessageType = {}));
var writePermissionDenied = (encoder, reason) => {
  writeVarUint(encoder, AuthMessageType.PermissionDenied);
  writeVarString(encoder, reason);
};
var writeAuthenticated = (encoder, scope) => {
  writeVarUint(encoder, AuthMessageType.Authenticated);
  writeVarString(encoder, scope);
};
var ResetConnection = {
  code: 4205,
  reason: "Reset Connection"
};
var Unauthorized = {
  code: 4401,
  reason: "Unauthorized"
};
var Forbidden = {
  code: 4403,
  reason: "Forbidden"
};
var ConnectionTimeout = {
  code: 4408,
  reason: "Connection Timeout"
};
var awarenessStatesToArray = (states) => {
  return Array.from(states.entries()).map(([key, value]) => {
    return {
      clientId: key,
      ...value
    };
  });
};
var WsReadyStates;
(function(WsReadyStates2) {
  WsReadyStates2[WsReadyStates2["Connecting"] = 0] = "Connecting";
  WsReadyStates2[WsReadyStates2["Open"] = 1] = "Open";
  WsReadyStates2[WsReadyStates2["Closing"] = 2] = "Closing";
  WsReadyStates2[WsReadyStates2["Closed"] = 3] = "Closed";
})(WsReadyStates || (WsReadyStates = {}));

// ../../node_modules/lib0/map.js
var create2 = () => new Map;
var copy = (m) => {
  const r = create2();
  m.forEach((v, k) => {
    r.set(k, v);
  });
  return r;
};
var setIfUndefined = (map, key, createT) => {
  let set = map.get(key);
  if (set === undefined) {
    map.set(key, set = createT());
  }
  return set;
};
var any = (m, f) => {
  for (const [key, value] of m) {
    if (f(value, key)) {
      return true;
    }
  }
  return false;
};

// ../../node_modules/lib0/set.js
var create3 = () => new Set;

// ../../node_modules/lib0/array.js
var last = (arr) => arr[arr.length - 1];
var appendTo = (dest, src) => {
  for (let i = 0;i < src.length; i++) {
    dest.push(src[i]);
  }
};
var from = Array.from;
var isArray = Array.isArray;

// ../../node_modules/lib0/observable.js
class ObservableV2 {
  constructor() {
    this._observers = create2();
  }
  on(name, f) {
    setIfUndefined(this._observers, name, create3).add(f);
    return f;
  }
  once(name, f) {
    const _f = (...args) => {
      this.off(name, _f);
      f(...args);
    };
    this.on(name, _f);
  }
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== undefined) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  emit(name, args) {
    return from((this._observers.get(name) || create2()).values()).forEach((f) => f(...args));
  }
  destroy() {
    this._observers = create2();
  }
}

// ../../node_modules/lib0/math.js
var floor2 = Math.floor;
var abs = Math.abs;
var min2 = (a, b) => a < b ? a : b;
var max2 = (a, b) => a > b ? a : b;
var isNaN2 = Number.isNaN;
var isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;

// ../../node_modules/lib0/binary.js
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT82 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS72 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// ../../node_modules/lib0/number.js
var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor2(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// ../../node_modules/lib0/string.js
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var toLowerCase = (s) => s.toLowerCase();
var trimLeftRegex = /^\s*/g;
var trimLeft = (s) => s.replace(trimLeftRegex, "");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
var _encodeUtf8Polyfill2 = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i = 0;i < len; i++) {
    buf[i] = encodedString.codePointAt(i);
  }
  return buf;
};
var utf8TextEncoder2 = typeof TextEncoder !== "undefined" ? new TextEncoder : null;
var _encodeUtf8Native2 = (str) => utf8TextEncoder2.encode(str);
var encodeUtf82 = utf8TextEncoder2 ? _encodeUtf8Native2 : _encodeUtf8Polyfill2;
var utf8TextDecoder2 = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder2 && utf8TextDecoder2.decode(new Uint8Array).length === 1) {
  utf8TextDecoder2 = null;
}

// ../../node_modules/lib0/encoding.js
class Encoder {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
}
var createEncoder = () => new Encoder;
var length = (encoder) => {
  let len = encoder.cpos;
  for (let i = 0;i < encoder.bufs.length; i++) {
    len += encoder.bufs[i].length;
  }
  return len;
};
var toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length(encoder));
  let curPos = 0;
  for (let i = 0;i < encoder.bufs.length; i++) {
    const d = encoder.bufs[i];
    uint8arr.set(d, curPos);
    curPos += d.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
var verifyLen = (encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max2(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
};
var write2 = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeUint8 = write2;
var writeVarUint2 = (encoder, num) => {
  while (num > BITS72) {
    write2(encoder, BIT82 | BITS72 & num);
    num = floor2(num / 128);
  }
  write2(encoder, BITS72 & num);
};
var writeVarInt = (encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write2(encoder, (num > BITS6 ? BIT82 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor2(num / 64);
  while (num > 0) {
    write2(encoder, (num > BITS72 ? BIT82 : 0) | BITS72 & num);
    num = floor2(num / 128);
  }
};
var _strBuffer2 = new Uint8Array(30000);
var _maxStrBSize2 = _strBuffer2.length / 3;
var _writeVarStringNative2 = (encoder, str) => {
  if (str.length < _maxStrBSize2) {
    const written = utf8TextEncoder2.encodeInto(str, _strBuffer2).written || 0;
    writeVarUint2(encoder, written);
    for (let i = 0;i < written; i++) {
      write2(encoder, _strBuffer2[i]);
    }
  } else {
    writeVarUint8Array2(encoder, encodeUtf82(str));
  }
};
var _writeVarStringPolyfill2 = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint2(encoder, len);
  for (let i = 0;i < len; i++) {
    write2(encoder, encodedString.codePointAt(i));
  }
};
var writeVarString2 = utf8TextEncoder2 && utf8TextEncoder2.encodeInto ? _writeVarStringNative2 : _writeVarStringPolyfill2;
var writeUint8Array2 = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min2(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max2(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array2 = (encoder, uint8Array) => {
  writeVarUint2(encoder, uint8Array.byteLength);
  writeUint8Array2(encoder, uint8Array);
};
var writeOnDataView = (encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
};
var writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
var writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
var writeBigInt64 = (encoder, num) => writeOnDataView(encoder, 8).setBigInt64(0, num, false);
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
var writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write2(encoder, 119);
      writeVarString2(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write2(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write2(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write2(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write2(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write2(encoder, 126);
      } else if (isArray(data)) {
        write2(encoder, 117);
        writeVarUint2(encoder, data.length);
        for (let i = 0;i < data.length; i++) {
          writeAny(encoder, data[i]);
        }
      } else if (data instanceof Uint8Array) {
        write2(encoder, 116);
        writeVarUint8Array2(encoder, data);
      } else {
        write2(encoder, 118);
        const keys = Object.keys(data);
        writeVarUint2(encoder, keys.length);
        for (let i = 0;i < keys.length; i++) {
          const key = keys[i];
          writeVarString2(encoder, key);
          writeAny(encoder, data[key]);
        }
      }
      break;
    case "boolean":
      write2(encoder, data ? 120 : 121);
      break;
    default:
      write2(encoder, 127);
  }
};

class RleEncoder extends Encoder {
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint2(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v);
      this.s = v;
    }
  }
}
var flushUintOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
    if (encoder.count > 1) {
      writeVarUint2(encoder.encoder, encoder.count - 2);
    }
  }
};

class UintOptRleEncoder {
  constructor() {
    this.encoder = new Encoder;
    this.s = 0;
    this.count = 0;
  }
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v;
    }
  }
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
}
var flushIntDiffOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
    writeVarInt(encoder.encoder, encodedDiff);
    if (encoder.count > 1) {
      writeVarUint2(encoder.encoder, encoder.count - 2);
    }
  }
};

class IntDiffOptRleEncoder {
  constructor() {
    this.encoder = new Encoder;
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  write(v) {
    if (this.diff === v - this.s) {
      this.s = v;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v - this.s;
      this.s = v;
    }
  }
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
}

class StringEncoder {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder;
  }
  write(string) {
    this.s += string;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string.length);
  }
  toUint8Array() {
    const encoder = new Encoder;
    this.sarr.push(this.s);
    this.s = "";
    writeVarString2(encoder, this.sarr.join(""));
    writeUint8Array2(encoder, this.lensE.toUint8Array());
    return toUint8Array(encoder);
  }
}

// ../../node_modules/lib0/error.js
var create4 = (s) => new Error(s);
var methodUnimplemented = () => {
  throw create4("Method unimplemented");
};
var unexpectedCase = () => {
  throw create4("Unexpected case");
};

// ../../node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray2 = create4("Unexpected end of array");
var errorIntegerOutOfRange2 = create4("Integer out of Range");

class Decoder {
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
}
var createDecoder = (uint8Array) => new Decoder(uint8Array);
var hasContent = (decoder) => decoder.pos !== decoder.arr.length;
var readUint8Array = (decoder, len) => {
  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
};
var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));
var readUint8 = (decoder) => decoder.arr[decoder.pos++];
var readVarUint = (decoder) => {
  let num = 0;
  let mult = 1;
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    const r = decoder.arr[decoder.pos++];
    num = num + (r & BITS72) * mult;
    mult *= 128;
    if (r < BIT82) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER2) {
      throw errorIntegerOutOfRange2;
    }
  }
  throw errorUnexpectedEndOfArray2;
};
var readVarInt = (decoder) => {
  let r = decoder.arr[decoder.pos++];
  let num = r & BITS6;
  let mult = 64;
  const sign = (r & BIT7) > 0 ? -1 : 1;
  if ((r & BIT82) === 0) {
    return sign * num;
  }
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    r = decoder.arr[decoder.pos++];
    num = num + (r & BITS72) * mult;
    mult *= 128;
    if (r < BIT82) {
      return sign * num;
    }
    if (num > MAX_SAFE_INTEGER2) {
      throw errorIntegerOutOfRange2;
    }
  }
  throw errorUnexpectedEndOfArray2;
};
var _readVarStringPolyfill = (decoder) => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(null, bytes);
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative = (decoder) => utf8TextDecoder2.decode(readVarUint8Array(decoder));
var readVarString = utf8TextDecoder2 ? _readVarStringNative : _readVarStringPolyfill;
var readFromDataView = (decoder, len) => {
  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
  decoder.pos += len;
  return dv;
};
var readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);
var readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);
var readBigInt64 = (decoder) => readFromDataView(decoder, 8).getBigInt64(0, false);
var readAnyLookupTable = [
  (decoder) => {
    return;
  },
  (decoder) => null,
  readVarInt,
  readFloat32,
  readFloat64,
  readBigInt64,
  (decoder) => false,
  (decoder) => true,
  readVarString,
  (decoder) => {
    const len = readVarUint(decoder);
    const obj = {};
    for (let i = 0;i < len; i++) {
      const key = readVarString(decoder);
      obj[key] = readAny(decoder);
    }
    return obj;
  },
  (decoder) => {
    const len = readVarUint(decoder);
    const arr = [];
    for (let i = 0;i < len; i++) {
      arr.push(readAny(decoder));
    }
    return arr;
  },
  readVarUint8Array
];
var readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);

class RleDecoder extends Decoder {
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return this.s;
  }
}
class UintOptRleDecoder extends Decoder {
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative = isNegativeZero(this.s);
      this.count = 1;
      if (isNegative) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return this.s;
  }
}
class IntDiffOptRleDecoder extends Decoder {
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  read() {
    if (this.count === 0) {
      const diff = readVarInt(this);
      const hasCount = diff & 1;
      this.diff = floor2(diff / 2);
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
}

class StringDecoder {
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
}

// ../../node_modules/lib0/webcrypto.node.js
import {webcrypto} from "node:crypto";
var subtle = webcrypto.subtle;
var getRandomValues = webcrypto.getRandomValues.bind(webcrypto);

// ../../node_modules/lib0/random.js
var uint32 = () => getRandomValues(new Uint32Array(1))[0];
var uuidv4Template = [1e7] + -1000 + -4000 + -8000 + -100000000000;
var uuidv4 = () => uuidv4Template.replace(/[018]/g, (c) => (c ^ uint32() & 15 >> c / 4).toString(16));

// ../../node_modules/lib0/time.js
var getUnixTime = Date.now;

// ../../node_modules/lib0/promise.js
var create5 = (f) => new Promise(f);
var all = Promise.all.bind(Promise);

// ../../node_modules/lib0/conditions.js
var undefinedToNull = (v) => v === undefined ? null : v;

// ../../node_modules/lib0/storage.js
class VarStoragePolyfill {
  constructor() {
    this.map = new Map;
  }
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  getItem(key) {
    return this.map.get(key);
  }
}
var _localStorage = new VarStoragePolyfill;
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e) {
}
var varStorage = _localStorage;

// ../../node_modules/lib0/object.js
var assign = Object.assign;
var keys = Object.keys;
var forEach = (obj, f) => {
  for (const key in obj) {
    f(obj[key], key);
  }
};
var size = (obj) => keys(obj).length;
var isEmpty = (obj) => {
  for (const _k in obj) {
    return false;
  }
  return true;
};
var every = (obj, f) => {
  for (const key in obj) {
    if (!f(obj[key], key)) {
      return false;
    }
  }
  return true;
};
var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var equalFlat = (a, b) => a === b || size(a) === size(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val);

// ../../node_modules/lib0/function.js
var callAll = (fs, args, i = 0) => {
  try {
    for (;i < fs.length; i++) {
      fs[i](...args);
    }
  } finally {
    if (i < fs.length) {
      callAll(fs, args, i + 1);
    }
  }
};
var id = (a) => a;
var isOneOf = (value, options) => options.includes(value);

// ../../node_modules/lib0/environment.js
var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = () => {
  if (params === undefined) {
    if (isNode) {
      params = create2();
      const pargs = process.argv;
      let currParamName = null;
      for (let i = 0;i < pargs.length; i++) {
        const parg = pargs[i];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create2();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create2();
    }
  }
  return params;
};
var hasParam = (name) => computeParams().has(name);
var getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name));
var hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
var production = hasConf("production");
var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor = !hasParam("--no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("--color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

// ../../node_modules/lib0/buffer.js
var createUint8ArrayFromLen = (len) => new Uint8Array(len);
var copyUint8Array = (uint8Array) => {
  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
  newBuf.set(uint8Array);
  return newBuf;
};

// ../../node_modules/lib0/symbol.js
var create6 = Symbol;

// ../../node_modules/lib0/logging.common.js
var BOLD = create6();
var UNBOLD = create6();
var BLUE = create6();
var GREY = create6();
var GREEN = create6();
var RED = create6();
var PURPLE = create6();
var ORANGE = create6();
var UNCOLOR = create6();
var computeNoColorLoggingArgs = (args2) => {
  if (args2.length === 1 && args2[0]?.constructor === Function) {
    args2 = args2[0]();
  }
  const strBuilder = [];
  const logArgs = [];
  let i = 0;
  for (;i < args2.length; i++) {
    const arg = args2[i];
    if (arg === undefined) {
      strBuilder.push("undefined");
    } else if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      logArgs.push(JSON.stringify(arg));
    }
  }
  return logArgs;
};
var lastLoggingTime = getUnixTime();

// ../../node_modules/lib0/logging.node.js
var _nodeStyleMap = {
  [BOLD]: "\x1B[1m",
  [UNBOLD]: "\x1B[2m",
  [BLUE]: "\x1B[34m",
  [GREEN]: "\x1B[32m",
  [GREY]: "\x1B[37m",
  [RED]: "\x1B[31m",
  [PURPLE]: "\x1B[35m",
  [ORANGE]: "\x1B[38;5;208m",
  [UNCOLOR]: "\x1B[0m"
};
var computeNodeLoggingArgs = (args2) => {
  if (args2.length === 1 && args2[0]?.constructor === Function) {
    args2 = args2[0]();
  }
  const strBuilder = [];
  const logArgs = [];
  let i = 0;
  for (;i < args2.length; i++) {
    const arg = args2[i];
    const style = _nodeStyleMap[arg];
    if (style !== undefined) {
      strBuilder.push(style);
    } else {
      if (arg === undefined) {
        break;
      } else if (arg.constructor === String || arg.constructor === Number) {
        strBuilder.push(arg);
      } else {
        break;
      }
    }
  }
  if (i > 0) {
    strBuilder.push("\x1B[0m");
    logArgs.push(strBuilder.join(""));
  }
  for (;i < args2.length; i++) {
    const arg = args2[i];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var computeLoggingArgs = supportsColor ? computeNodeLoggingArgs : computeNoColorLoggingArgs;
var print = (...args2) => {
  console.log(...computeLoggingArgs(args2));
};

// ../../node_modules/lib0/iterator.js
var createIterator = (next) => ({
  [Symbol.iterator]() {
    return this;
  },
  next
});
var iteratorFilter = (iterator, filter) => createIterator(() => {
  let res;
  do {
    res = iterator.next();
  } while (!res.done && !filter(res.value));
  return res;
});
var iteratorMap = (iterator, fmap) => createIterator(() => {
  const { done, value } = iterator.next();
  return { done, value: done ? undefined : fmap(value) };
});

// ../../node_modules/yjs/dist/yjs.mjs
function* lazyStructReaderGenerator(decoder) {
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i = 0;i < numOfStateUpdates; i++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    for (let i2 = 0;i2 < numberOfStructs; i2++) {
      const info = decoder.readInfo();
      if (info === 10) {
        const len = readVarUint(decoder.restDecoder);
        yield new Skip(createID(client, clock), len);
        clock += len;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT82)) === 0;
        const struct = new Item(createID(client, clock), null, (info & BIT82) === BIT82 ? decoder.readLeftID() : null, null, (info & BIT7) === BIT7 ? decoder.readRightID() : null, cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null, cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null, readItemContent(decoder, info));
        yield struct;
        clock += struct.length;
      } else {
        const len = decoder.readLen();
        yield new GC(createID(client, clock), len);
        clock += len;
      }
    }
  }
}
class DeleteItem {
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
}

class DeleteSet {
  constructor() {
    this.clients = new Map;
  }
}
var iterateDeletedStructs = (transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {
  const structs = transaction.doc.store.clients.get(clientid);
  for (let i = 0;i < deletes.length; i++) {
    const del = deletes[i];
    iterateStructs(transaction, structs, del.clock, del.len, f);
  }
});
var findIndexDS = (dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor2((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
};
var isDeleted = (ds, id2) => {
  const dis = ds.clients.get(id2.client);
  return dis !== undefined && findIndexDS(dis, id2.clock) !== null;
};
var sortAndMergeDeleteSet = (ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a, b) => a.clock - b.clock);
    let i, j;
    for (i = 1, j = 1;i < dels.length; i++) {
      const left = dels[j - 1];
      const right = dels[i];
      if (left.clock + left.len >= right.clock) {
        left.len = max2(left.len, right.clock + right.len - left.clock);
      } else {
        if (j < i) {
          dels[j] = right;
        }
        j++;
      }
    }
    dels.length = j;
  });
};
var mergeDeleteSets = (dss) => {
  const merged = new DeleteSet;
  for (let dssI = 0;dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i = dssI + 1;i < dss.length; i++) {
          appendTo(dels, dss[i].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
};
var addToDeleteSet = (ds, client, clock, length2) => {
  setIfUndefined(ds.clients, client, () => []).push(new DeleteItem(clock, length2));
};
var createDeleteSet = () => new DeleteSet;
var createDeleteSetFromStructStore = (ss) => {
  const ds = createDeleteSet();
  ss.clients.forEach((structs, client) => {
    const dsitems = [];
    for (let i = 0;i < structs.length; i++) {
      const struct = structs[i];
      if (struct.deleted) {
        const clock = struct.id.clock;
        let len = struct.length;
        if (i + 1 < structs.length) {
          for (let next = structs[i + 1];i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {
            len += next.length;
          }
        }
        dsitems.push(new DeleteItem(clock, len));
      }
    }
    if (dsitems.length > 0) {
      ds.clients.set(client, dsitems);
    }
  });
  return ds;
};
var writeDeleteSet = (encoder, ds) => {
  writeVarUint2(encoder.restEncoder, ds.clients.size);
  from(ds.clients.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, dsitems]) => {
    encoder.resetDsCurVal();
    writeVarUint2(encoder.restEncoder, client);
    const len = dsitems.length;
    writeVarUint2(encoder.restEncoder, len);
    for (let i = 0;i < len; i++) {
      const item = dsitems[i];
      encoder.writeDsClock(item.clock);
      encoder.writeDsLen(item.len);
    }
  });
};
var readDeleteSet = (decoder) => {
  const ds = new DeleteSet;
  const numClients = readVarUint(decoder.restDecoder);
  for (let i = 0;i < numClients; i++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds.clients, client, () => []);
      for (let i2 = 0;i2 < numberOfDeletes; i2++) {
        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
      }
    }
  }
  return ds;
};
var readAndApplyDeleteSet = (decoder, transaction, store) => {
  const unappliedDS = new DeleteSet;
  const numClients = readVarUint(decoder.restDecoder);
  for (let i = 0;i < numClients; i++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    const structs = store.clients.get(client) || [];
    const state = getState(store, client);
    for (let i2 = 0;i2 < numberOfDeletes; i2++) {
      const clock = decoder.readDsClock();
      const clockEnd = clock + decoder.readDsLen();
      if (clock < state) {
        if (state < clockEnd) {
          addToDeleteSet(unappliedDS, client, state, clockEnd - state);
        }
        let index = findIndexSS(structs, clock);
        let struct = structs[index];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          index++;
        }
        while (index < structs.length) {
          struct = structs[index++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds = new UpdateEncoderV2;
    writeVarUint2(ds.restEncoder, 0);
    writeDeleteSet(ds, unappliedDS);
    return ds.toUint8Array();
  }
  return null;
};
var equalDeleteSets = (ds1, ds2) => {
  if (ds1.clients.size !== ds2.clients.size)
    return false;
  for (const [client, deleteItems1] of ds1.clients.entries()) {
    const deleteItems2 = ds2.clients.get(client);
    if (deleteItems2 === undefined || deleteItems1.length !== deleteItems2.length)
      return false;
    for (let i = 0;i < deleteItems1.length; i++) {
      const di1 = deleteItems1[i];
      const di2 = deleteItems2[i];
      if (di1.clock !== di2.clock || di1.len !== di2.len) {
        return false;
      }
    }
  }
  return true;
};
var generateNewClientId = uint32;

class Doc extends ObservableV2 {
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = new Map;
    this.store = new StructStore;
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = new Set;
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.isSynced = false;
    this.whenLoaded = create5((resolve) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve(this);
      });
    });
    const provideSyncedPromise = () => create5((resolve) => {
      const eventHandler = (isSynced) => {
        if (isSynced === undefined || isSynced === true) {
          this.off("sync", eventHandler);
          resolve();
        }
      };
      this.on("sync", eventHandler);
    });
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === undefined || isSynced === true;
      if (this.isSynced && !this.isLoaded) {
        this.emit("load", [this]);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(item.parent.doc, (transaction) => {
        transaction.subdocsLoaded.add(this);
      }, null, true);
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from(this.subdocs).map((doc) => doc.guid));
  }
  transact(f, origin = null) {
    return transact(this, f, origin);
  }
  get(name, TypeConstructor = AbstractType) {
    const type = setIfUndefined(this.share, name, () => {
      const t = new TypeConstructor;
      t._integrate(this, null);
      return t;
    });
    const Constr = type.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t = new TypeConstructor;
        t._map = type._map;
        type._map.forEach((n) => {
          for (;n !== null; n = n.left) {
            n.parent = t;
          }
        });
        t._start = type._start;
        for (let n = t._start;n !== null; n = n.right) {
          n.parent = t;
        }
        t._length = type._length;
        this.share.set(name, t);
        t._integrate(this, null);
        return t;
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
      }
    }
    return type;
  }
  getArray(name = "") {
    return this.get(name, YArray);
  }
  getText(name = "") {
    return this.get(name, YText);
  }
  getMap(name = "") {
    return this.get(name, YMap);
  }
  getXmlElement(name = "") {
    return this.get(name, YXmlElement);
  }
  getXmlFragment(name = "") {
    return this.get(name, YXmlFragment);
  }
  toJSON() {
    const doc = {};
    this.share.forEach((value, key) => {
      doc[key] = value.toJSON();
    });
    return doc;
  }
  destroy() {
    from(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content = item.content;
      content.doc = new Doc({ guid: this.guid, ...content.opts, shouldLoad: false });
      content.doc._item = item;
      transact(item.parent.doc, (transaction) => {
        const doc = content.doc;
        if (!item.deleted) {
          transaction.subdocsAdded.add(doc);
        }
        transaction.subdocsRemoved.add(this);
      }, null, true);
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
}

class DSDecoderV1 {
  constructor(decoder) {
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
  }
  readDsClock() {
    return readVarUint(this.restDecoder);
  }
  readDsLen() {
    return readVarUint(this.restDecoder);
  }
}

class UpdateDecoderV1 extends DSDecoderV1 {
  readLeftID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  readRightID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  readClient() {
    return readVarUint(this.restDecoder);
  }
  readInfo() {
    return readUint8(this.restDecoder);
  }
  readString() {
    return readVarString(this.restDecoder);
  }
  readParentInfo() {
    return readVarUint(this.restDecoder) === 1;
  }
  readTypeRef() {
    return readVarUint(this.restDecoder);
  }
  readLen() {
    return readVarUint(this.restDecoder);
  }
  readAny() {
    return readAny(this.restDecoder);
  }
  readBuf() {
    return copyUint8Array(readVarUint8Array(this.restDecoder));
  }
  readJSON() {
    return JSON.parse(readVarString(this.restDecoder));
  }
  readKey() {
    return readVarString(this.restDecoder);
  }
}

class DSDecoderV2 {
  constructor(decoder) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  readDsLen() {
    const diff = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff;
    return diff;
  }
}

class UpdateDecoderV2 extends DSDecoderV2 {
  constructor(decoder) {
    super(decoder);
    this.keys = [];
    readVarUint(decoder);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
  }
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  readClient() {
    return this.clientDecoder.read();
  }
  readInfo() {
    return this.infoDecoder.read();
  }
  readString() {
    return this.stringDecoder.read();
  }
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  readLen() {
    return this.lenDecoder.read();
  }
  readAny() {
    return readAny(this.restDecoder);
  }
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  readJSON() {
    return readAny(this.restDecoder);
  }
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key = this.stringDecoder.read();
      this.keys.push(key);
      return key;
    }
  }
}

class DSEncoderV1 {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  writeDsClock(clock) {
    writeVarUint2(this.restEncoder, clock);
  }
  writeDsLen(len) {
    writeVarUint2(this.restEncoder, len);
  }
}

class UpdateEncoderV1 extends DSEncoderV1 {
  writeLeftID(id2) {
    writeVarUint2(this.restEncoder, id2.client);
    writeVarUint2(this.restEncoder, id2.clock);
  }
  writeRightID(id2) {
    writeVarUint2(this.restEncoder, id2.client);
    writeVarUint2(this.restEncoder, id2.clock);
  }
  writeClient(client) {
    writeVarUint2(this.restEncoder, client);
  }
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  writeString(s) {
    writeVarString2(this.restEncoder, s);
  }
  writeParentInfo(isYKey) {
    writeVarUint2(this.restEncoder, isYKey ? 1 : 0);
  }
  writeTypeRef(info) {
    writeVarUint2(this.restEncoder, info);
  }
  writeLen(len) {
    writeVarUint2(this.restEncoder, len);
  }
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  writeBuf(buf) {
    writeVarUint8Array2(this.restEncoder, buf);
  }
  writeJSON(embed) {
    writeVarString2(this.restEncoder, JSON.stringify(embed));
  }
  writeKey(key) {
    writeVarString2(this.restEncoder, key);
  }
}

class DSEncoderV2 {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint2(this.restEncoder, diff);
  }
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint2(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
}

class UpdateEncoderV2 extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = new Map;
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder;
    this.clientEncoder = new UintOptRleEncoder;
    this.leftClockEncoder = new IntDiffOptRleEncoder;
    this.rightClockEncoder = new IntDiffOptRleEncoder;
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder;
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder;
    this.lenEncoder = new UintOptRleEncoder;
  }
  toUint8Array() {
    const encoder = createEncoder();
    writeVarUint2(encoder, 0);
    writeVarUint8Array2(encoder, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array2(encoder, this.clientEncoder.toUint8Array());
    writeVarUint8Array2(encoder, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array2(encoder, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array2(encoder, toUint8Array(this.infoEncoder));
    writeVarUint8Array2(encoder, this.stringEncoder.toUint8Array());
    writeVarUint8Array2(encoder, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array2(encoder, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array2(encoder, this.lenEncoder.toUint8Array());
    writeUint8Array2(encoder, toUint8Array(this.restEncoder));
    return toUint8Array(encoder);
  }
  writeLeftID(id2) {
    this.clientEncoder.write(id2.client);
    this.leftClockEncoder.write(id2.clock);
  }
  writeRightID(id2) {
    this.clientEncoder.write(id2.client);
    this.rightClockEncoder.write(id2.clock);
  }
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  writeString(s) {
    this.stringEncoder.write(s);
  }
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  writeBuf(buf) {
    writeVarUint8Array2(this.restEncoder, buf);
  }
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  writeKey(key) {
    const clock = this.keyMap.get(key);
    if (clock === undefined) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
}
var writeStructs = (encoder, structs, client, clock) => {
  clock = max2(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint2(encoder.restEncoder, structs.length - startNewStructs);
  encoder.writeClient(client);
  writeVarUint2(encoder.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder, clock - firstStruct.id.clock);
  for (let i = startNewStructs + 1;i < structs.length; i++) {
    structs[i].write(encoder, 0);
  }
};
var writeClientsStructs = (encoder, store, _sm) => {
  const sm = new Map;
  _sm.forEach((clock, client) => {
    if (getState(store, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store).forEach((_clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint2(encoder.restEncoder, sm.size);
  from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeStructs(encoder, store.clients.get(client), client, clock);
  });
};
var readClientsStructRefs = (decoder, doc) => {
  const clientRefs = create2();
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i = 0;i < numOfStateUpdates; i++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i2 = 0;i2 < numberOfStructs; i2++) {
      const info = decoder.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len = decoder.readLen();
          refs[i2] = new GC(createID(client, clock), len);
          clock += len;
          break;
        }
        case 10: {
          const len = readVarUint(decoder.restDecoder);
          refs[i2] = new Skip(createID(client, clock), len);
          clock += len;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT82)) === 0;
          const struct = new Item(createID(client, clock), null, (info & BIT82) === BIT82 ? decoder.readLeftID() : null, null, (info & BIT7) === BIT7 ? decoder.readRightID() : null, cantCopyParentInfo ? decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID() : null, cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null, readItemContent(decoder, info));
          refs[i2] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
};
var integrateStructs = (transaction, store, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = from(clientsStructRefs.keys()).sort((a, b) => a - b);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = () => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  };
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null) {
    return null;
  }
  const restStructs = new StructStore;
  const missingSV = new Map;
  const updateMissingSv = (client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  };
  let stackHead = curStructsTarget.refs[curStructsTarget.i++];
  const state = new Map;
  const addStackToRestSS = () => {
    for (const item of stack) {
      const client = item.id.client;
      const unapplicableItems = clientsStructRefs.get(client);
      if (unapplicableItems) {
        unapplicableItems.i--;
        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
        clientsStructRefs.delete(client);
        unapplicableItems.i = 0;
        unapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c) => c !== client);
    }
    stack.length = 0;
  };
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
      const offset = localClock - stackHead.id.clock;
      if (offset < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction, store);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(missing) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(missing, getState(store, missing));
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset === 0 || offset < stackHead.length) {
          stackHead.integrate(transaction, offset);
          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder = new UpdateEncoderV2;
    writeClientsStructs(encoder, restStructs, new Map);
    writeVarUint2(encoder.restEncoder, 0);
    return { missing: missingSV, update: encoder.toUint8Array() };
  }
  return null;
};
var writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
var readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {
  transaction.local = false;
  let retry = false;
  const doc = transaction.doc;
  const store = doc.store;
  const ss = readClientsStructRefs(structDecoder, doc);
  const restStructs = integrateStructs(transaction, store, ss);
  const pending = store.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store, client)) {
        retry = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
  if (store.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
    if (dsRest && dsRest2) {
      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store.pendingDs = dsRest || dsRest2;
    }
  } else {
    store.pendingDs = dsRest;
  }
  if (retry) {
    const update = store.pendingStructs.update;
    store.pendingStructs = null;
    applyUpdateV2(transaction.doc, update);
  }
}, transactionOrigin, false);
var applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder = createDecoder(update);
  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
var applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
var writeStateAsUpdate = (encoder, doc, targetStateVector = new Map) => {
  writeClientsStructs(encoder, doc.store, targetStateVector);
  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));
};
var encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2) => {
  const targetStateVector = decodeStateVector(encodedTargetStateVector);
  writeStateAsUpdate(encoder, doc, targetStateVector);
  const updates = [encoder.toUint8Array()];
  if (doc.store.pendingDs) {
    updates.push(doc.store.pendingDs);
  }
  if (doc.store.pendingStructs) {
    updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));
  }
  if (updates.length > 1) {
    if (encoder.constructor === UpdateEncoderV1) {
      return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)));
    } else if (encoder.constructor === UpdateEncoderV2) {
      return mergeUpdatesV2(updates);
    }
  }
  return updates[0];
};
var encodeStateAsUpdate = (doc, encodedTargetStateVector) => encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1);
var readStateVector = (decoder) => {
  const ss = new Map;
  const ssLength = readVarUint(decoder.restDecoder);
  for (let i = 0;i < ssLength; i++) {
    const client = readVarUint(decoder.restDecoder);
    const clock = readVarUint(decoder.restDecoder);
    ss.set(client, clock);
  }
  return ss;
};
var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));
var writeStateVector = (encoder, sv) => {
  writeVarUint2(encoder.restEncoder, sv.size);
  from(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeVarUint2(encoder.restEncoder, client);
    writeVarUint2(encoder.restEncoder, clock);
  });
  return encoder;
};
var writeDocumentStateVector = (encoder, doc) => writeStateVector(encoder, getStateVector(doc.store));
var encodeStateVectorV2 = (doc, encoder = new DSEncoderV2) => {
  if (doc instanceof Map) {
    writeStateVector(encoder, doc);
  } else {
    writeDocumentStateVector(encoder, doc);
  }
  return encoder.toUint8Array();
};
var encodeStateVector = (doc) => encodeStateVectorV2(doc, new DSEncoderV1);

class EventHandler {
  constructor() {
    this.l = [];
  }
}
var createEventHandler = () => new EventHandler;
var addEventHandlerListener = (eventHandler, f) => eventHandler.l.push(f);
var removeEventHandlerListener = (eventHandler, f) => {
  const l = eventHandler.l;
  const len = l.length;
  eventHandler.l = l.filter((g) => f !== g);
  if (len === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn\'t exist.");
  }
};
var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);

class ID {
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
}
var compareIDs = (a, b) => a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;
var createID = (client, clock) => new ID(client, clock);
var findRootTypeKey = (type) => {
  for (const [key, value] of type.doc.share.entries()) {
    if (value === type) {
      return key;
    }
  }
  throw unexpectedCase();
};
class Snapshot {
  constructor(ds, sv) {
    this.ds = ds;
    this.sv = sv;
  }
}
var createSnapshot = (ds, sm) => new Snapshot(ds, sm);
var emptySnapshot = createSnapshot(createDeleteSet(), new Map);
var snapshot = (doc) => createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));
var isVisible = (item, snapshot2) => snapshot2 === undefined ? !item.deleted : snapshot2.sv.has(item.id.client) && (snapshot2.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot2.ds, item.id);
var splitSnapshotAffectedStructs = (transaction, snapshot2) => {
  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create3);
  const store = transaction.doc.store;
  if (!meta.has(snapshot2)) {
    snapshot2.sv.forEach((clock, client) => {
      if (clock < getState(store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot2.ds, (_item) => {
    });
    meta.add(snapshot2);
  }
};
var snapshotContainsUpdateV2 = (snapshot2, update, YDecoder = UpdateDecoderV2) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  for (let curr = lazyDecoder.curr;curr !== null; curr = lazyDecoder.next()) {
    if ((snapshot2.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) {
      return false;
    }
  }
  const mergedDS = mergeDeleteSets([snapshot2.ds, readDeleteSet(updateDecoder)]);
  return equalDeleteSets(snapshot2.ds, mergedDS);
};
var snapshotContainsUpdate = (snapshot2, update) => snapshotContainsUpdateV2(snapshot2, update, UpdateDecoderV1);

class StructStore {
  constructor() {
    this.clients = new Map;
    this.pendingStructs = null;
    this.pendingDs = null;
  }
}
var getStateVector = (store) => {
  const sm = new Map;
  store.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
};
var getState = (store, client) => {
  const structs = store.clients.get(client);
  if (structs === undefined) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
};
var addStruct = (store, struct) => {
  let structs = store.clients.get(struct.id.client);
  if (structs === undefined) {
    structs = [];
    store.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
};
var findIndexSS = (structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor2(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor2((left + right) / 2);
  }
  throw unexpectedCase();
};
var find = (store, id2) => {
  const structs = store.clients.get(id2.client);
  return structs[findIndexSS(structs, id2.clock)];
};
var getItem = find;
var findIndexCleanStart = (transaction, structs, clock) => {
  const index = findIndexSS(structs, clock);
  const struct = structs[index];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index + 1;
  }
  return index;
};
var getItemCleanStart = (transaction, id2) => {
  const structs = transaction.doc.store.clients.get(id2.client);
  return structs[findIndexCleanStart(transaction, structs, id2.clock)];
};
var getItemCleanEnd = (transaction, store, id2) => {
  const structs = store.clients.get(id2.client);
  const index = findIndexSS(structs, id2.clock);
  const struct = structs[index];
  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));
  }
  return struct;
};
var replaceStruct = (store, struct, newStruct) => {
  const structs = store.clients.get(struct.id.client);
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
var iterateStructs = (transaction, structs, clockStart, len, f) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f(struct);
  } while (index < structs.length && structs[index].id.clock < clockEnd);
};

class Transaction {
  constructor(doc, origin, local) {
    this.doc = doc;
    this.deleteSet = new DeleteSet;
    this.beforeState = getStateVector(doc.store);
    this.afterState = new Map;
    this.changed = new Map;
    this.changedParentTypes = new Map;
    this._mergeStructs = [];
    this.origin = origin;
    this.meta = new Map;
    this.local = local;
    this.subdocsAdded = new Set;
    this.subdocsRemoved = new Set;
    this.subdocsLoaded = new Set;
    this._needFormattingCleanup = false;
  }
}
var writeUpdateMessageFromTransaction = (encoder, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder, transaction);
  writeDeleteSet(encoder, transaction.deleteSet);
  return true;
};
var addChangedTypeToTransaction = (transaction, type, parentSub) => {
  const item = type._item;
  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction.changed, type, create3).add(parentSub);
  }
};
var tryToMergeWithLefts = (structs, pos) => {
  let right = structs[pos];
  let left = structs[pos - 1];
  let i = pos;
  for (;i > 0; right = left, left = structs[--i - 1]) {
    if (left.deleted === right.deleted && left.constructor === right.constructor) {
      if (left.mergeWith(right)) {
        if (right instanceof Item && right.parentSub !== null && right.parent._map.get(right.parentSub) === right) {
          right.parent._map.set(right.parentSub, left);
        }
        continue;
      }
    }
    break;
  }
  const merged = pos - i;
  if (merged) {
    structs.splice(pos + 1 - merged, merged);
  }
  return merged;
};
var tryGcDeleteSet = (ds, store, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = store.clients.get(client);
    for (let di = deleteItems.length - 1;di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si];si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store, false);
        }
      }
    }
  }
};
var tryMergeDeleteSet = (ds, store) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = store.clients.get(client);
    for (let di = deleteItems.length - 1;di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min2(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si];si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
        si -= 1 + tryToMergeWithLefts(structs, si);
      }
    }
  });
};
var cleanupTransactions = (transactionCleanups, i) => {
  if (i < transactionCleanups.length) {
    const transaction = transactionCleanups[i];
    const doc = transaction.doc;
    const store = doc.store;
    const ds = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc.emit("beforeObserverCalls", [transaction, doc]);
      const fs = [];
      transaction.changed.forEach((subs, itemtype) => fs.push(() => {
        if (itemtype._item === null || !itemtype._item.deleted) {
          itemtype._callObserver(transaction, subs);
        }
      }));
      fs.push(() => {
        transaction.changedParentTypes.forEach((events, type) => {
          if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
            events = events.filter((event) => event.target._item === null || !event.target._item.deleted);
            events.forEach((event) => {
              event.currentTarget = type;
              event._path = null;
            });
            events.sort((event1, event2) => event1.path.length - event2.path.length);
            callEventHandlerListeners(type._dEH, events, transaction);
          }
        });
      });
      fs.push(() => doc.emit("afterTransaction", [transaction, doc]));
      callAll(fs, []);
      if (transaction._needFormattingCleanup) {
        cleanupYTextAfterTransaction(transaction);
      }
    } finally {
      if (doc.gc) {
        tryGcDeleteSet(ds, store, doc.gcFilter);
      }
      tryMergeDeleteSet(ds, store);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = store.clients.get(client);
          const firstChangePos = max2(findIndexSS(structs, beforeClock), 1);
          for (let i2 = structs.length - 1;i2 >= firstChangePos; ) {
            i2 -= 1 + tryToMergeWithLefts(structs, i2);
          }
        }
      });
      for (let i2 = mergeStructs.length - 1;i2 >= 0; i2--) {
        const { client, clock } = mergeStructs[i2].id;
        const structs = store.clients.get(client);
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
            continue;
          }
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLefts(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc.clientID = generateNewClientId();
      }
      doc.emit("afterTransactionCleanup", [transaction, doc]);
      if (doc._observers.has("update")) {
        const encoder = new UpdateEncoderV1;
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc.emit("update", [encoder.toUint8Array(), transaction.origin, doc, transaction]);
        }
      }
      if (doc._observers.has("updateV2")) {
        const encoder = new UpdateEncoderV2;
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc.collectionid;
          }
          doc.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc.subdocs.delete(subdoc));
        doc.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i + 1) {
        doc._transactionCleanups = [];
        doc.emit("afterAllTransactions", [doc, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i + 1);
      }
    }
  }
};
var transact = (doc, f, origin = null, local = true) => {
  const transactionCleanups = doc._transactionCleanups;
  let initialCall = false;
  let result = null;
  if (doc._transaction === null) {
    initialCall = true;
    doc._transaction = new Transaction(doc, origin, local);
    transactionCleanups.push(doc._transaction);
    if (transactionCleanups.length === 1) {
      doc.emit("beforeAllTransactions", [doc]);
    }
    doc.emit("beforeTransaction", [doc._transaction, doc]);
  }
  try {
    result = f(doc._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc._transaction === transactionCleanups[0];
      doc._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result;
};
class LazyStructReader {
  constructor(decoder, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
}
class LazyStructWriter {
  constructor(encoder) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder;
    this.clientStructs = [];
  }
}
var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
var sliceStruct = (left, diff) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff), left.length - diff);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff), left.length - diff);
  } else {
    const leftItem = left;
    const { client, clock } = leftItem.id;
    return new Item(createID(client, clock + diff), null, createID(client, clock + diff - 1), null, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));
  }
};
var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
  let currWrite = null;
  const updateEncoder = new YEncoder;
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort((dec1, dec2) => {
      if (dec1.curr.id.client === dec2.curr.id.client) {
        const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
        if (clockDiff === 0) {
          return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
        } else {
          return clockDiff;
        }
      } else {
        return dec2.curr.id.client - dec1.curr.id.client;
      }
    });
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = currDecoder.curr.id.client;
    if (currWrite !== null) {
      let curr = currDecoder.curr;
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || curr.id.client !== firstClient || iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff;
            } else {
              curr = sliceStruct(curr, diff);
            }
          }
          if (!currWrite.struct.mergeWith(curr)) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: currDecoder.curr, offset: 0 };
      currDecoder.next();
    }
    for (let next = currDecoder.curr;next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
  const ds = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  const state = decodeStateVector(sv);
  const encoder = new YEncoder;
  const lazyStructWriter = new LazyStructWriter(encoder);
  const decoder = new YDecoder(createDecoder(update));
  const reader = new LazyStructReader(decoder, false);
  while (reader.curr) {
    const curr = reader.curr;
    const currClient = curr.id.client;
    const svClock = state.get(currClient) || 0;
    if (reader.curr.constructor === Skip) {
      reader.next();
      continue;
    }
    if (curr.id.clock + curr.length > svClock) {
      writeStructToLazyStructWriter(lazyStructWriter, curr, max2(svClock - curr.id.clock, 0));
      reader.next();
      while (reader.curr && reader.curr.id.client === currClient) {
        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
        reader.next();
      }
    } else {
      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
        reader.next();
      }
    }
  }
  finishLazyStructWriting(lazyStructWriter);
  const ds = readDeleteSet(decoder);
  writeDeleteSet(encoder, ds);
  return encoder.toUint8Array();
};
var flushLazyStructWriter = (lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
};
var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint2(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
  }
  struct.write(lazyWriter.encoder, offset);
  lazyWriter.written++;
};
var finishLazyStructWriting = (lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint2(restEncoder, lazyWriter.clientStructs.length);
  for (let i = 0;i < lazyWriter.clientStructs.length; i++) {
    const partStructs = lazyWriter.clientStructs[i];
    writeVarUint2(restEncoder, partStructs.written);
    writeUint8Array2(restEncoder, partStructs.restEncoder);
  }
};
var convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  const updateEncoder = new YEncoder;
  const lazyWriter = new LazyStructWriter(updateEncoder);
  for (let curr = lazyDecoder.curr;curr !== null; curr = lazyDecoder.next()) {
    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
  }
  finishLazyStructWriting(lazyWriter);
  const ds = readDeleteSet(updateDecoder);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, id, UpdateDecoderV2, UpdateEncoderV1);
var errorComputeChanges = "You must not compute changes after the event-handler fired.";

class YEvent {
  constructor(target, transaction) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
    this._path = null;
  }
  get path() {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target));
  }
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create4(errorComputeChanges);
      }
      const keys2 = new Map;
      const target = this.target;
      const changed = this.transaction.changed.get(target);
      changed.forEach((key) => {
        if (key !== null) {
          const item = target._map.get(key);
          let action;
          let oldValue;
          if (this.adds(item)) {
            let prev = item.left;
            while (prev !== null && this.adds(prev)) {
              prev = prev.left;
            }
            if (this.deletes(item)) {
              if (prev !== null && this.deletes(prev)) {
                action = "delete";
                oldValue = last(prev.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev !== null && this.deletes(prev)) {
                action = "update";
                oldValue = last(prev.content.getContent());
              } else {
                action = "add";
                oldValue = undefined;
              }
            }
          } else {
            if (this.deletes(item)) {
              action = "delete";
              oldValue = last(item.content.getContent());
            } else {
              return;
            }
          }
          keys2.set(key, { action, oldValue });
        }
      });
      this._keys = keys2;
    }
    return this._keys;
  }
  get delta() {
    return this.changes.delta;
  }
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create4(errorComputeChanges);
      }
      const target = this.target;
      const added = create3();
      const deleted = create3();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = this.transaction.changed.get(target);
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = () => {
          if (lastOp) {
            delta.push(lastOp);
          }
        };
        for (let item = target._start;item !== null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp === null || lastOp.delete === undefined) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item.length;
              deleted.add(item);
            }
          } else {
            if (this.adds(item)) {
              if (lastOp === null || lastOp.insert === undefined) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent());
              added.add(item);
            } else {
              if (lastOp === null || lastOp.retain === undefined) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === undefined) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return changes;
  }
}
var getPathTo = (parent, child) => {
  const path2 = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path2.unshift(child._item.parentSub);
    } else {
      let i = 0;
      let c = child._item.parent._start;
      while (c !== child._item && c !== null) {
        if (!c.deleted && c.countable) {
          i += c.length;
        }
        c = c.right;
      }
      path2.unshift(i);
    }
    child = child._item.parent;
  }
  return path2;
};
var maxSearchMarker = 80;
var globalSearchMarkerTimestamp = 0;

class ArraySearchMarker {
  constructor(p, index) {
    p.marker = true;
    this.p = p;
    this.index = index;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
}
var refreshMarkerTimestamp = (marker) => {
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var overwriteMarker = (marker, p, index) => {
  marker.p.marker = false;
  marker.p = p;
  p.marker = true;
  marker.index = index;
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var markPosition = (searchMarker, p, index) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);
    overwriteMarker(marker, p, index);
    return marker;
  } else {
    const pm = new ArraySearchMarker(p, index);
    searchMarker.push(pm);
    return pm;
  }
};
var findMarker = (yarray, index) => {
  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => abs(index - a.index) < abs(index - b.index) ? a : b);
  let p = yarray._start;
  let pindex = 0;
  if (marker !== null) {
    p = marker.p;
    pindex = marker.index;
    refreshMarkerTimestamp(marker);
  }
  while (p.right !== null && pindex < index) {
    if (!p.deleted && p.countable) {
      if (index < pindex + p.length) {
        break;
      }
      pindex += p.length;
    }
    p = p.right;
  }
  while (p.left !== null && pindex > index) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  if (marker !== null && abs(marker.index - pindex) < p.parent.length / maxSearchMarker) {
    overwriteMarker(marker, p, pindex);
    return marker;
  } else {
    return markPosition(yarray._searchMarker, p, pindex);
  }
};
var updateMarkerChanges = (searchMarker, index, len) => {
  for (let i = searchMarker.length - 1;i >= 0; i--) {
    const m = searchMarker[i];
    if (len > 0) {
      let p = m.p;
      p.marker = false;
      while (p && (p.deleted || !p.countable)) {
        p = p.left;
        if (p && !p.deleted && p.countable) {
          m.index -= p.length;
        }
      }
      if (p === null || p.marker === true) {
        searchMarker.splice(i, 1);
        continue;
      }
      m.p = p;
      p.marker = true;
    }
    if (index < m.index || len > 0 && index === m.index) {
      m.index = max2(index, m.index + len);
    }
  }
};
var callTypeObservers = (type, transaction, event) => {
  const changedType = type;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type, () => []).push(event);
    if (type._item === null) {
      break;
    }
    type = type._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction);
};

class AbstractType {
  constructor() {
    this._item = null;
    this._map = new Map;
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  get parent() {
    return this._item ? this._item.parent : null;
  }
  _integrate(y, item) {
    this.doc = y;
    this._item = item;
  }
  _copy() {
    throw methodUnimplemented();
  }
  clone() {
    throw methodUnimplemented();
  }
  _write(_encoder) {
  }
  get _first() {
    let n = this._start;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  observe(f) {
    addEventHandlerListener(this._eH, f);
  }
  observeDeep(f) {
    addEventHandlerListener(this._dEH, f);
  }
  unobserve(f) {
    removeEventHandlerListener(this._eH, f);
  }
  unobserveDeep(f) {
    removeEventHandlerListener(this._dEH, f);
  }
  toJSON() {
  }
}
var typeListSlice = (type, start, end) => {
  if (start < 0) {
    start = type._length + start;
  }
  if (end < 0) {
    end = type._length + end;
  }
  let len = end - start;
  const cs = [];
  let n = type._start;
  while (n !== null && len > 0) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      if (c.length <= start) {
        start -= c.length;
      } else {
        for (let i = start;i < c.length && len > 0; i++) {
          cs.push(c[i]);
          len--;
        }
        start = 0;
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListToArray = (type) => {
  const cs = [];
  let n = type._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i = 0;i < c.length; i++) {
        cs.push(c[i]);
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListForEach = (type, f) => {
  let index = 0;
  let n = type._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i = 0;i < c.length; i++) {
        f(c[i], index++, type);
      }
    }
    n = n.right;
  }
};
var typeListMap = (type, f) => {
  const result = [];
  typeListForEach(type, (c, i) => {
    result.push(f(c, i, type));
  });
  return result;
};
var typeListCreateIterator = (type) => {
  let n = type._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (currentContent === null) {
        while (n !== null && n.deleted) {
          n = n.right;
        }
        if (n === null) {
          return {
            done: true,
            value: undefined
          };
        }
        currentContent = n.content.getContent();
        currentContentIndex = 0;
        n = n.right;
      }
      const value = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value
      };
    }
  };
};
var typeListGet = (type, index) => {
  const marker = findMarker(type, index);
  let n = type._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (;n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        return n.content.getContent()[index];
      }
      index -= n.length;
    }
  }
};
var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {
  let left = referenceItem;
  const doc = transaction.doc;
  const ownClientId = doc.clientID;
  const store = doc.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = () => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  };
  content.forEach((c) => {
    if (c === null) {
      jsonContent.push(c);
    } else {
      switch (c.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c);
          break;
        default:
          packJsonContent();
          switch (c.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(c)));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(c));
              left.integrate(transaction, 0);
              break;
            default:
              if (c instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
};
var lengthExceeded = () => create4("Length exceeded!");
var typeListInsertGenerics = (transaction, parent, index, content) => {
  if (index > parent._length) {
    throw lengthExceeded();
  }
  if (index === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index, content.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content);
  }
  const startIndex = index;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
    if (index === 0) {
      n = n.prev;
      index += n && n.countable && !n.deleted ? n.length : 0;
    }
  }
  for (;n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index <= n.length) {
        if (index < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
        }
        break;
      }
      index -= n.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
var typeListPushGenerics = (transaction, parent, content) => {
  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n = marker.p;
  if (n) {
    while (n.right) {
      n = n.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
var typeListDelete = (transaction, parent, index, length2) => {
  if (length2 === 0) {
    return;
  }
  const startIndex = index;
  const startLength = length2;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (;n !== null && index > 0; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
      }
      index -= n.length;
    }
  }
  while (length2 > 0 && n !== null) {
    if (!n.deleted) {
      if (length2 < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length2));
      }
      n.delete(transaction);
      length2 -= n.length;
    }
    n = n.right;
  }
  if (length2 > 0) {
    throw lengthExceeded();
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length2);
  }
};
var typeMapDelete = (transaction, parent, key) => {
  const c = parent._map.get(key);
  if (c !== undefined) {
    c.delete(transaction);
  }
};
var typeMapSet = (transaction, parent, key, value) => {
  const left = parent._map.get(key) || null;
  const doc = transaction.doc;
  const ownClientId = doc.clientID;
  let content;
  if (value == null) {
    content = new ContentAny([value]);
  } else {
    switch (value.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        content = new ContentAny([value]);
        break;
      case Uint8Array:
        content = new ContentBinary(value);
        break;
      case Doc:
        content = new ContentDoc(value);
        break;
      default:
        if (value instanceof AbstractType) {
          content = new ContentType(value);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
};
var typeMapGet = (parent, key) => {
  const val = parent._map.get(key);
  return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined;
};
var typeMapGetAll = (parent) => {
  const res = {};
  parent._map.forEach((value, key) => {
    if (!value.deleted) {
      res[key] = value.content.getContent()[value.length - 1];
    }
  });
  return res;
};
var typeMapHas = (parent, key) => {
  const val = parent._map.get(key);
  return val !== undefined && !val.deleted;
};
var typeMapGetAllSnapshot = (parent, snapshot2) => {
  const res = {};
  parent._map.forEach((value, key) => {
    let v = value;
    while (v !== null && (!snapshot2.sv.has(v.id.client) || v.id.clock >= (snapshot2.sv.get(v.id.client) || 0))) {
      v = v.left;
    }
    if (v !== null && isVisible(v, snapshot2)) {
      res[key] = v.content.getContent()[v.length - 1];
    }
  });
  return res;
};
var createMapIterator = (map) => iteratorFilter(map.entries(), (entry) => !entry[1].deleted);

class YArrayEvent extends YEvent {
}

class YArray extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  static from(items) {
    const a = new YArray;
    a.push(items);
    return a;
  }
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(0, this._prelimContent);
    this._prelimContent = null;
  }
  _copy() {
    return new YArray;
  }
  clone() {
    const arr = new YArray;
    arr.insert(0, this.toArray().map((el) => el instanceof AbstractType ? el.clone() : el));
    return arr;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index, content);
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  push(content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(transaction, this, content);
      });
    } else {
      this._prelimContent.push(...content);
    }
  }
  unshift(content) {
    this.insert(0, content);
  }
  delete(index, length2 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length2);
      });
    } else {
      this._prelimContent.splice(index, length2);
    }
  }
  get(index) {
    return typeListGet(this, index);
  }
  toArray() {
    return typeListToArray(this);
  }
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  toJSON() {
    return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);
  }
  map(f) {
    return typeListMap(this, f);
  }
  forEach(f) {
    typeListForEach(this, f);
  }
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  _write(encoder) {
    encoder.writeTypeRef(YArrayRefID);
  }
}
var readYArray = (_decoder) => new YArray;

class YMapEvent extends YEvent {
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
}

class YMap extends AbstractType {
  constructor(entries) {
    super();
    this._prelimContent = null;
    if (entries === undefined) {
      this._prelimContent = new Map;
    } else {
      this._prelimContent = new Map(entries);
    }
  }
  _integrate(y, item) {
    super._integrate(y, item);
    this._prelimContent.forEach((value, key) => {
      this.set(key, value);
    });
    this._prelimContent = null;
  }
  _copy() {
    return new YMap;
  }
  clone() {
    const map = new YMap;
    this.forEach((value, key) => {
      map.set(key, value instanceof AbstractType ? value.clone() : value);
    });
    return map;
  }
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  toJSON() {
    const map = {};
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        const v = item.content.getContent()[item.length - 1];
        map[key] = v instanceof AbstractType ? v.toJSON() : v;
      }
    });
    return map;
  }
  get size() {
    return [...createMapIterator(this._map)].length;
  }
  keys() {
    return iteratorMap(createMapIterator(this._map), (v) => v[0]);
  }
  values() {
    return iteratorMap(createMapIterator(this._map), (v) => v[1].content.getContent()[v[1].length - 1]);
  }
  entries() {
    return iteratorMap(createMapIterator(this._map), (v) => [v[0], v[1].content.getContent()[v[1].length - 1]]);
  }
  forEach(f) {
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        f(item.content.getContent()[item.length - 1], key, this);
      }
    });
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  delete(key) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key);
      });
    } else {
      this._prelimContent.delete(key);
    }
  }
  set(key, value) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, key, value);
      });
    } else {
      this._prelimContent.set(key, value);
    }
    return value;
  }
  get(key) {
    return typeMapGet(this, key);
  }
  has(key) {
    return typeMapHas(this, key);
  }
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key, map) {
          typeMapDelete(transaction, map, key);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  _write(encoder) {
    encoder.writeTypeRef(YMapRefID);
  }
}
var readYMap = (_decoder) => new YMap;
var equalAttrs = (a, b) => a === b || typeof a === "object" && typeof b === "object" && a && b && equalFlat(a, b);

class ItemTextListPosition {
  constructor(left, right, index, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index;
    this.currentAttributes = currentAttributes;
  }
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(this.currentAttributes, this.right.content);
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
}
var findNextPosition = (transaction, pos, count) => {
  while (pos.right !== null && count > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(pos.currentAttributes, pos.right.content);
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));
          }
          pos.index += pos.right.length;
          count -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
};
var findPosition = (transaction, parent, index, useSearchMarker) => {
  const currentAttributes = new Map;
  const marker = useSearchMarker ? findMarker(parent, index) : null;
  if (marker) {
    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
    return findNextPosition(transaction, pos, index - marker.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index);
  }
};
var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(negatedAttributes.get(currPos.right.content.key), currPos.right.content.value))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(currPos.right.content.key);
    }
    currPos.forward();
  }
  const doc = transaction.doc;
  const ownClientId = doc.clientID;
  negatedAttributes.forEach((val, key) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
};
var updateCurrentAttributes = (currentAttributes, format) => {
  const { key, value } = format;
  if (value === null) {
    currentAttributes.delete(key);
  } else {
    currentAttributes.set(key, value);
  }
};
var minimizeAttributeChanges = (currPos, attributes) => {
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[currPos.right.content.key] ?? null, currPos.right.content.value))
      ;
    else {
      break;
    }
    currPos.forward();
  }
};
var insertAttributes = (transaction, parent, currPos, attributes) => {
  const doc = transaction.doc;
  const ownClientId = doc.clientID;
  const negatedAttributes = new Map;
  for (const key in attributes) {
    const val = attributes[key];
    const currentVal = currPos.currentAttributes.get(key) ?? null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
};
var insertText = (transaction, parent, currPos, text, attributes) => {
  currPos.currentAttributes.forEach((_val, key) => {
    if (attributes[key] === undefined) {
      attributes[key] = null;
    }
  });
  const doc = transaction.doc;
  const ownClientId = doc.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content = text.constructor === String ? new ContentString(text) : text instanceof AbstractType ? new ContentType(text) : new ContentEmbed(text);
  let { left, right, index } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var formatText = (transaction, parent, currPos, length2, attributes) => {
  const doc = transaction.doc;
  const ownClientId = doc.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop:
    while (currPos.right !== null && (length2 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
      if (!currPos.right.deleted) {
        switch (currPos.right.content.constructor) {
          case ContentFormat: {
            const { key, value } = currPos.right.content;
            const attr = attributes[key];
            if (attr !== undefined) {
              if (equalAttrs(attr, value)) {
                negatedAttributes.delete(key);
              } else {
                if (length2 === 0) {
                  break iterationLoop;
                }
                negatedAttributes.set(key, value);
              }
              currPos.right.delete(transaction);
            } else {
              currPos.currentAttributes.set(key, value);
            }
            break;
          }
          default:
            if (length2 < currPos.right.length) {
              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length2));
            }
            length2 -= currPos.right.length;
            break;
        }
      }
      currPos.forward();
    }
  if (length2 > 0) {
    let newlines = "";
    for (;length2 > 0; length2--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
  let end = start;
  const endFormats = create2();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = end.content;
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start !== end) {
    if (curr === start) {
      reachedCurr = true;
    }
    if (!start.deleted) {
      const content = start.content;
      switch (content.constructor) {
        case ContentFormat: {
          const { key, value } = content;
          const startAttrValue = startAttributes.get(key) ?? null;
          if (endFormats.get(key) !== content || startAttrValue === value) {
            start.delete(transaction);
            cleanups++;
            if (!reachedCurr && (currAttributes.get(key) ?? null) === value && startAttrValue !== value) {
              if (startAttrValue === null) {
                currAttributes.delete(key);
              } else {
                currAttributes.set(key, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start.deleted) {
            updateCurrentAttributes(currAttributes, content);
          }
          break;
        }
      }
    }
    start = start.right;
  }
  return cleanups;
};
var cleanupContextlessFormattingGap = (transaction, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = new Set;
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key = item.content.key;
      if (attrs.has(key)) {
        item.delete(transaction);
      } else {
        attrs.add(key);
      }
    }
    item = item.left;
  }
};
var cleanupYTextFormatting = (type) => {
  let res = 0;
  transact(type.doc, (transaction) => {
    let start = type._start;
    let end = type._start;
    let startAttributes = create2();
    const currentAttributes = copy(startAttributes);
    while (end) {
      if (end.deleted === false) {
        switch (end.content.constructor) {
          case ContentFormat:
            updateCurrentAttributes(currentAttributes, end.content);
            break;
          default:
            res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
            startAttributes = copy(currentAttributes);
            start = end;
            break;
        }
      }
      end = end.right;
    }
  });
  return res;
};
var cleanupYTextAfterTransaction = (transaction) => {
  const needFullCleanup = new Set;
  const doc = transaction.doc;
  for (const [client, afterClock] of transaction.afterState.entries()) {
    const clock = transaction.beforeState.get(client) || 0;
    if (afterClock === clock) {
      continue;
    }
    iterateStructs(transaction, doc.store.clients.get(client), clock, afterClock, (item) => {
      if (!item.deleted && item.content.constructor === ContentFormat && item.constructor !== GC) {
        needFullCleanup.add(item.parent);
      }
    });
  }
  transact(doc, (t) => {
    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
      if (item instanceof GC || !item.parent._hasFormatting || needFullCleanup.has(item.parent)) {
        return;
      }
      const parent = item.parent;
      if (item.content.constructor === ContentFormat) {
        needFullCleanup.add(parent);
      } else {
        cleanupContextlessFormattingGap(t, item);
      }
    });
    for (const yText of needFullCleanup) {
      cleanupYTextFormatting(yText);
    }
  });
};
var deleteText = (transaction, currPos, length2) => {
  const startLength = length2;
  const startAttrs = copy(currPos.currentAttributes);
  const start = currPos.right;
  while (length2 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length2 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length2));
          }
          length2 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start) {
    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (currPos.left || currPos.right).parent;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length2);
  }
  return currPos;
};

class YTextEvent extends YEvent {
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = new Set;
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub);
      }
    });
  }
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: new Set,
        deleted: new Set
      };
      this._changes = changes;
    }
    return this._changes;
  }
  get delta() {
    if (this._delta === null) {
      const y = this.target.doc;
      const delta = [];
      transact(y, (transaction) => {
        const currentAttributes = new Map;
        const oldAttributes = new Map;
        let item = this.target._start;
        let action = null;
        const attributes = {};
        let insert = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = () => {
          if (action !== null) {
            let op = null;
            switch (action) {
              case "delete":
                if (deleteLen > 0) {
                  op = { delete: deleteLen };
                }
                deleteLen = 0;
                break;
              case "insert":
                if (typeof insert === "object" || insert.length > 0) {
                  op = { insert };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value, key) => {
                      if (value !== null) {
                        op.attributes[key] = value;
                      }
                    });
                  }
                }
                insert = "";
                break;
              case "retain":
                if (retain > 0) {
                  op = { retain };
                  if (!isEmpty(attributes)) {
                    op.attributes = assign({}, attributes);
                  }
                }
                retain = 0;
                break;
            }
            if (op)
              delta.push(op);
            action = null;
          }
        };
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action = "insert";
                  insert = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert += item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key, value } = item.content;
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = currentAttributes.get(key) ?? null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value, oldAttributes.get(key) ?? null)) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (value !== null) {
                    item.delete(transaction);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key, value);
                const curVal = currentAttributes.get(key) ?? null;
                if (!equalAttrs(curVal, value)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key, value);
                const attr = attributes[key];
                if (attr !== undefined) {
                  if (!equalAttrs(attr, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value === null) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (attr !== null) {
                    item.delete(transaction);
                  }
                }
              }
              if (!item.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(currentAttributes, item.content);
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== undefined && lastOp.attributes === undefined) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return this._delta;
  }
}

class YText extends AbstractType {
  constructor(string) {
    super();
    this._pending = string !== undefined ? [() => this.insert(0, string)] : [];
    this._searchMarker = [];
    this._hasFormatting = false;
  }
  get length() {
    return this._length;
  }
  _integrate(y, item) {
    super._integrate(y, item);
    try {
      this._pending.forEach((f) => f());
    } catch (e) {
      console.error(e);
    }
    this._pending = null;
  }
  _copy() {
    return new YText;
  }
  clone() {
    const text = new YText;
    text.applyDelta(this.toDelta());
    return text;
  }
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event = new YTextEvent(this, transaction, parentSubs);
    callTypeObservers(this, transaction, event);
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true;
    }
  }
  toString() {
    let str = "";
    let n = this._start;
    while (n !== null) {
      if (!n.deleted && n.countable && n.content.constructor === ContentString) {
        str += n.content.str;
      }
      n = n.right;
    }
    return str;
  }
  toJSON() {
    return this.toString();
  }
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, new Map);
        for (let i = 0;i < delta.length; i++) {
          const op = delta[i];
          if (op.insert !== undefined) {
            const ins = !sanitize && typeof op.insert === "string" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== undefined) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== undefined) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  toDelta(snapshot2, prevSnapshot, computeYChange) {
    const ops = [];
    const currentAttributes = new Map;
    const doc = this.doc;
    let str = "";
    let n = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value, key) => {
          addAttributes = true;
          attributes[key] = value;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    const computeDelta = () => {
      while (n !== null) {
        if (isVisible(n, snapshot2) || prevSnapshot !== undefined && isVisible(n, prevSnapshot)) {
          switch (n.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot2 !== undefined && !isVisible(n, snapshot2)) {
                if (cur === undefined || cur.user !== n.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {
                if (cur === undefined || cur.user !== n.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : { type: "added" });
                }
              } else if (cur !== undefined) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += n.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = {};
                op.attributes = attrs;
                currentAttributes.forEach((value, key) => {
                  attrs[key] = value;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n, snapshot2)) {
                packStr();
                updateCurrentAttributes(currentAttributes, n.content);
              }
              break;
          }
        }
        n = n.right;
      }
      packStr();
    };
    if (snapshot2 || prevSnapshot) {
      transact(doc, (transaction) => {
        if (snapshot2) {
          splitSnapshotAffectedStructs(transaction, snapshot2);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        computeDelta();
      }, "cleanup");
    } else {
      computeDelta();
    }
    return ops;
  }
  insert(index, text, attributes) {
    if (text.length <= 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v, k) => {
            attributes[k] = v;
          });
        }
        insertText(transaction, this, pos, text, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index, text, attributes));
    }
  }
  insertEmbed(index, embed, attributes) {
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        insertText(transaction, this, pos, embed, attributes || {});
      });
    } else {
      this._pending.push(() => this.insertEmbed(index, embed, attributes || {}));
    }
  }
  delete(index, length2) {
    if (length2 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        deleteText(transaction, findPosition(transaction, this, index, true), length2);
      });
    } else {
      this._pending.push(() => this.delete(index, length2));
    }
  }
  format(index, length2, attributes) {
    if (length2 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, false);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length2, attributes);
      });
    } else {
      this._pending.push(() => this.format(index, length2, attributes));
    }
  }
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  getAttribute(attributeName) {
    return typeMapGet(this, attributeName);
  }
  getAttributes() {
    return typeMapGetAll(this);
  }
  _write(encoder) {
    encoder.writeTypeRef(YTextRefID);
  }
}
var readYText = (_decoder) => new YText;

class YXmlTreeWalker {
  constructor(root, f = () => true) {
    this._filter = f;
    this._root = root;
    this._currentNode = root._start;
    this._firstCall = true;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let n = this._currentNode;
    let type = n && n.content && n.content.type;
    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {
      do {
        type = n.content.type;
        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
          n = type._start;
        } else {
          while (n !== null) {
            if (n.right !== null) {
              n = n.right;
              break;
            } else if (n.parent === this._root) {
              n = null;
            } else {
              n = n.parent._item;
            }
          }
        }
      } while (n !== null && (n.deleted || !this._filter(n.content.type)));
    }
    this._firstCall = false;
    if (n === null) {
      return { value: undefined, done: true };
    }
    this._currentNode = n;
    return { value: n.content.type, done: false };
  }
}

class YXmlFragment extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  get firstChild() {
    const first = this._first;
    return first ? first.content.getContent()[0] : null;
  }
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(0, this._prelimContent);
    this._prelimContent = null;
  }
  _copy() {
    return new YXmlFragment;
  }
  clone() {
    const el = new YXmlFragment;
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  createTreeWalker(filter) {
    return new YXmlTreeWalker(this, filter);
  }
  querySelector(query) {
    query = query.toUpperCase();
    const iterator = new YXmlTreeWalker(this, (element) => element.nodeName && element.nodeName.toUpperCase() === query);
    const next = iterator.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  querySelectorAll(query) {
    query = query.toUpperCase();
    return from(new YXmlTreeWalker(this, (element) => element.nodeName && element.nodeName.toUpperCase() === query));
  }
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  toString() {
    return typeListMap(this, (xml) => xml.toString()).join("");
  }
  toJSON() {
    return this.toString();
  }
  toDOM(_document = document, hooks = {}, binding) {
    const fragment = _document.createDocumentFragment();
    if (binding !== undefined) {
      binding._createAssociation(fragment, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment;
  }
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index, content);
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  insertAfter(ref, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction, this, refItem, content);
      });
    } else {
      const pc = this._prelimContent;
      const index = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
      if (index === 0 && ref !== null) {
        throw create4("Reference item not found");
      }
      pc.splice(index, 0, ...content);
    }
  }
  delete(index, length2 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length2);
      });
    } else {
      this._prelimContent.splice(index, length2);
    }
  }
  toArray() {
    return typeListToArray(this);
  }
  push(content) {
    this.insert(this.length, content);
  }
  unshift(content) {
    this.insert(0, content);
  }
  get(index) {
    return typeListGet(this, index);
  }
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  forEach(f) {
    typeListForEach(this, f);
  }
  _write(encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID);
  }
}
var readYXmlFragment = (_decoder) => new YXmlFragment;

class YXmlElement extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = new Map;
  }
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? n.content.type : null;
  }
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? n.content.type : null;
  }
  _integrate(y, item) {
    super._integrate(y, item);
    this._prelimAttrs.forEach((value, key) => {
      this.setAttribute(key, value);
    });
    this._prelimAttrs = null;
  }
  _copy() {
    return new YXmlElement(this.nodeName);
  }
  clone() {
    const el = new YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    forEach(attrs, (value, key) => {
      if (typeof value === "string") {
        el.setAttribute(key, value);
      }
    });
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys2 = [];
    for (const key in attrs) {
      keys2.push(key);
    }
    keys2.sort();
    const keysLen = keys2.length;
    for (let i = 0;i < keysLen; i++) {
      const key = keys2[i];
      stringBuilder.push(key + '="' + attrs[key] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  getAttribute(attributeName) {
    return typeMapGet(this, attributeName);
  }
  hasAttribute(attributeName) {
    return typeMapHas(this, attributeName);
  }
  getAttributes(snapshot2) {
    return snapshot2 ? typeMapGetAllSnapshot(this, snapshot2) : typeMapGetAll(this);
  }
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      const value = attrs[key];
      if (typeof value === "string") {
        dom.setAttribute(key, value);
      }
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== undefined) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  _write(encoder) {
    encoder.writeTypeRef(YXmlElementRefID);
    encoder.writeKey(this.nodeName);
  }
}
var readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());

class YXmlEvent extends YEvent {
  constructor(target, subs, transaction) {
    super(target, transaction);
    this.childListChanged = false;
    this.attributesChanged = new Set;
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub);
      }
    });
  }
}

class YXmlHook extends YMap {
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  _copy() {
    return new YXmlHook(this.hookName);
  }
  clone() {
    const el = new YXmlHook(this.hookName);
    this.forEach((value, key) => {
      el.set(key, value);
    });
    return el;
  }
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== undefined) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== undefined) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  _write(encoder) {
    encoder.writeTypeRef(YXmlHookRefID);
    encoder.writeKey(this.hookName);
  }
}
var readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());

class YXmlText extends YText {
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? n.content.type : null;
  }
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? n.content.type : null;
  }
  _copy() {
    return new YXmlText;
  }
  clone() {
    const text = new YXmlText;
    text.applyDelta(this.toDelta());
    return text;
  }
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== undefined) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key in delta.attributes[nodeName]) {
          attrs.push({ key, value: delta.attributes[nodeName][key] });
        }
        attrs.sort((a, b) => a.key < b.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);
      let str = "";
      for (let i = 0;i < nestedNodes.length; i++) {
        const node = nestedNodes[i];
        str += `<${node.nodeName}`;
        for (let j = 0;j < node.attrs.length; j++) {
          const attr = node.attrs[j];
          str += ` ${attr.key}="${attr.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i = nestedNodes.length - 1;i >= 0; i--) {
        str += `</${nestedNodes[i].nodeName}>`;
      }
      return str;
    }).join("");
  }
  toJSON() {
    return this.toString();
  }
  _write(encoder) {
    encoder.writeTypeRef(YXmlTextRefID);
  }
}
var readYXmlText = (decoder) => new YXmlText;

class AbstractStruct {
  constructor(id2, length2) {
    this.id = id2;
    this.length = length2;
  }
  get deleted() {
    throw methodUnimplemented();
  }
  mergeWith(right) {
    return false;
  }
  write(encoder, offset, encodingRef) {
    throw methodUnimplemented();
  }
  integrate(transaction, offset) {
    throw methodUnimplemented();
  }
}
var structGCRefNumber = 0;

class GC extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction.doc.store, this);
  }
  write(encoder, offset) {
    encoder.writeInfo(structGCRefNumber);
    encoder.writeLen(this.length - offset);
  }
  getMissing(transaction, store) {
    return null;
  }
}

class ContentBinary {
  constructor(content) {
    this.content = content;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.content];
  }
  isCountable() {
    return true;
  }
  copy() {
    return new ContentBinary(this.content);
  }
  splice(offset) {
    throw methodUnimplemented();
  }
  mergeWith(right) {
    return false;
  }
  integrate(transaction, item) {
  }
  delete(transaction) {
  }
  gc(store) {
  }
  write(encoder, offset) {
    encoder.writeBuf(this.content);
  }
  getRef() {
    return 3;
  }
}
var readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());

class ContentDeleted {
  constructor(len) {
    this.len = len;
  }
  getLength() {
    return this.len;
  }
  getContent() {
    return [];
  }
  isCountable() {
    return false;
  }
  copy() {
    return new ContentDeleted(this.len);
  }
  splice(offset) {
    const right = new ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  integrate(transaction, item) {
    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  delete(transaction) {
  }
  gc(store) {
  }
  write(encoder, offset) {
    encoder.writeLen(this.len - offset);
  }
  getRef() {
    return 1;
  }
}
var readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());
var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });

class ContentDoc {
  constructor(doc) {
    if (doc._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc;
    const opts = {};
    this.opts = opts;
    if (!doc.gc) {
      opts.gc = false;
    }
    if (doc.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc.meta !== null) {
      opts.meta = doc.meta;
    }
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.doc];
  }
  isCountable() {
    return true;
  }
  copy() {
    return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  splice(offset) {
    throw methodUnimplemented();
  }
  mergeWith(right) {
    return false;
  }
  integrate(transaction, item) {
    this.doc._item = item;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  gc(store) {
  }
  write(encoder, offset) {
    encoder.writeString(this.doc.guid);
    encoder.writeAny(this.opts);
  }
  getRef() {
    return 9;
  }
}
var readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));

class ContentEmbed {
  constructor(embed) {
    this.embed = embed;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.embed];
  }
  isCountable() {
    return true;
  }
  copy() {
    return new ContentEmbed(this.embed);
  }
  splice(offset) {
    throw methodUnimplemented();
  }
  mergeWith(right) {
    return false;
  }
  integrate(transaction, item) {
  }
  delete(transaction) {
  }
  gc(store) {
  }
  write(encoder, offset) {
    encoder.writeJSON(this.embed);
  }
  getRef() {
    return 5;
  }
}
var readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());

class ContentFormat {
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [];
  }
  isCountable() {
    return false;
  }
  copy() {
    return new ContentFormat(this.key, this.value);
  }
  splice(_offset) {
    throw methodUnimplemented();
  }
  mergeWith(_right) {
    return false;
  }
  integrate(_transaction, item) {
    const p = item.parent;
    p._searchMarker = null;
    p._hasFormatting = true;
  }
  delete(transaction) {
  }
  gc(store) {
  }
  write(encoder, offset) {
    encoder.writeKey(this.key);
    encoder.writeJSON(this.value);
  }
  getRef() {
    return 6;
  }
}
var readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());

class ContentJSON {
  constructor(arr) {
    this.arr = arr;
  }
  getLength() {
    return this.arr.length;
  }
  getContent() {
    return this.arr;
  }
  isCountable() {
    return true;
  }
  copy() {
    return new ContentJSON(this.arr);
  }
  splice(offset) {
    const right = new ContentJSON(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  integrate(transaction, item) {
  }
  delete(transaction) {
  }
  gc(store) {
  }
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i = offset;i < len; i++) {
      const c = this.arr[i];
      encoder.writeString(c === undefined ? "undefined" : JSON.stringify(c));
    }
  }
  getRef() {
    return 2;
  }
}
var readContentJSON = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i = 0;i < len; i++) {
    const c = decoder.readString();
    if (c === "undefined") {
      cs.push(undefined);
    } else {
      cs.push(JSON.parse(c));
    }
  }
  return new ContentJSON(cs);
};

class ContentAny {
  constructor(arr) {
    this.arr = arr;
  }
  getLength() {
    return this.arr.length;
  }
  getContent() {
    return this.arr;
  }
  isCountable() {
    return true;
  }
  copy() {
    return new ContentAny(this.arr);
  }
  splice(offset) {
    const right = new ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  integrate(transaction, item) {
  }
  delete(transaction) {
  }
  gc(store) {
  }
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i = offset;i < len; i++) {
      const c = this.arr[i];
      encoder.writeAny(c);
    }
  }
  getRef() {
    return 8;
  }
}
var readContentAny = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i = 0;i < len; i++) {
    cs.push(decoder.readAny());
  }
  return new ContentAny(cs);
};

class ContentString {
  constructor(str) {
    this.str = str;
  }
  getLength() {
    return this.str.length;
  }
  getContent() {
    return this.str.split("");
  }
  isCountable() {
    return true;
  }
  copy() {
    return new ContentString(this.str);
  }
  splice(offset) {
    const right = new ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "\uFFFD";
      right.str = "\uFFFD" + right.str.slice(1);
    }
    return right;
  }
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  integrate(transaction, item) {
  }
  delete(transaction) {
  }
  gc(store) {
  }
  write(encoder, offset) {
    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  getRef() {
    return 4;
  }
}
var readContentString = (decoder) => new ContentString(decoder.readString());
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;

class ContentType {
  constructor(type) {
    this.type = type;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.type];
  }
  isCountable() {
    return true;
  }
  copy() {
    return new ContentType(this.type._copy());
  }
  splice(offset) {
    throw methodUnimplemented();
  }
  mergeWith(right) {
    return false;
  }
  integrate(transaction, item) {
    this.type._integrate(transaction.doc, item);
  }
  delete(transaction) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction);
      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
        transaction._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
        transaction._mergeStructs.push(item2);
      }
    });
    transaction.changed.delete(this.type);
  }
  gc(store) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach((item2) => {
      while (item2 !== null) {
        item2.gc(store, true);
        item2 = item2.left;
      }
    });
    this.type._map = new Map;
  }
  write(encoder, offset) {
    this.type._write(encoder);
  }
  getRef() {
    return 7;
  }
}
var readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));
var splitItem = (transaction, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(createID(client, clock + diff), leftItem, createID(client, clock + diff - 1), leftItem.right, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  return rightItem;
};
class Item extends AbstractStruct {
  constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content) {
    super(id2, content.getLength());
    this.origin = origin;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  getMissing(transaction, store) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    } else if (!this.parent) {
      if (this.left && this.left.constructor === Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      }
      if (this.right && this.right.constructor === Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = parentItem.content.type;
      }
    }
    return null;
  }
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o;
        if (left !== null) {
          o = left.right;
        } else if (this.parentSub !== null) {
          o = this.parent._map.get(this.parentSub) || null;
          while (o !== null && o.left !== null) {
            o = o.left;
          }
        } else {
          o = this.parent._start;
        }
        const conflictingItems = new Set;
        const itemsBeforeOrigin = new Set;
        while (o !== null && o !== this.right) {
          itemsBeforeOrigin.add(o);
          conflictingItems.add(o);
          if (compareIDs(this.origin, o.origin)) {
            if (o.id.client < this.id.client) {
              left = o;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
              break;
            }
          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
              left = o;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o = o.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null) {
          r = this.parent._map.get(this.parentSub) || null;
          while (r !== null && r.left !== null) {
            r = r.left;
          }
        } else {
          r = this.parent._start;
          this.parent._start = this;
        }
        this.right = r;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(transaction, this.parent, this.parentSub);
      if (this.parent._item !== null && this.parent._item.deleted || this.parentSub !== null && this.right !== null) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  get next() {
    let n = this.right;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  get prev() {
    let n = this.left;
    while (n !== null && n.deleted) {
      n = n.left;
    }
    return n;
  }
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = this.parent._searchMarker;
      if (searchMarker) {
        searchMarker.forEach((marker) => {
          if (marker.p === right) {
            marker.p = this;
            if (!this.deleted && this.countable) {
              marker.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  delete(transaction) {
    if (!this.deleted) {
      const parent = this.parent;
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  gc(store, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store);
    if (parentGCd) {
      replaceStruct(store, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  write(encoder, offset) {
    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT82) | (rightOrigin === null ? 0 : BIT7) | (parentSub === null ? 0 : BIT6);
    encoder.writeInfo(info);
    if (origin !== null) {
      encoder.writeLeftID(origin);
    }
    if (rightOrigin !== null) {
      encoder.writeRightID(rightOrigin);
    }
    if (origin === null && rightOrigin === null) {
      const parent = this.parent;
      if (parent._item !== undefined) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder.writeParentInfo(true);
          encoder.writeString(ykey);
        } else {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder.writeParentInfo(true);
        encoder.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder.writeParentInfo(false);
        encoder.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder.writeString(parentSub);
      }
    }
    this.content.write(encoder, offset);
  }
}
var readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);
var contentRefs = [
  () => {
    unexpectedCase();
  },
  readContentDeleted,
  readContentJSON,
  readContentBinary,
  readContentString,
  readContentEmbed,
  readContentFormat,
  readContentType,
  readContentAny,
  readContentDoc,
  () => {
    unexpectedCase();
  }
];
var structSkipRefNumber = 10;

class Skip extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  integrate(transaction, offset) {
    unexpectedCase();
  }
  write(encoder, offset) {
    encoder.writeInfo(structSkipRefNumber);
    writeVarUint2(encoder.restEncoder, this.length - offset);
  }
  getMissing(transaction, store) {
    return null;
  }
}
var glo = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;

// ../../node_modules/kleur/index.mjs
var run = function(arr, str) {
  let i = 0, tmp, beg = "", end = "";
  for (;i < arr.length; i++) {
    tmp = arr[i];
    beg += tmp.open;
    end += tmp.close;
    if (!!~str.indexOf(tmp.close)) {
      str = str.replace(tmp.rgx, tmp.close + tmp.open);
    }
  }
  return beg + str + end;
};
var chain = function(has, keys2) {
  let ctx = { has, keys: keys2 };
  ctx.reset = $.reset.bind(ctx);
  ctx.bold = $.bold.bind(ctx);
  ctx.dim = $.dim.bind(ctx);
  ctx.italic = $.italic.bind(ctx);
  ctx.underline = $.underline.bind(ctx);
  ctx.inverse = $.inverse.bind(ctx);
  ctx.hidden = $.hidden.bind(ctx);
  ctx.strikethrough = $.strikethrough.bind(ctx);
  ctx.black = $.black.bind(ctx);
  ctx.red = $.red.bind(ctx);
  ctx.green = $.green.bind(ctx);
  ctx.yellow = $.yellow.bind(ctx);
  ctx.blue = $.blue.bind(ctx);
  ctx.magenta = $.magenta.bind(ctx);
  ctx.cyan = $.cyan.bind(ctx);
  ctx.white = $.white.bind(ctx);
  ctx.gray = $.gray.bind(ctx);
  ctx.grey = $.grey.bind(ctx);
  ctx.bgBlack = $.bgBlack.bind(ctx);
  ctx.bgRed = $.bgRed.bind(ctx);
  ctx.bgGreen = $.bgGreen.bind(ctx);
  ctx.bgYellow = $.bgYellow.bind(ctx);
  ctx.bgBlue = $.bgBlue.bind(ctx);
  ctx.bgMagenta = $.bgMagenta.bind(ctx);
  ctx.bgCyan = $.bgCyan.bind(ctx);
  ctx.bgWhite = $.bgWhite.bind(ctx);
  return ctx;
};
var init = function(open, close) {
  let blk = {
    open: `\x1B[${open}m`,
    close: `\x1B[${close}m`,
    rgx: new RegExp(`\\x1b\\[${close}m`, "g")
  };
  return function(txt) {
    if (this !== undefined && this.has !== undefined) {
      !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));
      return txt === undefined ? this : $.enabled ? run(this.keys, txt + "") : txt + "";
    }
    return txt === undefined ? chain([open], [blk]) : $.enabled ? run([blk], txt + "") : txt + "";
  };
};
var FORCE_COLOR;
var NODE_DISABLE_COLORS;
var NO_COLOR;
var TERM;
var isTTY = true;
if (typeof process !== "undefined") {
  ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
  isTTY = process.stdout && process.stdout.isTTY;
}
var $ = {
  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY),
  reset: init(0, 0),
  bold: init(1, 22),
  dim: init(2, 22),
  italic: init(3, 23),
  underline: init(4, 24),
  inverse: init(7, 27),
  hidden: init(8, 28),
  strikethrough: init(9, 29),
  black: init(30, 39),
  red: init(31, 39),
  green: init(32, 39),
  yellow: init(33, 39),
  blue: init(34, 39),
  magenta: init(35, 39),
  cyan: init(36, 39),
  white: init(37, 39),
  gray: init(90, 39),
  grey: init(90, 39),
  bgBlack: init(40, 49),
  bgRed: init(41, 49),
  bgGreen: init(42, 49),
  bgYellow: init(43, 49),
  bgBlue: init(44, 49),
  bgMagenta: init(45, 49),
  bgCyan: init(46, 49),
  bgWhite: init(47, 49)
};
var kleur_default = $;

// ../../node_modules/uuid/wrapper.mjs
var dist = __toESM(require_dist(), 1);
var v1 = dist.default.v1;
var v1ToV6 = dist.default.v1ToV6;
var v3 = dist.default.v3;
var v4 = dist.default.v4;
var v5 = dist.default.v5;
var v6 = dist.default.v6;
var v6ToV1 = dist.default.v6ToV1;
var v7 = dist.default.v7;
var NIL = dist.default.NIL;
var MAX = dist.default.MAX;
var version = dist.default.version;
var validate = dist.default.validate;
var stringify = dist.default.stringify;
var parse = dist.default.parse;

// ../../node_modules/@hocuspocus/server/dist/hocuspocus-server.esm.js
import {createServer} from "http";

// ../../node_modules/ws/wrapper.mjs
var stream = __toESM(require_stream(), 1);
var receiver = __toESM(require_receiver(), 1);
var sender = __toESM(require_sender(), 1);
var websocket = __toESM(require_websocket(), 1);
var websocket_server = __toESM(require_websocket_server(), 1);

// ../../node_modules/@hocuspocus/server/dist/hocuspocus-server.esm.js
import {URLSearchParams} from "url";
var getParameters = function(request) {
  var _a;
  const query = ((_a = request === null || request === undefined ? undefined : request.url) === null || _a === undefined ? undefined : _a.split("?")) || [];
  return new URLSearchParams(query[1] ? query[1] : "");
};
var BIT83 = 128;
var BITS73 = 127;
var floor3 = Math.floor;
var min3 = (a, b) => a < b ? a : b;
var max3 = (a, b) => a > b ? a : b;
var MAX_SAFE_INTEGER3 = Number.MAX_SAFE_INTEGER;
var create$2 = () => new Set;
var from2 = Array.from;
var _encodeUtf8Polyfill3 = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i = 0;i < len; i++) {
    buf[i] = encodedString.codePointAt(i);
  }
  return buf;
};
var utf8TextEncoder3 = typeof TextEncoder !== "undefined" ? new TextEncoder : null;
var _encodeUtf8Native3 = (str) => utf8TextEncoder3.encode(str);
var encodeUtf83 = utf8TextEncoder3 ? _encodeUtf8Native3 : _encodeUtf8Polyfill3;
var utf8TextDecoder3 = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder3 && utf8TextDecoder3.decode(new Uint8Array).length === 1) {
  utf8TextDecoder3 = null;
}
var create$1 = (s) => new Error(s);

class Encoder2 {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
}
var createEncoder2 = () => new Encoder2;
var length$1 = (encoder) => {
  let len = encoder.cpos;
  for (let i = 0;i < encoder.bufs.length; i++) {
    len += encoder.bufs[i].length;
  }
  return len;
};
var toUint8Array2 = (encoder) => {
  const uint8arr = new Uint8Array(length$1(encoder));
  let curPos = 0;
  for (let i = 0;i < encoder.bufs.length; i++) {
    const d = encoder.bufs[i];
    uint8arr.set(d, curPos);
    curPos += d.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
var write3 = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeVarUint3 = (encoder, num) => {
  while (num > BITS73) {
    write3(encoder, BIT83 | BITS73 & num);
    num = floor3(num / 128);
  }
  write3(encoder, BITS73 & num);
};
var _strBuffer3 = new Uint8Array(30000);
var _maxStrBSize3 = _strBuffer3.length / 3;
var _writeVarStringNative3 = (encoder, str) => {
  if (str.length < _maxStrBSize3) {
    const written = utf8TextEncoder3.encodeInto(str, _strBuffer3).written || 0;
    writeVarUint3(encoder, written);
    for (let i = 0;i < written; i++) {
      write3(encoder, _strBuffer3[i]);
    }
  } else {
    writeVarUint8Array3(encoder, encodeUtf83(str));
  }
};
var _writeVarStringPolyfill3 = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint3(encoder, len);
  for (let i = 0;i < len; i++) {
    write3(encoder, encodedString.codePointAt(i));
  }
};
var writeVarString3 = utf8TextEncoder3 && utf8TextEncoder3.encodeInto ? _writeVarStringNative3 : _writeVarStringPolyfill3;
var writeUint8Array3 = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min3(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max3(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array3 = (encoder, uint8Array) => {
  writeVarUint3(encoder, uint8Array.byteLength);
  writeUint8Array3(encoder, uint8Array);
};
var errorUnexpectedEndOfArray3 = create$1("Unexpected end of array");
var errorIntegerOutOfRange3 = create$1("Integer out of Range");

class Decoder2 {
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
}
var createDecoder2 = (uint8Array) => new Decoder2(uint8Array);
var readUint8Array2 = (decoder, len) => {
  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
};
var readVarUint8Array2 = (decoder) => readUint8Array2(decoder, readVarUint2(decoder));
var readUint82 = (decoder) => decoder.arr[decoder.pos++];
var readVarUint2 = (decoder) => {
  let num = 0;
  let mult = 1;
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    const r = decoder.arr[decoder.pos++];
    num = num + (r & BITS73) * mult;
    mult *= 128;
    if (r < BIT83) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER3) {
      throw errorIntegerOutOfRange3;
    }
  }
  throw errorUnexpectedEndOfArray3;
};
var _readVarStringPolyfill2 = (decoder) => {
  let remainingLen = readVarUint2(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint82(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint82(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(null, bytes);
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative2 = (decoder) => utf8TextDecoder3.decode(readVarUint8Array2(decoder));
var readVarString2 = utf8TextDecoder3 ? _readVarStringNative2 : _readVarStringPolyfill2;

class IncomingMessage {
  constructor(input) {
    if (!(input instanceof Uint8Array)) {
      input = new Uint8Array(input);
    }
    this.decoder = createDecoder2(input);
  }
  get encoder() {
    if (!this.encoderInternal) {
      this.encoderInternal = createEncoder2();
    }
    return this.encoderInternal;
  }
  readVarUint8Array() {
    return readVarUint8Array2(this.decoder);
  }
  readVarUint() {
    return readVarUint2(this.decoder);
  }
  readVarString() {
    return readVarString2(this.decoder);
  }
  toUint8Array() {
    return toUint8Array2(this.encoder);
  }
  writeVarUint(type) {
    writeVarUint3(this.encoder, type);
  }
  writeVarString(string) {
    writeVarString3(this.encoder, string);
  }
  get length() {
    return length$1(this.encoder);
  }
}
var getUnixTime2 = Date.now;
var create7 = () => new Map;
var setIfUndefined2 = (map, key, createT) => {
  let set = map.get(key);
  if (set === undefined) {
    map.set(key, set = createT());
  }
  return set;
};

class Observable {
  constructor() {
    this._observers = create7();
  }
  on(name, f) {
    setIfUndefined2(this._observers, name, create$2).add(f);
  }
  once(name, f) {
    const _f = (...args2) => {
      this.off(name, _f);
      f(...args2);
    };
    this.on(name, _f);
  }
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== undefined) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  emit(name, args2) {
    return from2((this._observers.get(name) || create7()).values()).forEach((f) => f(...args2));
  }
  destroy() {
    this._observers = create7();
  }
}
var keys2 = Object.keys;
var length2 = (obj) => keys2(obj).length;
var hasProperty2 = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var equalityStrict = (a, b) => a === b;
var equalityDeep = (a, b) => {
  if (a == null || b == null) {
    return equalityStrict(a, b);
  }
  if (a.constructor !== b.constructor) {
    return false;
  }
  if (a === b) {
    return true;
  }
  switch (a.constructor) {
    case ArrayBuffer:
      a = new Uint8Array(a);
      b = new Uint8Array(b);
    case Uint8Array: {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i = 0;i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a.size !== b.size) {
        return false;
      }
      for (const value of a) {
        if (!b.has(value)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a.size !== b.size) {
        return false;
      }
      for (const key of a.keys()) {
        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {
          return false;
        }
      }
      break;
    }
    case Object:
      if (length2(a) !== length2(b)) {
        return false;
      }
      for (const key in a) {
        if (!hasProperty2(a, key) || !equalityDeep(a[key], b[key])) {
          return false;
        }
      }
      break;
    case Array:
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0;i < a.length; i++) {
        if (!equalityDeep(a[i], b[i])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};
var outdatedTimeout = 30000;

class Awareness extends Observable {
  constructor(doc) {
    super();
    this.doc = doc;
    this.clientID = doc.clientID;
    this.states = new Map;
    this.meta = new Map;
    this._checkInterval = setInterval(() => {
      const now = getUnixTime2();
      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - this.meta.get(this.clientID).lastUpdated) {
        this.setLocalState(this.getLocalState());
      }
      const remove = [];
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid);
        }
      });
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, "timeout");
      }
    }, floor3(outdatedTimeout / 10));
    doc.on("destroy", () => {
      this.destroy();
    });
    this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]);
    this.setLocalState(null);
    super.destroy();
    clearInterval(this._checkInterval);
  }
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  setLocalState(state) {
    const clientID = this.clientID;
    const currLocalMeta = this.meta.get(clientID);
    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1;
    const prevState = this.states.get(clientID);
    if (state === null) {
      this.states.delete(clientID);
    } else {
      this.states.set(clientID, state);
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: getUnixTime2()
    });
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    if (state === null) {
      removed.push(clientID);
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID);
      }
    } else {
      updated.push(clientID);
      if (!equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID);
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
    }
    this.emit("update", [{ added, updated, removed }, "local"]);
  }
  setLocalStateField(field, value) {
    const state = this.getLocalState();
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value
      });
    }
  }
  getStates() {
    return this.states;
  }
}
var removeAwarenessStates = (awareness, clients, origin) => {
  const removed = [];
  for (let i = 0;i < clients.length; i++) {
    const clientID = clients[i];
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID);
      if (clientID === awareness.clientID) {
        const curMeta = awareness.meta.get(clientID);
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: getUnixTime2()
        });
      }
      removed.push(clientID);
    }
  }
  if (removed.length > 0) {
    awareness.emit("change", [{ added: [], updated: [], removed }, origin]);
    awareness.emit("update", [{ added: [], updated: [], removed }, origin]);
  }
};
var encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
  const len = clients.length;
  const encoder = createEncoder2();
  writeVarUint3(encoder, len);
  for (let i = 0;i < len; i++) {
    const clientID = clients[i];
    const state = states.get(clientID) || null;
    const clock = awareness.meta.get(clientID).clock;
    writeVarUint3(encoder, clientID);
    writeVarUint3(encoder, clock);
    writeVarString3(encoder, JSON.stringify(state));
  }
  return toUint8Array2(encoder);
};
var applyAwarenessUpdate = (awareness, update, origin) => {
  const decoder = createDecoder2(update);
  const timestamp = getUnixTime2();
  const added = [];
  const updated = [];
  const filteredUpdated = [];
  const removed = [];
  const len = readVarUint2(decoder);
  for (let i = 0;i < len; i++) {
    const clientID = readVarUint2(decoder);
    let clock = readVarUint2(decoder);
    const state = JSON.parse(readVarString2(decoder));
    const clientMeta = awareness.meta.get(clientID);
    const prevState = awareness.states.get(clientID);
    const currClock = clientMeta === undefined ? 0 : clientMeta.clock;
    if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {
      if (state === null) {
        if (clientID === awareness.clientID && awareness.getLocalState() != null) {
          clock++;
        } else {
          awareness.states.delete(clientID);
        }
      } else {
        awareness.states.set(clientID, state);
      }
      awareness.meta.set(clientID, {
        clock,
        lastUpdated: timestamp
      });
      if (clientMeta === undefined && state !== null) {
        added.push(clientID);
      } else if (clientMeta !== undefined && state === null) {
        removed.push(clientID);
      } else if (state !== null) {
        if (!equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID);
        }
        updated.push(clientID);
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness.emit("change", [{
      added,
      updated: filteredUpdated,
      removed
    }, origin]);
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness.emit("update", [{
      added,
      updated,
      removed
    }, origin]);
  }
};
var messageYjsSyncStep1 = 0;
var messageYjsSyncStep2 = 1;
var messageYjsUpdate = 2;
var writeSyncStep1 = (encoder, doc) => {
  writeVarUint3(encoder, messageYjsSyncStep1);
  const sv = encodeStateVector(doc);
  writeVarUint8Array3(encoder, sv);
};
var writeSyncStep2 = (encoder, doc, encodedStateVector) => {
  writeVarUint3(encoder, messageYjsSyncStep2);
  writeVarUint8Array3(encoder, encodeStateAsUpdate(doc, encodedStateVector));
};
var readSyncStep1 = (decoder, encoder, doc) => writeSyncStep2(encoder, doc, readVarUint8Array2(decoder));
var readSyncStep2 = (decoder, doc, transactionOrigin) => {
  try {
    applyUpdate(doc, readVarUint8Array2(decoder), transactionOrigin);
  } catch (error) {
    console.error("Caught error while handling a Yjs update", error);
  }
};
var writeUpdate = (encoder, update) => {
  writeVarUint3(encoder, messageYjsUpdate);
  writeVarUint8Array3(encoder, update);
};
var readUpdate = readSyncStep2;
var MessageType;
(function(MessageType2) {
  MessageType2[MessageType2["Unknown"] = -1] = "Unknown";
  MessageType2[MessageType2["Sync"] = 0] = "Sync";
  MessageType2[MessageType2["Awareness"] = 1] = "Awareness";
  MessageType2[MessageType2["Auth"] = 2] = "Auth";
  MessageType2[MessageType2["QueryAwareness"] = 3] = "QueryAwareness";
  MessageType2[MessageType2["SyncReply"] = 4] = "SyncReply";
  MessageType2[MessageType2["Stateless"] = 5] = "Stateless";
  MessageType2[MessageType2["BroadcastStateless"] = 6] = "BroadcastStateless";
  MessageType2[MessageType2["CLOSE"] = 7] = "CLOSE";
  MessageType2[MessageType2["SyncStatus"] = 8] = "SyncStatus";
})(MessageType || (MessageType = {}));

class OutgoingMessage {
  constructor(documentName) {
    this.encoder = createEncoder2();
    writeVarString3(this.encoder, documentName);
  }
  createSyncMessage() {
    this.type = MessageType.Sync;
    writeVarUint3(this.encoder, MessageType.Sync);
    return this;
  }
  createSyncReplyMessage() {
    this.type = MessageType.SyncReply;
    writeVarUint3(this.encoder, MessageType.SyncReply);
    return this;
  }
  createAwarenessUpdateMessage(awareness, changedClients) {
    this.type = MessageType.Awareness;
    this.category = "Update";
    const message = encodeAwarenessUpdate(awareness, changedClients || Array.from(awareness.getStates().keys()));
    writeVarUint3(this.encoder, MessageType.Awareness);
    writeVarUint8Array3(this.encoder, message);
    return this;
  }
  writeQueryAwareness() {
    this.type = MessageType.QueryAwareness;
    this.category = "Update";
    writeVarUint3(this.encoder, MessageType.QueryAwareness);
    return this;
  }
  writeAuthenticated(readonly) {
    this.type = MessageType.Auth;
    this.category = "Authenticated";
    writeVarUint3(this.encoder, MessageType.Auth);
    writeAuthenticated(this.encoder, readonly ? "readonly" : "read-write");
    return this;
  }
  writePermissionDenied(reason) {
    this.type = MessageType.Auth;
    this.category = "PermissionDenied";
    writeVarUint3(this.encoder, MessageType.Auth);
    writePermissionDenied(this.encoder, reason);
    return this;
  }
  writeFirstSyncStepFor(document2) {
    this.category = "SyncStep1";
    writeSyncStep1(this.encoder, document2);
    return this;
  }
  writeUpdate(update) {
    this.category = "Update";
    writeUpdate(this.encoder, update);
    return this;
  }
  writeStateless(payload) {
    this.category = "Stateless";
    writeVarUint3(this.encoder, MessageType.Stateless);
    writeVarString3(this.encoder, payload);
    return this;
  }
  writeBroadcastStateless(payload) {
    this.category = "Stateless";
    writeVarUint3(this.encoder, MessageType.BroadcastStateless);
    writeVarString3(this.encoder, payload);
    return this;
  }
  writeSyncStatus(updateSaved) {
    this.category = "SyncStatus";
    writeVarUint3(this.encoder, MessageType.SyncStatus);
    writeVarUint3(this.encoder, updateSaved ? 1 : 0);
    return this;
  }
  toUint8Array() {
    return toUint8Array2(this.encoder);
  }
}

class MessageReceiver {
  constructor(message, logger, defaultTransactionOrigin) {
    this.message = message;
    this.logger = logger;
    this.defaultTransactionOrigin = defaultTransactionOrigin;
  }
  apply(document2, connection, reply) {
    const { message } = this;
    const type = message.readVarUint();
    const emptyMessageLength = message.length;
    switch (type) {
      case MessageType.Sync:
      case MessageType.SyncReply: {
        message.writeVarUint(MessageType.Sync);
        this.readSyncMessage(message, document2, connection, reply, type !== MessageType.SyncReply);
        if (message.length > emptyMessageLength + 1) {
          if (reply) {
            reply(message.toUint8Array());
          } else if (connection) {
            connection.send(message.toUint8Array());
          }
        }
        break;
      }
      case MessageType.Awareness: {
        this.logger.log({
          direction: "in",
          type: MessageType.Awareness,
          category: "Update"
        });
        applyAwarenessUpdate(document2.awareness, message.readVarUint8Array(), connection);
        break;
      }
      case MessageType.QueryAwareness: {
        this.applyQueryAwarenessMessage(document2, reply);
        break;
      }
      case MessageType.Stateless: {
        connection === null || connection === undefined || connection.callbacks.statelessCallback({
          connection,
          documentName: document2.name,
          document: document2,
          payload: readVarString2(message.decoder)
        });
        break;
      }
      case MessageType.BroadcastStateless: {
        const msg = message.readVarString();
        document2.getConnections().forEach((connection2) => {
          connection2.sendStateless(msg);
        });
        break;
      }
      case MessageType.CLOSE: {
        connection === null || connection === undefined || connection.close({
          code: 1000,
          reason: "provider_initiated"
        });
        break;
      }
      case MessageType.Auth:
        console.error("Received an authentication message on a connection that is already fully authenticated. Probably your provider has been destroyed + recreated really fast.");
        break;
      default:
        console.error(`Unable to handle message of type ${type}: no handler defined! Are your provider/server versions aligned?`);
    }
  }
  readSyncMessage(message, document2, connection, reply, requestFirstSync = true) {
    const type = message.readVarUint();
    switch (type) {
      case messageYjsSyncStep1: {
        this.logger.log({
          direction: "in",
          type: MessageType.Sync,
          category: "SyncStep1"
        });
        readSyncStep1(message.decoder, message.encoder, document2);
        this.logger.log({
          direction: "out",
          type: MessageType.Sync,
          category: "SyncStep2"
        });
        if (reply && requestFirstSync) {
          const syncMessage = new OutgoingMessage(document2.name).createSyncReplyMessage().writeFirstSyncStepFor(document2);
          this.logger.log({
            direction: "out",
            type: MessageType.Sync,
            category: "SyncStep1"
          });
          reply(syncMessage.toUint8Array());
        } else if (connection) {
          const syncMessage = new OutgoingMessage(document2.name).createSyncMessage().writeFirstSyncStepFor(document2);
          this.logger.log({
            direction: "out",
            type: MessageType.Sync,
            category: "SyncStep1"
          });
          connection.send(syncMessage.toUint8Array());
        }
        break;
      }
      case messageYjsSyncStep2:
        this.logger.log({
          direction: "in",
          type: MessageType.Sync,
          category: "SyncStep2"
        });
        if (connection === null || connection === undefined ? undefined : connection.readOnly) {
          const snapshot2 = snapshot(document2);
          const update = readVarUint8Array2(message.decoder);
          if (snapshotContainsUpdate(snapshot2, update)) {
            const ackMessage = new OutgoingMessage(document2.name).writeSyncStatus(true);
            connection.send(ackMessage.toUint8Array());
          } else {
            const ackMessage = new OutgoingMessage(document2.name).writeSyncStatus(false);
            connection.send(ackMessage.toUint8Array());
          }
          break;
        }
        readSyncStep2(message.decoder, document2, connection !== null && connection !== undefined ? connection : this.defaultTransactionOrigin);
        if (connection) {
          connection.send(new OutgoingMessage(document2.name).writeSyncStatus(true).toUint8Array());
        }
        break;
      case messageYjsUpdate:
        this.logger.log({
          direction: "in",
          type: MessageType.Sync,
          category: "Update"
        });
        if (connection === null || connection === undefined ? undefined : connection.readOnly) {
          connection.send(new OutgoingMessage(document2.name).writeSyncStatus(false).toUint8Array());
          break;
        }
        readUpdate(message.decoder, document2, connection);
        if (connection) {
          connection.send(new OutgoingMessage(document2.name).writeSyncStatus(true).toUint8Array());
        }
        break;
      default:
        throw new Error(`Received a message with an unknown type: ${type}`);
    }
    return type;
  }
  applyQueryAwarenessMessage(document2, reply) {
    const message = new OutgoingMessage(document2.name).createAwarenessUpdateMessage(document2.awareness);
    if (reply) {
      reply(message.toUint8Array());
    }
  }
}

class Connection {
  constructor(connection, request, document2, timeout, socketId, context, readOnly = false, logger) {
    this.pongReceived = true;
    this.callbacks = {
      onClose: [(document3, event) => null],
      beforeHandleMessage: (connection2, update) => Promise,
      statelessCallback: () => Promise
    };
    this.boundClose = this.close.bind(this);
    this.boundHandlePong = this.handlePong.bind(this);
    this.webSocket = connection;
    this.context = context;
    this.document = document2;
    this.request = request;
    this.timeout = timeout;
    this.socketId = socketId;
    this.readOnly = readOnly;
    this.logger = logger;
    this.lock = new import_async_lock.default;
    this.webSocket.binaryType = "nodebuffer";
    this.document.addConnection(this);
    this.pingInterval = setInterval(this.check.bind(this), this.timeout);
    this.webSocket.on("close", this.boundClose);
    this.webSocket.on("pong", this.boundHandlePong);
    this.sendCurrentAwareness();
  }
  handlePong() {
    this.pongReceived = true;
  }
  onClose(callback) {
    this.callbacks.onClose.push(callback);
    return this;
  }
  onStatelessCallback(callback) {
    this.callbacks.statelessCallback = callback;
    return this;
  }
  beforeHandleMessage(callback) {
    this.callbacks.beforeHandleMessage = callback;
    return this;
  }
  send(message) {
    if (this.webSocket.readyState === WsReadyStates.Closing || this.webSocket.readyState === WsReadyStates.Closed) {
      this.close();
    }
    try {
      this.webSocket.send(message, (error) => {
        if (error != null)
          this.close();
      });
    } catch (exception) {
      this.close();
    }
  }
  sendStateless(payload) {
    const message = new OutgoingMessage(this.document.name).writeStateless(payload);
    this.logger.log({
      direction: "out",
      type: message.type,
      category: message.category
    });
    this.send(message.toUint8Array());
  }
  close(event) {
    this.lock.acquire("close", (done) => {
      if (this.pingInterval) {
        clearInterval(this.pingInterval);
      }
      if (this.document.hasConnection(this)) {
        this.document.removeConnection(this);
        this.callbacks.onClose.forEach((callback) => callback(this.document, event));
      }
      this.webSocket.removeListener("close", this.boundClose);
      this.webSocket.removeListener("pong", this.boundHandlePong);
      done();
    });
  }
  check() {
    if (!this.pongReceived) {
      return this.close(ConnectionTimeout);
    }
    if (this.document.hasConnection(this)) {
      this.pongReceived = false;
      try {
        this.webSocket.ping();
      } catch (error) {
        this.close(ConnectionTimeout);
      }
    }
  }
  sendCurrentAwareness() {
    if (!this.document.hasAwarenessStates()) {
      return;
    }
    const awarenessMessage = new OutgoingMessage(this.document.name).createAwarenessUpdateMessage(this.document.awareness);
    this.logger.log({
      direction: "out",
      type: awarenessMessage.type,
      category: awarenessMessage.category
    });
    this.send(awarenessMessage.toUint8Array());
  }
  handleMessage(data) {
    const message = new IncomingMessage(data);
    const documentName = message.readVarString();
    if (documentName !== this.document.name)
      return;
    message.writeVarString(documentName);
    this.callbacks.beforeHandleMessage(this, data).then(() => {
      new MessageReceiver(message, this.logger).apply(this.document, this);
    }).catch((e) => {
      console.log("closing connection because of exception", e);
      this.close({
        code: "code" in e ? e.code : Forbidden.code,
        reason: "reason" in e ? e.reason : Forbidden.reason
      });
    });
  }
}

class Debugger {
  constructor() {
    this.logs = [];
    this.listen = false;
    this.output = false;
  }
  enable() {
    this.flush();
    this.listen = true;
  }
  disable() {
    this.listen = false;
  }
  verbose() {
    this.output = true;
  }
  quiet() {
    this.output = false;
  }
  log(message) {
    if (!this.listen) {
      return this;
    }
    const item = {
      ...message,
      type: MessageType[message.type]
    };
    this.logs.push(item);
    if (this.output) {
      console.log("[DEBUGGER]", item.direction === "in" ? "IN \u2013>" : "OUT <\u2013", `${item.type}/${item.category}`);
    }
    return this;
  }
  flush() {
    this.logs = [];
    return this;
  }
  get() {
    return {
      logs: this.logs
    };
  }
}
var createMutex = () => {
  let token = true;
  return (f, g) => {
    if (token) {
      token = false;
      try {
        f();
      } finally {
        token = true;
      }
    } else if (g !== undefined) {
      g();
    }
  };
};

class Document extends Doc {
  constructor(name, logger, yDocOptions) {
    super(yDocOptions);
    this.callbacks = {
      onUpdate: (document2, connection, update) => {
      },
      beforeBroadcastStateless: (document2, stateless) => {
      }
    };
    this.connections = new Map;
    this.directConnectionsCount = 0;
    this.isDestroyed = false;
    this.name = name;
    this.mux = createMutex();
    this.awareness = new Awareness(this);
    this.awareness.setLocalState(null);
    this.awareness.on("update", this.handleAwarenessUpdate.bind(this));
    this.on("update", this.handleUpdate.bind(this));
    this.logger = logger;
    this.isLoading = true;
  }
  isEmpty(fieldName) {
    return !this.get(fieldName)._start && !this.get(fieldName)._map.size;
  }
  merge(documents) {
    (Array.isArray(documents) ? documents : [documents]).forEach((document2) => {
      applyUpdate(this, encodeStateAsUpdate(document2));
    });
    return this;
  }
  onUpdate(callback) {
    this.callbacks.onUpdate = callback;
    return this;
  }
  beforeBroadcastStateless(callback) {
    this.callbacks.beforeBroadcastStateless = callback;
    return this;
  }
  addConnection(connection) {
    this.connections.set(connection.webSocket, {
      clients: new Set,
      connection
    });
    return this;
  }
  hasConnection(connection) {
    return this.connections.has(connection.webSocket);
  }
  removeConnection(connection) {
    removeAwarenessStates(this.awareness, Array.from(this.getClients(connection.webSocket)), null);
    this.connections.delete(connection.webSocket);
    return this;
  }
  addDirectConnection() {
    this.directConnectionsCount += 1;
    return this;
  }
  removeDirectConnection() {
    if (this.directConnectionsCount > 0) {
      this.directConnectionsCount -= 1;
    }
    return this;
  }
  getConnectionsCount() {
    return this.connections.size + this.directConnectionsCount;
  }
  getConnections() {
    return Array.from(this.connections.values()).map((data) => data.connection);
  }
  getClients(connectionInstance) {
    const connection = this.connections.get(connectionInstance);
    return (connection === null || connection === undefined ? undefined : connection.clients) === undefined ? new Set : connection.clients;
  }
  hasAwarenessStates() {
    return this.awareness.getStates().size > 0;
  }
  applyAwarenessUpdate(connection, update) {
    applyAwarenessUpdate(this.awareness, update, connection.webSocket);
    return this;
  }
  handleAwarenessUpdate({ added, updated, removed }, connectionInstance) {
    const changedClients = added.concat(updated, removed);
    if (connectionInstance !== null) {
      const connection = this.connections.get(connectionInstance);
      if (connection) {
        added.forEach((clientId) => connection.clients.add(clientId));
        removed.forEach((clientId) => connection.clients.delete(clientId));
      }
    }
    this.getConnections().forEach((connection) => {
      var _a;
      const awarenessMessage = new OutgoingMessage(this.name).createAwarenessUpdateMessage(this.awareness, changedClients);
      (_a = this.logger) === null || _a === undefined || _a.log({
        direction: "out",
        type: awarenessMessage.type,
        category: awarenessMessage.category
      });
      connection.send(awarenessMessage.toUint8Array());
    });
    return this;
  }
  handleUpdate(update, connection) {
    this.callbacks.onUpdate(this, connection, update);
    const message = new OutgoingMessage(this.name).createSyncMessage().writeUpdate(update);
    this.getConnections().forEach((connection2) => {
      var _a;
      (_a = this.logger) === null || _a === undefined || _a.log({
        direction: "out",
        type: message.type,
        category: message.category
      });
      connection2.send(message.toUint8Array());
    });
    return this;
  }
  broadcastStateless(payload, filter) {
    this.callbacks.beforeBroadcastStateless(this, payload);
    const connections = filter ? this.getConnections().filter(filter) : this.getConnections();
    connections.forEach((connection) => {
      connection.sendStateless(payload);
    });
  }
  destroy() {
    super.destroy();
    this.isDestroyed = true;
  }
}
var name = "@hocuspocus/server";
var description = "plug & play collaboration backend";
var version2 = "2.13.5";
var homepage = "https://hocuspocus.dev";
var keywords = [
  "hocuspocus",
  "yjs",
  "yjs-websocket",
  "prosemirror"
];
var license = "MIT";
var type = "module";
var main = "dist/hocuspocus-server.cjs";
var module = "dist/hocuspocus-server.esm.js";
var types = "dist/packages/server/src/index.d.ts";
var exports = {
  source: {
    import: "./src"
  },
  default: {
    import: "./dist/hocuspocus-server.esm.js",
    require: "./dist/hocuspocus-server.cjs",
    types: "./dist/packages/server/src/index.d.ts"
  }
};
var files = [
  "src",
  "dist"
];
var dependencies = {
  "@hocuspocus/common": "^2.13.5",
  "async-lock": "^1.3.1",
  kleur: "^4.1.4",
  lib0: "^0.2.47",
  uuid: "^10.0.0",
  ws: "^8.5.0"
};
var devDependencies = {
  "@types/async-lock": "^1.1.3",
  "@types/uuid": "^10.0.0",
  "@types/ws": "^8.5.3"
};
var peerDependencies = {
  "y-protocols": "^1.0.6",
  yjs: "^13.6.8"
};
var gitHead = "b3454a4ca289a84ddfb7fa5607a2d4b8d5c37e9d";
var meta = {
  name,
  description,
  version: version2,
  homepage,
  keywords,
  license,
  type,
  main,
  module,
  types,
  exports,
  files,
  dependencies,
  devDependencies,
  peerDependencies,
  gitHead
};

class Server$1 {
  constructor(hocuspocus) {
    this.setupWebsocketConnection = () => {
      this.webSocketServer.on("connection", async (incoming, request) => {
        incoming.on("error", (error) => {
          this.hocuspocus.debugger.log("Error emitted from webSocket instance:");
          this.hocuspocus.debugger.log(error);
        });
        this.hocuspocus.handleConnection(incoming, request);
      });
    };
    this.setupHttpUpgrade = () => {
      this.httpServer.on("upgrade", async (request, socket, head) => {
        try {
          await this.hocuspocus.hooks("onUpgrade", {
            request,
            socket,
            head,
            instance: this.hocuspocus
          });
          this.webSocketServer.handleUpgrade(request, socket, head, (ws) => {
            this.webSocketServer.emit("connection", ws, request);
          });
        } catch (error) {
          if (error) {
            throw error;
          }
        }
      });
    };
    this.requestHandler = async (request, response) => {
      try {
        await this.hocuspocus.hooks("onRequest", { request, response, instance: this.hocuspocus });
        response.writeHead(200, { "Content-Type": "text/plain" });
        response.end("OK");
      } catch (error) {
        if (error) {
          throw error;
        }
      }
    };
    this.hocuspocus = hocuspocus;
    this.httpServer = createServer(this.requestHandler);
    this.webSocketServer = new websocket_server.default({ noServer: true });
    this.setupWebsocketConnection();
    this.setupHttpUpgrade();
  }
}

class ClientConnection {
  constructor(websocket2, request, documentProvider, hooks, debuggerTool, opts, defaultContext = {}) {
    this.websocket = websocket2;
    this.request = request;
    this.documentProvider = documentProvider;
    this.hooks = hooks;
    this.debuggerTool = debuggerTool;
    this.opts = opts;
    this.defaultContext = defaultContext;
    this.documentConnections = {};
    this.incomingMessageQueue = {};
    this.documentConnectionsEstablished = new Set;
    this.hookPayloads = {};
    this.callbacks = {
      onClose: [(document2, payload) => {
      }]
    };
    this.socketId = v4();
    this.setUpNewConnection = async (documentName) => {
      clearTimeout(this.closeIdleConnectionTimeout);
      const hookPayload = this.hookPayloads[documentName];
      const document2 = await this.documentProvider.createDocument(documentName, hookPayload.request, hookPayload.socketId, hookPayload.connection, hookPayload.context);
      const instance = this.createConnection(this.websocket, document2);
      instance.onClose((document3, event) => {
        delete this.hookPayloads[documentName];
        delete this.documentConnections[documentName];
        delete this.incomingMessageQueue[documentName];
        this.documentConnectionsEstablished.delete(documentName);
        if (Object.keys(this.documentConnections).length === 0) {
          instance.webSocket.close(event === null || event === undefined ? undefined : event.code, event === null || event === undefined ? undefined : event.reason);
        }
      });
      this.documentConnections[documentName] = instance;
      this.incomingMessageQueue[documentName].forEach((input) => {
        this.websocket.emit("message", input);
      });
      this.hooks("connected", {
        ...hookPayload,
        documentName,
        context: hookPayload.context,
        connectionInstance: instance
      });
    };
    this.handleQueueingMessage = async (data) => {
      var _a;
      try {
        const tmpMsg = new IncomingMessage(data);
        const documentName = readVarString2(tmpMsg.decoder);
        const type2 = readVarUint2(tmpMsg.decoder);
        if (!(type2 === MessageType.Auth && !this.documentConnectionsEstablished.has(documentName))) {
          this.incomingMessageQueue[documentName].push(data);
          return;
        }
        this.documentConnectionsEstablished.add(documentName);
        readVarUint2(tmpMsg.decoder);
        const token = readVarString2(tmpMsg.decoder);
        this.debuggerTool.log({
          direction: "in",
          type: type2,
          category: "Token"
        });
        try {
          const hookPayload = this.hookPayloads[documentName];
          await this.hooks("onAuthenticate", {
            token,
            ...hookPayload,
            documentName
          }, (contextAdditions) => {
            hookPayload.context = { ...hookPayload.context, ...contextAdditions };
          });
          hookPayload.connection.isAuthenticated = true;
          const message = new OutgoingMessage(documentName).writeAuthenticated(hookPayload.connection.readOnly);
          this.debuggerTool.log({
            direction: "out",
            type: message.type,
            category: message.category
          });
          this.websocket.send(message.toUint8Array());
          await this.setUpNewConnection(documentName);
        } catch (err) {
          const error = err || Forbidden;
          const message = new OutgoingMessage(documentName).writePermissionDenied((_a = error.reason) !== null && _a !== undefined ? _a : "permission-denied");
          this.debuggerTool.log({
            direction: "out",
            type: message.type,
            category: message.category
          });
          this.websocket.send(message.toUint8Array());
        }
      } catch (error) {
        console.error(error);
        this.websocket.close(Unauthorized.code, Unauthorized.reason);
      }
    };
    this.messageHandler = async (data) => {
      var _a, _b;
      try {
        const tmpMsg = new IncomingMessage(data);
        const documentName = readVarString2(tmpMsg.decoder);
        const connection = this.documentConnections[documentName];
        if (connection) {
          connection.handleMessage(data);
          return;
        }
        const isFirst = this.incomingMessageQueue[documentName] === undefined;
        if (isFirst) {
          this.incomingMessageQueue[documentName] = [];
          if (this.hookPayloads[documentName]) {
            throw new Error("first message, but hookPayloads exists");
          }
          const hookPayload = {
            instance: this.documentProvider,
            request: this.request,
            connection: {
              readOnly: false,
              requiresAuthentication: this.opts.requiresAuthentication,
              isAuthenticated: false
            },
            requestHeaders: this.request.headers,
            requestParameters: getParameters(this.request),
            socketId: this.socketId,
            context: {
              ...this.defaultContext
            }
          };
          this.hookPayloads[documentName] = hookPayload;
        }
        this.handleQueueingMessage(data);
        if (isFirst) {
          const hookPayload = this.hookPayloads[documentName];
          try {
            await this.hooks("onConnect", { ...hookPayload, documentName }, (contextAdditions) => {
              hookPayload.context = { ...hookPayload.context, ...contextAdditions };
            });
            if (hookPayload.connection.requiresAuthentication || this.documentConnectionsEstablished.has(documentName)) {
              return;
            }
            this.documentConnectionsEstablished.add(documentName);
            await this.setUpNewConnection(documentName);
          } catch (err) {
            const error = err || Forbidden;
            try {
              this.websocket.close((_a = error.code) !== null && _a !== undefined ? _a : Forbidden.code, (_b = error.reason) !== null && _b !== undefined ? _b : Forbidden.reason);
            } catch (closeError) {
              console.error(closeError);
              this.websocket.close(Unauthorized.code, Unauthorized.reason);
            }
          }
        }
      } catch (closeError) {
        console.error(closeError);
        this.websocket.close(Unauthorized.code, Unauthorized.reason);
      }
    };
    this.closeIdleConnectionTimeout = setTimeout(() => {
      websocket2.close(Unauthorized.code, Unauthorized.reason);
    }, opts.timeout);
    websocket2.on("message", this.messageHandler);
    websocket2.once("close", () => {
      websocket2.removeListener("message", this.messageHandler);
    });
  }
  onClose(callback) {
    this.callbacks.onClose.push(callback);
    return this;
  }
  createConnection(connection, document2) {
    const hookPayload = this.hookPayloads[document2.name];
    const instance = new Connection(connection, hookPayload.request, document2, this.opts.timeout, hookPayload.socketId, hookPayload.context, hookPayload.connection.readOnly, this.debuggerTool);
    instance.onClose(async (document3, event) => {
      const disconnectHookPayload = {
        instance: this.documentProvider,
        clientsCount: document3.getConnectionsCount(),
        context: hookPayload.context,
        document: document3,
        socketId: hookPayload.socketId,
        documentName: document3.name,
        requestHeaders: hookPayload.request.headers,
        requestParameters: getParameters(hookPayload.request)
      };
      await this.hooks("onDisconnect", disconnectHookPayload);
      this.callbacks.onClose.forEach((callback) => callback(document3, disconnectHookPayload));
    });
    instance.onStatelessCallback(async (payload) => {
      try {
        return await this.hooks("onStateless", payload);
      } catch (error) {
        if (error === null || error === undefined ? undefined : error.message) {
          throw error;
        }
      }
    });
    instance.beforeHandleMessage((connection2, update) => {
      const beforeHandleMessagePayload = {
        instance: this.documentProvider,
        clientsCount: document2.getConnectionsCount(),
        context: hookPayload.context,
        document: document2,
        socketId: hookPayload.socketId,
        connection: connection2,
        documentName: document2.name,
        requestHeaders: hookPayload.request.headers,
        requestParameters: getParameters(hookPayload.request),
        update
      };
      return this.hooks("beforeHandleMessage", beforeHandleMessagePayload);
    });
    if (connection.readyState === WsReadyStates.Closing || connection.readyState === WsReadyStates.Closed) {
      instance.close();
    }
    return instance;
  }
}

class DirectConnection {
  constructor(document2, instance, context) {
    this.document = null;
    this.document = document2;
    this.instance = instance;
    this.context = context;
    this.document.addDirectConnection();
  }
  async transact(transaction, transactionOrigin) {
    if (!this.document) {
      throw new Error("direct connection closed");
    }
    transaction(this.document);
    await this.instance.storeDocumentHooks(this.document, {
      clientsCount: this.document.getConnectionsCount(),
      context: this.context,
      document: this.document,
      documentName: this.document.name,
      instance: this.instance,
      requestHeaders: {},
      requestParameters: new URLSearchParams,
      socketId: "server",
      transactionOrigin
    }, true);
  }
  async disconnect() {
    var _a;
    if (this.document) {
      (_a = this.document) === null || _a === undefined || _a.removeDirectConnection();
      await this.instance.storeDocumentHooks(this.document, {
        clientsCount: this.document.getConnectionsCount(),
        context: this.context,
        document: this.document,
        documentName: this.document.name,
        instance: this.instance,
        requestHeaders: {},
        requestParameters: new URLSearchParams,
        socketId: "server"
      }, true);
      this.document = null;
    }
  }
}
var useDebounce = () => {
  const timers = new Map;
  const debounce = (id2, func, debounce2, maxDebounce) => {
    const old = timers.get(id2);
    const start = (old === null || old === undefined ? undefined : old.start) || Date.now();
    const run2 = () => {
      timers.delete(id2);
      return func();
    };
    if (old === null || old === undefined ? undefined : old.timeout) {
      clearTimeout(old.timeout);
    }
    if (debounce2 === 0) {
      return run2();
    }
    if (Date.now() - start >= maxDebounce) {
      return run2();
    }
    timers.set(id2, {
      start,
      timeout: setTimeout(run2, debounce2),
      func: run2
    });
  };
  const executeNow = (id2) => {
    const old = timers.get(id2);
    if (old) {
      clearTimeout(old.timeout);
      return old.func();
    }
  };
  const isDebounced = (id2) => {
    return timers.has(id2);
  };
  return { debounce, isDebounced, executeNow };
};
var defaultConfiguration = {
  name: null,
  port: 80,
  address: "0.0.0.0",
  timeout: 30000,
  debounce: 2000,
  maxDebounce: 1e4,
  quiet: false,
  yDocOptions: {
    gc: true,
    gcFilter: () => true
  },
  unloadImmediately: true,
  stopOnSignals: true
};

class Hocuspocus {
  constructor(configuration) {
    this.configuration = {
      ...defaultConfiguration,
      extensions: [],
      onConfigure: () => new Promise((r) => r(null)),
      onListen: () => new Promise((r) => r(null)),
      onUpgrade: () => new Promise((r) => r(null)),
      onConnect: () => new Promise((r) => r(null)),
      connected: () => new Promise((r) => r(null)),
      beforeHandleMessage: () => new Promise((r) => r(null)),
      beforeBroadcastStateless: () => new Promise((r) => r(null)),
      onStateless: () => new Promise((r) => r(null)),
      onChange: () => new Promise((r) => r(null)),
      onCreateDocument: () => new Promise((r) => r(null)),
      onLoadDocument: () => new Promise((r) => r(null)),
      onStoreDocument: () => new Promise((r) => r(null)),
      afterStoreDocument: () => new Promise((r) => r(null)),
      onAwarenessUpdate: () => new Promise((r) => r(null)),
      onRequest: () => new Promise((r) => r(null)),
      onDisconnect: () => new Promise((r) => r(null)),
      onDestroy: () => new Promise((r) => r(null))
    };
    this.loadingDocuments = new Map;
    this.documents = new Map;
    this.debugger = new Debugger;
    this.debouncer = useDebounce();
    if (configuration) {
      this.configure(configuration);
    }
  }
  configure(configuration) {
    this.configuration = {
      ...this.configuration,
      ...configuration
    };
    this.configuration.extensions.sort((a, b) => {
      const one = typeof a.priority === "undefined" ? 100 : a.priority;
      const two = typeof b.priority === "undefined" ? 100 : b.priority;
      if (one > two) {
        return -1;
      }
      if (one < two) {
        return 1;
      }
      return 0;
    });
    this.configuration.extensions.push({
      onConfigure: this.configuration.onConfigure,
      onListen: this.configuration.onListen,
      onUpgrade: this.configuration.onUpgrade,
      onConnect: this.configuration.onConnect,
      connected: this.configuration.connected,
      onAuthenticate: this.configuration.onAuthenticate,
      onLoadDocument: this.configuration.onLoadDocument,
      afterLoadDocument: this.configuration.afterLoadDocument,
      beforeHandleMessage: this.configuration.beforeHandleMessage,
      beforeBroadcastStateless: this.configuration.beforeBroadcastStateless,
      onStateless: this.configuration.onStateless,
      onChange: this.configuration.onChange,
      onStoreDocument: this.configuration.onStoreDocument,
      afterStoreDocument: this.configuration.afterStoreDocument,
      onAwarenessUpdate: this.configuration.onAwarenessUpdate,
      onRequest: this.configuration.onRequest,
      afterUnloadDocument: this.configuration.afterUnloadDocument,
      onDisconnect: this.configuration.onDisconnect,
      onDestroy: this.configuration.onDestroy
    });
    this.hooks("onConfigure", {
      configuration: this.configuration,
      version: meta.version,
      instance: this
    });
    return this;
  }
  get requiresAuthentication() {
    return !!this.configuration.extensions.find((extension) => {
      return extension.onAuthenticate !== undefined;
    });
  }
  async listen(portOrCallback = null, callback = null) {
    if (typeof portOrCallback === "number") {
      this.configuration.port = portOrCallback;
    }
    if (typeof portOrCallback === "function") {
      this.configuration.extensions.push({
        onListen: portOrCallback
      });
    }
    if (typeof callback === "function") {
      this.configuration.extensions.push({
        onListen: callback
      });
    }
    this.server = new Server$1(this);
    if (this.configuration.stopOnSignals) {
      const signalHandler = async () => {
        await this.destroy();
        process.exit(0);
      };
      process.on("SIGINT", signalHandler);
      process.on("SIGQUIT", signalHandler);
      process.on("SIGTERM", signalHandler);
    }
    return new Promise((resolve, reject) => {
      var _a;
      (_a = this.server) === null || _a === undefined || _a.httpServer.listen({
        port: this.configuration.port,
        host: this.configuration.address
      }, async () => {
        if (!this.configuration.quiet && true) {
          this.showStartScreen();
        }
        const onListenPayload = {
          instance: this,
          configuration: this.configuration,
          port: this.address.port
        };
        try {
          await this.hooks("onListen", onListenPayload);
          resolve(this);
        } catch (e) {
          reject(e);
        }
      });
    });
  }
  get address() {
    var _a, _b;
    return ((_b = (_a = this.server) === null || _a === undefined ? undefined : _a.httpServer) === null || _b === undefined ? undefined : _b.address()) || {
      port: this.configuration.port,
      address: this.configuration.address,
      family: "IPv4"
    };
  }
  get URL() {
    return `${this.configuration.address}:${this.address.port}`;
  }
  get webSocketURL() {
    return `ws://${this.URL}`;
  }
  get httpURL() {
    return `http://${this.URL}`;
  }
  showStartScreen() {
    var _a;
    const name2 = this.configuration.name ? ` (${this.configuration.name})` : "";
    console.log();
    console.log(`  ${kleur_default.cyan(`Hocuspocus v${meta.version}${name2}`)}${kleur_default.green(" running at:")}`);
    console.log();
    console.log(`  > HTTP: ${kleur_default.cyan(`${this.httpURL}`)}`);
    console.log(`  > WebSocket: ${this.webSocketURL}`);
    const extensions = (_a = this.configuration) === null || _a === undefined ? undefined : _a.extensions.map((extension) => {
      var _a2, _b;
      return (_a2 = extension.extensionName) !== null && _a2 !== undefined ? _a2 : (_b = extension.constructor) === null || _b === undefined ? undefined : _b.name;
    }).filter((name3) => name3).filter((name3) => name3 !== "Object");
    if (!extensions.length) {
      return;
    }
    console.log();
    console.log("  Extensions:");
    extensions.forEach((name3) => {
      console.log(`  - ${name3}`);
    });
    console.log();
    console.log(`  ${kleur_default.green("Ready.")}`);
    console.log();
  }
  getDocumentsCount() {
    return this.documents.size;
  }
  getConnectionsCount() {
    return Array.from(this.documents.values()).reduce((acc, document2) => {
      acc += document2.getConnectionsCount();
      return acc;
    }, 0);
  }
  closeConnections(documentName) {
    this.documents.forEach((document2) => {
      if (documentName && document2.name !== documentName) {
        return;
      }
      document2.connections.forEach(({ connection }) => {
        connection.close(ResetConnection);
      });
    });
  }
  async destroy() {
    await new Promise(async (resolve) => {
      var _a, _b, _c, _d;
      (_b = (_a = this.server) === null || _a === undefined ? undefined : _a.httpServer) === null || _b === undefined || _b.close();
      try {
        this.configuration.extensions.push({
          async afterUnloadDocument({ instance }) {
            if (instance.getDocumentsCount() === 0)
              resolve("");
          }
        });
        (_d = (_c = this.server) === null || _c === undefined ? undefined : _c.webSocketServer) === null || _d === undefined || _d.close();
        if (this.getDocumentsCount() === 0)
          resolve("");
        this.closeConnections();
      } catch (error) {
        console.error(error);
      }
      this.debugger.flush();
    });
    await this.hooks("onDestroy", { instance: this });
  }
  handleConnection(incoming, request, defaultContext = {}) {
    const clientConnection = new ClientConnection(incoming, request, this, this.hooks.bind(this), this.debugger, {
      requiresAuthentication: this.requiresAuthentication,
      timeout: this.configuration.timeout
    }, defaultContext);
    clientConnection.onClose((document2, hookPayload) => {
      if (document2.getConnectionsCount() > 0) {
        return;
      }
      if (!document2.isLoading && this.debouncer.isDebounced(`onStoreDocument-${document2.name}`)) {
        if (this.configuration.unloadImmediately) {
          this.debouncer.executeNow(`onStoreDocument-${document2.name}`);
        }
      } else {
        this.unloadDocument(document2);
      }
    });
  }
  async handleDocumentUpdate(document2, connection, update, request) {
    var _a, _b;
    const hookPayload = {
      instance: this,
      clientsCount: document2.getConnectionsCount(),
      context: (connection === null || connection === undefined ? undefined : connection.context) || {},
      document: document2,
      documentName: document2.name,
      requestHeaders: (_a = request === null || request === undefined ? undefined : request.headers) !== null && _a !== undefined ? _a : {},
      requestParameters: getParameters(request),
      socketId: (_b = connection === null || connection === undefined ? undefined : connection.socketId) !== null && _b !== undefined ? _b : "",
      update,
      transactionOrigin: connection
    };
    this.hooks("onChange", hookPayload).catch((error) => {
      throw error;
    });
    if (!connection || connection === "__hocuspocus__redis__origin__") {
      return;
    }
    await this.storeDocumentHooks(document2, hookPayload);
  }
  async createDocument(documentName, request, socketId, connection, context) {
    const existingLoadingDoc = this.loadingDocuments.get(documentName);
    if (existingLoadingDoc) {
      return existingLoadingDoc;
    }
    const existingDoc = this.documents.get(documentName);
    if (existingDoc) {
      return Promise.resolve(existingDoc);
    }
    const loadDocPromise = this.loadDocument(documentName, request, socketId, connection, context);
    this.loadingDocuments.set(documentName, loadDocPromise);
    try {
      await loadDocPromise;
      this.loadingDocuments.delete(documentName);
    } catch (e) {
      this.loadingDocuments.delete(documentName);
      throw e;
    }
    return loadDocPromise;
  }
  async loadDocument(documentName, request, socketId, connection, context) {
    var _a;
    const requestHeaders = (_a = request.headers) !== null && _a !== undefined ? _a : {};
    const requestParameters = getParameters(request);
    const yDocOptions = await this.hooks("onCreateDocument", {
      documentName,
      requestHeaders,
      requestParameters,
      connection,
      context,
      socketId,
      instance: this
    });
    const document2 = new Document(documentName, this.debugger, {
      ...this.configuration.yDocOptions,
      ...yDocOptions
    });
    this.documents.set(documentName, document2);
    const hookPayload = {
      instance: this,
      context,
      connection,
      document: document2,
      documentName,
      socketId,
      requestHeaders,
      requestParameters
    };
    try {
      await this.hooks("onLoadDocument", hookPayload, (loadedDocument) => {
        if ((loadedDocument === null || loadedDocument === undefined ? undefined : loadedDocument.constructor.name) === "Document" || (loadedDocument === null || loadedDocument === undefined ? undefined : loadedDocument.constructor.name) === "Doc") {
          applyUpdate(document2, encodeStateAsUpdate(loadedDocument));
        }
      });
    } catch (e) {
      this.closeConnections(documentName);
      this.unloadDocument(document2);
      throw e;
    }
    document2.isLoading = false;
    await this.hooks("afterLoadDocument", hookPayload);
    document2.onUpdate((document3, connection2, update) => {
      this.handleDocumentUpdate(document3, connection2, update, connection2 === null || connection2 === undefined ? undefined : connection2.request);
    });
    document2.beforeBroadcastStateless((document3, stateless) => {
      const hookPayload2 = {
        document: document3,
        documentName: document3.name,
        payload: stateless
      };
      this.hooks("beforeBroadcastStateless", hookPayload2);
    });
    document2.awareness.on("update", (update) => {
      this.hooks("onAwarenessUpdate", {
        ...hookPayload,
        ...update,
        awareness: document2.awareness,
        states: awarenessStatesToArray(document2.awareness.getStates())
      });
    });
    return document2;
  }
  storeDocumentHooks(document2, hookPayload, immediately) {
    return this.debouncer.debounce(`onStoreDocument-${document2.name}`, () => {
      return this.hooks("onStoreDocument", hookPayload).then(() => {
        this.hooks("afterStoreDocument", hookPayload).then(() => {
          if (document2.getConnectionsCount() > 0) {
            return;
          }
          this.unloadDocument(document2);
        });
      }).catch((error) => {
        console.error("Caught error during storeDocumentHooks", error);
        if (error === null || error === undefined ? undefined : error.message) {
          throw error;
        }
      });
    }, immediately ? 0 : this.configuration.debounce, this.configuration.maxDebounce);
  }
  hooks(name2, payload, callback = null) {
    const { extensions } = this.configuration;
    let chain2 = Promise.resolve();
    extensions.filter((extension) => typeof extension[name2] === "function").forEach((extension) => {
      chain2 = chain2.then(() => {
        var _a;
        return (_a = extension[name2]) === null || _a === undefined ? undefined : _a.call(extension, payload);
      }).catch((error) => {
        if (error === null || error === undefined ? undefined : error.message) {
          console.error(`[${name2}]`, error.message);
        }
        throw error;
      });
      if (callback) {
        chain2 = chain2.then((...args2) => callback(...args2));
      }
    });
    return chain2;
  }
  unloadDocument(document2) {
    const documentName = document2.name;
    if (!this.documents.has(documentName))
      return;
    this.documents.delete(documentName);
    document2.destroy();
    this.hooks("afterUnloadDocument", { instance: this, documentName });
  }
  enableDebugging() {
    this.debugger.enable();
  }
  enableMessageLogging() {
    this.debugger.enable();
    this.debugger.verbose();
  }
  disableLogging() {
    this.debugger.quiet();
  }
  disableDebugging() {
    this.debugger.disable();
  }
  flushMessageLogs() {
    this.debugger.flush();
    return this;
  }
  getMessageLogs() {
    var _a;
    return (_a = this.debugger.get()) === null || _a === undefined ? undefined : _a.logs;
  }
  async openDirectConnection(documentName, context) {
    const connectionConfig = {
      isAuthenticated: true,
      readOnly: false,
      requiresAuthentication: true
    };
    const document2 = await this.createDocument(documentName, {}, v4(), connectionConfig, context);
    return new DirectConnection(document2, this, context);
  }
}
var Server = new Hocuspocus;

// src/hocus/index.ts
var createServer2 = (db, options) => {
  const server2 = Server.configure({
    port: options.hocus.port,
    async onAuthenticate(data) {
      const { token } = data;
      console.log("Authenticating vault \uD83D\uDD12:", token);
    },
    async onConnect(data) {
      console.log("Connecting to vault \uD83D\uDD17:");
    },
    maxDebounce: 1000,
    extensions: []
  });
  return {
    server: server2
  };
};

// src/db/index.ts
import {Database} from "bun:sqlite";

// src/utils/encryption/index.ts
var encryptPassword = async (password) => {
  return await Bun.password.hash(password);
};
// src/utils/options/index.ts
var options = {
  hocus: {
    port: 4000
  },
  hono: {
    port: 8080
  },
  database: {
    database: "db.sqlite"
  },
  cors: {
    origin: ["http://localhost:3000", "http://localhost:1420", "http://localhost:5173"],
    default: "http://localhost:3000"
  }
};
// src/utils/server/index.ts
var pm2 = require_pm22();
// src/db/index.ts
var createDb = async (options3) => {
  const db = new Database(options3.database.database);
  db.exec("PRAGMA journal_mode = WAL;");
  db.query(`CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY,
    username TEXT NOT NULL,
    password TEXT NOT NULL,
    admin BOOLEAN NOT NULL
  )`).run();
  db.query(`CREATE TABLE IF NOT EXISTS "documents" (
    "name" varchar(255) NOT NULL,
    "data" blob NOT NULL,
    UNIQUE(name)
  )`).run();
  db.query(`CREATE TABLE IF NOT EXISTS sessions (
    id INTEGER PRIMARY KEY,
    uid INTEGER NOT NULL,
    token TEXT NOT NULL
  )`).run();
  db.query(`INSERT INTO users (username, password, admin) VALUES ('admin', '${await encryptPassword("admin")}', true)`).run();
  return {
    db
  };
};

// src/index.ts
var { db: db2 } = await createDb(options);
var { server: server3 } = createServer2(db2, options);
server3.listen();
